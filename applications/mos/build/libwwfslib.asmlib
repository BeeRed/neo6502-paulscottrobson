;
;	This file is automatically generated.
;
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		readheader.asm
;		Purpose:	Read a sector header
;		Created:	2nd July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									    Read a header
;
; ************************************************************************************************

		.section code

FSReadNextHeader:
		inc 	currentSector 				; bump last sector and read next one.
		lda 	currentSector
		;
FSReadHeaderA:
		cmp 	#0 							; sector 0 always okay.
		beq 	_FSIsOk
		cmp 	sectorCount 				; check legitimate sector
		bcs 	_FSReadHFail
_FSIsOk:
		phx
		sta 	currentSector 				; save as current
		ldx 	#sectorHeader & $FF 		; target address.
		stx 	iTemp0
		ldx 	#sectorHeader >> 8
		stx 	iTemp0+1
		ldx 	#0 							; subpage 0
		ldy 	#32 						; first 32 bytes only.
		jsr 	FSHRead 					; read the sector into memory
		plx

		lda 	shFileSize 					; copy file size - makes easily accessible
		sta 	shFileSizeCopy 				; for directory function.
		lda 	shFileSize+1
		sta 	shFileSizeCopy+1

		clc
		rts
_FSReadHFail:
		sec
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		read.asm
;		Purpose:	Read a file
;		Created:	2nd July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Read File
;
;						   On entry, YX points to a file block.
;							On exit, CS if file not found.
;
; ************************************************************************************************

		.section code

OSReadFile:
		stx 	fsBlock 					; file block.
		sty 	fsBlock+1

		stz 	currentSector 				; start from the beginning.

		lda 	#$FF 						; set flag to $FF
		sta 	successFlag
		;
		;		Look for (F)irst
		;
_OSReadLoop1:
		jsr 	FSReadNextHeader 			; read header ?
		bcs 	_OSReadExit 				; end of search, not found.
		lda 	shFirstNext 				; is it the (F)irst record
		cmp 	#"F"
		bne 	_OSReadLoop1
		jsr 	FSCompareFileNames 			; is it F and matching.
		bcc 	_OSReadLoop1 				; no, try next sector
		stz 	successFlag 				; zero when found file.
		;
		;		Read the block in.
		;
_OSReadBlock:
		jsr 	FSReadData 					; read the data file in.
		lda 	shContinue 					; continuation ?
		cmp 	#"N" 						; exit if no.
		beq 	_OSReadExit
		;
		;		Find the next block
		;
_OSReadLoop2:
		jsr 	FSReadNextHeader 			; read header ?
		bcs 	_OSReadExit 				; end of search.
		lda 	shFirstNext 				; is it the (F)irst record
		cmp 	#"N"
		bne 	_OSReadLoop2
		jsr 	FSCompareFileNames 			; is it F/N and matching.
		bcc 	_OSReadLoop2 				; no, try next sector
		bra 	_OSReadBlock 				; read block in.

_OSReadExit:
		asl 	successFlag					; shift success flag (0 if done) into carry
		rts

; ************************************************************************************************
;
;								Read current sector into memory
;
; ************************************************************************************************

FSReadData:
		ldx  	#1 							; current subpage in sector
_FSReadLoop:
		lda 	shDataSize 					; datasize count zero, exit ?
		ora 	shDataSize+1
		beq 	_OSRDExit

		jsr 	FSIncrementSetLoad 			; copy load address and bump by one page.

		ldy 	shDataSize 					; number of bytes to read
		lda 	shDataSize+1 				; if 00xx then it is xx
		beq 	_FSPartPage
		ldy 	#0 							; otherwise it's zero (e.g. 256)
_FSPartPage:
		lda 	currentSector 				; A = sector, X = subpage, Y = bytes to read
		phx
		jsr 	FSHRead 					; write out the sub page.
		plx
		inx  								; next sub page.

		lda 	shDataSize+1 				; if < 1 whole page we are done
		beq 	_OSRDExit

		dec 	shDataSize+1 				; done one.
		bra 	_FSReadLoop
_OSRDExit:
		rts

; ************************************************************************************************
;
;					Copy load/save address to iTemp0, increment it by 256
;
; ************************************************************************************************

FSIncrementSetLoad:
		phy
		clc
		ldy 	#2
		lda 	(fsBlock),y  				; copying previous to iTemp0
		sta 	iTemp0
		iny
		lda 	(fsBlock),y
		sta 	iTemp0+1
		inc 	a 							; move one page on.
		sta 	(fsBlock),y
		ply
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		read.asm
;		Purpose:	Read a file
;		Created:	3rd July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Write File
;
;						   On entry, YX points to a file block.
;					  On exit, CS if failed (most likely no space)
;
; ************************************************************************************************

		.section code

OSWriteFile:
		.debug
		stx 	fsBlock 					; file block.
		sty 	fsBlock+1
		jsr 	OSDeleteFile 				; delete file if it already exists
		.
		stz 	currentSector
		stz 	notFirstSector 				; clear "not first sector" (e.g. is first sector)
		;
		ldy 	#4 							; copy the size of the data to write to
		lda 	(fsBlock),y 				; the "remaining size" variable.
		sta 	fileRemainingSize
		iny
		lda 	(fsBlock),y
		sta 	fileRemainingSize+1
		;
		;		Main write loop. First find an empty slot.
		;
_OSWriteLoop:
		lda 	sectorCount  				; so we count incase we are full.
		sta 	iTemp0
		;
_OSFindUnused:
		dec 	iTemp0 						; done a full lap, no empty slots
		beq 	_OSWriteFail
		jsr 	FSReadNextHeader 			; read next header
		lda 	shFirstNext 				; check F, N , I
		cmp 	#"I"
		beq 	_OSFindUnused
		cmp 	#"N"
		beq 	_OSFindUnused
		cmp 	#"F"
		beq 	_OSFindUnused
		;
		;		Found on empty slot.
		;
		lda 	currentSector 				; erase sector
		jsr 	FSHErase
		lda 	currentSector 				; open for write.
		;
		;		Write the header to the first page.
		;
		jsr 	FSCreateHeader 				; create header

		ldx 	#sectorHeader & $FF 		; source address.
		stx 	iTemp0
		ldx 	#sectorHeader >> 8
		stx 	iTemp0+1
		;
		lda 	currentSector 				; write the sector out.
		ldx 	#0
		jsr 	FSHWrite
		;
		dec 	notFirstSector 				; set "not first sector" state.
		;
		;jsr 	FSWriteSendData 			; write the body out.
		;
		sec
		lda 	fileRemainingSize 			; subtract data sent from file remaining.
		sbc 	shDataSize
		sta 	fileRemainingSize
		lda 	fileRemainingSize+1
		sbc 	shDataSize+1
		sta 	fileRemainingSize+1
		;
		lda 	fileRemainingSize 			; check there is more to save, if not then exit.
		ora 	fileRemainingSize+1
		bne		_OSWriteLoop
		clc
		rts
		;
		;		Come here on failure (probably out of space)
		;
_OSWriteFail:
		jsr 	OSDeleteFile 				; delete any parts of the file.
		sec 								; return error
		rts

; ************************************************************************************************
;
;										Create the 32 byte header
;
; ************************************************************************************************

FSCreateHeader:
		;
		;		First or Next flag
		;
		lda 	#"N"						; first or next ?
		ldx 	notFirstSector
		bne 	_FSWCNotNext
		lda 	#"F"
_FSWCNotNext:
		sta 	shFirstNext
		;
		;		Work out the number of bytes going out into YX
		;
		ldx 	fileRemainingSize 			; XY is the number of bytes.
		ldy 	fileRemainingSize+1
		lda 	#"N"
		;
		cpy 	#(4096-256) >> 8 			; if less than a full sector
		bcc 	_FSNotFull

		ldy 	#(4096-256) >> 8 			; number of bytes to write
		ldx 	#0
		lda 	#"Y" 						; and there are more bytes.
_FSNotFull:
		;
		;		Set continue, data size, and file size.
		;
		sta 	shContinue 					; write out the continue
		;
		stx 	shDataSize 					; write out the size of data in this file.
		sty 	shDataSize+1
		;
		ldy 	#4
		lda 	(fsBlock),y
		sta 	shFileSize
		iny
		lda 	(fsBlock),y
		sta 	shFileSize+1
		;
		;		Copy name - iTemp0 points to string then copy it out.
		;
		ldy 	#1
		lda 	(fsBlock),y
		sta 	iTemp0+1
		lda 	(fsBlock)
		sta 	iTemp0
		;
		lda 	(iTemp0) 					; copy length.
		tax 								; length in X
		ldy 	#0
_FSOutName: 								; copy name.
		lda 	(iTemp0),y
		sta 	shNameLength,y
		iny
		dex
		bmi 	_FSOutName

_FSNameDone:
		rts

; ************************************************************************************************
;
;										Output the body
;
; ************************************************************************************************

FSWriteSendData:
;		lda 	bytesToWrite 				; complete
;		ora 	bytesToWrite+1
;		beq 	_FSWSDExit
;		jsr 	FSIncrementSetLoad 			; bump address, copy original to iTemp0
		lda 	(iTemp0)
;;		jsr 	FSHWrite
		;
;		lda 	bytesToWrite 				; decrement bytes to write counter
;		bne 	_FSWSDNoBorrow
;		dec 	bytesToWrite+1
;_FSWSDNoBorrow:
;		dec 	bytesToWrite
;
;		lda 	fileRemainingSize 			; decrement remaining size.
;		bne 	_FSWSDNoBorrow2
;		dec 	fileRemainingSize+1
;_FSWSDNoBorrow2:
;		dec 	fileRemainingSize
;		bra 	FSWriteSendData
;
_FSWSDExit:
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		directory.asm
;		Purpose:	Read a directory
;		Created:	2nd July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Directory Read.
;
;	Enter with CS to initialise.
;
;	Each subsequent call returns either CS (end of directory)
;										CC (record available), YX points to name (len prefix)
;
; ************************************************************************************************

		.section code

OSReadDirectory:
		bcs 	_OSRDReset
		;
_OSRDLoop:
		jsr 	FSReadNextHeader 			; read next sector header.
		bcs 	_OSRDExit 					; exit, end of file space, CS
		lda 	shFirstNext 				; is it an 'F' record
		cmp 	#'F'
		bne 	_OSRDLoop
		ldx 	#shNameLength & $FF 		; return the buffer address
		ldy 	#shNameLength >> 8
		clc 								; return with carry clear.
		rts

_OSRDReset:
		stz 	currentSector 				; back to the start.
_OSRDExit:
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		delete.asm
;		Purpose:	Delete a file
;		Created:	2nd July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Delete File
;
;						   On entry, YX points to a file block.
;							On exit, CS if file not found.
;
; ************************************************************************************************

		.section code

OSDeleteFile:
		stx 	fsBlock 					; file block.
		sty 	fsBlock+1

		stz 	currentSector
		lda 	#$FF 						; set flag to $FF
		sta 	successFlag
_OSDeleteLoop:
		jsr 	FSReadNextHeader 			; read header ?
		bcs 	_OSDeleteExit 				; end of search.
		jsr 	FSCompareFileNames 			; is it F/N and matching.
		bcc 	_OSDeleteLoop 				; no, try next sector

		lda 	currentSector 				; yes, then erase this sector
		jsr 	FSHErase
		stz 	successFlag 				; zero if successful
		bra 	_OSDeleteLoop
_OSDeleteExit:
		asl 	successFlag					; shift success flag (0 if done) into carry
		rts

; ************************************************************************************************
;
;			Check current header is (F)irst (N)ext and name matches that in iBlock
;										CS if match found
;
; ************************************************************************************************

FSCompareFileNames:
		lda 	shFirstNext 				; is it F/N type ?
		cmp 	#"F"
		beq 	_FSDeleteCheckName
		cmp 	#"N"
		bne 	_FSCompareFail 				; no, then compare fails.
_FSDeleteCheckName:
		ldy 	#1 							; copy filename to iTemp0
		lda 	(fsBlock)
		sta 	iTemp0
		lda 	(fsBlock),y
		sta 	iTemp0+1
		;
		lda 	(iTemp0) 					; compare n+1
		tay
_FSCompareName:
		lda 	shNameLength,y
		cmp 	(iTemp0),y
		bne 	_FSCompareFail
		dey
		bpl 	_FSCompareName
		sec
		rts

_FSCompareFail:
		clc
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		format.asm
;		Purpose:	Format the flash drive
;		Created:	5th July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Format drive
;
; 			    		   On entry, YX is the sector count
;
; ************************************************************************************************

		.section code

OSFormatFlash:
		phx 								; save sector count

		phy	 								; savce sector count as well.
		phx
		;
		;		Erase the information sector which doesn't care about sector sizes etc.
		;
		lda 	#0 							; erase sector zero
		jsr 	FSHErase
		;
		;		Write 'I',1,Count.Lo,Count.Hi,2^Size
		;
		lda 	#'I' 						; sector type (information)
		sta 	sectorHeader+0
		lda 	#'1'						; format 1
		sta 	sectorHeader+1

		pla 								; write the sector count.
		sta 	sectorHeader+2
		pla
		sta 	sectorHeader+3

		ldx 	#sectorHeader & $FF 		; source address.
		stx 	iTemp0
		ldx 	#sectorHeader >> 8
		stx 	iTemp0+1

		lda 	#0 							; sector and sub page zero
		tax

		jsr 	FSHWrite 					; write out
		;
		;		Re-initialise and erase other sectors
		;
		jsr 	FSInitialise 				; re-initialise the file system.

		pla 								; count of sectors.
_OSFFErase:
		dec 	a 							; last sector and backwards
		pha 								; erase it saving A
		jsr 	FSHErase
		pla
		cmp 	#1 							; don't erase sector 0
		bne 	_OSFFErase
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		initialise.asm
;		Purpose:	Initialise the Filesystem library
;		Created:	1st July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Initialise the Filesystem
;
; ************************************************************************************************

		.section code

FSInitialise:
		stz 	sectorCount 				; initial values to read $00
		stz 	sectorCount+1
		;
		;		Read in from the first sector (unaffected by size or count !)
		;		the sector size and count values.
		;
		;		Note in this version, a maximum of 256 sectors only allowed.
		;
		lda 	#0 							; read header sector 0
		jsr 	FSReadHeaderA

		lda 	sectorHeader+2 				; copy sector count
		sta 	sectorCount
		lda 	sectorHeader+3
		sta 	sectorCount+1

		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		emulator.asm
;		Purpose:	Emulator interface
;		Created:	1st July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Interface to Flash Hardware
;
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;										   Erase sector A
;
; ************************************************************************************************


FSHErase:
		sta 	$CF11 						; sector number.
		lda 	#0 							; erase command
		sta 	$CF10
		rts

; ************************************************************************************************
;
;						 Read Sector A, subpage X from iTemp0,y bytes (0 == 256)
;
; ************************************************************************************************

FSHRead:
		sty 	$CF15 						; byte count
		jsr 	FSHSetup 					; setup sector and address
		lda 	#1
		sta 	$CF10 						; read command.
		rts

; ************************************************************************************************
;
;							Write Sector A, subpage X from iTemp0
;
; ************************************************************************************************

FSHWrite:
		jsr 	FSHSetup 					; setup sector and address
		lda 	#2
		sta 	$CF10 						; write command.
		rts

; ************************************************************************************************
;
;										Common R/W setup
;
; ************************************************************************************************

FSHSetup:
		sta 	$CF11 						; sector/subpage
		stx 	$CF12
		lda 	iTemp0
		sta 	$CF13 						; copy data
		lda 	iTemp0+1
		sta 	$CF14
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

