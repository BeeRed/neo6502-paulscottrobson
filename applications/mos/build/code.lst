
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -q -Wall -c -C -b -L build/code.lst -l build/code.lbl -o build/osrom.bin osrom.asm
; Mon Jun  5 10:06:57 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: osrom.asm


;******  Processing file: ramdata.inc

=$08					ZeroPageBase = $08 							; zero page usage
=$200					StorageBase = $200 							; ROM usage
.0008					rTemp0:
>0008							.fill 	2
.000a					iTemp0:
>000a							.fill 	2
.000c					IFR0:
>000c							.fill 	4
.0010					IFR1:
>0010							.fill 	4
.0014					IFR2:
>0014							.fill 	4
.0018					IFRTemp:
>0018							.fill 	4
.0200					OSXPos:
>0200							.fill 	1
.0201					OSYPos:
>0201							.fill 	1
.0202					OSXSize:
>0202							.fill 	1
.0203					OSYSize:
>0203							.fill 	1
=16					OSKeyboardQueueMaxSize = 16					; keyboard queue max size.
.0204					OSKeyStatus:
>0204							.fill 	32
.0224					OSKeyboardQueue:
>0224							.fill 	OSKeyboardQueueMaxSize
.0234					OSKeyboardQueueSize:
>0234							.fill 	1
.0235					OSIsKeyUp:
>0235							.fill 	1
.0236					OSIsKeyShift:
>0236							.fill 	1
.0237					OSRKOriginal:
>0237							.fill 	1
=192					OSTextBufferSize = 192
.0238					OSXEdit:
>0238							.fill 	1
.0239					OSYEdit:
>0239							.fill 	1
.023a					OSEditWidth:
>023a							.fill 	1
.023b					OSEditPos:
>023b							.fill 	1
.023c					OSEditScroll:
>023c							.fill 	1
.023d					OSEditLength:
>023d							.fill 	1
.023e					OSEditBuffer:
>023e							.fill 	OSTextBufferSize
>02fe							.fill 	32
>031e							.align 	256

;******  Return to file: osrom.asm

.f800	20 63 fc	jsr $fc63	Boot:	jsr 	OSInitialise 				; set everything up.
.f803					TestEdit:
.f803	a9 1e		lda #$1e			lda 	#30
.f805	8d 00 02	sta $0200			sta 	OSXPos
.f808	a9 03		lda #$03			lda 	#3
.f80a	8d 01 02	sta $0201			sta 	OSYPos
.f80d	a2 10		ldx #$10			ldx 	#16
.f80f	8e 3d 02	stx $023d			stx 	OSEditLength
.f812	8a		txa		_TEFill:txa
.f813	09 40		ora #$40			ora 	#64
.f815	9d 3d 02	sta $023d,x			sta 	OSEditLength,x
.f818	ca		dex				dex
.f819	d0 f7		bne $f812			bne 	_TEFill
.f81b	20 b0 f9	jsr $f9b0			jsr 	OSEditLine
.f81e	20 7b fb	jsr $fb7b	h1:		jsr 	OSReadKeystroke
.f821	20 bb fb	jsr $fbbb			jsr 	OSWriteScreen
.f824	80 f8		bra $f81e			bra 	h1
.f826					KeyEcho:
.f826	20 7b fb	jsr $fb7b			jsr 	OSReadKeystroke
.f829	20 bb fb	jsr $fbbb			jsr 	OSWriteScreen
.f82c	20 7b fc	jsr $fc7b			jsr 	OSTWriteHex
.f82f	a9 20		lda #$20			lda 	#' '
.f831	20 bb fb	jsr $fbbb			jsr 	OSWriteScreen
.f834	80 f0		bra $f826			bra 	KeyEcho
.f836					NoInt:
.f836	40		rti				rti

;******  Processing file: include.files


;******  Processing file: src/drivers/charwrite.asm

.f837					OSReadPhysical:
.f837	20 45 f8	jsr $f845			jsr 	OSGetAddress
.f83a	b2 08		lda ($08)			lda 	(rTemp0)
.f83c	60		rts				rts
.f83d					OSWritePhysical:
.f83d	48		pha				pha
.f83e	20 45 f8	jsr $f845			jsr 	OSGetAddress
.f841	68		pla				pla
.f842	92 08		sta ($08)			sta 	(rTemp0)
.f844	60		rts				rts
.f845					OSGetAddress:
.f845	ac 01 02	ldy $0201	        ldy     OSYPos
.f848	ae 00 02	ldx $0200	        ldx 	OSXPos
.f84b					OSGetAddressXY:
.f84b	ad 02 02	lda $0202	        lda     OSXSize
.f84e	4a		lsr a		        lsr     a                           ; prime the carry bit for the loop
.f84f	85 08		sta $08		        sta     rTemp0
.f851	84 09		sty $09		        sty     rTemp0+1
.f853	a9 00		lda #$00	        lda     #0
.f855	a0 08		ldy #$08	        ldy     #8
.f857					_IFMLoop:
.f857	90 03		bcc $f85c	        bcc     _IFMNoAdd
.f859	18		clc		        clc
.f85a	65 09		adc $09		        adc     rTemp0+1
.f85c					_IFMNoAdd:
.f85c	6a		ror a		        ror     a
.f85d	66 08		ror $08		        ror     rTemp0                    ; pull another bit out for the next iteration
.f85f	88		dey		        dey
.f860	d0 f5		bne $f857	        bne     _IFMLoop
.f862	09 c0		ora #$c0	        ora 	#$C0
.f864	a8		tay		        tay
.f865	18		clc		        clc
.f866	8a		txa		        txa
.f867	65 08		adc $08		        adc 	rTemp0
.f869	85 08		sta $08		        sta 	rTemp0
.f86b	90 01		bcc $f86e	        bcc 	_IFMNoCarry
.f86d	c8		iny		        iny
.f86e					_IFMNoCarry:
.f86e	84 09		sty $09				sty 	rTemp0+1
.f870	60		rts		        rts

;******  Return to file: include.files


;******  Processing file: src/drivers/clear.asm

.f871					OSClearScreen:
.f871	a9 c0		lda #$c0			lda 	#$C0 						; set screen pos.
.f873	85 09		sta $09				sta 	rTemp0+1
.f875	64 08		stz $08				stz 	rTemp0
.f877	ac 03 02	ldy $0203			ldy 	OSYSize 					; clear height * width bytes.
.f87a					_OSCSLoop1:
.f87a	ae 02 02	ldx $0202			ldx 	OSXSize
.f87d					_OSCSLoop2:
.f87d	a9 20		lda #$20			lda 	#' '
.f87f	92 08		sta ($08)			sta 	(rTemp0)
.f881	e6 08		inc $08				inc 	rTemp0
.f883	d0 02		bne $f887			bne 	_OSCSNoCarry
.f885	e6 09		inc $09				inc 	rTemp0+1
.f887					_OSCSNoCarry:
.f887	ca		dex				dex
.f888	d0 f3		bne $f87d			bne 	_OSCSLoop2
.f88a	88		dey				dey
.f88b	d0 ed		bne $f87a			bne 	_OSCSLoop1
.f88d	20 5c fc	jsr $fc5c			jsr 	OSHomeCursor 				; cursor to (0,0)
.f890	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/ps2keyboard.asm

.f891					OSKeyboardDataProcess:
.f891	ad 00 cf	lda $cf00			lda 	$CF00 						; read keyboard port
.f894	f0 31		beq $f8c7			beq 	_OSKExit 					; no events available.
.f896	c9 f0		cmp #$f0			cmp 	#$F0 						; check key up ?
.f898	f0 2a		beq $f8c4			beq 	_OSKUp
.f89a	c9 e0		cmp #$e0			cmp 	#$E0 						; check extended scancode ?
.f89c	f0 1f		beq $f8bd			beq 	_OSKShift
.f89e	0d 36 02	ora $0236			ora 	OSIsKeyShift 				; actual key code.
.f8a1	48		pha				pha
.f8a2	20 c8 f8	jsr $f8c8			jsr 	OSKeyboardUpdateBits 		; update the up/down bits
.f8a5	68		pla				pla
.f8a6	ae 35 02	ldx $0235			ldx 	OSIsKeyUp 					; if key up reset up and shift flags.
.f8a9	f0 08		beq $f8b3			beq 	_OSKInsertQueue 			; if key down insert into queue
.f8ab	9c 35 02	stz $0235			stz 	OSIsKeyUp
.f8ae	9c 36 02	stz $0236			stz 	OSIsKeyShift
.f8b1	80 14		bra $f8c7			bra 	_OSKExit
.f8b3					_OSKInsertQueue:
.f8b3	20 60 f9	jsr $f960			jsr 	OSTranslateToASCII 			; convert to ASCII
.f8b6	b0 0f		bcs $f8c7			bcs 	_OSKExit 					; carry set, exit
.f8b8	20 f1 f8	jsr $f8f1			jsr 	OSInsertKeyboardQueue
.f8bb	80 0a		bra $f8c7			bra 	_OSKExit
.f8bd					_OSKShift:
.f8bd	a9 80		lda #$80			lda 	#$80
.f8bf	8d 36 02	sta $0236			sta 	OSIsKeyShift
.f8c2	80 03		bra $f8c7			bra 	_OSKExit
.f8c4					_OSKUp:
.f8c4	ce 35 02	dec $0235			dec 	OSIsKeyUp 					; received $F0 (key up)
.f8c7					_OSKExit:
.f8c7	60		rts				rts
.f8c8					OSKeyboardUpdateBits:
.f8c8	a2 00		ldx #$00			ldx 	#0 							; offset in table
.f8ca					_OSKUCalculate:
.f8ca	c9 08		cmp #$08			cmp 	#8 							; work out the row
.f8cc	90 06		bcc $f8d4			bcc 	_OSKUHaveRow
.f8ce	e8		inx				inx
.f8cf	38		sec				sec
.f8d0	e9 08		sbc #$08			sbc 	#8
.f8d2	80 f6		bra $f8ca			bra 	_OSKUCalculate
.f8d4					_OSKUHaveRow:
.f8d4	a8		tay				tay 								; work out the column
.f8d5	a9 00		lda #$00			lda 	#0
.f8d7	38		sec				sec
.f8d8					_OSKUCalculate2:
.f8d8	2a		rol a				rol 	a
.f8d9	88		dey				dey
.f8da	10 fc		bpl $f8d8			bpl 	_OSKUCalculate2  			; at end , A is bitmask, X is row (table entry)
.f8dc	2c 35 02	bit $0235			bit 	OSIsKeyUp 					; check up
.f8df	30 07		bmi $f8e8			bmi 	_OSKUUp
.f8e1	1d 04 02	ora $0204,x			ora 	OSKeyStatus,x 				; down set bit
.f8e4	9d 04 02	sta $0204,x			sta 	OSKeyStatus,x
.f8e7	60		rts				rts
.f8e8					_OSKUUp:
.f8e8	49 ff		eor #$ff			eor 	#$FF 						; make maske
.f8ea	3d 04 02	and $0204,x			and 	OSKeyStatus,x 				; up clear bit
.f8ed	9d 04 02	sta $0204,x			sta 	OSKeyStatus,x
.f8f0	60		rts				rts
.f8f1					OSInsertKeyboardQueue:
.f8f1	ae 34 02	ldx $0234			ldx 	OSKeyboardQueueSize 		; check to see if full
.f8f4	e0 10		cpx #$10			cpx	 	#OSKeyboardQueueMaxSize
.f8f6	b0 06		bcs $f8fe			bcs 	_OSIKQExit
.f8f8	9d 24 02	sta $0224,x			sta 	OSKeyboardQueue,x 			; add keyboard entry to queue.
.f8fb	ee 34 02	inc $0234			inc 	OSKeyboardQueueSize
.f8fe					_OSIKQExit:
.f8fe	60		rts				rts
.f8ff					OSKeyboardInitialise:
.f8ff	a2 32		ldx #$32			ldx 	#OSIsKeyShift-OSKeyStatus
.f901					_OSKILoop:
.f901	9e 04 02	stz $0204,x			stz 	OSKeyStatus,x
.f904	ca		dex				dex
.f905	10 fa		bpl $f901			bpl 	_OSKILoop
.f907	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/scroll.asm

.f908					OSScrollUp:
.f908	a9 c0		lda #$c0			lda 	#$C0
.f90a	64 08		stz $08				stz 	rTemp0
.f90c	85 09		sta $09				sta 	rTemp0+1
.f90e	ac 03 02	ldy $0203			ldy 	OSYSize
.f911	88		dey				dey
.f912					_OSSULoop1:
.f912	ae 02 02	ldx $0202			ldx 	OSXSize
.f915	5a		phy				phy
.f916	ac 02 02	ldy $0202			ldy 	OSXSize
.f919					_OSSULoop2:
.f919	b1 08		lda ($08),y			lda 	(rTemp0),y
.f91b	92 08		sta ($08)			sta 	(rTemp0)
.f91d	e6 08		inc $08				inc 	rTemp0
.f91f	d0 02		bne $f923			bne 	_OSSUCarry
.f921	e6 09		inc $09				inc 	rTemp0+1
.f923					_OSSUCarry:
.f923	ca		dex				dex
.f924	d0 f3		bne $f919			bne 	_OSSULoop2
.f926	7a		ply				ply
.f927	88		dey				dey
.f928	d0 e8		bne $f912			bne 	_OSSULoop1
.f92a	ac 02 02	ldy $0202			ldy 	OSXSize
.f92d					_OSSUFill:
.f92d	a9 20		lda #$20			lda 	#' '
.f92f	88		dey				dey
.f930	91 08		sta ($08),y			sta 	(rTemp0),y
.f932	d0 f9		bne $f92d			bne 	_OSSUFill
.f934	60		rts				rts
.f935					OSScrollDown:
.f935	ae 02 02	ldx $0202			ldx 	OSXSize
.f938	ac 03 02	ldy $0203			ldy 	OSYSize
.f93b	ca		dex				dex
.f93c	88		dey				dey
.f93d	88		dey				dey
.f93e	20 4b f8	jsr $f84b			jsr 	OSGetAddressXY
.f941	ac 02 02	ldy $0202			ldy 	OSXSize
.f944					_OSSDLoop:
.f944	b2 08		lda ($08)			lda 	(rTemp0)
.f946	91 08		sta ($08),y			sta 	(rTemp0),y
.f948	a5 08		lda $08				lda 	rTemp0
.f94a	d0 08		bne $f954			bne 	_OSSDNoBorrow
.f94c	a5 09		lda $09				lda 	rTemp0+1
.f94e	c9 c0		cmp #$c0			cmp 	#$C0
.f950	f0 06		beq $f958			beq 	_OSSDExit
.f952	c6 09		dec $09				dec 	rTemp0+1
.f954					_OSSDNoBorrow:
.f954	c6 08		dec $08				dec 	rTemp0
.f956	80 ec		bra $f944			bra 	_OSSDLoop
.f958					_OSSDExit:
.f958	a9 20		lda #$20			lda		#' '
.f95a	88		dey				dey
.f95b	91 08		sta ($08),y			sta 	(rTemp0),y
.f95d	d0 f9		bne $f958			bne 	_OSSDExit
.f95f	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/translate.asm

.f960					OSTranslateToASCII:
.f960	aa		tax				tax
.f961	bd 43 fa	lda $fa43,x			lda 	OSASCIIFromScanCode,x 		; get ASCII keystroke from scan code
.f964	f0 45		beq $f9ab			beq 	_OSTTAFail 					; wrong keyboard map/type ?
.f966	aa		tax				tax 								; save in X
.f967	ad 06 02	lda $0206			lda 	OSKeyStatus+OS_KP_LEFTCTRL_ROW
.f96a	29 10		and #$10			and 	#OS_KP_LEFTCTRL_COL
.f96c	d0 36		bne $f9a4			bne 	_OSTTAControl 				; check for CTRL + x
.f96e	ad 06 02	lda $0206			lda 	OSKeyStatus+OS_KP_LEFTSHIFT_ROW
.f971	29 04		and #$04			and 	#OS_KP_LEFTSHIFT_COL
.f973	d0 07		bne $f97c			bne 	_OSTTAShift 				; check for left/right shift
.f975	ad 0f 02	lda $020f			lda 	OSKeyStatus+OS_KP_RIGHTSHIFT_ROW
.f978	29 02		and #$02			and 	#OS_KP_RIGHTSHIFT_COL
.f97a	f0 2c		beq $f9a8			beq 	_OSTTAExit
.f97c					_OSTTAShift:
.f97c	e0 61		cpx #$61			cpx 	#"a"						; check alpha
.f97e	90 0a		bcc $f98a			bcc 	_OSTTANotAlpha
.f980	e0 7b		cpx #$7b			cpx 	#"z"+1
.f982	b0 06		bcs $f98a			bcs 	_OSTTANotAlpha
.f984	8a		txa				txa									; capitalise.
.f985	49 20		eor #$20			eor 	#$20
.f987	aa		tax				tax
.f988	80 1e		bra $f9a8			bra 	_OSTTAExit
.f98a					_OSTTANotAlpha:
.f98a	86 08		stx $08				stx 	rTemp0 						; save ASCII code.
.f98c	a0 00		ldy #$00			ldy 	#0 							; check the shift table
.f98e					_OSTTACheckShiftTable:
.f98e	b9 45 fb	lda $fb45,y			lda 	OSShiftFixTable+1,y 		; tax = shifted character
.f991	aa		tax				tax
.f992	b9 44 fb	lda $fb44,y			lda 	OSShiftFixTable,y 			; check unshifted match
.f995	c5 08		cmp $08				cmp 	rTemp0
.f997	f0 0f		beq $f9a8			beq 	_OSTTAExit
.f999	c8		iny				iny 								; next pair
.f99a	c8		iny				iny
.f99b	b9 44 fb	lda $fb44,y			lda 	OSShiftFixTable,y 			; until all checked
.f99e	10 ee		bpl $f98e			bpl 	_OSTTACheckShiftTable
.f9a0	a6 08		ldx $08				ldx 	rTemp0 						; not shiftable.
.f9a2	80 04		bra $f9a8			bra 	_OSTTAExit
.f9a4					_OSTTAControl:
.f9a4	8a		txa				txa
.f9a5	29 1f		and #$1f			and 	#31
.f9a7	aa		tax				tax
.f9a8					_OSTTAExit:
.f9a8	8a		txa				txa
.f9a9	18		clc				clc
.f9aa	60		rts				rts
.f9ab					_OSTTAFail:
.f9ab	38		sec				sec
.f9ac	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/editor/editor.asm

.f9ad					OSEditNewLine:
.f9ad	9c 3d 02	stz $023d			stz 	OSEditLength 				; clear buffer
.f9b0					OSEditLine:
.f9b0	ad 00 02	lda $0200			lda 	OSXPos 						; save edit point.
.f9b3	8d 38 02	sta $0238			sta 	OSXEdit
.f9b6	ad 01 02	lda $0201			lda 	OSYPos
.f9b9	8d 39 02	sta $0239			sta 	OSYEdit
.f9bc	ad 3d 02	lda $023d			lda 	OSEditLength 				; edit point at end of line.
.f9bf	8d 3b 02	sta $023b			sta 	OSEditPos
.f9c2	9c 3c 02	stz $023c			stz 	OSEditScroll 				; no initial scrolling
.f9c5	38		sec				sec 								; calculate edit box width.
.f9c6	ad 02 02	lda $0202			lda 	OSXSize
.f9c9	ed 00 02	sbc $0200			sbc 	OSXPos
.f9cc	8d 3a 02	sta $023a			sta 	OSEditWidth
.f9cf	38		sec				sec 								; force repaint.
.f9d0	20 e7 f9	jsr $f9e7			jsr 	OSEUpdatePosition 			; update the position.
.f9d3					_OSEditLoop:
.f9d3	20 7b fb	jsr $fb7b			jsr 	OSReadKeystroke 			; get one key.
.f9d6	c9 03		cmp #$03			cmp 	#3 							; down, up, esc, CR all exit
.f9d8	f0 0c		beq $f9e6			beq 	_OSEditExit
.f9da	c9 06		cmp #$06			cmp 	#6
.f9dc	f0 08		beq $f9e6			beq 	_OSEditExit
.f9de	c9 0d		cmp #$0d			cmp 	#13
.f9e0	f0 04		beq $f9e6			beq 	_OSEditExit
.f9e2	c9 1b		cmp #$1b			cmp 	#27
.f9e4	d0 01		bne $f9e7			bne 	_OSEditContinue
.f9e6					_OSEditExit:
.f9e6	60		rts				rts
.f9e7					_OSEditContinue:
.f9e7					OSEUpdatePosition:
.f9e7	08		php				php 								; save repaint flag.
.f9e8	ad 3c 02	lda $023c			lda 	OSEditScroll 				; save old edit scroll position.
.f9eb	48		pha				pha
.f9ec	20 03 fa	jsr $fa03			jsr 	OSECheckPosition 			; check position in range of text
>f9ef	db						.byte 	$DB
.f9f0	20 1a fa	jsr $fa1a			jsr 	OSECheckVisible 			; is it on screen ?
.f9f3	68		pla				pla 								; has the edit scroll position changed ?
.f9f4	cd 3c 02	cmp $023c			cmp 	OSEditScroll
.f9f7	f0 03		beq $f9fc			beq 	_OSECVNoChange
.f9f9	28		plp				plp 								; if so, set repaint flag
.f9fa	38		sec				sec
.f9fb	08		php				php
.f9fc					_OSECVNoChange:
.f9fc	28		plp				plp	 								; do we need a repaint.
.f9fd	90 03		bcc $fa02			bcc 	_OSECVNoRepaint
.f9ff	20 42 fa	jsr $fa42			jsr 	OSERepaint
.fa02					_OSECVNoRepaint:
.fa02	60		rts				rts
.fa03					OSECheckPosition:
.fa03	ad 3b 02	lda $023b			lda 	OSEditPos 					; if position = 255 (e.g. -1) then off left.
.fa06	c9 ff		cmp #$ff			cmp 	#255
.fa08	d0 04		bne $fa0e			bne 	_OSECPNotLeft
.fa0a	9c 3b 02	stz $023b			stz 	OSEditPos
.fa0d	60		rts				rts
.fa0e					_OSECPNotLeft:
.fa0e	cd 3d 02	cmp $023d			cmp 	OSEditLength 				; if >= edit length reset to edit length
.fa11	d0 06		bne $fa19			bne 	_OSEPCNotRight
.fa13	ad 3d 02	lda $023d			lda 	OSEditLength
.fa16	8d 3b 02	sta $023b			sta 	OSEditPos
.fa19					_OSEPCNotRight:
.fa19	60		rts				rts
.fa1a					OSECheckVisible:
.fa1a	ad 3b 02	lda $023b			lda 	OSEditPos 					; if editpos < editscroll
.fa1d	cd 3c 02	cmp $023c			cmp 	OSEditScroll
.fa20	b0 04		bcs $fa26			bcs 	_OSENotOffLeft
.fa22	8d 3c 02	sta $023c			sta 	OSEditScroll 				; then scroll at that position.
.fa25	60		rts				rts
.fa26					_OSENotOffLeft:
.fa26	38		sec				sec
.fa27	ad 3b 02	lda $023b			lda 	OSEditPos
.fa2a	ed 3c 02	sbc $023c			sbc 	OSEditScroll
.fa2d	cd 3a 02	cmp $023a			cmp 	OSEditWidth
.fa30	b0 01		bcs $fa33			bcs 	_OSEOffRight
.fa32	60		rts				rts
.fa33					_OSEOffRight:
.fa33	38		sec				sec
.fa34	ad 3b 02	lda $023b			lda 	OSEditPos
.fa37	ed 3a 02	sbc $023a			sbc 	OSEditWidth
.fa3a	b0 02		bcs $fa3e			bcs 	_OSENoTrim
.fa3c	a9 00		lda #$00			lda 	#0
.fa3e					_OSENoTrim:
.fa3e	8d 3c 02	sta $023c			sta 	OSEditScroll
.fa41	60		rts				rts
.fa42					OSERepaint:
.fa42	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/generated/ps2convert.asm

.fa43					OSASCIIFromScanCode:
>fa43	00					.byte	$00 ; $00
>fa44	19					.byte	$19 ; $01 chr$(25)
>fa45	00					.byte	$00 ; $02
>fa46	15					.byte	$15 ; $03 chr$(21)
>fa47	13					.byte	$13 ; $04 chr$(19)
>fa48	11					.byte	$11 ; $05 chr$(17)
>fa49	12					.byte	$12 ; $06 chr$(18)
>fa4a	00					.byte	$00 ; $07
>fa4b	00					.byte	$00 ; $08
>fa4c	1a					.byte	$1a ; $09 chr$(26)
>fa4d	18					.byte	$18 ; $0a chr$(24)
>fa4e	16					.byte	$16 ; $0b chr$(22)
>fa4f	14					.byte	$14 ; $0c chr$(20)
>fa50	09					.byte	$09 ; $0d chr$(9)
>fa51	60					.byte	$60 ; $0e '`'
>fa52	00					.byte	$00 ; $0f
>fa53	00					.byte	$00 ; $10
>fa54	00					.byte	$00 ; $11
>fa55	00					.byte	$00 ; $12
>fa56	00					.byte	$00 ; $13
>fa57	00					.byte	$00 ; $14
>fa58	71					.byte	$71 ; $15 'q'
>fa59	31					.byte	$31 ; $16 '1'
>fa5a	00					.byte	$00 ; $17
>fa5b	00					.byte	$00 ; $18
>fa5c	00					.byte	$00 ; $19
>fa5d	7a					.byte	$7a ; $1a 'z'
>fa5e	73					.byte	$73 ; $1b 's'
>fa5f	61					.byte	$61 ; $1c 'a'
>fa60	77					.byte	$77 ; $1d 'w'
>fa61	32					.byte	$32 ; $1e '2'
>fa62	00					.byte	$00 ; $1f
>fa63	00					.byte	$00 ; $20
>fa64	63					.byte	$63 ; $21 'c'
>fa65	78					.byte	$78 ; $22 'x'
>fa66	64					.byte	$64 ; $23 'd'
>fa67	65					.byte	$65 ; $24 'e'
>fa68	34					.byte	$34 ; $25 '4'
>fa69	33					.byte	$33 ; $26 '3'
>fa6a	00					.byte	$00 ; $27
>fa6b	00					.byte	$00 ; $28
>fa6c	20					.byte	$20 ; $29 ' '
>fa6d	76					.byte	$76 ; $2a 'v'
>fa6e	66					.byte	$66 ; $2b 'f'
>fa6f	74					.byte	$74 ; $2c 't'
>fa70	72					.byte	$72 ; $2d 'r'
>fa71	35					.byte	$35 ; $2e '5'
>fa72	00					.byte	$00 ; $2f
>fa73	00					.byte	$00 ; $30
>fa74	6e					.byte	$6e ; $31 'n'
>fa75	62					.byte	$62 ; $32 'b'
>fa76	68					.byte	$68 ; $33 'h'
>fa77	67					.byte	$67 ; $34 'g'
>fa78	79					.byte	$79 ; $35 'y'
>fa79	36					.byte	$36 ; $36 '6'
>fa7a	00					.byte	$00 ; $37
>fa7b	00					.byte	$00 ; $38
>fa7c	00					.byte	$00 ; $39
>fa7d	6d					.byte	$6d ; $3a 'm'
>fa7e	6a					.byte	$6a ; $3b 'j'
>fa7f	75					.byte	$75 ; $3c 'u'
>fa80	37					.byte	$37 ; $3d '7'
>fa81	38					.byte	$38 ; $3e '8'
>fa82	00					.byte	$00 ; $3f
>fa83	00					.byte	$00 ; $40
>fa84	2c					.byte	$2c ; $41 ','
>fa85	6b					.byte	$6b ; $42 'k'
>fa86	69					.byte	$69 ; $43 'i'
>fa87	6f					.byte	$6f ; $44 'o'
>fa88	30					.byte	$30 ; $45 '0'
>fa89	39					.byte	$39 ; $46 '9'
>fa8a	00					.byte	$00 ; $47
>fa8b	00					.byte	$00 ; $48
>fa8c	2e					.byte	$2e ; $49 '.'
>fa8d	2f					.byte	$2f ; $4a '/'
>fa8e	6c					.byte	$6c ; $4b 'l'
>fa8f	3b					.byte	$3b ; $4c ';'
>fa90	70					.byte	$70 ; $4d 'p'
>fa91	2d					.byte	$2d ; $4e '-'
>fa92	00					.byte	$00 ; $4f
>fa93	00					.byte	$00 ; $50
>fa94	00					.byte	$00 ; $51
>fa95	27					.byte	$27 ; $52 '''
>fa96	00					.byte	$00 ; $53
>fa97	5b					.byte	$5b ; $54 '['
>fa98	3d					.byte	$3d ; $55 '='
>fa99	00					.byte	$00 ; $56
>fa9a	00					.byte	$00 ; $57
>fa9b	00					.byte	$00 ; $58
>fa9c	00					.byte	$00 ; $59
>fa9d	0d					.byte	$0d ; $5a chr$(13)
>fa9e	5d					.byte	$5d ; $5b ']'
>fa9f	00					.byte	$00 ; $5c
>faa0	7c					.byte	$7c ; $5d '|'
>faa1	00					.byte	$00 ; $5e
>faa2	00					.byte	$00 ; $5f
>faa3	00					.byte	$00 ; $60
>faa4	00					.byte	$00 ; $61
>faa5	00					.byte	$00 ; $62
>faa6	00					.byte	$00 ; $63
>faa7	00					.byte	$00 ; $64
>faa8	00					.byte	$00 ; $65
>faa9	08					.byte	$08 ; $66 chr$(8)
>faaa	00					.byte	$00 ; $67
>faab	00					.byte	$00 ; $68
>faac	00					.byte	$00 ; $69
>faad	00					.byte	$00 ; $6a
>faae	01					.byte	$01 ; $6b chr$(1)
>faaf	00					.byte	$00 ; $6c
>fab0	00					.byte	$00 ; $6d
>fab1	00					.byte	$00 ; $6e
>fab2	00					.byte	$00 ; $6f
>fab3	00					.byte	$00 ; $70
>fab4	00					.byte	$00 ; $71
>fab5	03					.byte	$03 ; $72 chr$(3)
>fab6	00					.byte	$00 ; $73
>fab7	04					.byte	$04 ; $74 chr$(4)
>fab8	06					.byte	$06 ; $75 chr$(6)
>fab9	1b					.byte	$1b ; $76 chr$(27)
>faba	00					.byte	$00 ; $77
>fabb	00					.byte	$00 ; $78
>fabc	00					.byte	$00 ; $79
>fabd	00					.byte	$00 ; $7a
>fabe	00					.byte	$00 ; $7b
>fabf	00					.byte	$00 ; $7c
>fac0	00					.byte	$00 ; $7d
>fac1	00					.byte	$00 ; $7e
>fac2	00					.byte	$00 ; $7f
>fac3	00					.byte	$00 ; $80
>fac4	00					.byte	$00 ; $81
>fac5	00					.byte	$00 ; $82
>fac6	17					.byte	$17 ; $83 chr$(23)
>fac7	00					.byte	$00 ; $84
>fac8	00					.byte	$00 ; $85
>fac9	00					.byte	$00 ; $86
>faca	00					.byte	$00 ; $87
>facb	00					.byte	$00 ; $88
>facc	00					.byte	$00 ; $89
>facd	00					.byte	$00 ; $8a
>face	00					.byte	$00 ; $8b
>facf	00					.byte	$00 ; $8c
>fad0	00					.byte	$00 ; $8d
>fad1	00					.byte	$00 ; $8e
>fad2	00					.byte	$00 ; $8f
>fad3	00					.byte	$00 ; $90
>fad4	00					.byte	$00 ; $91
>fad5	00					.byte	$00 ; $92
>fad6	00					.byte	$00 ; $93
>fad7	00					.byte	$00 ; $94
>fad8	00					.byte	$00 ; $95
>fad9	00					.byte	$00 ; $96
>fada	00					.byte	$00 ; $97
>fadb	00					.byte	$00 ; $98
>fadc	00					.byte	$00 ; $99
>fadd	00					.byte	$00 ; $9a
>fade	00					.byte	$00 ; $9b
>fadf	00					.byte	$00 ; $9c
>fae0	00					.byte	$00 ; $9d
>fae1	00					.byte	$00 ; $9e
>fae2	00					.byte	$00 ; $9f
>fae3	00					.byte	$00 ; $a0
>fae4	00					.byte	$00 ; $a1
>fae5	00					.byte	$00 ; $a2
>fae6	00					.byte	$00 ; $a3
>fae7	00					.byte	$00 ; $a4
>fae8	00					.byte	$00 ; $a5
>fae9	00					.byte	$00 ; $a6
>faea	00					.byte	$00 ; $a7
>faeb	00					.byte	$00 ; $a8
>faec	00					.byte	$00 ; $a9
>faed	00					.byte	$00 ; $aa
>faee	00					.byte	$00 ; $ab
>faef	00					.byte	$00 ; $ac
>faf0	00					.byte	$00 ; $ad
>faf1	00					.byte	$00 ; $ae
>faf2	00					.byte	$00 ; $af
>faf3	00					.byte	$00 ; $b0
>faf4	00					.byte	$00 ; $b1
>faf5	00					.byte	$00 ; $b2
>faf6	00					.byte	$00 ; $b3
>faf7	00					.byte	$00 ; $b4
>faf8	00					.byte	$00 ; $b5
>faf9	00					.byte	$00 ; $b6
>fafa	00					.byte	$00 ; $b7
>fafb	00					.byte	$00 ; $b8
>fafc	00					.byte	$00 ; $b9
>fafd	00					.byte	$00 ; $ba
>fafe	00					.byte	$00 ; $bb
>faff	00					.byte	$00 ; $bc
>fb00	00					.byte	$00 ; $bd
>fb01	00					.byte	$00 ; $be
>fb02	00					.byte	$00 ; $bf
>fb03	00					.byte	$00 ; $c0
>fb04	00					.byte	$00 ; $c1
>fb05	00					.byte	$00 ; $c2
>fb06	00					.byte	$00 ; $c3
>fb07	00					.byte	$00 ; $c4
>fb08	00					.byte	$00 ; $c5
>fb09	00					.byte	$00 ; $c6
>fb0a	00					.byte	$00 ; $c7
>fb0b	00					.byte	$00 ; $c8
>fb0c	00					.byte	$00 ; $c9
>fb0d	00					.byte	$00 ; $ca
>fb0e	00					.byte	$00 ; $cb
>fb0f	00					.byte	$00 ; $cc
>fb10	00					.byte	$00 ; $cd
>fb11	00					.byte	$00 ; $ce
>fb12	00					.byte	$00 ; $cf
>fb13	00					.byte	$00 ; $d0
>fb14	00					.byte	$00 ; $d1
>fb15	00					.byte	$00 ; $d2
>fb16	00					.byte	$00 ; $d3
>fb17	00					.byte	$00 ; $d4
>fb18	00					.byte	$00 ; $d5
>fb19	00					.byte	$00 ; $d6
>fb1a	00					.byte	$00 ; $d7
>fb1b	00					.byte	$00 ; $d8
>fb1c	00					.byte	$00 ; $d9
>fb1d	00					.byte	$00 ; $da
>fb1e	00					.byte	$00 ; $db
>fb1f	00					.byte	$00 ; $dc
>fb20	00					.byte	$00 ; $dd
>fb21	00					.byte	$00 ; $de
>fb22	00					.byte	$00 ; $df
>fb23	00					.byte	$00 ; $e0
>fb24	00					.byte	$00 ; $e1
>fb25	00					.byte	$00 ; $e2
>fb26	00					.byte	$00 ; $e3
>fb27	00					.byte	$00 ; $e4
>fb28	00					.byte	$00 ; $e5
>fb29	00					.byte	$00 ; $e6
>fb2a	00					.byte	$00 ; $e7
>fb2b	00					.byte	$00 ; $e8
>fb2c	45					.byte	$45 ; $e9 'E'
>fb2d	00					.byte	$00 ; $ea
>fb2e	01					.byte	$01 ; $eb chr$(1)
>fb2f	02					.byte	$02 ; $ec chr$(2)
>fb30	00					.byte	$00 ; $ed
>fb31	00					.byte	$00 ; $ee
>fb32	00					.byte	$00 ; $ef
>fb33	00					.byte	$00 ; $f0
>fb34	07					.byte	$07 ; $f1 chr$(7)
>fb35	03					.byte	$03 ; $f2 chr$(3)
>fb36	00					.byte	$00 ; $f3
>fb37	04					.byte	$04 ; $f4 chr$(4)
>fb38	06					.byte	$06 ; $f5 chr$(6)
>fb39	00					.byte	$00 ; $f6
>fb3a	00					.byte	$00 ; $f7
>fb3b	00					.byte	$00 ; $f8
>fb3c	00					.byte	$00 ; $f9
>fb3d	00					.byte	$00 ; $fa
>fb3e	00					.byte	$00 ; $fb
>fb3f	00					.byte	$00 ; $fc
>fb40	00					.byte	$00 ; $fd
>fb41	00					.byte	$00 ; $fe
>fb42	00					.byte	$00 ; $ff
>fb43	ff					.byte	$FF
.fb44					OSShiftFixTable:
>fb44	60 7e					.byte	$60,$7e		; ` => ~
>fb46	31 21					.byte	$31,$21		; 1 => !
>fb48	32 40					.byte	$32,$40		; 2 => @
>fb4a	33 23					.byte	$33,$23		; 3 => #
>fb4c	34 24					.byte	$34,$24		; 4 => $
>fb4e	35 25					.byte	$35,$25		; 5 => %
>fb50	36 5e					.byte	$36,$5e		; 6 => ^
>fb52	37 26					.byte	$37,$26		; 7 => &
>fb54	38 2a					.byte	$38,$2a		; 8 => *
>fb56	39 28					.byte	$39,$28		; 9 => (
>fb58	30 29					.byte	$30,$29		; 0 => )
>fb5a	2d 5f					.byte	$2d,$5f		; - => _
>fb5c	3d 2b					.byte	$3d,$2b		; = => +
>fb5e	3b 3a					.byte	$3b,$3a		; ; => :
>fb60	27 22					.byte	$27,$22		; ' => "
>fb62	2c 3c					.byte	$2c,$3c		; , => <
>fb64	2e 3e					.byte	$2e,$3e		; . => >
>fb66	2f 3f					.byte	$2f,$3f		; / => ?
>fb68	ff					.byte	$FF
=2					OS_KP_LEFTCTRL_ROW = 2
=$10					OS_KP_LEFTCTRL_COL = $10
=2					OS_KP_LEFTSHIFT_ROW = 2
=$04					OS_KP_LEFTSHIFT_COL = $04
=11					OS_KP_RIGHTSHIFT_ROW = 11
=$02					OS_KP_RIGHTSHIFT_COL = $02
=4					OS_KP_C_ROW = 4
=$02					OS_KP_C_COL = $02
=3					OS_KP_Z_ROW = 3
=$04					OS_KP_Z_COL = $04
=4					OS_KP_X_ROW = 4
=$04					OS_KP_X_COL = $04
=8					OS_KP_K_ROW = 8
=$04					OS_KP_K_COL = $04
=7					OS_KP_M_ROW = 7
=$04					OS_KP_M_COL = $04
=9					OS_KP_L_ROW = 9
=$08					OS_KP_L_COL = $08

;******  Return to file: include.files


;******  Processing file: src/keyboard/keyboard.asm

.fb69					OSIsKeyAvailable:
.fb69	48		pha				pha
.fb6a	18		clc				clc
.fb6b	ad 34 02	lda $0234			lda 	OSKeyboardQueueSize  		; get entries in queue
.fb6e	d0 01		bne $fb71			bne 	_OSIKAHasKey
.fb70	38		sec				sec
.fb71					_OSIKAHasKey:
.fb71	68		pla				pla
.fb72	60		rts				rts
.fb73					OSReadKeyboard:
.fb73	da		phx				phx
.fb74	a2 01		ldx #$01			ldx 	#1
.fb76	20 9c fb	jsr $fb9c			jsr 	OSReadDevice
.fb79	fa		plx				plx
.fb7a	60		rts				rts
.fb7b					OSReadKeystroke:
.fb7b	da		phx				phx 								; save XY
.fb7c	5a		phy				phy
.fb7d	20 37 f8	jsr $f837			jsr 	OSReadPhysical 				; save old character
.fb80	8d 37 02	sta $0237			sta 	OSRKOriginal
.fb83	a9 7f		lda #$7f			lda 	#$7F 						; write prompt
.fb85	20 3d f8	jsr $f83d			jsr 	OSWritePhysical
.fb88					_OSWaitKey:
.fb88	20 91 f8	jsr $f891			jsr 	OSKeyboardDataProcess 		; this scans the keyboard, could be interrupt
.fb8b	20 73 fb	jsr $fb73			jsr 	OSReadKeyboard 				; key available
.fb8e	b0 f8		bcs $fb88			bcs 	_OSWaitKey
.fb90	48		pha				pha 								; save key
.fb91	ad 37 02	lda $0237			lda 	OSRKOriginal 				; old character back
.fb94	20 3d f8	jsr $f83d			jsr 	OSWritePhysical
.fb97	68		pla				pla 								; restore
.fb98	7a		ply				ply
.fb99	fa		plx				plx
.fb9a	18		clc				clc 								; success
.fb9b	60		rts				rts
.fb9c					OSReadDevice:
.fb9c	20 69 fb	jsr $fb69			jsr 	OSIsKeyAvailable 			; key available ?
.fb9f	b0 19		bcs $fbba			bcs 	_OSRDExit
.fba1	ad 24 02	lda $0224			lda 	OSKeyboardQueue 			; push char on stack
.fba4	48		pha				pha
.fba5	da		phx				phx
.fba6	a2 00		ldx #$00			ldx		#0 							; remove from queue array
.fba8					_OSRDDequeue:
.fba8	bd 25 02	lda $0225,x			lda 	OSKeyboardQueue+1,x
.fbab	9d 24 02	sta $0224,x			sta 	OSKeyboardQueue,x
.fbae	e8		inx				inx
.fbaf	ec 34 02	cpx $0234			cpx 	OSKeyboardQueueSize
.fbb2	d0 f4		bne $fba8			bne 	_OSRDDequeue
.fbb4	ce 34 02	dec $0234			dec 	OSKeyboardQueueSize			; dec queue count
.fbb7	fa		plx				plx
.fbb8	68		pla				pla 								; restore key
.fbb9	18		clc				clc
.fbba					_OSRDExit:
.fbba	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/screen/charout.asm

.fbbb					OSWriteScreen:
.fbbb	da		phx				phx
.fbbc	a2 00		ldx #$00			ldx 	#0
.fbbe	20 c3 fb	jsr $fbc3			jsr 	OSWriteDevice
.fbc1	fa		plx				plx
.fbc2	60		rts				rts
.fbc3					OSWriteDevice:
.fbc3	48		pha				pha
.fbc4	da		phx				phx
.fbc5	5a		phy				phy
.fbc6	c9 20		cmp #$20			cmp 	#32 						; standard character
.fbc8	b0 0c		bcs $fbd6			bcs 	_OSWriteDirect
.fbca	c9 10		cmp #$10			cmp 	#16 						; 16-32 for set colours, reserved.
.fbcc	b0 0e		bcs $fbdc			bcs 	_OSWriteDeviceExit
.fbce	0a		asl a				asl 	a 							; make to an offset in vector table
.fbcf	aa		tax				tax
.fbd0	4a		lsr a				lsr 	a
.fbd1	20 e1 fb	jsr $fbe1			jsr 	_OSCallVectorCode
.fbd4	80 06		bra $fbdc			bra 	_OSWriteDeviceExit
.fbd6					_OSWriteDirect:
.fbd6	20 3d f8	jsr $f83d			jsr 	OSWritePhysical
.fbd9	20 25 fc	jsr $fc25			jsr 	_OSCursorAdvance
.fbdc					_OSWriteDeviceExit:
.fbdc	7a		ply				ply
.fbdd	fa		plx				plx
.fbde	68		pla				pla
.fbdf	18		clc				clc 								; written fine.
.fbe0	60		rts				rts
.fbe1					_OSCallVectorCode:
.fbe1	7c e5 fb	jmp ($fbe5,x)			jmp 	(_OSWDVector,x)
.fbe4					_OSWNoFunction:
.fbe4	60		rts				rts
.fbe5					_OSWDVector:
>fbe5	e4 fb						.word 	_OSWNoFunction 				; $00 	No operation
>fbe7	13 fc						.word 	_OSCursorLeft 				; $01 	Left 		(Ctrl-A)
>fbe9	5c fc						.word 	OSHomeCursor 				; $02 	Home Cursor (Ctrl-B)
>fbeb	33 fc						.word 	_OSCursorDown 				; $03 	Down 		(Ctrl-C)
>fbed	1c fc						.word 	_OSCursorRight 				; $04 	Right 		(Ctrl-D)
>fbef	25 fc						.word 	_OSCursorAdvance			; $05 	Advance
>fbf1	45 fc						.word 	_OSCursorUp 				; $06	Up 			(Ctrl-F)
>fbf3	e4 fb						.word 	_OSWNoFunction 				; $07 	Delete 		(Del)
>fbf5	05 fc						.word 	_OSBackspace				; $08 	Backspace 	(Backspace)
>fbf7	51 fc						.word 	_OSWHTab 					; $09	Tab
>fbf9	e4 fb						.word 	_OSWNoFunction 				; $0A
>fbfb	e4 fb						.word 	_OSWNoFunction 				; $0B
>fbfd	71 f8						.word 	OSClearScreen 				; $0C	ClearScreen	(Ctrl-L)
>fbff	30 fc						.word 	_OSNewLine 					; $0D 	CarriageRet (Enter)
>fc01	08 f9						.word 	OSScrollUp 					; $0E 	Scroll Up 	(e.g. off bottom)
>fc03	35 f9						.word 	OSScrollDown 				; $0F 	Scroll Down (e.g. off top)
.fc05					_OSBackspace:
.fc05	ad 00 02	lda $0200			lda 	OSXPos 						; left side already ?
.fc08	f0 11		beq $fc1b			beq 	_OSCLExit
.fc0a	ce 00 02	dec $0200			dec 	OSXPos
.fc0d	a9 20		lda #$20			lda 	#' '
.fc0f	20 3d f8	jsr $f83d			jsr 	OSWritePhysical
.fc12	60		rts				rts
.fc13					_OSCursorLeft:
.fc13	ad 00 02	lda $0200			lda 	OSXPos 						; left side
.fc16	f0 03		beq $fc1b			beq 	_OSCLExit 					; yes, exit
.fc18	ce 00 02	dec $0200			dec 	OSXPos 						; cursor left
.fc1b					_OSCLExit:
.fc1b	60		rts				rts
.fc1c					_OSCursorRight:
.fc1c	ad 00 02	lda $0200			lda 	OSXPos 						; reached right side ?
.fc1f	1a		inc a				inc 	a
.fc20	cd 02 02	cmp $0202			cmp 	OSXSize
.fc23	f0 1f		beq $fc44			beq 	_OSCRExit 					; yes, exit.
.fc25					_OSCursorAdvance:
.fc25	ee 00 02	inc $0200			inc 	OSXPos 						; advance cursor and position.
.fc28	ad 00 02	lda $0200			lda 	OSXPos 						; reached RHS
.fc2b	cd 02 02	cmp $0202			cmp 	OSXSize
.fc2e	90 14		bcc $fc44			bcc 	_OSCRExit 					; if so exit.
.fc30					_OSNewLine:
.fc30	9c 00 02	stz $0200			stz 	OSXPos 						; start next line.
.fc33					_OSCursorDown:
.fc33	ee 01 02	inc $0201			inc 	OSYPos
.fc36	ad 01 02	lda $0201			lda 	OSYPos 						; reached bottom
.fc39	cd 03 02	cmp $0203			cmp 	OSYSize
.fc3c	90 06		bcc $fc44			bcc 	_OSCRExit
.fc3e	ce 01 02	dec $0201			dec 	OSYPos 						; back to bottom line.
.fc41	20 08 f9	jsr $f908			jsr 	OSScrollUp 					; scroll whole screen up.
.fc44					_OSCRExit:
.fc44	60		rts				rts
.fc45					_OSCursorUp:
.fc45	ce 01 02	dec $0201			dec 	OSYPos 						; up
.fc48	10 fa		bpl $fc44			bpl 	_OSCRExit 					; still on screen
.fc4a	ee 01 02	inc $0201			inc 	OSYPos 						; fix up
.fc4d	20 35 f9	jsr $f935			jsr 	OSScrollDown 				; scroll down.
.fc50	60		rts				rts
.fc51					_OSWHTab:
.fc51	20 25 fc	jsr $fc25			jsr 	_OSCursorAdvance
.fc54	ad 00 02	lda $0200			lda 	OSXPos
.fc57	29 07		and #$07			and 	#7
.fc59	d0 f6		bne $fc51			bne 	_OSWHTab
.fc5b	60		rts				rts
.fc5c					OSHomeCursor:
.fc5c	9c 00 02	stz $0200			stz 	OSXPos
.fc5f	9c 01 02	stz $0201			stz 	OSYPos
.fc62	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/utility/setup.asm

.fc63					OSInitialise:
.fc63	a9 28		lda #$28			lda 	#40 						; 40 x 30 display
.fc65	8d 02 02	sta $0202			sta 	OSXSize
.fc68	a9 1e		lda #$1e			lda 	#30
.fc6a	8d 03 02	sta $0203			sta 	OSYSize
.fc6d	20 71 f8	jsr $f871			jsr 	OSClearScreen 				; clear the display
.fc70	20 ff f8	jsr $f8ff			jsr 	OSKeyboardInitialise 		; reset the keyboard state.
.fc73	60		rts				rts
.fc74					OSGetScreenSize:
.fc74	ae 02 02	ldx $0202			ldx 	OSXSize
.fc77	ac 03 02	ldy $0203			ldy 	OSYSize
.fc7a	60		rts				rts

;******  Return to file: include.files


;******  Return to file: osrom.asm

.fc7b					OSTWriteHex:
.fc7b	48		pha				pha
.fc7c	4a		lsr a				lsr 	a
.fc7d	4a		lsr a				lsr 	a
.fc7e	4a		lsr a				lsr 	a
.fc7f	4a		lsr a				lsr 	a
.fc80	20 84 fc	jsr $fc84			jsr 	_OSTWriteNibble
.fc83	68		pla				pla
.fc84					_OSTWriteNibble:
.fc84	48		pha				pha
.fc85	29 0f		and #$0f			and 	#15
.fc87	c9 0a		cmp #$0a			cmp 	#10
.fc89	90 02		bcc $fc8d			bcc 	_OSTNotAlpha
.fc8b	69 06		adc #$06			adc 	#6
.fc8d					_OSTNotAlpha:
.fc8d	69 30		adc #$30			adc 	#48
.fc8f	20 bb fb	jsr $fbbb			jsr 	OSWriteScreen
.fc92	68		pla				pla
.fc93	60		rts				rts

;******  Processing file: src/generated/vectors.asmx

.ffe5	4c 74 fc	jmp $fc74		jmp		OSGetScreenSize          ; Get size of screen to XY
.ffe8	4c 69 fb	jmp $fb69		jmp		OSIsKeyAvailable         ; Check if key available (CS if so)
.ffeb	4c 7b fb	jmp $fb7b		jmp		OSReadKeystroke          ; Read A from keyboard, showing cursor while waiting.
.ffee	4c 73 fb	jmp $fb73		jmp		OSReadKeyboard           ; Read A from keyboard (device 1), CC = success
.fff1	4c bb fb	jmp $fbbb		jmp		OSWriteScreen            ; Write A to screen (device 0), CC = success
.fff4	4c 9c fb	jmp $fb9c		jmp		OSReadDevice             ; Read device X to A, CC = success
.fff7	4c c3 fb	jmp $fbc3		jmp		OSWriteDevice            ; Write A to device X, CC = success

;******  Return to file: osrom.asm

>fffa	36 f8						.word 	NoInt 						; NMI
>fffc	00 f8						.word 	Boot 						; Reset
>fffe	36 f8						.word 	NoInt						; IRQ

;******  End of listing
