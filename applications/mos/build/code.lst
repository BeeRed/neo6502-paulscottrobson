
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -q -Wall -c -C -b -L build/code.lst -l build/code.lbl -o build/osrom.bin osrom.asm
; Sun Jul  2 18:59:05 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: osrom.asm


;******  Processing file: ramdata.inc

=$08					ZeroPageBase = $08 							; zero page usage
=$200					StorageBase = $200 							; ROM usage
.0008					IFR0:
>0008							.fill 	4
.000c					IFR1:
>000c							.fill 	4
.0010					IFR2:
>0010							.fill 	4
.0014					IFRTemp:
>0014							.fill 	4
.0018					codePtr:
>0018							.fill 	4
.001c					rTemp0:
>001c							.fill 	2
.001e					rTemp1:
>001e							.fill 	2
.0020					iTemp0:
>0020							.fill 	2
.0200					OSNewLineFlag:
>0200							.fill 	32
.0220					OSXPos:
>0220							.fill 	1
.0221					OSYPos:
>0221							.fill 	1
.0222					OSXSize:
>0222							.fill 	1
.0223					OSYSize:
>0223							.fill 	1
.0224					OSXPosSave:
>0224							.fill 	1
.0225					OSYPosSave:
>0225							.fill 	1
.0226					OSYFrameTop:
>0226							.fill 	1
.0227					OSYFrameBottom:
>0227							.fill 	1
=16					OSKeyboardQueueMaxSize = 16					; keyboard queue max size.
.0228					OSKeyStatus:
>0228							.fill 	32
.0248					OSKeyboardQueue:
>0248							.fill 	OSKeyboardQueueMaxSize
.0258					OSKeyboardQueueSize:
>0258							.fill 	1
.0259					OSIsKeyUp:
>0259							.fill 	1
.025a					OSIsKeyShift:
>025a							.fill 	1
.025b					OSEscapePressed:
>025b							.fill 	1
.025c					OSRKOriginal:
>025c							.fill 	1
=192					OSTextBufferSize = 192
.025d					OSEditWidth:
>025d							.fill 	1
.025e					OSEditLength:
>025e							.fill 	1
.025f					OSEditBuffer:
>025f							.fill 	OSTextBufferSize+1
>0320							.fill 	32
.0022					fsBlock:
>0022							.fill 	2
.0340					sectorSize:
>0340							.fill 	2
.0342					sectorCount:
>0342							.fill 	2
.0344					currentSector:
>0344							.fill 	2
.0346					successFlag:
>0346							.fill 	1
.0347					sectorHeader:
.0347					shFirstNext:
>0347							.fill 	1
.0348					shContinue:
>0348							.fill 	1
.0349					shDataSize:
>0349							.fill 	2
.034b					shFileSize:
>034b							.fill 	2
>034d							.fill 	10
.0357					shNameLength:
>0357							.fill 	1
.0358					shNameText:
>0358							.fill 	15
.0367					shFileSizeCopy:
>0367							.fill 	2
>0369							.align 	256

;******  Return to file: osrom.asm

.f800	20 76 fd	jsr $fd76	Boot:	jsr 	OSInitialise 				; set everything up.
.f803	20 be fe	jsr $febe			jsr 	FSInitialise 				; initialise the WWFS
.f806	a2 24		ldx #$24			ldx 	#MainPrompt & $FF 			; display the boot prompt
.f808	a0 ff		ldy #$ff			ldy 	#MainPrompt >> 8
.f80a	20 5f f9	jsr $f95f			jsr 	OSWriteString
.f80d	a2 18		ldx #$18			ldx 	#setup & $FF
.f80f	a0 f8		ldy #$f8			ldy 	#setup >> 8
.f811	20 d0 fd	jsr $fdd0			jsr 	OSReadFile
.f814	4c 00 10	jmp $1000			jmp 	$1000 						; and run from $1000 onwards
.f817					NoInt:
.f817	40		rti				rti
>f818	1e f8				setup:	.word 	name
>f81a	00 50						.word 	$5000
>f81c	00 00						.word 	0
>f81e	09 74 65 78 74 33 2e 62		name:	.text 	9,"text3.bas"
>f826	61 73

;******  Processing file: include.files


;******  Processing file: src/basicio/charout.asm

.f828					OSWriteScreen:
.f828	48		pha				pha 								; save AXY
.f829	da		phx				phx
.f82a	5a		phy				phy
.f82b	c9 20		cmp #$20			cmp 	#32 						; standard character $20,$FF (we allow for cyrillic possibility here)
.f82d	b0 0c		bcs $f83b			bcs 	_OSWriteDirect
.f82f	c9 10		cmp #$10			cmp 	#16 						; 16-32 for set colours, reserved - this copies fgr -> bgr, updates fgr.
.f831	b0 0e		bcs $f841			bcs 	_OSWriteDeviceExit
.f833	0a		asl a				asl 	a 							; make to an offset in vector table
.f834	aa		tax				tax
.f835	4a		lsr a				lsr 	a
.f836	20 46 f8	jsr $f846			jsr 	_OSCallVectorCode 			; call that code
.f839	80 06		bra $f841			bra 	_OSWriteDeviceExit 			; and leave
.f83b					_OSWriteDirect:
.f83b	20 84 f9	jsr $f984			jsr 	OSDWritePhysical 			; $20-$FF write to screen
.f83e	20 c0 f8	jsr $f8c0			jsr 	_OSCursorAdvance 			; and forwards.
.f841					_OSWriteDeviceExit:
.f841	7a		ply				ply
.f842	fa		plx				plx
.f843	68		pla				pla
.f844	18		clc				clc 								; written fine.
.f845	60		rts				rts
.f846					_OSCallVectorCode:
.f846	7c 4a f8	jmp ($f84a,x)			jmp 	(_OSWDVector,x)
.f849					_OSWNoFunction:
.f849	60		rts				rts
.f84a					_OSWDVector:
>f84a	49 f8						.word 	_OSWNoFunction 				; $00 	No operation
>f84c	83 f8						.word 	_OSCursorLeft 				; $01 	Left 		(Ctrl-A)
>f84e	0b f9						.word 	OSHomeCursor 				; $02 	Home Cursor (Ctrl-B)
>f850	a4 f8						.word 	_OSCursorDown 				; $03 	Down 		(Ctrl-C)
>f852	95 f8						.word 	_OSCursorRight 				; $04 	Right 		(Ctrl-D)
>f854	49 f8						.word 	_OSWNoFunction				; $05
>f856	b3 f8						.word 	_OSCursorUp 				; $06	Up 			(Ctrl-F)
>f858	49 f8						.word 	_OSWNoFunction 				; $07 	Delete 		(Del)
>f85a	75 f8						.word 	_OSBackspace				; $08 	Backspace 	(Backspace)
>f85c	6a f8						.word 	_OSWHTab 					; $09	Tab 		(Tab stop)
>f85e	49 f8						.word 	_OSWNoFunction 				; $0A
>f860	49 f8						.word 	_OSWNoFunction 				; $0B
>f862	fc f8						.word 	_OSClearScreen 				; $0C	ClearScreen	(Ctrl-L)
>f864	cd f8						.word 	_OSNewLine 					; $0D 	CarriageRet (Enter)
>f866	49 f8						.word 	_OSWNoFunction 				; $0E
>f868	49 f8						.word 	_OSWNoFunction 				; $0F
.f86a					_OSWHTab:
.f86a	20 95 f8	jsr $f895			jsr 	_OSCursorRight
.f86d	ad 20 02	lda $0220			lda 	OSXPos
.f870	29 07		and #$07			and 	#7
.f872	d0 f6		bne $f86a			bne 	_OSWHTab
.f874	60		rts				rts
.f875					_OSBackspace:
.f875	ad 20 02	lda $0220			lda 	OSXPos 						; left side already ?
.f878	f0 1a		beq $f894			beq 	_OSCLExit
.f87a	ce 20 02	dec $0220			dec 	OSXPos 						; go left one.
.f87d	a9 20		lda #$20			lda 	#' ' 						; ovewrite the character there.
.f87f	20 84 f9	jsr $f984			jsr 	OSDWritePhysical
.f882	60		rts				rts
.f883					_OSCursorLeft:
.f883	ad 20 02	lda $0220			lda 	OSXPos 						; left side
.f886	ce 20 02	dec $0220			dec 	OSXPos 						; cursor left
.f889	c9 00		cmp #$00			cmp 	#0 							; if at left side
.f88b	d0 07		bne $f894			bne 	_OSCLExit 					; no, exit
.f88d	ad 22 02	lda $0222			lda 	OSXSize 					; yes, shift to right.
.f890	3a		dec a				dec 	a
.f891	8d 20 02	sta $0220			sta 	OSXPos
.f894					_OSCLExit:
.f894	60		rts				rts
.f895					_OSCursorRight:
.f895	ee 20 02	inc $0220			inc 	OSXPos 						; go right ?
.f898	ad 20 02	lda $0220			lda 	OSXPos 						; reached right side ?
.f89b	cd 22 02	cmp $0222			cmp 	OSXSize
.f89e	d0 f4		bne $f894			bne 	_OSCLExit 					; no, then exit
.f8a0	9c 20 02	stz $0220			stz 	OSXPos 						; back to left
.f8a3	60		rts				rts
.f8a4					_OSCursorDown:
.f8a4	ee 21 02	inc $0221			inc 	OSYPos 						; down one line.
.f8a7	ad 21 02	lda $0221			lda 	OSYPos 						; reached bottom
.f8aa	cd 23 02	cmp $0223			cmp 	OSYSize
.f8ad	90 03		bcc $f8b2			bcc 	_OSCDExit 					; no, we're done.
.f8af	9c 21 02	stz $0221			stz 	OSYPos 						; position back to top line
.f8b2					_OSCDExit:
.f8b2	60		rts				rts
.f8b3					_OSCursorUp:
.f8b3	ce 21 02	dec $0221			dec 	OSYPos 						; up one line ?
.f8b6	10 07		bpl $f8bf			bpl 	_OSCUExit 					; exit if still on screen
.f8b8	ad 23 02	lda $0223			lda 	OSYSize 					; back to top
.f8bb	3a		dec a				dec 	a
.f8bc	8d 21 02	sta $0221			sta 	OSYPos
.f8bf					_OSCUExit:
.f8bf	60		rts				rts
.f8c0					_OSCursorAdvance:
.f8c0	ee 20 02	inc $0220			inc 	OSXPos 						; try moving right
.f8c3	ad 20 02	lda $0220			lda 	OSXPos						; reached the write.
.f8c6	cd 22 02	cmp $0222			cmp 	OSXSize
.f8c9	d0 30		bne $f8fb			bne 	_OSLCExit 	 				; exit if not at the RHS.
.f8cb	a2 00		ldx #$00			ldx 	#0 							; we want to zero any consequent CRs.
.f8cd					_OSNewLine:
.f8cd	da		phx				phx 								; save CR/char flag.
.f8ce	9c 20 02	stz $0220			stz 	OSXPos 						; left side
.f8d1	ee 21 02	inc $0221			inc 	OSYPos 						; down one.
.f8d4	ad 21 02	lda $0221			lda 	OSYPos 						; reached the bottom
.f8d7	cd 23 02	cmp $0223			cmp 	OSYSize
.f8da	90 18		bcc $f8f4			bcc 	_OSLCUpdateCR				; no, update CR flag and exit
.f8dc	ad 23 02	lda $0223			lda 	OSYSize 					; bottom of screen
.f8df	3a		dec a				dec 	a
.f8e0	8d 21 02	sta $0221			sta 	OSYPos 						; back up one line
.f8e3	20 5d fa	jsr $fa5d			jsr 	OSDScrollUp 				; scroll the whole screen up.
.f8e6	a2 00		ldx #$00			ldx 	#0 							; scroll the CR flag table up
.f8e8					_OSNLScrollFlag:
.f8e8	bd 01 02	lda $0201,x			lda 	OSNewLineFlag+1,x
.f8eb	9d 00 02	sta $0200,x			sta 	OSNewLineFlag,x
.f8ee	e8		inx				inx
.f8ef	ec 23 02	cpx $0223			cpx 	OSYSize
.f8f2	d0 f4		bne $f8e8			bne	 	_OSNLScrollFlag
.f8f4					_OSLCUpdateCR:
.f8f4	ae 21 02	ldx $0221			ldx 	OSYPos 						; set appropriate flag.
.f8f7	68		pla				pla
.f8f8	9d 00 02	sta $0200,x			sta 	OSNewLineFlag,x
.f8fb					_OSLCExit:
.f8fb	60		rts				rts
.f8fc					_OSClearScreen:
.f8fc	20 b8 f9	jsr $f9b8			jsr 	OSDClearScreen 				; physical clear.
.f8ff	ae 23 02	ldx $0223			ldx 	OSYSize 					; set all the CR flags on each row
.f902					_OSCSSetLoop:
.f902	a9 ff		lda #$ff			lda 	#$FF
.f904	9d ff 01	sta $01ff,x			sta 	OSNewLineFlag-1,x
.f907	ca		dex				dex
.f908	d0 f8		bne $f902			bne		_OSCSSetLoop
.f90a	60		rts				rts
.f90b					OSHomeCursor:
.f90b	9c 20 02	stz $0220			stz 	OSXPos
.f90e	9c 21 02	stz $0221			stz	 	OSYPos
.f911	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/basicio/keyboard.asm

.f912					OSIsKeyAvailable:
.f912	48		pha				pha
.f913	18		clc				clc
.f914	ad 58 02	lda $0258			lda 	OSKeyboardQueueSize  		; get count of entries in queue
.f917	d0 01		bne $f91a			bne 	_OSIKAHasKey
.f919	38		sec				sec
.f91a					_OSIKAHasKey:
.f91a	68		pla				pla
.f91b	60		rts				rts
.f91c					OSReadKeyboard:
.f91c	20 d8 f9	jsr $f9d8			jsr 	OSKeyboardDataProcess 		; this scans the keyboard etc.
.f91f	20 12 f9	jsr $f912			jsr 	OSIsKeyAvailable 			; key available ?
.f922	b0 19		bcs $f93d			bcs 	_OSRDExit 					; no exit with CS.
.f924	ad 48 02	lda $0248			lda 	OSKeyboardQueue 			; push char from head of queueon stack
.f927	48		pha				pha
.f928	da		phx				phx 								; shift everything else up one.
.f929	a2 00		ldx #$00			ldx		#0 							; remove from queue array
.f92b					_OSRDDequeue:
.f92b	bd 49 02	lda $0249,x			lda 	OSKeyboardQueue+1,x
.f92e	9d 48 02	sta $0248,x			sta 	OSKeyboardQueue,x
.f931	e8		inx				inx
.f932	ec 58 02	cpx $0258			cpx 	OSKeyboardQueueSize
.f935	d0 f4		bne $f92b			bne 	_OSRDDequeue
.f937	ce 58 02	dec $0258			dec 	OSKeyboardQueueSize			; dec queue count
.f93a	fa		plx				plx
.f93b	68		pla				pla 								; restore key
.f93c	18		clc				clc
.f93d					_OSRDExit:
.f93d	60		rts				rts
.f93e					OSReadKeystroke:
.f93e	da		phx				phx 								; save XY
.f93f	5a		phy				phy
.f940	20 7e f9	jsr $f97e			jsr 	OSDReadPhysical 			; save old character under cursor
.f943	8d 5c 02	sta $025c			sta 	OSRKOriginal
.f946	49 80		eor #$80			eor 	#$80 						; write prompt
.f948	20 84 f9	jsr $f984			jsr 	OSDWritePhysical
.f94b					_OSWaitKey:
.f94b	20 d8 f9	jsr $f9d8			jsr 	OSKeyboardDataProcess 		; this scans the keyboard, could be interrupt
.f94e	20 1c f9	jsr $f91c			jsr 	OSReadKeyboard 				; key available
.f951	b0 f8		bcs $f94b			bcs 	_OSWaitKey 					; no keep going
.f953	48		pha				pha 								; save key
.f954	ad 5c 02	lda $025c			lda 	OSRKOriginal 				; old character back and write to screen.
.f957	20 84 f9	jsr $f984			jsr 	OSDWritePhysical
.f95a	68		pla				pla 								; restore
.f95b	7a		ply				ply
.f95c	fa		plx				plx
.f95d	18		clc				clc 								; success
.f95e	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/basicio/writestring.asm

.f95f					OSWriteString:
.f95f	48		pha				pha 								; save AXY
.f960	da		phx				phx
.f961	5a		phy				phy
.f962	86 1e		stx $1e				stx		rTemp1 						; address of string in rTemp1
.f964	84 1f		sty $1f				sty 	rTemp1+1
.f966	b2 1e		lda ($1e)			lda 	(rTemp1)
.f968	aa		tax				tax 								; count in X
.f969	a0 00		ldy #$00			ldy 	#0
.f96b					OSWSLoop:
.f96b	e0 00		cpx #$00			cpx 	#0 							; done them all, exit
.f96d	f0 0b		beq $f97a			beq 	_OSWSExit
.f96f	ca		dex				dex 								; dec count
.f970	c8		iny				iny 								; get next character
.f971	b1 1e		lda ($1e),y			lda 	(rTemp1),y
.f973	f0 05		beq $f97a			beq 	_OSWSExit 					; end if $00
.f975	20 28 f8	jsr $f828			jsr 	OSWriteScreen				; otherwise write to screen.
.f978	80 f1		bra $f96b			bra 	OSWSLoop
.f97a					_OSWSExit:
.f97a	7a		ply				ply 								; restore AXY and exit
.f97b	fa		plx				plx
.f97c	68		pla				pla
.f97d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/charwrite.asm

.f97e					OSDReadPhysical:
.f97e	20 8c f9	jsr $f98c			jsr 	OSDGetAddress
.f981	b2 1c		lda ($1c)			lda 	(rTemp0)
.f983	60		rts				rts
.f984					OSDWritePhysical:
.f984	48		pha				pha
.f985	20 8c f9	jsr $f98c			jsr 	OSDGetAddress
.f988	68		pla				pla
.f989	92 1c		sta ($1c)			sta 	(rTemp0)
.f98b	60		rts				rts
.f98c					OSDGetAddress:
.f98c	ac 21 02	ldy $0221			ldy     OSYPos
.f98f	ae 20 02	ldx $0220			ldx 	OSXPos
.f992					OSDGetAddressXY:
.f992	ad 22 02	lda $0222			lda     OSXSize
.f995	4a		lsr a				lsr     a                           ; prime the carry bit for the loop
.f996	85 1c		sta $1c				sta     rTemp0
.f998	84 1d		sty $1d				sty     rTemp0+1
.f99a	a9 00		lda #$00			lda     #0
.f99c	a0 08		ldy #$08			ldy     #8
.f99e					_IFMLoop:
.f99e	90 03		bcc $f9a3			bcc     _IFMNoAdd
.f9a0	18		clc				clc
.f9a1	65 1d		adc $1d				adc     rTemp0+1
.f9a3					_IFMNoAdd:
.f9a3	6a		ror a				ror     a
.f9a4	66 1c		ror $1c				ror     rTemp0                      ; pull another bit out for the next iteration
.f9a6	88		dey				dey
.f9a7	d0 f5		bne $f99e			bne     _IFMLoop
.f9a9	09 c0		ora #$c0			ora 	#$C0
.f9ab	a8		tay				tay
.f9ac	18		clc				clc
.f9ad	8a		txa				txa
.f9ae	65 1c		adc $1c				adc 	rTemp0
.f9b0	85 1c		sta $1c				sta 	rTemp0
.f9b2	90 01		bcc $f9b5			bcc 	_IFMNoCarry
.f9b4	c8		iny				iny
.f9b5					_IFMNoCarry:
.f9b5	84 1d		sty $1d				sty 	rTemp0+1
.f9b7	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/clear.asm

.f9b8					OSDClearScreen:
.f9b8	a9 c0		lda #$c0			lda 	#$C0 						; set screen pos.
.f9ba	85 1d		sta $1d				sta 	rTemp0+1
.f9bc	64 1c		stz $1c				stz 	rTemp0
.f9be	ac 23 02	ldy $0223			ldy 	OSYSize 					; clear height * width bytes.
.f9c1					_OSCSLoop1:
.f9c1	ae 22 02	ldx $0222			ldx 	OSXSize
.f9c4					_OSCSLoop2:
.f9c4	a9 20		lda #$20			lda 	#' '
.f9c6	92 1c		sta ($1c)			sta 	(rTemp0)
.f9c8	e6 1c		inc $1c				inc 	rTemp0
.f9ca	d0 02		bne $f9ce			bne 	_OSCSNoCarry
.f9cc	e6 1d		inc $1d				inc 	rTemp0+1
.f9ce					_OSCSNoCarry:
.f9ce	ca		dex				dex
.f9cf	d0 f3		bne $f9c4			bne 	_OSCSLoop2
.f9d1	88		dey				dey
.f9d2	d0 ed		bne $f9c1			bne 	_OSCSLoop1
.f9d4	20 0b f9	jsr $f90b			jsr 	OSHomeCursor 				; cursor to (0,0)
.f9d7	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/ps2keyboard.asm

.f9d8					OSKeyboardDataProcess:
.f9d8	ad 00 cf	lda $cf00			lda 	$CF00 						; read keyboard port
.f9db	f0 31		beq $fa0e			beq 	_OSKExit 					; no events available.
.f9dd	c9 f0		cmp #$f0			cmp 	#$F0 						; check key up ?
.f9df	f0 2a		beq $fa0b			beq 	_OSKUp
.f9e1	c9 e0		cmp #$e0			cmp 	#$E0 						; check extended scancode ?
.f9e3	f0 1f		beq $fa04			beq 	_OSKShift
.f9e5	0d 5a 02	ora $025a			ora 	OSIsKeyShift 				; actual key code - sets bit 7 if extended scancode.
.f9e8	48		pha				pha
.f9e9	20 17 fa	jsr $fa17			jsr 	OSDKeyboardUpdateBits 		; update the up/down bits
.f9ec	68		pla				pla
.f9ed	ae 59 02	ldx $0259			ldx 	OSIsKeyUp 					; if key up reset up and shift flags.
.f9f0	f0 08		beq $f9fa			beq 	_OSKInsertQueue 			; if key down insert into queue
.f9f2	9c 59 02	stz $0259			stz 	OSIsKeyUp 					; reset up/shift
.f9f5	9c 5a 02	stz $025a			stz 	OSIsKeyShift
.f9f8	80 14		bra $fa0e			bra 	_OSKExit
.f9fa					_OSKInsertQueue:
.f9fa	20 8a fa	jsr $fa8a			jsr 	OSDTranslateToASCII 		; convert to ASCII
.f9fd	b0 0f		bcs $fa0e			bcs 	_OSKExit 					; carry set, exit (unknown key)
.f9ff	20 40 fa	jsr $fa40			jsr 	OSDInsertKeyboardQueue 		; insert into keyboard queue.
.fa02	80 0a		bra $fa0e			bra 	_OSKExit
.fa04					_OSKShift:
.fa04	a9 80		lda #$80			lda 	#$80 						; set this so the OR seets bit 7.
.fa06	8d 5a 02	sta $025a			sta 	OSIsKeyShift
.fa09	80 03		bra $fa0e			bra 	_OSKExit
.fa0b					_OSKUp:
.fa0b	ce 59 02	dec $0259			dec 	OSIsKeyUp 					; received $F0 (key up), set that flag
.fa0e					_OSKExit:
.fa0e	ad 36 02	lda $0236			lda 	OSKeyStatus+$0E 			; and on the way out check if ESC was pressed.
.fa11	29 40		and #$40			and 	#$40
.fa13	8d 5b 02	sta $025b			sta 	OSEscapePressed
.fa16	60		rts				rts
.fa17					OSDKeyboardUpdateBits:
.fa17	a2 00		ldx #$00			ldx 	#0 							; offset in table
.fa19					_OSKUCalculate:
.fa19	c9 08		cmp #$08			cmp 	#8 							; work out the row
.fa1b	90 06		bcc $fa23			bcc 	_OSKUHaveRow
.fa1d	e8		inx				inx
.fa1e	38		sec				sec
.fa1f	e9 08		sbc #$08			sbc 	#8
.fa21	80 f6		bra $fa19			bra 	_OSKUCalculate
.fa23					_OSKUHaveRow:
.fa23	a8		tay				tay 								; work out the column
.fa24	a9 00		lda #$00			lda 	#0
.fa26	38		sec				sec
.fa27					_OSKUCalculate2:
.fa27	2a		rol a				rol 	a
.fa28	88		dey				dey
.fa29	10 fc		bpl $fa27			bpl 	_OSKUCalculate2  			; at end , A is bitmask, X is row (table entry)
.fa2b	2c 59 02	bit $0259			bit 	OSIsKeyUp 					; check up
.fa2e	30 07		bmi $fa37			bmi 	_OSKUUp
.fa30	1d 28 02	ora $0228,x			ora 	OSKeyStatus,x 				; down set bit
.fa33	9d 28 02	sta $0228,x			sta 	OSKeyStatus,x
.fa36	60		rts				rts
.fa37					_OSKUUp:
.fa37	49 ff		eor #$ff			eor 	#$FF 						; make maske
.fa39	3d 28 02	and $0228,x			and 	OSKeyStatus,x 				; up clear bit
.fa3c	9d 28 02	sta $0228,x			sta 	OSKeyStatus,x
.fa3f	60		rts				rts
.fa40					OSDInsertKeyboardQueue:
.fa40	ae 58 02	ldx $0258			ldx 	OSKeyboardQueueSize 		; check to see if full
.fa43	e0 10		cpx #$10			cpx	 	#OSKeyboardQueueMaxSize
.fa45	b0 06		bcs $fa4d			bcs 	_OSIKQExit 					; if so, you will never know.
.fa47	9d 48 02	sta $0248,x			sta 	OSKeyboardQueue,x 			; add keyboard entry to queue.
.fa4a	ee 58 02	inc $0258			inc 	OSKeyboardQueueSize
.fa4d					_OSIKQExit:
.fa4d	60		rts				rts
.fa4e					OSDKeyboardInitialise:
.fa4e	a2 32		ldx #$32			ldx 	#OSIsKeyShift-OSKeyStatus
.fa50					_OSKILoop:
.fa50	9e 28 02	stz $0228,x			stz 	OSKeyStatus,x
.fa53	ca		dex				dex
.fa54	10 fa		bpl $fa50			bpl 	_OSKILoop
.fa56	9c 59 02	stz $0259			stz 	OSIsKeyUp 					; reset up/shift
.fa59	9c 5a 02	stz $025a			stz 	OSIsKeyShift
.fa5c	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/scroll.asm

.fa5d					OSDScrollUp:
.fa5d	a9 c0		lda #$c0			lda 	#$C0 						; scroll whole screen up.
.fa5f	64 1c		stz $1c				stz 	rTemp0
.fa61	85 1d		sta $1d				sta 	rTemp0+1
.fa63	ac 23 02	ldy $0223			ldy 	OSYSize 					; line counts.
.fa66	88		dey				dey
.fa67					_OSSULoop1:
.fa67	ae 22 02	ldx $0222			ldx 	OSXSize 					; number of bytes to copy
.fa6a	5a		phy				phy
.fa6b	ac 22 02	ldy $0222			ldy 	OSXSize 					; offset
.fa6e					_OSSULoop2:
.fa6e	b1 1c		lda ($1c),y			lda 	(rTemp0),y 					; copy up
.fa70	92 1c		sta ($1c)			sta 	(rTemp0)
.fa72	e6 1c		inc $1c				inc 	rTemp0 						; adjust position.
.fa74	d0 02		bne $fa78			bne 	_OSSUCarry
.fa76	e6 1d		inc $1d				inc 	rTemp0+1
.fa78					_OSSUCarry:
.fa78	ca		dex				dex 								; do the whole row
.fa79	d0 f3		bne $fa6e			bne 	_OSSULoop2
.fa7b	7a		ply				ply
.fa7c	88		dey				dey 								; for n-1 rows
.fa7d	d0 e8		bne $fa67			bne 	_OSSULoop1
.fa7f	ac 22 02	ldy $0222			ldy 	OSXSize 					; fill bottom row with spaces.
.fa82					_OSSUFill:
.fa82	a9 20		lda #$20			lda 	#' '
.fa84	88		dey				dey
.fa85	91 1c		sta ($1c),y			sta 	(rTemp0),y
.fa87	d0 f9		bne $fa82			bne 	_OSSUFill
.fa89	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/translate.asm

.fa8a					OSDTranslateToASCII:
.fa8a	aa		tax				tax
.fa8b	bd d7 fa	lda $fad7,x			lda 	OSASCIIFromScanCode,x 		; get ASCII keystroke from scan code
.fa8e	f0 45		beq $fad5			beq 	_OSTTAFail 					; wrong keyboard map/type ?
.fa90	aa		tax				tax 								; save in X
.fa91	ad 2a 02	lda $022a			lda 	OSKeyStatus+OS_KP_LEFTCTRL_ROW
.fa94	29 10		and #$10			and 	#OS_KP_LEFTCTRL_COL
.fa96	d0 36		bne $face			bne 	_OSTTAControl 				; check for CTRL + x
.fa98	ad 2a 02	lda $022a			lda 	OSKeyStatus+OS_KP_LEFTSHIFT_ROW
.fa9b	29 04		and #$04			and 	#OS_KP_LEFTSHIFT_COL
.fa9d	d0 07		bne $faa6			bne 	_OSTTAShift 				; check for left/right shift
.fa9f	ad 33 02	lda $0233			lda 	OSKeyStatus+OS_KP_RIGHTSHIFT_ROW
.faa2	29 02		and #$02			and 	#OS_KP_RIGHTSHIFT_COL
.faa4	f0 2c		beq $fad2			beq 	_OSTTAExit 					; no, no translate
.faa6					_OSTTAShift:
.faa6	e0 61		cpx #$61			cpx 	#"a"						; check alpha a-z => A-Z
.faa8	90 0a		bcc $fab4			bcc 	_OSTTANotAlpha
.faaa	e0 7b		cpx #$7b			cpx 	#"z"+1
.faac	b0 06		bcs $fab4			bcs 	_OSTTANotAlpha
.faae	8a		txa				txa									; capitalise.
.faaf	49 20		eor #$20			eor 	#$20
.fab1	aa		tax				tax
.fab2	80 1e		bra $fad2			bra 	_OSTTAExit
.fab4					_OSTTANotAlpha:
.fab4	86 1c		stx $1c				stx 	rTemp0 						; save ASCII code.
.fab6	a0 00		ldy #$00			ldy 	#0 							; check the shift table
.fab8					_OSTTACheckShiftTable:
.fab8	b9 d9 fb	lda $fbd9,y			lda 	OSShiftFixTable+1,y 		; tax = shifted character
.fabb	aa		tax				tax
.fabc	b9 d8 fb	lda $fbd8,y			lda 	OSShiftFixTable,y 			; check unshifted match
.fabf	c5 1c		cmp $1c				cmp 	rTemp0
.fac1	f0 0f		beq $fad2			beq 	_OSTTAExit
.fac3	c8		iny				iny 								; next pair
.fac4	c8		iny				iny
.fac5	b9 d8 fb	lda $fbd8,y			lda 	OSShiftFixTable,y 			; until all checked
.fac8	10 ee		bpl $fab8			bpl 	_OSTTACheckShiftTable
.faca	a6 1c		ldx $1c				ldx 	rTemp0 						; not shiftable.
.facc	80 04		bra $fad2			bra 	_OSTTAExit
.face					_OSTTAControl:
.face	8a		txa				txa
.facf	29 1f		and #$1f			and 	#31
.fad1	aa		tax				tax
.fad2					_OSTTAExit:
.fad2	8a		txa				txa
.fad3	18		clc				clc
.fad4	60		rts				rts
.fad5					_OSTTAFail:
.fad5	38		sec				sec
.fad6	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/generated/ps2convert.asm

.fad7					OSASCIIFromScanCode:
>fad7	00					.byte	$00 ; $00
>fad8	19					.byte	$19 ; $01 chr$(25)
>fad9	00					.byte	$00 ; $02
>fada	15					.byte	$15 ; $03 chr$(21)
>fadb	13					.byte	$13 ; $04 chr$(19)
>fadc	11					.byte	$11 ; $05 chr$(17)
>fadd	12					.byte	$12 ; $06 chr$(18)
>fade	00					.byte	$00 ; $07
>fadf	00					.byte	$00 ; $08
>fae0	1a					.byte	$1a ; $09 chr$(26)
>fae1	18					.byte	$18 ; $0a chr$(24)
>fae2	16					.byte	$16 ; $0b chr$(22)
>fae3	14					.byte	$14 ; $0c chr$(20)
>fae4	09					.byte	$09 ; $0d chr$(9)
>fae5	60					.byte	$60 ; $0e '`'
>fae6	00					.byte	$00 ; $0f
>fae7	00					.byte	$00 ; $10
>fae8	00					.byte	$00 ; $11
>fae9	00					.byte	$00 ; $12
>faea	00					.byte	$00 ; $13
>faeb	00					.byte	$00 ; $14
>faec	71					.byte	$71 ; $15 'q'
>faed	31					.byte	$31 ; $16 '1'
>faee	00					.byte	$00 ; $17
>faef	00					.byte	$00 ; $18
>faf0	00					.byte	$00 ; $19
>faf1	7a					.byte	$7a ; $1a 'z'
>faf2	73					.byte	$73 ; $1b 's'
>faf3	61					.byte	$61 ; $1c 'a'
>faf4	77					.byte	$77 ; $1d 'w'
>faf5	32					.byte	$32 ; $1e '2'
>faf6	00					.byte	$00 ; $1f
>faf7	00					.byte	$00 ; $20
>faf8	63					.byte	$63 ; $21 'c'
>faf9	78					.byte	$78 ; $22 'x'
>fafa	64					.byte	$64 ; $23 'd'
>fafb	65					.byte	$65 ; $24 'e'
>fafc	34					.byte	$34 ; $25 '4'
>fafd	33					.byte	$33 ; $26 '3'
>fafe	00					.byte	$00 ; $27
>faff	00					.byte	$00 ; $28
>fb00	20					.byte	$20 ; $29 ' '
>fb01	76					.byte	$76 ; $2a 'v'
>fb02	66					.byte	$66 ; $2b 'f'
>fb03	74					.byte	$74 ; $2c 't'
>fb04	72					.byte	$72 ; $2d 'r'
>fb05	35					.byte	$35 ; $2e '5'
>fb06	00					.byte	$00 ; $2f
>fb07	00					.byte	$00 ; $30
>fb08	6e					.byte	$6e ; $31 'n'
>fb09	62					.byte	$62 ; $32 'b'
>fb0a	68					.byte	$68 ; $33 'h'
>fb0b	67					.byte	$67 ; $34 'g'
>fb0c	79					.byte	$79 ; $35 'y'
>fb0d	36					.byte	$36 ; $36 '6'
>fb0e	00					.byte	$00 ; $37
>fb0f	00					.byte	$00 ; $38
>fb10	00					.byte	$00 ; $39
>fb11	6d					.byte	$6d ; $3a 'm'
>fb12	6a					.byte	$6a ; $3b 'j'
>fb13	75					.byte	$75 ; $3c 'u'
>fb14	37					.byte	$37 ; $3d '7'
>fb15	38					.byte	$38 ; $3e '8'
>fb16	00					.byte	$00 ; $3f
>fb17	00					.byte	$00 ; $40
>fb18	2c					.byte	$2c ; $41 ','
>fb19	6b					.byte	$6b ; $42 'k'
>fb1a	69					.byte	$69 ; $43 'i'
>fb1b	6f					.byte	$6f ; $44 'o'
>fb1c	30					.byte	$30 ; $45 '0'
>fb1d	39					.byte	$39 ; $46 '9'
>fb1e	00					.byte	$00 ; $47
>fb1f	00					.byte	$00 ; $48
>fb20	2e					.byte	$2e ; $49 '.'
>fb21	2f					.byte	$2f ; $4a '/'
>fb22	6c					.byte	$6c ; $4b 'l'
>fb23	3b					.byte	$3b ; $4c ';'
>fb24	70					.byte	$70 ; $4d 'p'
>fb25	2d					.byte	$2d ; $4e '-'
>fb26	00					.byte	$00 ; $4f
>fb27	00					.byte	$00 ; $50
>fb28	00					.byte	$00 ; $51
>fb29	27					.byte	$27 ; $52 '''
>fb2a	00					.byte	$00 ; $53
>fb2b	5b					.byte	$5b ; $54 '['
>fb2c	3d					.byte	$3d ; $55 '='
>fb2d	00					.byte	$00 ; $56
>fb2e	00					.byte	$00 ; $57
>fb2f	00					.byte	$00 ; $58
>fb30	00					.byte	$00 ; $59
>fb31	0d					.byte	$0d ; $5a chr$(13)
>fb32	5d					.byte	$5d ; $5b ']'
>fb33	00					.byte	$00 ; $5c
>fb34	7c					.byte	$7c ; $5d '|'
>fb35	00					.byte	$00 ; $5e
>fb36	00					.byte	$00 ; $5f
>fb37	00					.byte	$00 ; $60
>fb38	00					.byte	$00 ; $61
>fb39	00					.byte	$00 ; $62
>fb3a	00					.byte	$00 ; $63
>fb3b	00					.byte	$00 ; $64
>fb3c	00					.byte	$00 ; $65
>fb3d	08					.byte	$08 ; $66 chr$(8)
>fb3e	00					.byte	$00 ; $67
>fb3f	00					.byte	$00 ; $68
>fb40	00					.byte	$00 ; $69
>fb41	00					.byte	$00 ; $6a
>fb42	01					.byte	$01 ; $6b chr$(1)
>fb43	00					.byte	$00 ; $6c
>fb44	00					.byte	$00 ; $6d
>fb45	00					.byte	$00 ; $6e
>fb46	00					.byte	$00 ; $6f
>fb47	00					.byte	$00 ; $70
>fb48	00					.byte	$00 ; $71
>fb49	03					.byte	$03 ; $72 chr$(3)
>fb4a	00					.byte	$00 ; $73
>fb4b	04					.byte	$04 ; $74 chr$(4)
>fb4c	06					.byte	$06 ; $75 chr$(6)
>fb4d	1b					.byte	$1b ; $76 chr$(27)
>fb4e	00					.byte	$00 ; $77
>fb4f	00					.byte	$00 ; $78
>fb50	00					.byte	$00 ; $79
>fb51	00					.byte	$00 ; $7a
>fb52	00					.byte	$00 ; $7b
>fb53	00					.byte	$00 ; $7c
>fb54	00					.byte	$00 ; $7d
>fb55	00					.byte	$00 ; $7e
>fb56	00					.byte	$00 ; $7f
>fb57	00					.byte	$00 ; $80
>fb58	00					.byte	$00 ; $81
>fb59	00					.byte	$00 ; $82
>fb5a	17					.byte	$17 ; $83 chr$(23)
>fb5b	00					.byte	$00 ; $84
>fb5c	00					.byte	$00 ; $85
>fb5d	00					.byte	$00 ; $86
>fb5e	00					.byte	$00 ; $87
>fb5f	00					.byte	$00 ; $88
>fb60	00					.byte	$00 ; $89
>fb61	00					.byte	$00 ; $8a
>fb62	00					.byte	$00 ; $8b
>fb63	00					.byte	$00 ; $8c
>fb64	00					.byte	$00 ; $8d
>fb65	00					.byte	$00 ; $8e
>fb66	00					.byte	$00 ; $8f
>fb67	00					.byte	$00 ; $90
>fb68	00					.byte	$00 ; $91
>fb69	00					.byte	$00 ; $92
>fb6a	00					.byte	$00 ; $93
>fb6b	00					.byte	$00 ; $94
>fb6c	00					.byte	$00 ; $95
>fb6d	00					.byte	$00 ; $96
>fb6e	00					.byte	$00 ; $97
>fb6f	00					.byte	$00 ; $98
>fb70	00					.byte	$00 ; $99
>fb71	00					.byte	$00 ; $9a
>fb72	00					.byte	$00 ; $9b
>fb73	00					.byte	$00 ; $9c
>fb74	00					.byte	$00 ; $9d
>fb75	00					.byte	$00 ; $9e
>fb76	00					.byte	$00 ; $9f
>fb77	00					.byte	$00 ; $a0
>fb78	00					.byte	$00 ; $a1
>fb79	00					.byte	$00 ; $a2
>fb7a	00					.byte	$00 ; $a3
>fb7b	00					.byte	$00 ; $a4
>fb7c	00					.byte	$00 ; $a5
>fb7d	00					.byte	$00 ; $a6
>fb7e	00					.byte	$00 ; $a7
>fb7f	00					.byte	$00 ; $a8
>fb80	00					.byte	$00 ; $a9
>fb81	00					.byte	$00 ; $aa
>fb82	00					.byte	$00 ; $ab
>fb83	00					.byte	$00 ; $ac
>fb84	00					.byte	$00 ; $ad
>fb85	00					.byte	$00 ; $ae
>fb86	00					.byte	$00 ; $af
>fb87	00					.byte	$00 ; $b0
>fb88	00					.byte	$00 ; $b1
>fb89	00					.byte	$00 ; $b2
>fb8a	00					.byte	$00 ; $b3
>fb8b	00					.byte	$00 ; $b4
>fb8c	00					.byte	$00 ; $b5
>fb8d	00					.byte	$00 ; $b6
>fb8e	00					.byte	$00 ; $b7
>fb8f	00					.byte	$00 ; $b8
>fb90	00					.byte	$00 ; $b9
>fb91	00					.byte	$00 ; $ba
>fb92	00					.byte	$00 ; $bb
>fb93	00					.byte	$00 ; $bc
>fb94	00					.byte	$00 ; $bd
>fb95	00					.byte	$00 ; $be
>fb96	00					.byte	$00 ; $bf
>fb97	00					.byte	$00 ; $c0
>fb98	00					.byte	$00 ; $c1
>fb99	00					.byte	$00 ; $c2
>fb9a	00					.byte	$00 ; $c3
>fb9b	00					.byte	$00 ; $c4
>fb9c	00					.byte	$00 ; $c5
>fb9d	00					.byte	$00 ; $c6
>fb9e	00					.byte	$00 ; $c7
>fb9f	00					.byte	$00 ; $c8
>fba0	00					.byte	$00 ; $c9
>fba1	00					.byte	$00 ; $ca
>fba2	00					.byte	$00 ; $cb
>fba3	00					.byte	$00 ; $cc
>fba4	00					.byte	$00 ; $cd
>fba5	00					.byte	$00 ; $ce
>fba6	00					.byte	$00 ; $cf
>fba7	00					.byte	$00 ; $d0
>fba8	00					.byte	$00 ; $d1
>fba9	00					.byte	$00 ; $d2
>fbaa	00					.byte	$00 ; $d3
>fbab	00					.byte	$00 ; $d4
>fbac	00					.byte	$00 ; $d5
>fbad	00					.byte	$00 ; $d6
>fbae	00					.byte	$00 ; $d7
>fbaf	00					.byte	$00 ; $d8
>fbb0	00					.byte	$00 ; $d9
>fbb1	00					.byte	$00 ; $da
>fbb2	00					.byte	$00 ; $db
>fbb3	00					.byte	$00 ; $dc
>fbb4	00					.byte	$00 ; $dd
>fbb5	00					.byte	$00 ; $de
>fbb6	00					.byte	$00 ; $df
>fbb7	00					.byte	$00 ; $e0
>fbb8	00					.byte	$00 ; $e1
>fbb9	00					.byte	$00 ; $e2
>fbba	00					.byte	$00 ; $e3
>fbbb	00					.byte	$00 ; $e4
>fbbc	00					.byte	$00 ; $e5
>fbbd	00					.byte	$00 ; $e6
>fbbe	00					.byte	$00 ; $e7
>fbbf	00					.byte	$00 ; $e8
>fbc0	45					.byte	$45 ; $e9 'E'
>fbc1	00					.byte	$00 ; $ea
>fbc2	01					.byte	$01 ; $eb chr$(1)
>fbc3	02					.byte	$02 ; $ec chr$(2)
>fbc4	00					.byte	$00 ; $ed
>fbc5	00					.byte	$00 ; $ee
>fbc6	00					.byte	$00 ; $ef
>fbc7	10					.byte	$10 ; $f0 chr$(16)
>fbc8	07					.byte	$07 ; $f1 chr$(7)
>fbc9	03					.byte	$03 ; $f2 chr$(3)
>fbca	00					.byte	$00 ; $f3
>fbcb	04					.byte	$04 ; $f4 chr$(4)
>fbcc	06					.byte	$06 ; $f5 chr$(6)
>fbcd	00					.byte	$00 ; $f6
>fbce	00					.byte	$00 ; $f7
>fbcf	00					.byte	$00 ; $f8
>fbd0	00					.byte	$00 ; $f9
>fbd1	00					.byte	$00 ; $fa
>fbd2	00					.byte	$00 ; $fb
>fbd3	00					.byte	$00 ; $fc
>fbd4	00					.byte	$00 ; $fd
>fbd5	00					.byte	$00 ; $fe
>fbd6	00					.byte	$00 ; $ff
>fbd7	ff					.byte	$FF
.fbd8					OSShiftFixTable:
>fbd8	60 7e					.byte	$60,$7e		; ` => ~
>fbda	31 21					.byte	$31,$21		; 1 => !
>fbdc	32 40					.byte	$32,$40		; 2 => @
>fbde	33 23					.byte	$33,$23		; 3 => #
>fbe0	34 24					.byte	$34,$24		; 4 => $
>fbe2	35 25					.byte	$35,$25		; 5 => %
>fbe4	36 5e					.byte	$36,$5e		; 6 => ^
>fbe6	37 26					.byte	$37,$26		; 7 => &
>fbe8	38 2a					.byte	$38,$2a		; 8 => *
>fbea	39 28					.byte	$39,$28		; 9 => (
>fbec	30 29					.byte	$30,$29		; 0 => )
>fbee	2d 5f					.byte	$2d,$5f		; - => _
>fbf0	3d 2b					.byte	$3d,$2b		; = => +
>fbf2	3b 3a					.byte	$3b,$3a		; ; => :
>fbf4	27 22					.byte	$27,$22		; ' => "
>fbf6	2c 3c					.byte	$2c,$3c		; , => <
>fbf8	2e 3e					.byte	$2e,$3e		; . => >
>fbfa	2f 3f					.byte	$2f,$3f		; / => ?
>fbfc	ff					.byte	$FF
=2					OS_KP_LEFTCTRL_ROW = 2
=$10					OS_KP_LEFTCTRL_COL = $10
=2					OS_KP_LEFTSHIFT_ROW = 2
=$04					OS_KP_LEFTSHIFT_COL = $04
=11					OS_KP_RIGHTSHIFT_ROW = 11
=$02					OS_KP_RIGHTSHIFT_COL = $02
=4					OS_KP_C_ROW = 4
=$02					OS_KP_C_COL = $02
=3					OS_KP_Z_ROW = 3
=$04					OS_KP_Z_COL = $04
=4					OS_KP_X_ROW = 4
=$04					OS_KP_X_COL = $04
=8					OS_KP_K_ROW = 8
=$04					OS_KP_K_COL = $04
=7					OS_KP_M_ROW = 7
=$04					OS_KP_M_COL = $04
=9					OS_KP_L_ROW = 9
=$08					OS_KP_L_COL = $08

;******  Return to file: include.files


;******  Processing file: src/line_editor/lineeditor.asm

.fbfd					OSEnterLine:
.fbfd	9c 5e 02	stz $025e			stz 	OSEditLength 				; clear buffer
.fc00	38		sec				sec 								; calculate edit box max width.
.fc01	ad 22 02	lda $0222			lda 	OSXSize
.fc04	ed 20 02	sbc $0220			sbc 	OSXPos
.fc07	3a		dec a				dec 	a 							; one for RHS
.fc08	8d 5d 02	sta $025d			sta 	OSEditWidth
.fc0b					_OSEditLoop:
.fc0b	20 3e f9	jsr $f93e			jsr 	OSReadKeystroke 			; get one key.
.fc0e	c9 20		cmp #$20			cmp 	#' '	 					; standard character
.fc10	b0 23		bcs $fc35			bcs 	_OSECharacter
.fc12	c9 08		cmp #$08			cmp 	#8 							; check for backspace
.fc14	f0 12		beq $fc28			beq 	_OSEBackspace
.fc16	c9 0d		cmp #$0d			cmp 	#13	 						; check for CR.
.fc18	d0 f1		bne $fc0b			bne 	_OSEditLoop 				; ignore everything else
.fc1a	20 28 f8	jsr $f828			jsr 	OSWriteScreen
.fc1d	ae 5e 02	ldx $025e			ldx 	OSEditLength 				; make it ASCIIZ as well (!)
.fc20	9e 5f 02	stz $025f,x			stz 	OSEditBuffer,x
.fc23	a2 5e		ldx #$5e			ldx 	#OSEditLength & $FF 		; XY = Buffer
.fc25	a0 02		ldy #$02			ldy 	#OSEditLength >> 8
.fc27	60		rts				rts
.fc28					_OSEBackspace:
.fc28	ae 5e 02	ldx $025e			ldx 	OSEditLength 				; can't backspace past beginning
.fc2b	f0 de		beq $fc0b			beq 	_OSEditLoop
.fc2d	20 28 f8	jsr $f828			jsr 	OSWriteScreen 				; backspace one.
.fc30	ce 5e 02	dec $025e			dec 	OSEditLength
.fc33	80 d6		bra $fc0b			bra 	_OSEditLoop
.fc35					_OSECharacter:
.fc35	ae 5e 02	ldx $025e			ldx 	OSEditLength 				; too many characters ?
.fc38	ec 5d 02	cpx $025d			cpx 	OSEditWidth
.fc3b	f0 ce		beq $fc0b			beq 	_OSEditLoop
.fc3d	9d 5f 02	sta $025f,x			sta 	OSEditBuffer,x 				; write in buffer
.fc40	ee 5e 02	inc $025e			inc 	OSEditLength 				; bump length
.fc43	20 28 f8	jsr $f828			jsr 	OSWriteScreen
.fc46	80 c3		bra $fc0b			bra 	_OSEditLoop

;******  Return to file: include.files


;******  Processing file: src/screen_editor/screeneditor.asm

.fc48					OSScreenLine:
.fc48	9c 5e 02	stz $025e			stz 	OSEditLength 				; clear buffer
.fc4b					_OSScreenLoop:
.fc4b	20 3e f9	jsr $f93e			jsr 	OSReadKeystroke	 			; get key.
.fc4e	c9 10		cmp #$10			cmp 	#$10						; insert
.fc50	f0 4a		beq $fc9c			beq 	_OSSInsert
.fc52	c9 07		cmp #$07			cmp 	#$07 						; delete / backspace
.fc54	f0 1d		beq $fc73			beq 	_OSSDelete
.fc56	c9 08		cmp #$08			cmp 	#$08
.fc58	f0 09		beq $fc63			beq 	_OSSBackspace
.fc5a	c9 0d		cmp #$0d			cmp 	#$0D 						; Return key ?
.fc5c	f0 6f		beq $fccd			beq 	_OSSReturn
.fc5e	20 28 f8	jsr $f828			jsr 	OSWriteScreen
.fc61	80 e8		bra $fc4b			bra 	_OSScreenLoop
.fc63					_OSSBackspace:
.fc63	ad 20 02	lda $0220			lda 	OSXPos 						; backspace blocked if first character on line
.fc66	d0 08		bne $fc70			bne 	_OSSBackspaceOk
.fc68	ae 21 02	ldx $0221			ldx 	OSYPos 						; and its the start of a group.
.fc6b	bd 00 02	lda $0200,x			lda 	OSNewLineFlag,x
.fc6e	d0 db		bne $fc4b			bne 	_OSScreenLoop
.fc70					_OSSBackspaceOk:
.fc70	20 50 fd	jsr $fd50			jsr 	OSSLeft 					; move left.
.fc73					_OSSDelete:
.fc73	20 1f fd	jsr $fd1f			jsr 	OSSSaveGetFrame 			; save current position and get frame.
.fc76					_OSSDeleteLoop:
.fc76	ad 27 02	lda $0227			lda 	OSYFrameBottom 				; reached the end
.fc79	cd 21 02	cmp $0221			cmp 	OSYPos
.fc7c	90 11		bcc $fc8f			bcc 	_OSSDelComplete
.fc7e	20 62 fd	jsr $fd62			jsr 	OSSRight 					; shuffle everything
.fc81	20 7e f9	jsr $f97e			jsr 	OSDReadPhysical
.fc84	20 50 fd	jsr $fd50			jsr 	OSSLeft
.fc87	20 84 f9	jsr $f984			jsr 	OSDWritePhysical
.fc8a	20 62 fd	jsr $fd62			jsr 	OSSRight
.fc8d	80 e7		bra $fc76			bra 	_OSSDeleteLoop
.fc8f					_OSSDelComplete:
.fc8f	20 50 fd	jsr $fd50			jsr 	OSSLeft 					; blank last character
.fc92					_OSSWriteSpace:
.fc92	a9 20		lda #$20			lda 	#' ' 						; write space at posiition
.fc94	20 84 f9	jsr $f984			jsr 	OSDWritePhysical
.fc97	20 12 fd	jsr $fd12			jsr 	OSSLoadPosition 			; restore original pos and loop back.
.fc9a	80 af		bra $fc4b			bra		_OSScreenLoop
.fc9c					_OSSInsert:
.fc9c	20 1f fd	jsr $fd1f			jsr 	OSSSaveGetFrame 			; save current position and get frame.
.fc9f	ad 22 02	lda $0222			lda 	OSXSize 					; start insert copy is end
.fca2	3a		dec a				dec 	a
.fca3	8d 20 02	sta $0220			sta 	OSXPos
.fca6	ad 27 02	lda $0227			lda 	OSYFrameBottom
.fca9	8d 21 02	sta $0221			sta 	OSYPos
.fcac					_OSSInsertLoop:
.fcac	ad 20 02	lda $0220			lda 	OSXPos 						; reached insert point ?
.fcaf	cd 24 02	cmp $0224			cmp 	OSXPosSave
.fcb2	d0 08		bne $fcbc			bne 	_OSSShiftUp
.fcb4	ad 21 02	lda $0221			lda 	OSYPos
.fcb7	cd 25 02	cmp $0225			cmp 	OSYPosSave
.fcba	f0 d6		beq $fc92			beq 	_OSSWriteSpace 				; space there and continue
.fcbc					_OSSShiftUp:
.fcbc	20 50 fd	jsr $fd50			jsr 	OSSLeft
.fcbf	20 7e f9	jsr $f97e			jsr 	OSDReadPhysical
.fcc2	20 62 fd	jsr $fd62			jsr 	OSSRight
.fcc5	20 84 f9	jsr $f984			jsr 	OSDWritePhysical
.fcc8	20 50 fd	jsr $fd50			jsr 	OSSLeft
.fccb	80 df		bra $fcac			bra 	_OSSInsertLoop
.fccd					_OSSReturn:
.fccd	20 1f fd	jsr $fd1f			jsr 	OSSSaveGetFrame 			; save current position and get frame.
.fcd0	9c 20 02	stz $0220			stz 	OSXPos
.fcd3	ad 26 02	lda $0226			lda 	OSYFrameTop					; start position.
.fcd6	8d 21 02	sta $0221			sta 	OSYPos
.fcd9					_OSSRCopy:
.fcd9	ad 27 02	lda $0227			lda 	OSYFrameBottom 				; reached the end
.fcdc	cd 21 02	cmp $0221			cmp 	OSYPos
.fcdf	90 11		bcc $fcf2			bcc 	_OSSRCopied
.fce1	20 7e f9	jsr $f97e			jsr 	OSDReadPhysical
.fce4	ae 5e 02	ldx $025e			ldx 	OSEditLength
.fce7	9d 5f 02	sta $025f,x			sta 	OSEditBuffer,x
.fcea	ee 5e 02	inc $025e			inc 	OSEditLength
.fced	20 62 fd	jsr $fd62			jsr 	OSSRight
.fcf0	80 e7		bra $fcd9			bra 	_OSSRCopy
.fcf2					_OSSRCopied:
.fcf2	20 50 fd	jsr $fd50			jsr 	OSSLeft 					; do a CR from previous line, scroll if required.
.fcf5	a9 0d		lda #$0d			lda		#13
.fcf7	20 28 f8	jsr $f828			jsr 	OSWriteScreen
.fcfa	ae 5e 02	ldx $025e			ldx 	OSEditLength 				; strip trailing spaces
.fcfd					_OSSSStripSpaces:
.fcfd	ca		dex				dex
.fcfe	bd 5f 02	lda $025f,x			lda 	OSEditBuffer,x
.fd01	c9 20		cmp #$20			cmp 	#$20
.fd03	d0 08		bne $fd0d			bne 	_OSSSSSEnd
.fd05	9e 5f 02	stz $025f,x			stz 	OSEditBuffer,x
.fd08	8e 5e 02	stx $025e			stx 	OSEditLength
.fd0b	80 f0		bra $fcfd			bra 	_OSSSStripSpaces
.fd0d					_OSSSSSEnd:
.fd0d	a2 5e		ldx #$5e			ldx 	#OSEditLength & $FF
.fd0f	a0 02		ldy #$02			ldy 	#OSEditLength >> 8
.fd11	60		rts				rts
.fd12					OSSLoadPosition:
.fd12	ae 24 02	ldx $0224			ldx 	OSXPosSave
.fd15	8e 20 02	stx $0220			stx 	OSXPos
.fd18	ae 25 02	ldx $0225			ldx 	OSYPosSave
.fd1b	8e 21 02	stx $0221			stx 	OSYPos
.fd1e	60		rts				rts
.fd1f					OSSSaveGetFrame:
.fd1f	ae 20 02	ldx $0220			ldx 	OSXPos 						; save current position
.fd22	8e 24 02	stx $0224			stx 	OSXPosSave
.fd25	ae 21 02	ldx $0221			ldx 	OSYPos
.fd28	8e 25 02	stx $0225			stx 	OSYPosSave
.fd2b					_OSSSFindTop:
.fd2b	e0 00		cpx #$00			cpx 	#0 							; top of screen
.fd2d	f0 08		beq $fd37			beq 	_OSSSTFound
.fd2f	bd 00 02	lda $0200,x			lda 	OSNewLineFlag,x  			; start of frame.
.fd32	d0 03		bne $fd37			bne 	_OSSSTFound
.fd34	ca		dex				dex
.fd35	80 f4		bra $fd2b			bra 	_OSSSFindTop
.fd37					_OSSSTFound:
.fd37	8e 26 02	stx $0226			stx 	OSYFrameTop
.fd3a	ae 21 02	ldx $0221			ldx 	OSYPos
.fd3d					_OSSSFindBottom:
.fd3d	8a		txa				txa
.fd3e	1a		inc a				inc 	a
.fd3f	cd 23 02	cmp $0223			cmp 	OSYSize 					; bottom of screen
.fd42	f0 08		beq $fd4c			beq 	_OSSSBFound
.fd44	bd 01 02	lda $0201,x			lda 	OSNewLineFlag+1,x
.fd47	d0 03		bne $fd4c			bne 	_OSSSBFound
.fd49	e8		inx				inx
.fd4a	80 f1		bra $fd3d			bra 	_OSSSFindBottom
.fd4c					_OSSSBFound:
.fd4c	8e 27 02	stx $0227			stx 	OSYFrameBottom
.fd4f	60		rts				rts
.fd50					OSSLeft:
.fd50	48		pha				pha
.fd51	ce 20 02	dec $0220			dec 	OSXPos
.fd54	10 0a		bpl $fd60			bpl 	_OSSLExit
.fd56	ce 21 02	dec $0221			dec 	OSYPos
.fd59	ad 22 02	lda $0222			lda 	OSXSize
.fd5c	3a		dec a				dec 	a
.fd5d	8d 20 02	sta $0220			sta 	OSXPos
.fd60					_OSSLExit:
.fd60	68		pla				pla
.fd61	60		rts				rts
.fd62					OSSRight:
.fd62	48		pha				pha
.fd63	ee 20 02	inc $0220			inc 	OSXPos
.fd66	ad 20 02	lda $0220			lda 	OSXPos
.fd69	cd 22 02	cmp $0222			cmp 	OSXSize
.fd6c	d0 06		bne $fd74			bne 	_OSSRExit
.fd6e	9c 20 02	stz $0220			stz 	OSXPos
.fd71	ee 21 02	inc $0221			inc 	OSYPos
.fd74					_OSSRExit:
.fd74	68		pla				pla
.fd75	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/utility/setup.asm

.fd76					OSInitialise:
.fd76	a9 28		lda #$28			lda 	#40 						; 40 x 30 display
.fd78	8d 22 02	sta $0222			sta 	OSXSize
.fd7b	a9 1e		lda #$1e			lda 	#30
.fd7d	8d 23 02	sta $0223			sta 	OSYSize
.fd80	20 b8 f9	jsr $f9b8			jsr 	OSDClearScreen 				; clear the display
.fd83	20 4e fa	jsr $fa4e			jsr 	OSDKeyboardInitialise 		; reset the keyboard state.
.fd86	60		rts				rts
.fd87					OSGetScreenSize:
.fd87	ae 22 02	ldx $0222			ldx 	OSXSize
.fd8a	ac 23 02	ldy $0223			ldy 	OSYSize
.fd8d	60		rts				rts
.fd8e					OSGetScreenPosition:
.fd8e	ae 20 02	ldx $0220			ldx 	OSXPos
.fd91	ac 21 02	ldy $0221			ldy 	OSYPos
.fd94	60		rts				rts
.fd95					OSCheckBreak:
.fd95	ad 5b 02	lda $025b			lda 	OSEscapePressed
.fd98	60		rts				rts

;******  Return to file: include.files


;******  Return to file: osrom.asm


;******  Processing file: build/libwwfslib.asmlib

.fd99					FSReadNextHeader:
.fd99	ee 44 03	inc $0344			inc 	currentSector 				; bump last sector and read next one.
.fd9c	ad 44 03	lda $0344			lda 	currentSector
.fd9f					FSReadHeaderA:
.fd9f	c9 00		cmp #$00			cmp 	#0 							; sector 0 always okay.
.fda1	f0 05		beq $fda8			beq 	_FSIsOk
.fda3	cd 42 03	cmp $0342			cmp 	sectorCount 				; check legitimate sector
.fda6	b0 26		bcs $fdce			bcs 	_FSReadHFail
.fda8					_FSIsOk:
.fda8	da		phx				phx
.fda9	8d 44 03	sta $0344			sta 	currentSector 				; save as current
.fdac	20 f4 fe	jsr $fef4			jsr 	FSHOpenRead 				; open for read
.fdaf	a2 00		ldx #$00			ldx 	#0 							; read in.
.fdb1					_FSReadHLoop:
.fdb1	20 06 ff	jsr $ff06			jsr 	FSHRead
.fdb4	9d 47 03	sta $0347,x			sta 	sectorHeader,x
.fdb7	e8		inx				inx
.fdb8	e0 20		cpx #$20			cpx 	#32
.fdba	d0 f5		bne $fdb1			bne 	_FSReadHLoop
.fdbc	20 1b ff	jsr $ff1b			jsr 	FSHEndCommand				; end read.
.fdbf	fa		plx				plx
.fdc0	ad 4b 03	lda $034b			lda 	shFileSize 					; copy file size - makes easily accessible
.fdc3	8d 67 03	sta $0367			sta 	shFileSizeCopy 				; for directory function.
.fdc6	ad 4c 03	lda $034c			lda 	shFileSize+1
.fdc9	8d 68 03	sta $0368			sta 	shFileSizeCopy+1
.fdcc	18		clc				clc
.fdcd	60		rts				rts
.fdce					_FSReadHFail:
.fdce	38		sec				sec
.fdcf	60		rts				rts
.fdd0					OSReadFile:
.fdd0	86 22		stx $22				stx 	fsBlock 					; file block.
.fdd2	84 23		sty $23				sty 	fsBlock+1
.fdd4	9c 44 03	stz $0344			stz 	currentSector
.fdd7	a9 ff		lda #$ff			lda 	#$FF 						; set flag to $FF
.fdd9	8d 46 03	sta $0346			sta 	successFlag
.fddc					_OSReadLoop1:
.fddc	20 99 fd	jsr $fd99			jsr 	FSReadNextHeader 			; read header ?
.fddf	b0 32		bcs $fe13			bcs 	_OSReadExit 				; end of search.
.fde1	ad 47 03	lda $0347			lda 	shFirstNext 				; is it the (F)irst record
.fde4	c9 46		cmp #$46			cmp 	#"F"
.fde6	d0 f4		bne $fddc			bne 	_OSReadLoop1
.fde8	20 98 fe	jsr $fe98			jsr 	FSCompareFileNames 			; is it F/N and matching.
.fdeb	90 ef		bcc $fddc			bcc 	_OSReadLoop1 				; no, try next sector
.fded	9c 46 03	stz $0346			stz 	successFlag 				; zero when found file.
.fdf0					_OSReadBlock:
.fdf0	ad 44 03	lda $0344			lda 	currentSector
.fdf3	20 17 fe	jsr $fe17			jsr 	FSReadData 					; read the data file in.
.fdf6	ad 48 03	lda $0348			lda 	shContinue 					; continuation ?
.fdf9	c9 4e		cmp #$4e			cmp 	#"N" 						; exit if no.
.fdfb	f0 16		beq $fe13			beq 	_OSReadExit
.fdfd					_OSReadLoop2:
.fdfd	ad 44 03	lda $0344			lda 	currentSector
.fe00	20 99 fd	jsr $fd99			jsr 	FSReadNextHeader 			; read header ?
.fe03	b0 0e		bcs $fe13			bcs 	_OSReadExit 				; end of search.
.fe05	ad 47 03	lda $0347			lda 	shFirstNext 				; is it the (F)irst record
.fe08	c9 4e		cmp #$4e			cmp 	#"N"
.fe0a	d0 f1		bne $fdfd			bne 	_OSReadLoop2
.fe0c	20 98 fe	jsr $fe98			jsr 	FSCompareFileNames 			; is it F/N and matching.
.fe0f	90 ec		bcc $fdfd			bcc 	_OSReadLoop2 				; no, try next sector
.fe11	80 dd		bra $fdf0			bra 	_OSReadBlock 				; read block in.
.fe13					_OSReadExit:
.fe13	0e 46 03	asl $0346			asl 	successFlag					; shift success flag (0 if done) into carry
.fe16	60		rts				rts
.fe17					FSReadData:
.fe17	ad 44 03	lda $0344			lda 	currentSector
.fe1a	20 f4 fe	jsr $fef4			jsr 	FSHOpenRead 				; open for read
.fe1d	a2 20		ldx #$20			ldx 	#32 						; read past the header
.fe1f					_FSReadHLoop:
.fe1f	20 06 ff	jsr $ff06			jsr 	FSHRead
.fe22	ca		dex				dex
.fe23	d0 fa		bne $fe1f			bne 	_FSReadHLoop
.fe25					_FSRDCopy:
.fe25	ad 49 03	lda $0349			lda 	shDataSize 					; datasize count zero ?
.fe28	0d 4a 03	ora $034a			ora 	shDataSize+1
.fe2b	f0 15		beq $fe42			beq 	_OSRDExit
.fe2d	ad 49 03	lda $0349			lda 	shDataSize 					; decrement the data count.
.fe30	d0 03		bne $fe35			bne 	_OSRDNoBorrow
.fe32	ce 4a 03	dec $034a			dec 	shDataSize+1
.fe35					_OSRDNoBorrow:
.fe35	ce 49 03	dec $0349			dec 	shDataSize
.fe38	20 46 fe	jsr $fe46			jsr 	FSIncrementSetLoad 			; load address to zTemp0 and increment it.
.fe3b	20 06 ff	jsr $ff06			jsr 	FSHRead 					; copy byte there
.fe3e	92 20		sta ($20)			sta 	(iTemp0)
.fe40	80 e3		bra $fe25			bra 	_FSRDCopy 					; go round again.
.fe42					_OSRDExit:
.fe42	20 1b ff	jsr $ff1b			jsr 	FSHEndCommand
.fe45	60		rts				rts
.fe46					FSIncrementSetLoad:
.fe46	18		clc				clc
.fe47	a0 02		ldy #$02			ldy 	#2 							; increment load address
.fe49	b1 22		lda ($22),y			lda 	(fsBlock),y  				; copying previous to zTemp0
.fe4b	85 20		sta $20				sta 	iTemp0
.fe4d	69 01		adc #$01			adc 	#1
.fe4f	91 22		sta ($22),y			sta 	(fsBlock),y
.fe51	c8		iny				iny
.fe52	b1 22		lda ($22),y			lda 	(fsBlock),y
.fe54	85 21		sta $21				sta 	iTemp0+1
.fe56	69 00		adc #$00			adc 	#0
.fe58	91 22		sta ($22),y			sta 	(fsBlock),y
.fe5a	60		rts				rts
.fe5b					OSReadDirectory:
.fe5b	b0 12		bcs $fe6f			bcs 	_OSRDReset
.fe5d					_OSRDLoop:
.fe5d	20 99 fd	jsr $fd99			jsr 	FSReadNextHeader 			; read next sector header.
.fe60	b0 10		bcs $fe72			bcs 	_OSRDExit 					; exit, end of file space, CS
.fe62	ad 47 03	lda $0347			lda 	shFirstNext 				; is it an 'F' record
.fe65	c9 46		cmp #$46			cmp 	#'F'
.fe67	d0 f4		bne $fe5d			bne 	_OSRDLoop
.fe69	a2 57		ldx #$57			ldx 	#shNameLength & $FF 		; return the buffer address
.fe6b	a0 03		ldy #$03			ldy 	#shNameLength >> 8
.fe6d	18		clc				clc 								; return with carry clear.
.fe6e	60		rts				rts
.fe6f					_OSRDReset:
.fe6f	9c 44 03	stz $0344			stz 	currentSector 				; back to the start.
.fe72					_OSRDExit:
.fe72	60		rts				rts
.fe73					OSDeleteFile:
.fe73	86 22		stx $22				stx 	fsBlock 					; file block.
.fe75	84 23		sty $23				sty 	fsBlock+1
.fe77	9c 44 03	stz $0344			stz 	currentSector
.fe7a	a9 ff		lda #$ff			lda 	#$FF 						; set flag to $FF
.fe7c	8d 46 03	sta $0346			sta 	successFlag
.fe7f					_OSDeleteLoop:
.fe7f	20 99 fd	jsr $fd99			jsr 	FSReadNextHeader 			; read header ?
.fe82	b0 10		bcs $fe94			bcs 	_OSDeleteExit 				; end of search.
.fe84	20 98 fe	jsr $fe98			jsr 	FSCompareFileNames 			; is it F/N and matching.
.fe87	90 f6		bcc $fe7f			bcc 	_OSDeleteLoop 				; no, try next sector
.fe89	ad 44 03	lda $0344			lda 	currentSector 				; yes, then erase this sector
.fe8c	20 eb fe	jsr $feeb			jsr 	FSHErase
.fe8f	9c 46 03	stz $0346			stz 	successFlag 				; zero if successful
.fe92	80 eb		bra $fe7f			bra 	_OSDeleteLoop
.fe94					_OSDeleteExit:
.fe94	0e 46 03	asl $0346			asl 	successFlag					; shift success flag (0 if done) into carry
.fe97	60		rts				rts
.fe98					FSCompareFileNames:
.fe98	ad 47 03	lda $0347			lda 	shFirstNext 				; is it F/N type ?
.fe9b	c9 46		cmp #$46			cmp 	#"F"
.fe9d	f0 04		beq $fea3			beq 	_FSDeleteCheckName
.fe9f	c9 4e		cmp #$4e			cmp 	#"N"
.fea1	d0 19		bne $febc			bne 	_FSCompareFail 				; no, then compare fails.
.fea3					_FSDeleteCheckName:
.fea3	a0 01		ldy #$01			ldy 	#1 							; copy filename to iTemp0
.fea5	b2 22		lda ($22)			lda 	(fsBlock)
.fea7	85 20		sta $20				sta 	iTemp0
.fea9	b1 22		lda ($22),y			lda 	(fsBlock),y
.feab	85 21		sta $21				sta 	iTemp0+1
.fead	b2 20		lda ($20)			lda 	(iTemp0) 					; compare n+1
.feaf	a8		tay				tay
.feb0					_FSCompareName:
.feb0	b9 57 03	lda $0357,y			lda 	shNameLength,y
.feb3	d1 20		cmp ($20),y			cmp 	(iTemp0),y
.feb5	d0 05		bne $febc			bne 	_FSCompareFail
.feb7	88		dey				dey
.feb8	10 f6		bpl $feb0			bpl 	_FSCompareName
.feba	38		sec				sec
.febb	60		rts				rts
.febc					_FSCompareFail:
.febc	18		clc				clc
.febd	60		rts				rts
.febe					FSInitialise:
.febe	9c 42 03	stz $0342			stz 	sectorCount 				; initial values to read $00
.fec1	9c 43 03	stz $0343			stz 	sectorCount+1
.fec4	9c 40 03	stz $0340			stz 	sectorSize
.fec7	9c 41 03	stz $0341			stz 	sectorSize+1
.feca	a9 00		lda #$00			lda 	#0 							; read header sector 0
.fecc	20 9f fd	jsr $fd9f			jsr 	FSReadHeaderA
.fecf	ad 49 03	lda $0349			lda 	sectorHeader+2 				; copy sector count
.fed2	8d 42 03	sta $0342			sta 	sectorCount
.fed5	ad 4a 03	lda $034a			lda 	sectorHeader+3
.fed8	8d 43 03	sta $0343			sta 	sectorCount+1
.fedb	ad 4b 03	lda $034b			lda 	sectorHeader+4 				; sector size power
.fede	ee 40 03	inc $0340			inc 	sectorSize 					; convert to sector size.
.fee1					_FSICalcSS:
.fee1	0e 40 03	asl $0340			asl 	sectorSize
.fee4	2e 41 03	rol $0341			rol 	sectorSize+1
.fee7	3a		dec a				dec 	a
.fee8	d0 f7		bne $fee1			bne 	_FSICalcSS
.feea	60		rts				rts
.feeb					FSHErase:
.feeb	8d 11 cf	sta $cf11			sta 	$CF11 						; save data
.feee	a9 00		lda #$00			lda 	#0 						; activate on command write
.fef0	8d 10 cf	sta $cf10			sta 	$CF10
.fef3	60		rts				rts
.fef4					FSHOpenRead:
.fef4	8d 11 cf	sta $cf11			sta 	$CF11 						; save data
.fef7	a9 01		lda #$01			lda 	#1 						; activate on command write
.fef9	8d 10 cf	sta $cf10			sta 	$CF10
.fefc	60		rts				rts
.fefd					FSHOpenWrite:
.fefd	8d 11 cf	sta $cf11			sta 	$CF11 						; save data
.ff00	a9 02		lda #$02			lda 	#2 						; activate on command write
.ff02	8d 10 cf	sta $cf10			sta 	$CF10
.ff05	60		rts				rts
.ff06					FSHRead:
.ff06	8d 11 cf	sta $cf11			sta 	$CF11 						; save data
.ff09	a9 03		lda #$03			lda 	#3 						; activate on command write
.ff0b	8d 10 cf	sta $cf10			sta 	$CF10
.ff0e	ad 12 cf	lda $cf12			lda 	$CF12
.ff11	60		rts				rts
.ff12					FSHWrite:
.ff12	8d 11 cf	sta $cf11			sta 	$CF11 						; save data
.ff15	a9 04		lda #$04			lda 	#4 						; activate on command write
.ff17	8d 10 cf	sta $cf10			sta 	$CF10
.ff1a	60		rts				rts
.ff1b					FSHEndCommand:
.ff1b	8d 11 cf	sta $cf11			sta 	$CF11 						; save data
.ff1e	a9 05		lda #$05			lda 	#5 						; activate on command write
.ff20	8d 10 cf	sta $cf10			sta 	$CF10
.ff23	60		rts				rts

;******  Return to file: osrom.asm

.ff24					MainPrompt:
>ff24	68						.byte 	_MPEnd-MainPrompt-1
>ff25	0c 2a 2a 2a 20 4f 4c 49				.text 	12,"*** OLIMEX Neo6502 RetroComputer ***",13,13
>ff2d	4d 45 58 20 4e 65 6f 36 35 30 32 20 52 65 74 72
>ff3d	6f 43 6f 6d 70 75 74 65 72 20 2a 2a 2a 0d 0d
>ff4c	41 6c 70 68 61 20 3a 20				.text 	"Alpha : Built "
>ff54	42 75 69 6c 74 20

;******  Processing file: src/generated/time.incx

>ff5a	32 33 2f 30 37 2f 30 32			.text	"23/07/02"

;******  Return to file: osrom.asm

>ff62	0d 0d						.byte 	13,13
>ff64	50 6c 65 61 73 65 20 72				.text 	"Please report bugs: paul@robsons.org.uk",13,13
>ff6c	65 70 6f 72 74 20 62 75 67 73 3a 20 70 61 75 6c
>ff7c	40 72 6f 62 73 6f 6e 73 2e 6f 72 67 2e 75 6b 0d
>ff8c	0d
.ff8d					_MPEnd:

;******  Processing file: src/generated/vectors.asmx

.ffd0	4c 5b fe	jmp $fe5b		jmp		OSReadDirectory          ; Read file directory.
.ffd3	4c 73 fe	jmp $fe73		jmp		OSDeleteFile             ; Delete file
.ffd6	4c d0 fd	jmp $fdd0		jmp		OSReadFile               ; Read file into memory
.ffd9	4c 8e fd	jmp $fd8e		jmp		OSGetScreenPosition      ; Screen position to XY
.ffdc	4c 87 fd	jmp $fd87		jmp		OSGetScreenSize          ; Get size of screen to XY
.ffdf	4c 5f f9	jmp $f95f		jmp		OSWriteString            ; Write length prefixed string YX to screen
.ffe2	4c fd fb	jmp $fbfd		jmp		OSEnterLine              ; Edit line, return line in YX length prefixed, backspace only editing.
.ffe5	4c 48 fc	jmp $fc48		jmp		OSScreenLine             ; Edit line, return line in YX length prefixed, full screen editing.
.ffe8	4c d8 f9	jmp $f9d8		jmp		OSKeyboardDataProcess    ; Keyboard update process.
.ffeb	4c 95 fd	jmp $fd95		jmp		OSCheckBreak             ; NZ if ESC pressed.
.ffee	4c 12 f9	jmp $f912		jmp		OSIsKeyAvailable         ; Check if key available (CS if so)
.fff1	4c 3e f9	jmp $f93e		jmp		OSReadKeystroke          ; Read A from keyboard, display cursor, wait for key.
.fff4	4c 1c f9	jmp $f91c		jmp		OSReadKeyboard           ; Read A from keyboard, CC = success, CS = no key
.fff7	4c 28 f8	jmp $f828		jmp		OSWriteScreen            ; Write A to screen, CC = success

;******  Return to file: osrom.asm

>fffa	17 f8						.word 	NoInt 						; NMI
>fffc	00 f8						.word 	Boot 						; Reset
>fffe	17 f8						.word 	NoInt						; IRQ

;******  End of listing
