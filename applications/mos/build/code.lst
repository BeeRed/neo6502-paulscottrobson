
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -q -Wall -c -C -b -L build/code.lst -l build/code.lbl -o build/osrom.bin osrom.asm
; Wed Jun 28 17:10:04 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: osrom.asm


;******  Processing file: ramdata.inc

=$08					ZeroPageBase = $08 							; zero page usage
=$200					StorageBase = $200 							; ROM usage
.0008					IFR0:
>0008							.fill 	4
.000c					IFR1:
>000c							.fill 	4
.0010					IFR2:
>0010							.fill 	4
.0014					IFRTemp:
>0014							.fill 	4
.0018					codePtr:
>0018							.fill 	4
.001c					rTemp0:
>001c							.fill 	2
.001e					rTemp1:
>001e							.fill 	2
.0020					iTemp0:
>0020							.fill 	2
.0200					OSXPos:
>0200							.fill 	1
.0201					OSYPos:
>0201							.fill 	1
.0202					OSXSize:
>0202							.fill 	1
.0203					OSYSize:
>0203							.fill 	1
=16					OSKeyboardQueueMaxSize = 16					; keyboard queue max size.
.0204					OSKeyStatus:
>0204							.fill 	32
.0224					OSKeyboardQueue:
>0224							.fill 	OSKeyboardQueueMaxSize
.0234					OSKeyboardQueueSize:
>0234							.fill 	1
.0235					OSIsKeyUp:
>0235							.fill 	1
.0236					OSIsKeyShift:
>0236							.fill 	1
.0237					OSEscapePressed:
>0237							.fill 	1
.0238					OSRKOriginal:
>0238							.fill 	1
=192					OSTextBufferSize = 192
.0239					OSEditWidth:
>0239							.fill 	1
.023a					OSEditLength:
>023a							.fill 	1
.023b					OSEditBuffer:
>023b							.fill 	OSTextBufferSize+1
>02fc							.fill 	32
>031c							.align 	256

;******  Return to file: osrom.asm

.f800	20 17 fc	jsr $fc17	Boot:	jsr 	OSInitialise 				; set everything up.
.f803	a2 33		ldx #$33			ldx 	#MainPrompt & $FF 			; display the boot prompt
.f805	a0 fc		ldy #$fc			ldy 	#MainPrompt >> 8
.f807	20 03 f9	jsr $f903			jsr 	OSWriteString
.f80a	4c 00 10	jmp $1000			jmp 	$1000 						; and run from $1000 onwards
.f80d					NoInt:
.f80d	40		rti				rti

;******  Processing file: include.files


;******  Processing file: src/basicio/charout.asm

.f80e					OSWriteScreen:
.f80e	da		phx				phx
.f80f	a2 00		ldx #$00			ldx 	#0 							; screen is device #0
.f811	20 16 f8	jsr $f816			jsr 	OSWriteDevice
.f814	fa		plx				plx
.f815	60		rts				rts
.f816					OSWriteDevice:
.f816	48		pha				pha 								; save AXY
.f817	da		phx				phx
.f818	5a		phy				phy
.f819	c9 20		cmp #$20			cmp 	#32 						; standard character $20,$FF (we allow for cyrillic possibility here)
.f81b	b0 0c		bcs $f829			bcs 	_OSWriteDirect
.f81d	c9 10		cmp #$10			cmp 	#16 						; 16-32 for set colours, reserved.
.f81f	b0 0e		bcs $f82f			bcs 	_OSWriteDeviceExit
.f821	0a		asl a				asl 	a 							; make to an offset in vector table
.f822	aa		tax				tax
.f823	4a		lsr a				lsr 	a
.f824	20 34 f8	jsr $f834			jsr 	_OSCallVectorCode 			; call that code
.f827	80 06		bra $f82f			bra 	_OSWriteDeviceExit 			; and leave
.f829					_OSWriteDirect:
.f829	20 28 f9	jsr $f928			jsr 	OSWritePhysical 			; $20-$FF write to screen
.f82c	20 78 f8	jsr $f878			jsr 	_OSCursorAdvance 			; and forwards.
.f82f					_OSWriteDeviceExit:
.f82f	7a		ply				ply
.f830	fa		plx				plx
.f831	68		pla				pla
.f832	18		clc				clc 								; written fine.
.f833	60		rts				rts
.f834					_OSCallVectorCode:
.f834	7c 38 f8	jmp ($f838,x)			jmp 	(_OSWDVector,x)
.f837					_OSWNoFunction:
.f837	60		rts				rts
.f838					_OSWDVector:
>f838	37 f8						.word 	_OSWNoFunction 				; $00 	No operation
>f83a	66 f8						.word 	_OSCursorLeft 				; $01 	Left 		(Ctrl-A)
>f83c	af f8						.word 	OSHomeCursor 				; $02 	Home Cursor (Ctrl-B)
>f83e	86 f8						.word 	_OSCursorDown 				; $03 	Down 		(Ctrl-C)
>f840	6f f8						.word 	_OSCursorRight 				; $04 	Right 		(Ctrl-D)
>f842	78 f8						.word 	_OSCursorAdvance			; $05 	Advance
>f844	98 f8						.word 	_OSCursorUp 				; $06	Up 			(Ctrl-F)
>f846	37 f8						.word 	_OSWNoFunction 				; $07 	Delete 		(Del)
>f848	58 f8						.word 	_OSBackspace				; $08 	Backspace 	(Backspace)
>f84a	a4 f8						.word 	_OSWHTab 					; $09	Tab
>f84c	37 f8						.word 	_OSWNoFunction 				; $0A
>f84e	37 f8						.word 	_OSWNoFunction 				; $0B
>f850	5c f9						.word 	OSClearScreen 				; $0C	ClearScreen	(Ctrl-L)
>f852	83 f8						.word 	_OSNewLine 					; $0D 	CarriageRet (Enter)
>f854	01 fa						.word 	OSScrollUp 					; $0E 	Scroll Up 	(e.g. off bottom)
>f856	2e fa						.word 	OSScrollDown 				; $0F 	Scroll Down (e.g. off top)
.f858					_OSBackspace:
.f858	ad 00 02	lda $0200			lda 	OSXPos 						; left side already ?
.f85b	f0 11		beq $f86e			beq 	_OSCLExit
.f85d	ce 00 02	dec $0200			dec 	OSXPos 						; go left one.
.f860	a9 20		lda #$20			lda 	#' ' 						; ovewrite the character there.
.f862	20 28 f9	jsr $f928			jsr 	OSWritePhysical
.f865	60		rts				rts
.f866					_OSCursorLeft:
.f866	ad 00 02	lda $0200			lda 	OSXPos 						; left side
.f869	f0 03		beq $f86e			beq 	_OSCLExit 					; yes, exit
.f86b	ce 00 02	dec $0200			dec 	OSXPos 						; cursor left
.f86e					_OSCLExit:
.f86e	60		rts				rts
.f86f					_OSCursorRight:
.f86f	ad 00 02	lda $0200			lda 	OSXPos 						; reached right side ?
.f872	1a		inc a				inc 	a
.f873	cd 02 02	cmp $0202			cmp 	OSXSize
.f876	f0 1f		beq $f897			beq 	_OSCRExit 					; yes, exit, no, fall through.
.f878					_OSCursorAdvance:
.f878	ee 00 02	inc $0200			inc 	OSXPos 						; advance cursor and position.
.f87b	ad 00 02	lda $0200			lda 	OSXPos 						; reached RHS
.f87e	cd 02 02	cmp $0202			cmp 	OSXSize
.f881	90 14		bcc $f897			bcc 	_OSCRExit 					; if not, then exit.
.f883					_OSNewLine:
.f883	9c 00 02	stz $0200			stz 	OSXPos 						; start next line.
.f886					_OSCursorDown:
.f886	ee 01 02	inc $0201			inc 	OSYPos 						; down one line.
.f889	ad 01 02	lda $0201			lda 	OSYPos 						; reached bottom
.f88c	cd 03 02	cmp $0203			cmp 	OSYSize
.f88f	90 06		bcc $f897			bcc 	_OSCRExit 					; no, we're done.
.f891	ce 01 02	dec $0201			dec 	OSYPos 						; position back to bottom line.
.f894	20 01 fa	jsr $fa01			jsr 	OSScrollUp 					; scroll whole screen up.
.f897					_OSCRExit:
.f897	60		rts				rts
.f898					_OSCursorUp:
.f898	ce 01 02	dec $0201			dec 	OSYPos 						; up one line ?
.f89b	10 fa		bpl $f897			bpl 	_OSCRExit 					; exit if still on screen
.f89d	ee 01 02	inc $0201			inc 	OSYPos 						; fix up position.
.f8a0	20 2e fa	jsr $fa2e			jsr 	OSScrollDown 				; scroll down.
.f8a3	60		rts				rts
.f8a4					_OSWHTab:
.f8a4	20 78 f8	jsr $f878			jsr 	_OSCursorAdvance
.f8a7	ad 00 02	lda $0200			lda 	OSXPos
.f8aa	29 07		and #$07			and 	#7
.f8ac	d0 f6		bne $f8a4			bne 	_OSWHTab
.f8ae	60		rts				rts
.f8af					OSHomeCursor:
.f8af	9c 00 02	stz $0200			stz 	OSXPos
.f8b2	9c 01 02	stz $0201			stz 	OSYPos
.f8b5	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/basicio/keyboard.asm

.f8b6					OSIsKeyAvailable:
.f8b6	48		pha				pha
.f8b7	18		clc				clc
.f8b8	ad 34 02	lda $0234			lda 	OSKeyboardQueueSize  		; get count of entries in queue
.f8bb	d0 01		bne $f8be			bne 	_OSIKAHasKey
.f8bd	38		sec				sec
.f8be					_OSIKAHasKey:
.f8be	68		pla				pla
.f8bf	60		rts				rts
.f8c0					OSReadKeyboard:
.f8c0	20 7c f9	jsr $f97c			jsr 	OSKeyboardDataProcess 		; this scans the keyboard etc.
.f8c3	20 b6 f8	jsr $f8b6			jsr 	OSIsKeyAvailable 			; key available ?
.f8c6	b0 19		bcs $f8e1			bcs 	_OSRDExit 					; no exit with CS.
.f8c8	ad 24 02	lda $0224			lda 	OSKeyboardQueue 			; push char from head of queueon stack
.f8cb	48		pha				pha
.f8cc	da		phx				phx 								; shift everything else up one.
.f8cd	a2 00		ldx #$00			ldx		#0 							; remove from queue array
.f8cf					_OSRDDequeue:
.f8cf	bd 25 02	lda $0225,x			lda 	OSKeyboardQueue+1,x
.f8d2	9d 24 02	sta $0224,x			sta 	OSKeyboardQueue,x
.f8d5	e8		inx				inx
.f8d6	ec 34 02	cpx $0234			cpx 	OSKeyboardQueueSize
.f8d9	d0 f4		bne $f8cf			bne 	_OSRDDequeue
.f8db	ce 34 02	dec $0234			dec 	OSKeyboardQueueSize			; dec queue count
.f8de	fa		plx				plx
.f8df	68		pla				pla 								; restore key
.f8e0	18		clc				clc
.f8e1					_OSRDExit:
.f8e1	60		rts				rts
.f8e2					OSReadKeystroke:
.f8e2	da		phx				phx 								; save XY
.f8e3	5a		phy				phy
.f8e4	20 22 f9	jsr $f922			jsr 	OSReadPhysical 				; save old character under cursor
.f8e7	8d 38 02	sta $0238			sta 	OSRKOriginal
.f8ea	a9 7f		lda #$7f			lda 	#$7F 						; write prompt
.f8ec	20 28 f9	jsr $f928			jsr 	OSWritePhysical
.f8ef					_OSWaitKey:
.f8ef	20 7c f9	jsr $f97c			jsr 	OSKeyboardDataProcess 		; this scans the keyboard, could be interrupt
.f8f2	20 c0 f8	jsr $f8c0			jsr 	OSReadKeyboard 				; key available
.f8f5	b0 f8		bcs $f8ef			bcs 	_OSWaitKey 					; no keep going
.f8f7	48		pha				pha 								; save key
.f8f8	ad 38 02	lda $0238			lda 	OSRKOriginal 				; old character back and write to screen.
.f8fb	20 28 f9	jsr $f928			jsr 	OSWritePhysical
.f8fe	68		pla				pla 								; restore
.f8ff	7a		ply				ply
.f900	fa		plx				plx
.f901	18		clc				clc 								; success
.f902	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/basicio/writestring.asm

.f903					OSWriteString:
.f903	48		pha				pha 								; save AXY
.f904	da		phx				phx
.f905	5a		phy				phy
.f906	86 1e		stx $1e				stx		rTemp1 						; address of string in rTemp1
.f908	84 1f		sty $1f				sty 	rTemp1+1
.f90a	b2 1e		lda ($1e)			lda 	(rTemp1)
.f90c	aa		tax				tax 								; count in X
.f90d	a0 00		ldy #$00			ldy 	#0
.f90f					OSWSLoop:
.f90f	e0 00		cpx #$00			cpx 	#0 							; done them all, exit
.f911	f0 0b		beq $f91e			beq 	_OSWSExit
.f913	ca		dex				dex 								; dec count
.f914	c8		iny				iny 								; get next character
.f915	b1 1e		lda ($1e),y			lda 	(rTemp1),y
.f917	f0 05		beq $f91e			beq 	_OSWSExit 					; end if $00
.f919	20 0e f8	jsr $f80e			jsr 	OSWriteScreen				; otherwise write to screen.
.f91c	80 f1		bra $f90f			bra 	OSWSLoop
.f91e					_OSWSExit:
.f91e	7a		ply				ply 								; restore AXY and exit
.f91f	fa		plx				plx
.f920	68		pla				pla
.f921	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/charwrite.asm

.f922					OSReadPhysical:
.f922	20 30 f9	jsr $f930			jsr 	OSGetAddress
.f925	b2 1c		lda ($1c)			lda 	(rTemp0)
.f927	60		rts				rts
.f928					OSWritePhysical:
.f928	48		pha				pha
.f929	20 30 f9	jsr $f930			jsr 	OSGetAddress
.f92c	68		pla				pla
.f92d	92 1c		sta ($1c)			sta 	(rTemp0)
.f92f	60		rts				rts
.f930					OSGetAddress:
.f930	ac 01 02	ldy $0201	        ldy     OSYPos
.f933	ae 00 02	ldx $0200	        ldx 	OSXPos
.f936					OSGetAddressXY:
.f936	ad 02 02	lda $0202	        lda     OSXSize
.f939	4a		lsr a		        lsr     a                           ; prime the carry bit for the loop
.f93a	85 1c		sta $1c		        sta     rTemp0
.f93c	84 1d		sty $1d		        sty     rTemp0+1
.f93e	a9 00		lda #$00	        lda     #0
.f940	a0 08		ldy #$08	        ldy     #8
.f942					_IFMLoop:
.f942	90 03		bcc $f947	        bcc     _IFMNoAdd
.f944	18		clc		        clc
.f945	65 1d		adc $1d		        adc     rTemp0+1
.f947					_IFMNoAdd:
.f947	6a		ror a		        ror     a
.f948	66 1c		ror $1c		        ror     rTemp0                      ; pull another bit out for the next iteration
.f94a	88		dey		        dey
.f94b	d0 f5		bne $f942	        bne     _IFMLoop
.f94d	09 c0		ora #$c0	        ora 	#$C0
.f94f	a8		tay		        tay
.f950	18		clc		        clc
.f951	8a		txa		        txa
.f952	65 1c		adc $1c		        adc 	rTemp0
.f954	85 1c		sta $1c		        sta 	rTemp0
.f956	90 01		bcc $f959	        bcc 	_IFMNoCarry
.f958	c8		iny		        iny
.f959					_IFMNoCarry:
.f959	84 1d		sty $1d				sty 	rTemp0+1
.f95b	60		rts		        rts

;******  Return to file: include.files


;******  Processing file: src/drivers/clear.asm

.f95c					OSClearScreen:
.f95c	a9 c0		lda #$c0			lda 	#$C0 						; set screen pos.
.f95e	85 1d		sta $1d				sta 	rTemp0+1
.f960	64 1c		stz $1c				stz 	rTemp0
.f962	ac 03 02	ldy $0203			ldy 	OSYSize 					; clear height * width bytes.
.f965					_OSCSLoop1:
.f965	ae 02 02	ldx $0202			ldx 	OSXSize
.f968					_OSCSLoop2:
.f968	a9 20		lda #$20			lda 	#' '
.f96a	92 1c		sta ($1c)			sta 	(rTemp0)
.f96c	e6 1c		inc $1c				inc 	rTemp0
.f96e	d0 02		bne $f972			bne 	_OSCSNoCarry
.f970	e6 1d		inc $1d				inc 	rTemp0+1
.f972					_OSCSNoCarry:
.f972	ca		dex				dex
.f973	d0 f3		bne $f968			bne 	_OSCSLoop2
.f975	88		dey				dey
.f976	d0 ed		bne $f965			bne 	_OSCSLoop1
.f978	20 af f8	jsr $f8af			jsr 	OSHomeCursor 				; cursor to (0,0)
.f97b	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/ps2keyboard.asm

.f97c					OSKeyboardDataProcess:
.f97c	ad 00 cf	lda $cf00			lda 	$CF00 						; read keyboard port
.f97f	f0 31		beq $f9b2			beq 	_OSKExit 					; no events available.
.f981	c9 f0		cmp #$f0			cmp 	#$F0 						; check key up ?
.f983	f0 2a		beq $f9af			beq 	_OSKUp
.f985	c9 e0		cmp #$e0			cmp 	#$E0 						; check extended scancode ?
.f987	f0 1f		beq $f9a8			beq 	_OSKShift
.f989	0d 36 02	ora $0236			ora 	OSIsKeyShift 				; actual key code - sets bit 7 if extended scancode.
.f98c	48		pha				pha
.f98d	20 bb f9	jsr $f9bb			jsr 	OSKeyboardUpdateBits 		; update the up/down bits
.f990	68		pla				pla
.f991	ae 35 02	ldx $0235			ldx 	OSIsKeyUp 					; if key up reset up and shift flags.
.f994	f0 08		beq $f99e			beq 	_OSKInsertQueue 			; if key down insert into queue
.f996	9c 35 02	stz $0235			stz 	OSIsKeyUp 					; reset up/shift
.f999	9c 36 02	stz $0236			stz 	OSIsKeyShift
.f99c	80 14		bra $f9b2			bra 	_OSKExit
.f99e					_OSKInsertQueue:
.f99e	20 59 fa	jsr $fa59			jsr 	OSTranslateToASCII 			; convert to ASCII
.f9a1	b0 0f		bcs $f9b2			bcs 	_OSKExit 					; carry set, exit (unknown key)
.f9a3	20 e4 f9	jsr $f9e4			jsr 	OSInsertKeyboardQueue 		; insert into keyboard queue.
.f9a6	80 0a		bra $f9b2			bra 	_OSKExit
.f9a8					_OSKShift:
.f9a8	a9 80		lda #$80			lda 	#$80 						; set this so the OR seets bit 7.
.f9aa	8d 36 02	sta $0236			sta 	OSIsKeyShift
.f9ad	80 03		bra $f9b2			bra 	_OSKExit
.f9af					_OSKUp:
.f9af	ce 35 02	dec $0235			dec 	OSIsKeyUp 					; received $F0 (key up), set that flag
.f9b2					_OSKExit:
.f9b2	ad 12 02	lda $0212			lda 	OSKeyStatus+$0E 			; and on the way out check if ESC was pressed.
.f9b5	29 40		and #$40			and 	#$40
.f9b7	8d 37 02	sta $0237			sta 	OSEscapePressed
.f9ba	60		rts				rts
.f9bb					OSKeyboardUpdateBits:
.f9bb	a2 00		ldx #$00			ldx 	#0 							; offset in table
.f9bd					_OSKUCalculate:
.f9bd	c9 08		cmp #$08			cmp 	#8 							; work out the row
.f9bf	90 06		bcc $f9c7			bcc 	_OSKUHaveRow
.f9c1	e8		inx				inx
.f9c2	38		sec				sec
.f9c3	e9 08		sbc #$08			sbc 	#8
.f9c5	80 f6		bra $f9bd			bra 	_OSKUCalculate
.f9c7					_OSKUHaveRow:
.f9c7	a8		tay				tay 								; work out the column
.f9c8	a9 00		lda #$00			lda 	#0
.f9ca	38		sec				sec
.f9cb					_OSKUCalculate2:
.f9cb	2a		rol a				rol 	a
.f9cc	88		dey				dey
.f9cd	10 fc		bpl $f9cb			bpl 	_OSKUCalculate2  			; at end , A is bitmask, X is row (table entry)
.f9cf	2c 35 02	bit $0235			bit 	OSIsKeyUp 					; check up
.f9d2	30 07		bmi $f9db			bmi 	_OSKUUp
.f9d4	1d 04 02	ora $0204,x			ora 	OSKeyStatus,x 				; down set bit
.f9d7	9d 04 02	sta $0204,x			sta 	OSKeyStatus,x
.f9da	60		rts				rts
.f9db					_OSKUUp:
.f9db	49 ff		eor #$ff			eor 	#$FF 						; make maske
.f9dd	3d 04 02	and $0204,x			and 	OSKeyStatus,x 				; up clear bit
.f9e0	9d 04 02	sta $0204,x			sta 	OSKeyStatus,x
.f9e3	60		rts				rts
.f9e4					OSInsertKeyboardQueue:
.f9e4	ae 34 02	ldx $0234			ldx 	OSKeyboardQueueSize 		; check to see if full
.f9e7	e0 10		cpx #$10			cpx	 	#OSKeyboardQueueMaxSize
.f9e9	b0 06		bcs $f9f1			bcs 	_OSIKQExit 					; if so, you will never know.
.f9eb	9d 24 02	sta $0224,x			sta 	OSKeyboardQueue,x 			; add keyboard entry to queue.
.f9ee	ee 34 02	inc $0234			inc 	OSKeyboardQueueSize
.f9f1					_OSIKQExit:
.f9f1	60		rts				rts
.f9f2					OSKeyboardInitialise:
.f9f2	a2 32		ldx #$32			ldx 	#OSIsKeyShift-OSKeyStatus
.f9f4					_OSKILoop:
.f9f4	9e 04 02	stz $0204,x			stz 	OSKeyStatus,x
.f9f7	ca		dex				dex
.f9f8	10 fa		bpl $f9f4			bpl 	_OSKILoop
.f9fa	9c 35 02	stz $0235			stz 	OSIsKeyUp 					; reset up/shift
.f9fd	9c 36 02	stz $0236			stz 	OSIsKeyShift
.fa00	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/scroll.asm

.fa01					OSScrollUp:
.fa01	a9 c0		lda #$c0			lda 	#$C0 						; scroll whole screen up.
.fa03	64 1c		stz $1c				stz 	rTemp0
.fa05	85 1d		sta $1d				sta 	rTemp0+1
.fa07	ac 03 02	ldy $0203			ldy 	OSYSize 					; line counts.
.fa0a	88		dey				dey
.fa0b					_OSSULoop1:
.fa0b	ae 02 02	ldx $0202			ldx 	OSXSize 					; number of bytes to copy
.fa0e	5a		phy				phy
.fa0f	ac 02 02	ldy $0202			ldy 	OSXSize 					; offset
.fa12					_OSSULoop2:
.fa12	b1 1c		lda ($1c),y			lda 	(rTemp0),y 					; copy up
.fa14	92 1c		sta ($1c)			sta 	(rTemp0)
.fa16	e6 1c		inc $1c				inc 	rTemp0 						; adjust position.
.fa18	d0 02		bne $fa1c			bne 	_OSSUCarry
.fa1a	e6 1d		inc $1d				inc 	rTemp0+1
.fa1c					_OSSUCarry:
.fa1c	ca		dex				dex 								; do the whole row
.fa1d	d0 f3		bne $fa12			bne 	_OSSULoop2
.fa1f	7a		ply				ply
.fa20	88		dey				dey 								; for n-1 rows
.fa21	d0 e8		bne $fa0b			bne 	_OSSULoop1
.fa23	ac 02 02	ldy $0202			ldy 	OSXSize 					; fill bottom row with spaces.
.fa26					_OSSUFill:
.fa26	a9 20		lda #$20			lda 	#' '
.fa28	88		dey				dey
.fa29	91 1c		sta ($1c),y			sta 	(rTemp0),y
.fa2b	d0 f9		bne $fa26			bne 	_OSSUFill
.fa2d	60		rts				rts
.fa2e					OSScrollDown:
.fa2e	ae 02 02	ldx $0202			ldx 	OSXSize 					; get address of (RHS, Bottom-1).
.fa31	ac 03 02	ldy $0203			ldy 	OSYSize
.fa34	ca		dex				dex
.fa35	88		dey				dey
.fa36	88		dey				dey
.fa37	20 36 f9	jsr $f936			jsr 	OSGetAddressXY
.fa3a	ac 02 02	ldy $0202			ldy 	OSXSize 					; copy one row.
.fa3d					_OSSDLoop:
.fa3d	b2 1c		lda ($1c)			lda 	(rTemp0) 					; copy it down
.fa3f	91 1c		sta ($1c),y			sta 	(rTemp0),y
.fa41	a5 1c		lda $1c				lda 	rTemp0 						; decrement address
.fa43	d0 08		bne $fa4d			bne 	_OSSDNoBorrow
.fa45	a5 1d		lda $1d				lda 	rTemp0+1 					; until we've shifted $C000 down.
.fa47	c9 c0		cmp #$c0			cmp 	#$C0
.fa49	f0 06		beq $fa51			beq 	_OSSDExit
.fa4b	c6 1d		dec $1d				dec 	rTemp0+1
.fa4d					_OSSDNoBorrow:
.fa4d	c6 1c		dec $1c				dec 	rTemp0
.fa4f	80 ec		bra $fa3d			bra 	_OSSDLoop
.fa51					_OSSDExit:
.fa51	a9 20		lda #$20			lda		#' ' 						; erase the top row.
.fa53	88		dey				dey
.fa54	91 1c		sta ($1c),y			sta 	(rTemp0),y
.fa56	d0 f9		bne $fa51			bne 	_OSSDExit
.fa58	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/drivers/translate.asm

.fa59					OSTranslateToASCII:
.fa59	aa		tax				tax
.fa5a	bd a6 fa	lda $faa6,x			lda 	OSASCIIFromScanCode,x 		; get ASCII keystroke from scan code
.fa5d	f0 45		beq $faa4			beq 	_OSTTAFail 					; wrong keyboard map/type ?
.fa5f	aa		tax				tax 								; save in X
.fa60	ad 06 02	lda $0206			lda 	OSKeyStatus+OS_KP_LEFTCTRL_ROW
.fa63	29 10		and #$10			and 	#OS_KP_LEFTCTRL_COL
.fa65	d0 36		bne $fa9d			bne 	_OSTTAControl 				; check for CTRL + x
.fa67	ad 06 02	lda $0206			lda 	OSKeyStatus+OS_KP_LEFTSHIFT_ROW
.fa6a	29 04		and #$04			and 	#OS_KP_LEFTSHIFT_COL
.fa6c	d0 07		bne $fa75			bne 	_OSTTAShift 				; check for left/right shift
.fa6e	ad 0f 02	lda $020f			lda 	OSKeyStatus+OS_KP_RIGHTSHIFT_ROW
.fa71	29 02		and #$02			and 	#OS_KP_RIGHTSHIFT_COL
.fa73	f0 2c		beq $faa1			beq 	_OSTTAExit 					; no, no translate
.fa75					_OSTTAShift:
.fa75	e0 61		cpx #$61			cpx 	#"a"						; check alpha a-z => A-Z
.fa77	90 0a		bcc $fa83			bcc 	_OSTTANotAlpha
.fa79	e0 7b		cpx #$7b			cpx 	#"z"+1
.fa7b	b0 06		bcs $fa83			bcs 	_OSTTANotAlpha
.fa7d	8a		txa				txa									; capitalise.
.fa7e	49 20		eor #$20			eor 	#$20
.fa80	aa		tax				tax
.fa81	80 1e		bra $faa1			bra 	_OSTTAExit
.fa83					_OSTTANotAlpha:
.fa83	86 1c		stx $1c				stx 	rTemp0 						; save ASCII code.
.fa85	a0 00		ldy #$00			ldy 	#0 							; check the shift table
.fa87					_OSTTACheckShiftTable:
.fa87	b9 a8 fb	lda $fba8,y			lda 	OSShiftFixTable+1,y 		; tax = shifted character
.fa8a	aa		tax				tax
.fa8b	b9 a7 fb	lda $fba7,y			lda 	OSShiftFixTable,y 			; check unshifted match
.fa8e	c5 1c		cmp $1c				cmp 	rTemp0
.fa90	f0 0f		beq $faa1			beq 	_OSTTAExit
.fa92	c8		iny				iny 								; next pair
.fa93	c8		iny				iny
.fa94	b9 a7 fb	lda $fba7,y			lda 	OSShiftFixTable,y 			; until all checked
.fa97	10 ee		bpl $fa87			bpl 	_OSTTACheckShiftTable
.fa99	a6 1c		ldx $1c				ldx 	rTemp0 						; not shiftable.
.fa9b	80 04		bra $faa1			bra 	_OSTTAExit
.fa9d					_OSTTAControl:
.fa9d	8a		txa				txa
.fa9e	29 1f		and #$1f			and 	#31
.faa0	aa		tax				tax
.faa1					_OSTTAExit:
.faa1	8a		txa				txa
.faa2	18		clc				clc
.faa3	60		rts				rts
.faa4					_OSTTAFail:
.faa4	38		sec				sec
.faa5	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/generated/ps2convert.asm

.faa6					OSASCIIFromScanCode:
>faa6	00					.byte	$00 ; $00
>faa7	19					.byte	$19 ; $01 chr$(25)
>faa8	00					.byte	$00 ; $02
>faa9	15					.byte	$15 ; $03 chr$(21)
>faaa	13					.byte	$13 ; $04 chr$(19)
>faab	11					.byte	$11 ; $05 chr$(17)
>faac	12					.byte	$12 ; $06 chr$(18)
>faad	00					.byte	$00 ; $07
>faae	00					.byte	$00 ; $08
>faaf	1a					.byte	$1a ; $09 chr$(26)
>fab0	18					.byte	$18 ; $0a chr$(24)
>fab1	16					.byte	$16 ; $0b chr$(22)
>fab2	14					.byte	$14 ; $0c chr$(20)
>fab3	09					.byte	$09 ; $0d chr$(9)
>fab4	60					.byte	$60 ; $0e '`'
>fab5	00					.byte	$00 ; $0f
>fab6	00					.byte	$00 ; $10
>fab7	00					.byte	$00 ; $11
>fab8	00					.byte	$00 ; $12
>fab9	00					.byte	$00 ; $13
>faba	00					.byte	$00 ; $14
>fabb	71					.byte	$71 ; $15 'q'
>fabc	31					.byte	$31 ; $16 '1'
>fabd	00					.byte	$00 ; $17
>fabe	00					.byte	$00 ; $18
>fabf	00					.byte	$00 ; $19
>fac0	7a					.byte	$7a ; $1a 'z'
>fac1	73					.byte	$73 ; $1b 's'
>fac2	61					.byte	$61 ; $1c 'a'
>fac3	77					.byte	$77 ; $1d 'w'
>fac4	32					.byte	$32 ; $1e '2'
>fac5	00					.byte	$00 ; $1f
>fac6	00					.byte	$00 ; $20
>fac7	63					.byte	$63 ; $21 'c'
>fac8	78					.byte	$78 ; $22 'x'
>fac9	64					.byte	$64 ; $23 'd'
>faca	65					.byte	$65 ; $24 'e'
>facb	34					.byte	$34 ; $25 '4'
>facc	33					.byte	$33 ; $26 '3'
>facd	00					.byte	$00 ; $27
>face	00					.byte	$00 ; $28
>facf	20					.byte	$20 ; $29 ' '
>fad0	76					.byte	$76 ; $2a 'v'
>fad1	66					.byte	$66 ; $2b 'f'
>fad2	74					.byte	$74 ; $2c 't'
>fad3	72					.byte	$72 ; $2d 'r'
>fad4	35					.byte	$35 ; $2e '5'
>fad5	00					.byte	$00 ; $2f
>fad6	00					.byte	$00 ; $30
>fad7	6e					.byte	$6e ; $31 'n'
>fad8	62					.byte	$62 ; $32 'b'
>fad9	68					.byte	$68 ; $33 'h'
>fada	67					.byte	$67 ; $34 'g'
>fadb	79					.byte	$79 ; $35 'y'
>fadc	36					.byte	$36 ; $36 '6'
>fadd	00					.byte	$00 ; $37
>fade	00					.byte	$00 ; $38
>fadf	00					.byte	$00 ; $39
>fae0	6d					.byte	$6d ; $3a 'm'
>fae1	6a					.byte	$6a ; $3b 'j'
>fae2	75					.byte	$75 ; $3c 'u'
>fae3	37					.byte	$37 ; $3d '7'
>fae4	38					.byte	$38 ; $3e '8'
>fae5	00					.byte	$00 ; $3f
>fae6	00					.byte	$00 ; $40
>fae7	2c					.byte	$2c ; $41 ','
>fae8	6b					.byte	$6b ; $42 'k'
>fae9	69					.byte	$69 ; $43 'i'
>faea	6f					.byte	$6f ; $44 'o'
>faeb	30					.byte	$30 ; $45 '0'
>faec	39					.byte	$39 ; $46 '9'
>faed	00					.byte	$00 ; $47
>faee	00					.byte	$00 ; $48
>faef	2e					.byte	$2e ; $49 '.'
>faf0	2f					.byte	$2f ; $4a '/'
>faf1	6c					.byte	$6c ; $4b 'l'
>faf2	3b					.byte	$3b ; $4c ';'
>faf3	70					.byte	$70 ; $4d 'p'
>faf4	2d					.byte	$2d ; $4e '-'
>faf5	00					.byte	$00 ; $4f
>faf6	00					.byte	$00 ; $50
>faf7	00					.byte	$00 ; $51
>faf8	27					.byte	$27 ; $52 '''
>faf9	00					.byte	$00 ; $53
>fafa	5b					.byte	$5b ; $54 '['
>fafb	3d					.byte	$3d ; $55 '='
>fafc	00					.byte	$00 ; $56
>fafd	00					.byte	$00 ; $57
>fafe	00					.byte	$00 ; $58
>faff	00					.byte	$00 ; $59
>fb00	0d					.byte	$0d ; $5a chr$(13)
>fb01	5d					.byte	$5d ; $5b ']'
>fb02	00					.byte	$00 ; $5c
>fb03	7c					.byte	$7c ; $5d '|'
>fb04	00					.byte	$00 ; $5e
>fb05	00					.byte	$00 ; $5f
>fb06	00					.byte	$00 ; $60
>fb07	00					.byte	$00 ; $61
>fb08	00					.byte	$00 ; $62
>fb09	00					.byte	$00 ; $63
>fb0a	00					.byte	$00 ; $64
>fb0b	00					.byte	$00 ; $65
>fb0c	08					.byte	$08 ; $66 chr$(8)
>fb0d	00					.byte	$00 ; $67
>fb0e	00					.byte	$00 ; $68
>fb0f	00					.byte	$00 ; $69
>fb10	00					.byte	$00 ; $6a
>fb11	01					.byte	$01 ; $6b chr$(1)
>fb12	00					.byte	$00 ; $6c
>fb13	00					.byte	$00 ; $6d
>fb14	00					.byte	$00 ; $6e
>fb15	00					.byte	$00 ; $6f
>fb16	00					.byte	$00 ; $70
>fb17	00					.byte	$00 ; $71
>fb18	03					.byte	$03 ; $72 chr$(3)
>fb19	00					.byte	$00 ; $73
>fb1a	04					.byte	$04 ; $74 chr$(4)
>fb1b	06					.byte	$06 ; $75 chr$(6)
>fb1c	1b					.byte	$1b ; $76 chr$(27)
>fb1d	00					.byte	$00 ; $77
>fb1e	00					.byte	$00 ; $78
>fb1f	00					.byte	$00 ; $79
>fb20	00					.byte	$00 ; $7a
>fb21	00					.byte	$00 ; $7b
>fb22	00					.byte	$00 ; $7c
>fb23	00					.byte	$00 ; $7d
>fb24	00					.byte	$00 ; $7e
>fb25	00					.byte	$00 ; $7f
>fb26	00					.byte	$00 ; $80
>fb27	00					.byte	$00 ; $81
>fb28	00					.byte	$00 ; $82
>fb29	17					.byte	$17 ; $83 chr$(23)
>fb2a	00					.byte	$00 ; $84
>fb2b	00					.byte	$00 ; $85
>fb2c	00					.byte	$00 ; $86
>fb2d	00					.byte	$00 ; $87
>fb2e	00					.byte	$00 ; $88
>fb2f	00					.byte	$00 ; $89
>fb30	00					.byte	$00 ; $8a
>fb31	00					.byte	$00 ; $8b
>fb32	00					.byte	$00 ; $8c
>fb33	00					.byte	$00 ; $8d
>fb34	00					.byte	$00 ; $8e
>fb35	00					.byte	$00 ; $8f
>fb36	00					.byte	$00 ; $90
>fb37	00					.byte	$00 ; $91
>fb38	00					.byte	$00 ; $92
>fb39	00					.byte	$00 ; $93
>fb3a	00					.byte	$00 ; $94
>fb3b	00					.byte	$00 ; $95
>fb3c	00					.byte	$00 ; $96
>fb3d	00					.byte	$00 ; $97
>fb3e	00					.byte	$00 ; $98
>fb3f	00					.byte	$00 ; $99
>fb40	00					.byte	$00 ; $9a
>fb41	00					.byte	$00 ; $9b
>fb42	00					.byte	$00 ; $9c
>fb43	00					.byte	$00 ; $9d
>fb44	00					.byte	$00 ; $9e
>fb45	00					.byte	$00 ; $9f
>fb46	00					.byte	$00 ; $a0
>fb47	00					.byte	$00 ; $a1
>fb48	00					.byte	$00 ; $a2
>fb49	00					.byte	$00 ; $a3
>fb4a	00					.byte	$00 ; $a4
>fb4b	00					.byte	$00 ; $a5
>fb4c	00					.byte	$00 ; $a6
>fb4d	00					.byte	$00 ; $a7
>fb4e	00					.byte	$00 ; $a8
>fb4f	00					.byte	$00 ; $a9
>fb50	00					.byte	$00 ; $aa
>fb51	00					.byte	$00 ; $ab
>fb52	00					.byte	$00 ; $ac
>fb53	00					.byte	$00 ; $ad
>fb54	00					.byte	$00 ; $ae
>fb55	00					.byte	$00 ; $af
>fb56	00					.byte	$00 ; $b0
>fb57	00					.byte	$00 ; $b1
>fb58	00					.byte	$00 ; $b2
>fb59	00					.byte	$00 ; $b3
>fb5a	00					.byte	$00 ; $b4
>fb5b	00					.byte	$00 ; $b5
>fb5c	00					.byte	$00 ; $b6
>fb5d	00					.byte	$00 ; $b7
>fb5e	00					.byte	$00 ; $b8
>fb5f	00					.byte	$00 ; $b9
>fb60	00					.byte	$00 ; $ba
>fb61	00					.byte	$00 ; $bb
>fb62	00					.byte	$00 ; $bc
>fb63	00					.byte	$00 ; $bd
>fb64	00					.byte	$00 ; $be
>fb65	00					.byte	$00 ; $bf
>fb66	00					.byte	$00 ; $c0
>fb67	00					.byte	$00 ; $c1
>fb68	00					.byte	$00 ; $c2
>fb69	00					.byte	$00 ; $c3
>fb6a	00					.byte	$00 ; $c4
>fb6b	00					.byte	$00 ; $c5
>fb6c	00					.byte	$00 ; $c6
>fb6d	00					.byte	$00 ; $c7
>fb6e	00					.byte	$00 ; $c8
>fb6f	00					.byte	$00 ; $c9
>fb70	00					.byte	$00 ; $ca
>fb71	00					.byte	$00 ; $cb
>fb72	00					.byte	$00 ; $cc
>fb73	00					.byte	$00 ; $cd
>fb74	00					.byte	$00 ; $ce
>fb75	00					.byte	$00 ; $cf
>fb76	00					.byte	$00 ; $d0
>fb77	00					.byte	$00 ; $d1
>fb78	00					.byte	$00 ; $d2
>fb79	00					.byte	$00 ; $d3
>fb7a	00					.byte	$00 ; $d4
>fb7b	00					.byte	$00 ; $d5
>fb7c	00					.byte	$00 ; $d6
>fb7d	00					.byte	$00 ; $d7
>fb7e	00					.byte	$00 ; $d8
>fb7f	00					.byte	$00 ; $d9
>fb80	00					.byte	$00 ; $da
>fb81	00					.byte	$00 ; $db
>fb82	00					.byte	$00 ; $dc
>fb83	00					.byte	$00 ; $dd
>fb84	00					.byte	$00 ; $de
>fb85	00					.byte	$00 ; $df
>fb86	00					.byte	$00 ; $e0
>fb87	00					.byte	$00 ; $e1
>fb88	00					.byte	$00 ; $e2
>fb89	00					.byte	$00 ; $e3
>fb8a	00					.byte	$00 ; $e4
>fb8b	00					.byte	$00 ; $e5
>fb8c	00					.byte	$00 ; $e6
>fb8d	00					.byte	$00 ; $e7
>fb8e	00					.byte	$00 ; $e8
>fb8f	45					.byte	$45 ; $e9 'E'
>fb90	00					.byte	$00 ; $ea
>fb91	01					.byte	$01 ; $eb chr$(1)
>fb92	02					.byte	$02 ; $ec chr$(2)
>fb93	00					.byte	$00 ; $ed
>fb94	00					.byte	$00 ; $ee
>fb95	00					.byte	$00 ; $ef
>fb96	00					.byte	$00 ; $f0
>fb97	07					.byte	$07 ; $f1 chr$(7)
>fb98	03					.byte	$03 ; $f2 chr$(3)
>fb99	00					.byte	$00 ; $f3
>fb9a	04					.byte	$04 ; $f4 chr$(4)
>fb9b	06					.byte	$06 ; $f5 chr$(6)
>fb9c	00					.byte	$00 ; $f6
>fb9d	00					.byte	$00 ; $f7
>fb9e	00					.byte	$00 ; $f8
>fb9f	00					.byte	$00 ; $f9
>fba0	00					.byte	$00 ; $fa
>fba1	00					.byte	$00 ; $fb
>fba2	00					.byte	$00 ; $fc
>fba3	00					.byte	$00 ; $fd
>fba4	00					.byte	$00 ; $fe
>fba5	00					.byte	$00 ; $ff
>fba6	ff					.byte	$FF
.fba7					OSShiftFixTable:
>fba7	60 7e					.byte	$60,$7e		; ` => ~
>fba9	31 21					.byte	$31,$21		; 1 => !
>fbab	32 40					.byte	$32,$40		; 2 => @
>fbad	33 23					.byte	$33,$23		; 3 => #
>fbaf	34 24					.byte	$34,$24		; 4 => $
>fbb1	35 25					.byte	$35,$25		; 5 => %
>fbb3	36 5e					.byte	$36,$5e		; 6 => ^
>fbb5	37 26					.byte	$37,$26		; 7 => &
>fbb7	38 2a					.byte	$38,$2a		; 8 => *
>fbb9	39 28					.byte	$39,$28		; 9 => (
>fbbb	30 29					.byte	$30,$29		; 0 => )
>fbbd	2d 5f					.byte	$2d,$5f		; - => _
>fbbf	3d 2b					.byte	$3d,$2b		; = => +
>fbc1	3b 3a					.byte	$3b,$3a		; ; => :
>fbc3	27 22					.byte	$27,$22		; ' => "
>fbc5	2c 3c					.byte	$2c,$3c		; , => <
>fbc7	2e 3e					.byte	$2e,$3e		; . => >
>fbc9	2f 3f					.byte	$2f,$3f		; / => ?
>fbcb	ff					.byte	$FF
=2					OS_KP_LEFTCTRL_ROW = 2
=$10					OS_KP_LEFTCTRL_COL = $10
=2					OS_KP_LEFTSHIFT_ROW = 2
=$04					OS_KP_LEFTSHIFT_COL = $04
=11					OS_KP_RIGHTSHIFT_ROW = 11
=$02					OS_KP_RIGHTSHIFT_COL = $02
=4					OS_KP_C_ROW = 4
=$02					OS_KP_C_COL = $02
=3					OS_KP_Z_ROW = 3
=$04					OS_KP_Z_COL = $04
=4					OS_KP_X_ROW = 4
=$04					OS_KP_X_COL = $04
=8					OS_KP_K_ROW = 8
=$04					OS_KP_K_COL = $04
=7					OS_KP_M_ROW = 7
=$04					OS_KP_M_COL = $04
=9					OS_KP_L_ROW = 9
=$08					OS_KP_L_COL = $08

;******  Return to file: include.files


;******  Processing file: src/line_editor/editor.asm

.fbcc					OSEnterLine:
.fbcc	9c 3a 02	stz $023a			stz 	OSEditLength 				; clear buffer
.fbcf	38		sec				sec 								; calculate edit box max width.
.fbd0	ad 02 02	lda $0202			lda 	OSXSize
.fbd3	ed 00 02	sbc $0200			sbc 	OSXPos
.fbd6	3a		dec a				dec 	a 							; one for RHS
.fbd7	8d 39 02	sta $0239			sta 	OSEditWidth
.fbda					_OSEditLoop:
.fbda	20 e2 f8	jsr $f8e2			jsr 	OSReadKeystroke 			; get one key.
.fbdd	c9 20		cmp #$20			cmp 	#' '	 					; standard character
.fbdf	b0 23		bcs $fc04			bcs 	_OSECharacter
.fbe1	c9 08		cmp #$08			cmp 	#8 							; check for backspace
.fbe3	f0 12		beq $fbf7			beq 	_OSEBackspace
.fbe5	c9 0d		cmp #$0d			cmp 	#13	 						; check for CR.
.fbe7	d0 f1		bne $fbda			bne 	_OSEditLoop 				; ignore everything else
.fbe9	20 0e f8	jsr $f80e			jsr 	OSWriteScreen
.fbec	ae 3a 02	ldx $023a			ldx 	OSEditLength 				; make it ASCIIZ as well (!)
.fbef	9e 3b 02	stz $023b,x			stz 	OSEditBuffer,x
.fbf2	a2 3a		ldx #$3a			ldx 	#OSEditLength & $FF 		; XY = Buffer
.fbf4	a0 02		ldy #$02			ldy 	#OSEditLength >> 8
.fbf6	60		rts				rts
.fbf7					_OSEBackspace:
.fbf7	ae 3a 02	ldx $023a			ldx 	OSEditLength 				; can't backspace past beginning
.fbfa	f0 de		beq $fbda			beq 	_OSEditLoop
.fbfc	20 0e f8	jsr $f80e			jsr 	OSWriteScreen 				; backspace one.
.fbff	ce 3a 02	dec $023a			dec 	OSEditLength
.fc02	80 d6		bra $fbda			bra 	_OSEditLoop
.fc04					_OSECharacter:
.fc04	ae 3a 02	ldx $023a			ldx 	OSEditLength 				; too many characters ?
.fc07	ec 39 02	cpx $0239			cpx 	OSEditWidth
.fc0a	f0 ce		beq $fbda			beq 	_OSEditLoop
.fc0c	9d 3b 02	sta $023b,x			sta 	OSEditBuffer,x 				; write in buffer
.fc0f	ee 3a 02	inc $023a			inc 	OSEditLength 				; bump length
.fc12	20 0e f8	jsr $f80e			jsr 	OSWriteScreen
.fc15	80 c3		bra $fbda			bra 	_OSEditLoop

;******  Return to file: include.files


;******  Processing file: src/utility/setup.asm

.fc17					OSInitialise:
.fc17	a9 28		lda #$28			lda 	#40 						; 40 x 30 display
.fc19	8d 02 02	sta $0202			sta 	OSXSize
.fc1c	a9 1e		lda #$1e			lda 	#30
.fc1e	8d 03 02	sta $0203			sta 	OSYSize
.fc21	20 5c f9	jsr $f95c			jsr 	OSClearScreen 				; clear the display
.fc24	20 f2 f9	jsr $f9f2			jsr 	OSKeyboardInitialise 		; reset the keyboard state.
.fc27	60		rts				rts
.fc28					OSGetScreenSize:
.fc28	ae 02 02	ldx $0202			ldx 	OSXSize
.fc2b	ac 03 02	ldy $0203			ldy 	OSYSize
.fc2e	60		rts				rts
.fc2f					OSCheckBreak:
.fc2f	ad 37 02	lda $0237			lda 	OSEscapePressed
.fc32	60		rts				rts

;******  Return to file: include.files


;******  Return to file: osrom.asm

.fc33					MainPrompt:
>fc33	67						.byte 	_MPEnd-MainPrompt-1
>fc34	2a 2a 2a 20 4f 4c 49 4d				.text 	"*** OLIMEX Neo6502 RetroComputer ***",13,13
>fc3c	45 58 20 4e 65 6f 36 35 30 32 20 52 65 74 72 6f
>fc4c	43 6f 6d 70 75 74 65 72 20 2a 2a 2a 0d 0d
>fc5a	41 6c 70 68 61 20 3a 20				.text 	"Alpha : Built "
>fc62	42 75 69 6c 74 20

;******  Processing file: src/generated/time.incx

>fc68	32 33 2f 30 36 2f 32 38			.text	"23/06/28"

;******  Return to file: osrom.asm

>fc70	0d 0d						.byte 	13,13
>fc72	50 6c 65 61 73 65 20 72				.text 	"Please report bugs: paul@robsons.org.uk",13,13
>fc7a	65 70 6f 72 74 20 62 75 67 73 3a 20 70 61 75 6c
>fc8a	40 72 6f 62 73 6f 6e 73 2e 6f 72 67 2e 75 6b 0d
>fc9a	0d
.fc9b					_MPEnd:

;******  Processing file: src/generated/vectors.asmx

.ffdf	4c cc fb	jmp $fbcc		jmp		OSEnterLine              ; Edit line, return line in YX length prefixed, backspace only editing.
.ffe2	4c 7c f9	jmp $f97c		jmp		OSKeyboardDataProcess    ; Keyboard update process.
.ffe5	4c 2f fc	jmp $fc2f		jmp		OSCheckBreak             ; NZ if ESC pressed.
.ffe8	4c b6 f8	jmp $f8b6		jmp		OSIsKeyAvailable         ; Check if key available (CS if so)
.ffeb	4c c0 f8	jmp $f8c0		jmp		OSReadKeyboard           ; Read A from keyboard, CC = success, CS = no key
.ffee	4c e2 f8	jmp $f8e2		jmp		OSReadKeystroke          ; Read A from keyboard, display cursor, wait for key.
.fff1	4c 0e f8	jmp $f80e		jmp		OSWriteScreen            ; Write A to screen, CC = success
.fff4	4c 03 f9	jmp $f903		jmp		OSWriteString            ; Write length prefixed string YX to screen
.fff7	4c 28 fc	jmp $fc28		jmp		OSGetScreenSize          ; Get size of screen to XY

;******  Return to file: osrom.asm

>fffa	0d f8						.word 	NoInt 						; NMI
>fffc	00 f8						.word 	Boot 						; Reset
>fffe	0d f8						.word 	NoInt						; IRQ

;******  End of listing
