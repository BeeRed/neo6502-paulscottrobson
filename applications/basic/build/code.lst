
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -q -Wall -c -C -b -L build/code.lst -l build/code.lbl -D "BASICLOAD=\$1000" -D "BASICCODE=\$6000" -D "ENDMEMORY=\$B000" -D STACKPAGES=2 -D runEdit=1 -o build/basic.bin basic.asm
; Mon Jun  5 20:43:13 2023

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=$1000					BASICLOAD=$1000
=$6000					BASICCODE=$6000
=$b000					ENDMEMORY=$B000
=2					STACKPAGES=2
=1					runEdit=1

;******  Processing input file: basic.asm


;******  Processing file: build/ramdata.inc

=$08					ZeroPageBase = $08 							; zero page usage
=$200					StorageBase = $200 							; ROM usage
.0008					rTemp0:
>0008							.fill 	2
.000a					iTemp0:
>000a							.fill 	2
.000c					IFR0:
>000c							.fill 	4
.0010					IFR1:
>0010							.fill 	4
.0014					IFR2:
>0014							.fill 	4
.0018					IFRTemp:
>0018							.fill 	4
.0200					OSXPos:
>0200							.fill 	1
.0201					OSYPos:
>0201							.fill 	1
.0202					OSXSize:
>0202							.fill 	1
.0203					OSYSize:
>0203							.fill 	1
=16					OSKeyboardQueueMaxSize = 16					; keyboard queue max size.
.0204					OSKeyStatus:
>0204							.fill 	32
.0224					OSKeyboardQueue:
>0224							.fill 	OSKeyboardQueueMaxSize
.0234					OSKeyboardQueueSize:
>0234							.fill 	1
.0235					OSIsKeyUp:
>0235							.fill 	1
.0236					OSIsKeyShift:
>0236							.fill 	1
.0237					OSRKOriginal:
>0237							.fill 	1
=192					OSTextBufferSize = 192
.0238					OSXEdit:
>0238							.fill 	1
.0239					OSYEdit:
>0239							.fill 	1
.023a					OSEditWidth:
>023a							.fill 	1
.023b					OSEditPos:
>023b							.fill 	1
.023c					OSEditScroll:
>023c							.fill 	1
.023d					OSEditLength:
>023d							.fill 	1
.023e					OSEditBuffer:
>023e							.fill 	OSTextBufferSize+1
>02ff							.fill 	32
>031f							.align 	256

;******  Return to file: basic.asm


;******  Processing file: build/osvectors.inc

=$ffe5					OSGetScreenSize          = $ffe5 ; Get size of screen to XY
=$ffe8					OSIsKeyAvailable         = $ffe8 ; Check if key available (CS if so)
=$ffeb					OSReadKeystroke          = $ffeb ; Read A from keyboard, showing cursor while waiting.
=$ffee					OSReadKeyboard           = $ffee ; Read A from keyboard (device 1), CC = success
=$fff1					OSWriteScreen            = $fff1 ; Write A to screen (device 0), CC = success
=$fff4					OSReadDevice             = $fff4 ; Read device X to A, CC = success
=$fff7					OSWriteDevice            = $fff7 ; Write A to device X, CC = success

;******  Return to file: basic.asm

=0					runEdit = 0 								; setting to 1 builds with the program/testing stuff in.
.1000					boot:
.1000	a2 60		ldx #$60			ldx 	#BASICCODE >> 8
.1002	a0 b0		ldy #$b0			ldy 	#ENDMEMORY >> 8
.1004	20 09 3e	jsr $3e09			jsr 	PGMSetBaseAddress
.1007	20 39 48	jsr $4839			jsr 	IFInitialise
.100a	4c 0d 10	jmp $100d			jmp 	TestCode

;******  Processing file: src/program/testing/testing.asmx

.100d					TestCode:
.100d	20 10 3e	jsr $3e10			jsr 	PGMNewProgram
.1010	9c ff ff	stz $ffff			stz 	$FFFF

;******  Processing file: src/program/testing/testrun.incx

.1013	a2 5e		ldx #$5e		ldx #Line0 & $FF
.1015	a0 13		ldy #$13		ldy #Line0 >> 8
.1017	20 1a 31	jsr $311a		jsr TOKOneLine
.101a	a2 a5		ldx #$a5		ldx #Line1 & $FF
.101c	a0 13		ldy #$13		ldy #Line1 >> 8
.101e	20 1a 31	jsr $311a		jsr TOKOneLine
.1021	a2 a9		ldx #$a9		ldx #Line2 & $FF
.1023	a0 13		ldy #$13		ldy #Line2 >> 8
.1025	20 1a 31	jsr $311a		jsr TOKOneLine
.1028	a2 0d		ldx #$0d		ldx #Line3 & $FF
.102a	a0 14		ldy #$14		ldy #Line3 >> 8
.102c	20 1a 31	jsr $311a		jsr TOKOneLine
.102f	a2 1c		ldx #$1c		ldx #Line4 & $FF
.1031	a0 14		ldy #$14		ldy #Line4 >> 8
.1033	20 1a 31	jsr $311a		jsr TOKOneLine
.1036	a2 38		ldx #$38		ldx #Line5 & $FF
.1038	a0 14		ldy #$14		ldy #Line5 >> 8
.103a	20 1a 31	jsr $311a		jsr TOKOneLine
.103d	a2 bc		ldx #$bc		ldx #Line6 & $FF
.103f	a0 14		ldy #$14		ldy #Line6 >> 8
.1041	20 1a 31	jsr $311a		jsr TOKOneLine
.1044	a2 f0		ldx #$f0		ldx #Line7 & $FF
.1046	a0 14		ldy #$14		ldy #Line7 >> 8
.1048	20 1a 31	jsr $311a		jsr TOKOneLine
.104b	a2 15		ldx #$15		ldx #Line8 & $FF
.104d	a0 15		ldy #$15		ldy #Line8 >> 8
.104f	20 1a 31	jsr $311a		jsr TOKOneLine
.1052	a2 23		ldx #$23		ldx #Line9 & $FF
.1054	a0 15		ldy #$15		ldy #Line9 >> 8
.1056	20 1a 31	jsr $311a		jsr TOKOneLine
.1059	a2 95		ldx #$95		ldx #Line10 & $FF
.105b	a0 15		ldy #$15		ldy #Line10 >> 8
.105d	20 1a 31	jsr $311a		jsr TOKOneLine
.1060	a2 99		ldx #$99		ldx #Line11 & $FF
.1062	a0 15		ldy #$15		ldy #Line11 >> 8
.1064	20 1a 31	jsr $311a		jsr TOKOneLine
.1067	a2 d0		ldx #$d0		ldx #Line12 & $FF
.1069	a0 15		ldy #$15		ldy #Line12 >> 8
.106b	20 1a 31	jsr $311a		jsr TOKOneLine
.106e	a2 45		ldx #$45		ldx #Line13 & $FF
.1070	a0 16		ldy #$16		ldy #Line13 >> 8
.1072	20 1a 31	jsr $311a		jsr TOKOneLine
.1075	a2 66		ldx #$66		ldx #Line14 & $FF
.1077	a0 16		ldy #$16		ldy #Line14 >> 8
.1079	20 1a 31	jsr $311a		jsr TOKOneLine
.107c	a2 ec		ldx #$ec		ldx #Line15 & $FF
.107e	a0 16		ldy #$16		ldy #Line15 >> 8
.1080	20 1a 31	jsr $311a		jsr TOKOneLine
.1083	a2 f0		ldx #$f0		ldx #Line16 & $FF
.1085	a0 16		ldy #$16		ldy #Line16 >> 8
.1087	20 1a 31	jsr $311a		jsr TOKOneLine
.108a	a2 45		ldx #$45		ldx #Line17 & $FF
.108c	a0 17		ldy #$17		ldy #Line17 >> 8
.108e	20 1a 31	jsr $311a		jsr TOKOneLine
.1091	a2 5c		ldx #$5c		ldx #Line18 & $FF
.1093	a0 17		ldy #$17		ldy #Line18 >> 8
.1095	20 1a 31	jsr $311a		jsr TOKOneLine
.1098	a2 6d		ldx #$6d		ldx #Line19 & $FF
.109a	a0 17		ldy #$17		ldy #Line19 >> 8
.109c	20 1a 31	jsr $311a		jsr TOKOneLine
.109f	a2 ac		ldx #$ac		ldx #Line20 & $FF
.10a1	a0 17		ldy #$17		ldy #Line20 >> 8
.10a3	20 1a 31	jsr $311a		jsr TOKOneLine
.10a6	a2 d4		ldx #$d4		ldx #Line21 & $FF
.10a8	a0 17		ldy #$17		ldy #Line21 >> 8
.10aa	20 1a 31	jsr $311a		jsr TOKOneLine
.10ad	a2 d9		ldx #$d9		ldx #Line22 & $FF
.10af	a0 17		ldy #$17		ldy #Line22 >> 8
.10b1	20 1a 31	jsr $311a		jsr TOKOneLine
.10b4	a2 50		ldx #$50		ldx #Line23 & $FF
.10b6	a0 18		ldy #$18		ldy #Line23 >> 8
.10b8	20 1a 31	jsr $311a		jsr TOKOneLine
.10bb	a2 64		ldx #$64		ldx #Line24 & $FF
.10bd	a0 18		ldy #$18		ldy #Line24 >> 8
.10bf	20 1a 31	jsr $311a		jsr TOKOneLine
.10c2	a2 6b		ldx #$6b		ldx #Line25 & $FF
.10c4	a0 18		ldy #$18		ldy #Line25 >> 8
.10c6	20 1a 31	jsr $311a		jsr TOKOneLine
.10c9	a2 85		ldx #$85		ldx #Line26 & $FF
.10cb	a0 18		ldy #$18		ldy #Line26 >> 8
.10cd	20 1a 31	jsr $311a		jsr TOKOneLine
.10d0	a2 0c		ldx #$0c		ldx #Line27 & $FF
.10d2	a0 19		ldy #$19		ldy #Line27 >> 8
.10d4	20 1a 31	jsr $311a		jsr TOKOneLine
.10d7	a2 69		ldx #$69		ldx #Line28 & $FF
.10d9	a0 19		ldy #$19		ldy #Line28 >> 8
.10db	20 1a 31	jsr $311a		jsr TOKOneLine
.10de	a2 85		ldx #$85		ldx #Line29 & $FF
.10e0	a0 19		ldy #$19		ldy #Line29 >> 8
.10e2	20 1a 31	jsr $311a		jsr TOKOneLine
.10e5	a2 8c		ldx #$8c		ldx #Line30 & $FF
.10e7	a0 19		ldy #$19		ldy #Line30 >> 8
.10e9	20 1a 31	jsr $311a		jsr TOKOneLine
.10ec	a2 91		ldx #$91		ldx #Line31 & $FF
.10ee	a0 19		ldy #$19		ldy #Line31 >> 8
.10f0	20 1a 31	jsr $311a		jsr TOKOneLine
.10f3	a2 bf		ldx #$bf		ldx #Line32 & $FF
.10f5	a0 19		ldy #$19		ldy #Line32 >> 8
.10f7	20 1a 31	jsr $311a		jsr TOKOneLine
.10fa	a2 48		ldx #$48		ldx #Line33 & $FF
.10fc	a0 1a		ldy #$1a		ldy #Line33 >> 8
.10fe	20 1a 31	jsr $311a		jsr TOKOneLine
.1101	a2 b0		ldx #$b0		ldx #Line34 & $FF
.1103	a0 1a		ldy #$1a		ldy #Line34 >> 8
.1105	20 1a 31	jsr $311a		jsr TOKOneLine
.1108	a2 eb		ldx #$eb		ldx #Line35 & $FF
.110a	a0 1a		ldy #$1a		ldy #Line35 >> 8
.110c	20 1a 31	jsr $311a		jsr TOKOneLine
.110f	a2 3f		ldx #$3f		ldx #Line36 & $FF
.1111	a0 1b		ldy #$1b		ldy #Line36 >> 8
.1113	20 1a 31	jsr $311a		jsr TOKOneLine
.1116	a2 73		ldx #$73		ldx #Line37 & $FF
.1118	a0 1b		ldy #$1b		ldy #Line37 >> 8
.111a	20 1a 31	jsr $311a		jsr TOKOneLine
.111d	a2 c1		ldx #$c1		ldx #Line38 & $FF
.111f	a0 1b		ldy #$1b		ldy #Line38 >> 8
.1121	20 1a 31	jsr $311a		jsr TOKOneLine
.1124	a2 13		ldx #$13		ldx #Line39 & $FF
.1126	a0 1c		ldy #$1c		ldy #Line39 >> 8
.1128	20 1a 31	jsr $311a		jsr TOKOneLine
.112b	a2 93		ldx #$93		ldx #Line40 & $FF
.112d	a0 1c		ldy #$1c		ldy #Line40 >> 8
.112f	20 1a 31	jsr $311a		jsr TOKOneLine
.1132	a2 10		ldx #$10		ldx #Line41 & $FF
.1134	a0 1d		ldy #$1d		ldy #Line41 >> 8
.1136	20 1a 31	jsr $311a		jsr TOKOneLine
.1139	a2 22		ldx #$22		ldx #Line42 & $FF
.113b	a0 1d		ldy #$1d		ldy #Line42 >> 8
.113d	20 1a 31	jsr $311a		jsr TOKOneLine
.1140	a2 5a		ldx #$5a		ldx #Line43 & $FF
.1142	a0 1d		ldy #$1d		ldy #Line43 >> 8
.1144	20 1a 31	jsr $311a		jsr TOKOneLine
.1147	a2 5e		ldx #$5e		ldx #Line44 & $FF
.1149	a0 1d		ldy #$1d		ldy #Line44 >> 8
.114b	20 1a 31	jsr $311a		jsr TOKOneLine
.114e	a2 c6		ldx #$c6		ldx #Line45 & $FF
.1150	a0 1d		ldy #$1d		ldy #Line45 >> 8
.1152	20 1a 31	jsr $311a		jsr TOKOneLine
.1155	a2 ca		ldx #$ca		ldx #Line46 & $FF
.1157	a0 1d		ldy #$1d		ldy #Line46 >> 8
.1159	20 1a 31	jsr $311a		jsr TOKOneLine
.115c	a2 2a		ldx #$2a		ldx #Line47 & $FF
.115e	a0 1e		ldy #$1e		ldy #Line47 >> 8
.1160	20 1a 31	jsr $311a		jsr TOKOneLine
.1163	a2 3d		ldx #$3d		ldx #Line48 & $FF
.1165	a0 1e		ldy #$1e		ldy #Line48 >> 8
.1167	20 1a 31	jsr $311a		jsr TOKOneLine
.116a	a2 b5		ldx #$b5		ldx #Line49 & $FF
.116c	a0 1e		ldy #$1e		ldy #Line49 >> 8
.116e	20 1a 31	jsr $311a		jsr TOKOneLine
.1171	a2 0a		ldx #$0a		ldx #Line50 & $FF
.1173	a0 1f		ldy #$1f		ldy #Line50 >> 8
.1175	20 1a 31	jsr $311a		jsr TOKOneLine
.1178	a2 55		ldx #$55		ldx #Line51 & $FF
.117a	a0 1f		ldy #$1f		ldy #Line51 >> 8
.117c	20 1a 31	jsr $311a		jsr TOKOneLine
.117f	a2 ae		ldx #$ae		ldx #Line52 & $FF
.1181	a0 1f		ldy #$1f		ldy #Line52 >> 8
.1183	20 1a 31	jsr $311a		jsr TOKOneLine
.1186	a2 35		ldx #$35		ldx #Line53 & $FF
.1188	a0 20		ldy #$20		ldy #Line53 >> 8
.118a	20 1a 31	jsr $311a		jsr TOKOneLine
.118d	a2 94		ldx #$94		ldx #Line54 & $FF
.118f	a0 20		ldy #$20		ldy #Line54 >> 8
.1191	20 1a 31	jsr $311a		jsr TOKOneLine
.1194	a2 11		ldx #$11		ldx #Line55 & $FF
.1196	a0 21		ldy #$21		ldy #Line55 >> 8
.1198	20 1a 31	jsr $311a		jsr TOKOneLine
.119b	a2 52		ldx #$52		ldx #Line56 & $FF
.119d	a0 21		ldy #$21		ldy #Line56 >> 8
.119f	20 1a 31	jsr $311a		jsr TOKOneLine
.11a2	a2 56		ldx #$56		ldx #Line57 & $FF
.11a4	a0 21		ldy #$21		ldy #Line57 >> 8
.11a6	20 1a 31	jsr $311a		jsr TOKOneLine
.11a9	a2 8d		ldx #$8d		ldx #Line58 & $FF
.11ab	a0 21		ldy #$21		ldy #Line58 >> 8
.11ad	20 1a 31	jsr $311a		jsr TOKOneLine
.11b0	a2 e0		ldx #$e0		ldx #Line59 & $FF
.11b2	a0 21		ldy #$21		ldy #Line59 >> 8
.11b4	20 1a 31	jsr $311a		jsr TOKOneLine
.11b7	a2 5e		ldx #$5e		ldx #Line60 & $FF
.11b9	a0 22		ldy #$22		ldy #Line60 >> 8
.11bb	20 1a 31	jsr $311a		jsr TOKOneLine
.11be	a2 89		ldx #$89		ldx #Line61 & $FF
.11c0	a0 22		ldy #$22		ldy #Line61 >> 8
.11c2	20 1a 31	jsr $311a		jsr TOKOneLine
.11c5	a2 d9		ldx #$d9		ldx #Line62 & $FF
.11c7	a0 22		ldy #$22		ldy #Line62 >> 8
.11c9	20 1a 31	jsr $311a		jsr TOKOneLine
.11cc	a2 15		ldx #$15		ldx #Line63 & $FF
.11ce	a0 23		ldy #$23		ldy #Line63 >> 8
.11d0	20 1a 31	jsr $311a		jsr TOKOneLine
.11d3	a2 99		ldx #$99		ldx #Line64 & $FF
.11d5	a0 23		ldy #$23		ldy #Line64 >> 8
.11d7	20 1a 31	jsr $311a		jsr TOKOneLine
.11da	a2 06		ldx #$06		ldx #Line65 & $FF
.11dc	a0 24		ldy #$24		ldy #Line65 >> 8
.11de	20 1a 31	jsr $311a		jsr TOKOneLine
.11e1	a2 2d		ldx #$2d		ldx #Line66 & $FF
.11e3	a0 24		ldy #$24		ldy #Line66 >> 8
.11e5	20 1a 31	jsr $311a		jsr TOKOneLine
.11e8	a2 32		ldx #$32		ldx #Line67 & $FF
.11ea	a0 24		ldy #$24		ldy #Line67 >> 8
.11ec	20 1a 31	jsr $311a		jsr TOKOneLine
.11ef	a2 36		ldx #$36		ldx #Line68 & $FF
.11f1	a0 24		ldy #$24		ldy #Line68 >> 8
.11f3	20 1a 31	jsr $311a		jsr TOKOneLine
.11f6	a2 3a		ldx #$3a		ldx #Line69 & $FF
.11f8	a0 24		ldy #$24		ldy #Line69 >> 8
.11fa	20 1a 31	jsr $311a		jsr TOKOneLine
.11fd	a2 3f		ldx #$3f		ldx #Line70 & $FF
.11ff	a0 24		ldy #$24		ldy #Line70 >> 8
.1201	20 1a 31	jsr $311a		jsr TOKOneLine
.1204	a2 ad		ldx #$ad		ldx #Line71 & $FF
.1206	a0 24		ldy #$24		ldy #Line71 >> 8
.1208	20 1a 31	jsr $311a		jsr TOKOneLine
.120b	a2 2a		ldx #$2a		ldx #Line72 & $FF
.120d	a0 25		ldy #$25		ldy #Line72 >> 8
.120f	20 1a 31	jsr $311a		jsr TOKOneLine
.1212	a2 59		ldx #$59		ldx #Line73 & $FF
.1214	a0 25		ldy #$25		ldy #Line73 >> 8
.1216	20 1a 31	jsr $311a		jsr TOKOneLine
.1219	a2 61		ldx #$61		ldx #Line74 & $FF
.121b	a0 25		ldy #$25		ldy #Line74 >> 8
.121d	20 1a 31	jsr $311a		jsr TOKOneLine
.1220	a2 93		ldx #$93		ldx #Line75 & $FF
.1222	a0 25		ldy #$25		ldy #Line75 >> 8
.1224	20 1a 31	jsr $311a		jsr TOKOneLine
.1227	a2 d6		ldx #$d6		ldx #Line76 & $FF
.1229	a0 25		ldy #$25		ldy #Line76 >> 8
.122b	20 1a 31	jsr $311a		jsr TOKOneLine
.122e	a2 df		ldx #$df		ldx #Line77 & $FF
.1230	a0 25		ldy #$25		ldy #Line77 >> 8
.1232	20 1a 31	jsr $311a		jsr TOKOneLine
.1235	a2 06		ldx #$06		ldx #Line78 & $FF
.1237	a0 26		ldy #$26		ldy #Line78 >> 8
.1239	20 1a 31	jsr $311a		jsr TOKOneLine
.123c	a2 49		ldx #$49		ldx #Line79 & $FF
.123e	a0 26		ldy #$26		ldy #Line79 >> 8
.1240	20 1a 31	jsr $311a		jsr TOKOneLine
.1243	a2 78		ldx #$78		ldx #Line80 & $FF
.1245	a0 26		ldy #$26		ldy #Line80 >> 8
.1247	20 1a 31	jsr $311a		jsr TOKOneLine
.124a	a2 7d		ldx #$7d		ldx #Line81 & $FF
.124c	a0 26		ldy #$26		ldy #Line81 >> 8
.124e	20 1a 31	jsr $311a		jsr TOKOneLine
.1251	a2 c3		ldx #$c3		ldx #Line82 & $FF
.1253	a0 26		ldy #$26		ldy #Line82 >> 8
.1255	20 1a 31	jsr $311a		jsr TOKOneLine
.1258	a2 cb		ldx #$cb		ldx #Line83 & $FF
.125a	a0 26		ldy #$26		ldy #Line83 >> 8
.125c	20 1a 31	jsr $311a		jsr TOKOneLine
.125f	a2 dc		ldx #$dc		ldx #Line84 & $FF
.1261	a0 26		ldy #$26		ldy #Line84 >> 8
.1263	20 1a 31	jsr $311a		jsr TOKOneLine
.1266	a2 19		ldx #$19		ldx #Line85 & $FF
.1268	a0 27		ldy #$27		ldy #Line85 >> 8
.126a	20 1a 31	jsr $311a		jsr TOKOneLine
.126d	a2 84		ldx #$84		ldx #Line86 & $FF
.126f	a0 27		ldy #$27		ldy #Line86 >> 8
.1271	20 1a 31	jsr $311a		jsr TOKOneLine
.1274	a2 fc		ldx #$fc		ldx #Line87 & $FF
.1276	a0 27		ldy #$27		ldy #Line87 >> 8
.1278	20 1a 31	jsr $311a		jsr TOKOneLine
.127b	a2 7a		ldx #$7a		ldx #Line88 & $FF
.127d	a0 28		ldy #$28		ldy #Line88 >> 8
.127f	20 1a 31	jsr $311a		jsr TOKOneLine
.1282	a2 fd		ldx #$fd		ldx #Line89 & $FF
.1284	a0 28		ldy #$28		ldy #Line89 >> 8
.1286	20 1a 31	jsr $311a		jsr TOKOneLine
.1289	a2 3d		ldx #$3d		ldx #Line90 & $FF
.128b	a0 29		ldy #$29		ldy #Line90 >> 8
.128d	20 1a 31	jsr $311a		jsr TOKOneLine
.1290	a2 8b		ldx #$8b		ldx #Line91 & $FF
.1292	a0 29		ldy #$29		ldy #Line91 >> 8
.1294	20 1a 31	jsr $311a		jsr TOKOneLine
.1297	a2 d1		ldx #$d1		ldx #Line92 & $FF
.1299	a0 29		ldy #$29		ldy #Line92 >> 8
.129b	20 1a 31	jsr $311a		jsr TOKOneLine
.129e	a2 16		ldx #$16		ldx #Line93 & $FF
.12a0	a0 2a		ldy #$2a		ldy #Line93 >> 8
.12a2	20 1a 31	jsr $311a		jsr TOKOneLine
.12a5	a2 86		ldx #$86		ldx #Line94 & $FF
.12a7	a0 2a		ldy #$2a		ldy #Line94 >> 8
.12a9	20 1a 31	jsr $311a		jsr TOKOneLine
.12ac	a2 94		ldx #$94		ldx #Line95 & $FF
.12ae	a0 2a		ldy #$2a		ldy #Line95 >> 8
.12b0	20 1a 31	jsr $311a		jsr TOKOneLine
.12b3	a2 e7		ldx #$e7		ldx #Line96 & $FF
.12b5	a0 2a		ldy #$2a		ldy #Line96 >> 8
.12b7	20 1a 31	jsr $311a		jsr TOKOneLine
.12ba	a2 26		ldx #$26		ldx #Line97 & $FF
.12bc	a0 2b		ldy #$2b		ldy #Line97 >> 8
.12be	20 1a 31	jsr $311a		jsr TOKOneLine
.12c1	a2 88		ldx #$88		ldx #Line98 & $FF
.12c3	a0 2b		ldy #$2b		ldy #Line98 >> 8
.12c5	20 1a 31	jsr $311a		jsr TOKOneLine
.12c8	a2 f2		ldx #$f2		ldx #Line99 & $FF
.12ca	a0 2b		ldy #$2b		ldy #Line99 >> 8
.12cc	20 1a 31	jsr $311a		jsr TOKOneLine
.12cf	a2 f6		ldx #$f6		ldx #Line100 & $FF
.12d1	a0 2b		ldy #$2b		ldy #Line100 >> 8
.12d3	20 1a 31	jsr $311a		jsr TOKOneLine
.12d6	a2 fa		ldx #$fa		ldx #Line101 & $FF
.12d8	a0 2b		ldy #$2b		ldy #Line101 >> 8
.12da	20 1a 31	jsr $311a		jsr TOKOneLine
.12dd	a2 39		ldx #$39		ldx #Line102 & $FF
.12df	a0 2c		ldy #$2c		ldy #Line102 >> 8
.12e1	20 1a 31	jsr $311a		jsr TOKOneLine
.12e4	a2 9d		ldx #$9d		ldx #Line103 & $FF
.12e6	a0 2c		ldy #$2c		ldy #Line103 >> 8
.12e8	20 1a 31	jsr $311a		jsr TOKOneLine
.12eb	a2 fd		ldx #$fd		ldx #Line104 & $FF
.12ed	a0 2c		ldy #$2c		ldy #Line104 >> 8
.12ef	20 1a 31	jsr $311a		jsr TOKOneLine
.12f2	a2 20		ldx #$20		ldx #Line105 & $FF
.12f4	a0 2d		ldy #$2d		ldy #Line105 >> 8
.12f6	20 1a 31	jsr $311a		jsr TOKOneLine
.12f9	a2 84		ldx #$84		ldx #Line106 & $FF
.12fb	a0 2d		ldy #$2d		ldy #Line106 >> 8
.12fd	20 1a 31	jsr $311a		jsr TOKOneLine
.1300	a2 04		ldx #$04		ldx #Line107 & $FF
.1302	a0 2e		ldy #$2e		ldy #Line107 >> 8
.1304	20 1a 31	jsr $311a		jsr TOKOneLine
.1307	a2 17		ldx #$17		ldx #Line108 & $FF
.1309	a0 2e		ldy #$2e		ldy #Line108 >> 8
.130b	20 1a 31	jsr $311a		jsr TOKOneLine
.130e	a2 83		ldx #$83		ldx #Line109 & $FF
.1310	a0 2e		ldy #$2e		ldy #Line109 >> 8
.1312	20 1a 31	jsr $311a		jsr TOKOneLine
.1315	a2 89		ldx #$89		ldx #Line110 & $FF
.1317	a0 2e		ldy #$2e		ldy #Line110 >> 8
.1319	20 1a 31	jsr $311a		jsr TOKOneLine
.131c	a2 e4		ldx #$e4		ldx #Line111 & $FF
.131e	a0 2e		ldy #$2e		ldy #Line111 >> 8
.1320	20 1a 31	jsr $311a		jsr TOKOneLine
.1323	a2 e9		ldx #$e9		ldx #Line112 & $FF
.1325	a0 2e		ldy #$2e		ldy #Line112 >> 8
.1327	20 1a 31	jsr $311a		jsr TOKOneLine
.132a	a2 67		ldx #$67		ldx #Line113 & $FF
.132c	a0 2f		ldy #$2f		ldy #Line113 >> 8
.132e	20 1a 31	jsr $311a		jsr TOKOneLine
.1331	a2 8b		ldx #$8b		ldx #Line114 & $FF
.1333	a0 2f		ldy #$2f		ldy #Line114 >> 8
.1335	20 1a 31	jsr $311a		jsr TOKOneLine
.1338	a2 f4		ldx #$f4		ldx #Line115 & $FF
.133a	a0 2f		ldy #$2f		ldy #Line115 >> 8
.133c	20 1a 31	jsr $311a		jsr TOKOneLine
.133f	a2 f8		ldx #$f8		ldx #Line116 & $FF
.1341	a0 2f		ldy #$2f		ldy #Line116 >> 8
.1343	20 1a 31	jsr $311a		jsr TOKOneLine
.1346	a2 2f		ldx #$2f		ldx #Line117 & $FF
.1348	a0 30		ldy #$30		ldy #Line117 >> 8
.134a	20 1a 31	jsr $311a		jsr TOKOneLine
.134d	a2 6f		ldx #$6f		ldx #Line118 & $FF
.134f	a0 30		ldy #$30		ldy #Line118 >> 8
.1351	20 1a 31	jsr $311a		jsr TOKOneLine
.1354	a2 ed		ldx #$ed		ldx #Line119 & $FF
.1356	a0 30		ldy #$30		ldy #Line119 >> 8
.1358	20 1a 31	jsr $311a		jsr TOKOneLine

;******  Return to file: src/program/testing/testing.asmx

.135b	4c ff ff	jmp $ffff			jmp 	$FFFF

;******  Processing file: src/program/testing/testdat.incx

.135e					Line0:
>135e	31 30 35 35 20 34 31 35			.text '1055 415 UNTIL 475""/STEP "EAR" - (K9 335 RND( 1255+ 745> "TTTWDAS" *X',0
>1366	20 55 4e 54 49 4c 20 34 37 35 22 22 2f 53 54 45
>1376	50 20 22 45 41 52 22 20 2d 20 28 4b 39 20 33 33
>1386	35 20 52 4e 44 28 20 31 32 35 35 2b 20 37 34 35
>1396	3e 20 22 54 54 54 57 44 41 53 22 20 2a 58 00
.13a5					Line1:
>13a5	39 38 35 00				.text '985',0
.13a9					Line2:
>13a9	31 33 33 35 20 39 2e 30			.text '1335 9.05 RND(Y3A -9.68 +LIST 1225"AZ"/ N8J1O M3 945 335"AHIVFRQ"/Q"GPITM@L@" 1255 P1 PRINT"" C 505',0
>13b1	35 20 52 4e 44 28 59 33 41 20 2d 39 2e 36 38 20
>13c1	2b 4c 49 53 54 20 31 32 32 35 22 41 5a 22 2f 20
>13d1	4e 38 4a 31 4f 20 4d 33 20 39 34 35 20 33 33 35
>13e1	22 41 48 49 56 46 52 51 22 2f 51 22 47 50 49 54
>13f1	4d 40 4c 40 22 20 31 32 35 35 20 50 31 20 50 52
>1401	49 4e 54 22 22 20 43 20 35 30 35 00
.140d					Line3:
>140d	37 32 35 20 20 32 2e 38			.text '725  2.81 TIME',0
>1415	31 20 54 49 4d 45 00
.141c					Line4:
>141c	31 32 38 35 20 20 3d 37			.text '1285  =745- POKE "YNM@COTG"',0
>1424	34 35 2d 20 50 4f 4b 45 20 22 59 4e 4d 40 43 4f
>1434	54 47 22 00
.1438					Line5:
>1438	35 37 35 20 2d 39 2e 39			.text '575 -9.92 ABS(ENDPROC ( LET STEP"FJSRQX"-)P0K E2X7B K9< EVENT(1105 7.41 895"BLSFN" END 825-9.11 STR$( FOR)"UHCTTOFB"STR$(3.68 795 C',0
>1440	32 20 41 42 53 28 45 4e 44 50 52 4f 43 20 28 20
>1450	4c 45 54 20 53 54 45 50 22 46 4a 53 52 51 58 22
>1460	2d 29 50 30 4b 20 45 32 58 37 42 20 4b 39 3c 20
>1470	45 56 45 4e 54 28 31 31 30 35 20 37 2e 34 31 20
>1480	38 39 35 22 42 4c 53 46 4e 22 20 45 4e 44 20 38
>1490	32 35 2d 39 2e 31 31 20 53 54 52 24 28 20 46 4f
>14a0	52 29 22 55 48 43 54 54 4f 46 42 22 53 54 52 24
>14b0	28 33 2e 36 38 20 37 39 35 20 43 00
.14bc					Line6:
>14bc	31 30 31 35 20 20 37 2e			.text '1015  7.69=-5.88"PGUBXG">ASC(("TSGHMKV">H 515 = 675',0
>14c4	36 39 3d 2d 35 2e 38 38 22 50 47 55 42 58 47 22
>14d4	3e 41 53 43 28 28 22 54 53 47 48 4d 4b 56 22 3e
>14e4	48 20 35 31 35 20 3d 20 36 37 35 00
.14f0					Line7:
>14f0	37 33 35 20 33 34 35 20			.text '735 345 5.52"ZY"*Y3A 1345 M3- *NEXT/',0
>14f8	35 2e 35 32 22 5a 59 22 2a 59 33 41 20 31 33 34
>1508	35 20 4d 33 2d 20 2a 4e 45 58 54 2f 00
.1515					Line8:
>1515	31 32 31 35 20 20 52 49			.text '1215  RIGHT$(',0
>151d	47 48 54 24 28 00
.1523					Line9:
>1523	31 33 37 35 20 20 22 4d			.text '1375  "MYX") 895-8.18 955"@"1.31 1385 1.41 7.71 ENDIF"VBBZA"<G5Q F -6.54-3.73 CLEAR 8.16 E3C2B2 8.0 1015) + "UA"*',0
>152b	59 58 22 29 20 38 39 35 2d 38 2e 31 38 20 39 35
>153b	35 22 40 22 31 2e 33 31 20 31 33 38 35 20 31 2e
>154b	34 31 20 37 2e 37 31 20 45 4e 44 49 46 22 56 42
>155b	42 5a 41 22 3c 47 35 51 20 46 20 2d 36 2e 35 34
>156b	2d 33 2e 37 33 20 43 4c 45 41 52 20 38 2e 31 36
>157b	20 45 33 43 32 42 32 20 38 2e 30 20 31 30 31 35
>158b	29 20 2b 20 22 55 41 22 2a 00
.1595					Line10:
>1595	35 39 35 00				.text '595',0
.1599					Line11:
>1599	36 36 35 20 20 2a 37 2e			.text '665  *7.89 4.68"BX"<>-6.06"KF"B( LEN(F INPUT END"KFTR"',0
>15a1	38 39 20 34 2e 36 38 22 42 58 22 3c 3e 2d 36 2e
>15b1	30 36 22 4b 46 22 42 28 20 4c 45 4e 28 46 20 49
>15c1	4e 50 55 54 20 45 4e 44 22 4b 46 54 52 22 00
.15d0					Line12:
>15d0	37 38 35 20 22 48 4d 45			.text '785 "HMEGI"795 1145"PSFX"-4.97 -4.95 1.38-6.98 A0F4U0 525>"R"+895-0.45 "CEENSZ" 1135 / "DLXDNP@"= 375"MGCYOZ" W STEP',0
>15d8	47 49 22 37 39 35 20 31 31 34 35 22 50 53 46 58
>15e8	22 2d 34 2e 39 37 20 2d 34 2e 39 35 20 31 2e 33
>15f8	38 2d 36 2e 39 38 20 41 30 46 34 55 30 20 35 32
>1608	35 3e 22 52 22 2b 38 39 35 2d 30 2e 34 35 20 22
>1618	43 45 45 4e 53 5a 22 20 31 31 33 35 20 2f 20 22
>1628	44 4c 58 44 4e 50 40 22 3d 20 33 37 35 22 4d 47
>1638	43 59 4f 5a 22 20 57 20 53 54 45 50 00
.1645					Line13:
>1645	31 34 32 35 20 34 36 35			.text '1425 465 635""*405 7.1 ASC( I2M1',0
>164d	20 36 33 35 22 22 2a 34 30 35 20 37 2e 31 20 41
>165d	53 43 28 20 49 32 4d 31 00
.1666					Line14:
>1666	31 32 30 35 20 20 29 20			.text '1205  ) RIGHT$(2.16-2.85 SAVE 1425 1265 L9Z2J F9R8H G "OSAWNWK"4.73 <"GXC"VAL(= "NDCWB" T1K("JTETHLIW"635 /D9Z X5"PD"7.74"@QIRF"B4B3<',0
>166e	52 49 47 48 54 24 28 32 2e 31 36 2d 32 2e 38 35
>167e	20 53 41 56 45 20 31 34 32 35 20 31 32 36 35 20
>168e	4c 39 5a 32 4a 20 46 39 52 38 48 20 47 20 22 4f
>169e	53 41 57 4e 57 4b 22 34 2e 37 33 20 3c 22 47 58
>16ae	43 22 56 41 4c 28 3d 20 22 4e 44 43 57 42 22 20
>16be	54 31 4b 28 22 4a 54 45 54 48 4c 49 57 22 36 33
>16ce	35 20 2f 44 39 5a 20 58 35 22 50 44 22 37 2e 37
>16de	34 22 40 51 49 52 46 22 42 34 42 33 3c 00
.16ec					Line15:
>16ec	33 33 35 00				.text '335',0
.16f0					Line16:
>16f0	31 31 33 35 20 3c 3e 43			.text '1135 <>C8F0 705="APRFA@FD" +X2I2H-"EUFX" )1135 1035-/ "PUYNKUX" J3S1U( INT( X5<<T1K(',0
>16f8	38 46 30 20 37 30 35 3d 22 41 50 52 46 41 40 46
>1708	44 22 20 2b 58 32 49 32 48 2d 22 45 55 46 58 22
>1718	20 29 31 31 33 35 20 31 30 33 35 2d 2f 20 22 50
>1728	55 59 4e 4b 55 58 22 20 4a 33 53 31 55 28 20 49
>1738	4e 54 28 20 58 35 3c 3c 54 31 4b 28 00
.1745					Line17:
>1745	34 38 35 20 50 30 41 38			.text '485 P0A8$ REPEAT B5H3A',0
>174d	24 20 52 45 50 45 41 54 20 42 35 48 33 41 00
.175c					Line18:
>175c	37 37 35 20 31 32 35 35			.text '775 1255 U9N2L7$',0
>1764	20 55 39 4e 32 4c 37 24 00
.176d					Line19:
>176d	31 34 38 35 20 33 33 35			.text '1485 335-3.3 565 UNTIL-7.7 DEEK(845 />1195"R" /4.94 STR$(-9.46',0
>1775	2d 33 2e 33 20 35 36 35 20 55 4e 54 49 4c 2d 37
>1785	2e 37 20 44 45 45 4b 28 38 34 35 20 2f 3e 31 31
>1795	39 35 22 52 22 20 2f 34 2e 39 34 20 53 54 52 24
>17a5	28 2d 39 2e 34 36 00
.17ac					Line20:
>17ac	38 33 35 20 20 2d 39 2e			.text '835  -9.44 "ELMMYVU";305 M2$325"@DSVI"/',0
>17b4	34 34 20 22 45 4c 4d 4d 59 56 55 22 3b 33 30 35
>17c4	20 4d 32 24 33 32 35 22 40 44 53 56 49 22 2f 00
.17d4					Line21:
>17d4	31 32 32 35 00				.text '1225',0
.17d9					Line22:
>17d9	35 33 35 20 3e 44 4f 20			.text '535 >DO FRAC(RUN I9X "SWJQXB"A0F4U0 X2I2H 7.53 N2"VTPTN"1225 "QE"VAL(END: 1105 1295"HGIQXE" 6.28 A0F4U0 Z8F6G7"NENOCV"',0
>17e1	46 52 41 43 28 52 55 4e 20 49 39 58 20 22 53 57
>17f1	4a 51 58 42 22 41 30 46 34 55 30 20 58 32 49 32
>1801	48 20 37 2e 35 33 20 4e 32 22 56 54 50 54 4e 22
>1811	31 32 32 35 20 22 51 45 22 56 41 4c 28 45 4e 44
>1821	3a 20 31 31 30 35 20 31 32 39 35 22 48 47 49 51
>1831	58 45 22 20 36 2e 32 38 20 41 30 46 34 55 30 20
>1841	5a 38 46 36 47 37 22 4e 45 4e 4f 43 56 22 00
.1850					Line23:
>1850	33 37 35 20 3a 22 49 55			.text '375 :"IUDSLFA"-5.68',0
>1858	44 53 4c 46 41 22 2d 35 2e 36 38 00
.1864					Line24:
>1864	36 35 35 20 20 28 00			.text '655  (',0
.186b					Line25:
>186b	31 32 37 35 20 59 38 44			.text '1275 Y8D -1.64 H- "URNHW"',0
>1873	20 2d 31 2e 36 34 20 48 2d 20 22 55 52 4e 48 57
>1883	22 00
.1885					Line26:
>1885	39 38 35 20 50 33 54 33			.text '985 P3T3V"ICLFPB" 9.66 ""VAL(I7D6 STEP"QZQLZEFR"665 FRAC(PEEK(>/S N X2I2H-9.11==-1.93*-3.21 P5 WHILE 0.27 "OCA""DAXPLWYM" 815-1.18 RUN',0
>188d	56 22 49 43 4c 46 50 42 22 20 39 2e 36 36 20 22
>189d	22 56 41 4c 28 49 37 44 36 20 53 54 45 50 22 51
>18ad	5a 51 4c 5a 45 46 52 22 36 36 35 20 46 52 41 43
>18bd	28 50 45 45 4b 28 3e 2f 53 20 4e 20 58 32 49 32
>18cd	48 2d 39 2e 31 31 3d 3d 2d 31 2e 39 33 2a 2d 33
>18dd	2e 32 31 20 50 35 20 57 48 49 4c 45 20 30 2e 32
>18ed	37 20 22 4f 43 41 22 22 44 41 58 50 4c 57 59 4d
>18fd	22 20 38 31 35 2d 31 2e 31 38 20 52 55 4e 00
.190c					Line27:
>190c	38 35 35 20 20 2d 38 2e			.text '855  -8.8 "ZOBI"DIM>Y3A-0.22 415"H@MLT"555 1275 LEFT$(D9D6Q 1215+ "N""SGBQCT" +"QMXGZU">755>',0
>1914	38 20 22 5a 4f 42 49 22 44 49 4d 3e 59 33 41 2d
>1924	30 2e 32 32 20 34 31 35 22 48 40 4d 4c 54 22 35
>1934	35 35 20 31 32 37 35 20 4c 45 46 54 24 28 44 39
>1944	44 36 51 20 31 32 31 35 2b 20 22 4e 22 22 53 47
>1954	42 51 43 54 22 20 2b 22 51 4d 58 47 5a 55 22 3e
>1964	37 35 35 3e 00
.1969					Line28:
>1969	34 35 35 20 2d 32 2e 39			.text '455 -2.93 7.72 MOD "K"-6.95',0
>1971	33 20 37 2e 37 32 20 4d 4f 44 20 22 4b 22 2d 36
>1981	2e 39 35 00
.1985					Line29:
>1985	31 33 38 35 20 28 00			.text '1385 (',0
.198c					Line30:
>198c	31 33 35 35 00				.text '1355',0
.1991					Line31:
>1991	35 33 35 20 20 59 38 24			.text '535  Y8$(INPUT 1415 1305 1.32 :"TTYYF"M2G7R6-',0
>1999	28 49 4e 50 55 54 20 31 34 31 35 20 31 33 30 35
>19a9	20 31 2e 33 32 20 3a 22 54 54 59 59 46 22 4d 32
>19b9	47 37 52 36 2d 00
.19bf					Line32:
>19bf	35 38 35 20 20 3c 3e 49			.text '585  <>I2C6B I2M1 -7.55> U9N2L7$ -9.69-0.91"PLTZ@SL"DO Z8F6G7 1435 CLEAR<V1J2A Q3 /CLEAR T1K(-9.5 <POKE D1L2$"ZCZ">405 9.1 INPUT 735 755',0
>19c7	32 43 36 42 20 49 32 4d 31 20 2d 37 2e 35 35 3e
>19d7	20 55 39 4e 32 4c 37 24 20 2d 39 2e 36 39 2d 30
>19e7	2e 39 31 22 50 4c 54 5a 40 53 4c 22 44 4f 20 5a
>19f7	38 46 36 47 37 20 31 34 33 35 20 43 4c 45 41 52
>1a07	3c 56 31 4a 32 41 20 51 33 20 2f 43 4c 45 41 52
>1a17	20 54 31 4b 28 2d 39 2e 35 20 3c 50 4f 4b 45 20
>1a27	44 31 4c 32 24 22 5a 43 5a 22 3e 34 30 35 20 39
>1a37	2e 31 20 49 4e 50 55 54 20 37 33 35 20 37 35 35
>1a47	00
.1a48					Line33:
>1a48	36 32 35 20 29 4c 4f 4f			.text '625 )LOOP M( <>IF-7.55"JXN"6.79 2.1"I@FLPH""DKQCOA" 1395 E2X7B (RUN 505 WHILE /RUN<RUN+-4.83 E3C2B2 B1A',0
>1a50	50 20 4d 28 20 3c 3e 49 46 2d 37 2e 35 35 22 4a
>1a60	58 4e 22 36 2e 37 39 20 32 2e 31 22 49 40 46 4c
>1a70	50 48 22 22 44 4b 51 43 4f 41 22 20 31 33 39 35
>1a80	20 45 32 58 37 42 20 28 52 55 4e 20 35 30 35 20
>1a90	57 48 49 4c 45 20 2f 52 55 4e 3c 52 55 4e 2b 2d
>1aa0	34 2e 38 33 20 45 33 43 32 42 32 20 42 31 41 00
.1ab0					Line34:
>1ab0	36 36 35 20 20 2f 53 34			.text '665  /S4L0A *-9.74 605 -8.59-CHR$( "GJQ" L EVENT( -0.7 AND',0
>1ab8	4c 30 41 20 2a 2d 39 2e 37 34 20 36 30 35 20 2d
>1ac8	38 2e 35 39 2d 43 48 52 24 28 20 22 47 4a 51 22
>1ad8	20 4c 20 45 56 45 4e 54 28 20 2d 30 2e 37 20 41
>1ae8	4e 44 00
.1aeb					Line35:
>1aeb	35 31 35 20 20 22 42 22			.text '515  "B"( -9.1< ) 8.49"N"E"TFMX""PGDMB@V"-1.3 G8 935"SXNTL"N2P5W 1055 5.23 1105 305',0
>1af3	28 20 2d 39 2e 31 3c 20 29 20 38 2e 34 39 22 4e
>1b03	22 45 22 54 46 4d 58 22 22 50 47 44 4d 42 40 56
>1b13	22 2d 31 2e 33 20 47 38 20 39 33 35 22 53 58 4e
>1b23	54 4c 22 4e 32 50 35 57 20 31 30 35 35 20 35 2e
>1b33	32 33 20 31 31 30 35 20 33 30 35 00
.1b3f					Line36:
>1b3f	35 31 35 20 20 30 2e 32			.text '515  0.24"WX"455 ASC(1405- "E" > STOP = 415 K9 C8F0',0
>1b47	34 22 57 58 22 34 35 35 20 41 53 43 28 31 34 30
>1b57	35 2d 20 22 45 22 20 3e 20 53 54 4f 50 20 3d 20
>1b67	34 31 35 20 4b 39 20 43 38 46 30 00
.1b73					Line37:
>1b73	37 36 35 20 20 43 38 46			.text '765  C8F0 1065"F"1425 <P1H4S> "@VUNQNYN" DEC(==0.21"""@ZJNG" L9Z2J"IFORRIEK"W',0
>1b7b	30 20 31 30 36 35 22 46 22 31 34 32 35 20 3c 50
>1b8b	31 48 34 53 3e 20 22 40 56 55 4e 51 4e 59 4e 22
>1b9b	20 44 45 43 28 3d 3d 30 2e 32 31 22 22 22 40 5a
>1bab	4a 4e 47 22 20 4c 39 5a 32 4a 22 49 46 4f 52 52
>1bbb	49 45 4b 22 57 00
.1bc1					Line38:
>1bc1	31 30 33 35 20 42 39 49			.text '1035 B9I4U( 9.61 THEN I2M1 "JHCQFXRQ"HEX$(B(FOR <>"EZDRBMP""KHJA""MK" >/Q3Z L"JE"',0
>1bc9	34 55 28 20 39 2e 36 31 20 54 48 45 4e 20 49 32
>1bd9	4d 31 20 22 4a 48 43 51 46 58 52 51 22 48 45 58
>1be9	24 28 42 28 46 4f 52 20 3c 3e 22 45 5a 44 52 42
>1bf9	4d 50 22 22 4b 48 4a 41 22 22 4d 4b 22 20 3e 2f
>1c09	51 33 5a 20 4c 22 4a 45 22 00
.1c13					Line39:
>1c13	36 33 35 20 20 49 4e 50			.text '635  INPUT 1185 1345 -8.67= <)575 Q6P8$1475 1145 1.57 6.74"IERWU" R8F9M7 W(:>LEFT$( ,G5Q1 + 8.09 495 - (305 "ICHUTND"8.95 F2B0R',0
>1c1b	55 54 20 31 31 38 35 20 31 33 34 35 20 2d 38 2e
>1c2b	36 37 3d 20 3c 29 35 37 35 20 51 36 50 38 24 31
>1c3b	34 37 35 20 31 31 34 35 20 31 2e 35 37 20 36 2e
>1c4b	37 34 22 49 45 52 57 55 22 20 52 38 46 39 4d 37
>1c5b	20 57 28 3a 3e 4c 45 46 54 24 28 20 2c 47 35 51
>1c6b	31 20 2b 20 38 2e 30 39 20 34 39 35 20 2d 20 28
>1c7b	33 30 35 20 22 49 43 48 55 54 4e 44 22 38 2e 39
>1c8b	35 20 46 32 42 30 52 00
.1c93					Line40:
>1c93	31 30 36 35 20 20 36 2e			.text '1065  6.75 "Q"-)"OPSZYCR" 755 685"GXY"1035 "KPYVRM"INKEY$( 555 Y8D"CARA"RAND(605 1405"NBYTHL"<> R7J5 575"GT" INPUT<- "XBW" <',0
>1c9b	37 35 20 22 51 22 2d 29 22 4f 50 53 5a 59 43 52
>1cab	22 20 37 35 35 20 36 38 35 22 47 58 59 22 31 30
>1cbb	33 35 20 22 4b 50 59 56 52 4d 22 49 4e 4b 45 59
>1ccb	24 28 20 35 35 35 20 59 38 44 22 43 41 52 41 22
>1cdb	52 41 4e 44 28 36 30 35 20 31 34 30 35 22 4e 42
>1ceb	59 54 48 4c 22 3c 3e 20 52 37 4a 35 20 35 37 35
>1cfb	22 47 54 22 20 49 4e 50 55 54 3c 2d 20 22 58 42
>1d0b	57 22 20 3c 00
.1d10					Line41:
>1d10	38 30 35 20 20 4c 39 5a			.text '805  L9Z2J J3S1U(',0
>1d18	32 4a 20 4a 33 53 31 55 28 00
.1d22					Line42:
>1d22	34 33 35 20 20 2a 20 22			.text '435  * "I"M( PEEK(LEN(2.11 I2M1"D" T1K( -9.93-2.64-C8F0',0
>1d2a	49 22 4d 28 20 50 45 45 4b 28 4c 45 4e 28 32 2e
>1d3a	31 31 20 49 32 4d 31 22 44 22 20 54 31 4b 28 20
>1d4a	2d 39 2e 39 33 2d 32 2e 36 34 2d 43 38 46 30 00
.1d5a					Line43:
>1d5a	34 39 35 00				.text '495',0
.1d5e					Line44:
>1d5e	31 30 30 35 20 43 48 52			.text '1005 CHR$("BGJLVNE"-1.73 845 P4F6 1235"@IZMHB" O 1285 345 1445 575"LHZ" 465 9.03-6.27 STR$(> T9M9 435""',0
>1d66	24 28 22 42 47 4a 4c 56 4e 45 22 2d 31 2e 37 33
>1d76	20 38 34 35 20 50 34 46 36 20 31 32 33 35 22 40
>1d86	49 5a 4d 48 42 22 20 4f 20 31 32 38 35 20 33 34
>1d96	35 20 31 34 34 35 20 35 37 35 22 4c 48 5a 22 20
>1da6	34 36 35 20 39 2e 30 33 2d 36 2e 32 37 20 53 54
>1db6	52 24 28 3e 20 54 39 4d 39 20 34 33 35 22 22 00
.1dc6					Line45:
>1dc6	33 30 35 00				.text '305',0
.1dca					Line46:
>1dca	31 32 38 35 20 2f 29 20			.text '1285 /) + 8.23 9.03 2.7 PROC"@PKVGU" F9J0G9= P5 STOP Y3(9.5-9.53"VQEMQLY"=RND((-"AJQN"7.85 MOD+',0
>1dd2	2b 20 38 2e 32 33 20 39 2e 30 33 20 32 2e 37 20
>1de2	50 52 4f 43 22 40 50 4b 56 47 55 22 20 46 39 4a
>1df2	30 47 39 3d 20 50 35 20 53 54 4f 50 20 59 33 28
>1e02	39 2e 35 2d 39 2e 35 33 22 56 51 45 4d 51 4c 59
>1e12	22 3d 52 4e 44 28 28 2d 22 41 4a 51 4e 22 37 2e
>1e22	38 35 20 4d 4f 44 2b 00
.1e2a					Line47:
>1e2a	31 32 35 35 20 20 35 36			.text '1255  565 "TQJ"525',0
>1e32	35 20 22 54 51 4a 22 35 32 35 00
.1e3d					Line48:
>1e3d	31 33 31 35 20 20 22 51			.text '1315  "QZMKNTC"> /1275 M( END 1405 Q3 925 N0 1465 PEEK(;LET 6.91 975 665 1375 >P4F6 STR$(DOKE M3 C8J7 INT(E =END-7.82 U',0
>1e45	5a 4d 4b 4e 54 43 22 3e 20 2f 31 32 37 35 20 4d
>1e55	28 20 45 4e 44 20 31 34 30 35 20 51 33 20 39 32
>1e65	35 20 4e 30 20 31 34 36 35 20 50 45 45 4b 28 3b
>1e75	4c 45 54 20 36 2e 39 31 20 39 37 35 20 36 36 35
>1e85	20 31 33 37 35 20 3e 50 34 46 36 20 53 54 52 24
>1e95	28 44 4f 4b 45 20 4d 33 20 43 38 4a 37 20 49 4e
>1ea5	54 28 45 20 3d 45 4e 44 2d 37 2e 38 32 20 55 00
.1eb5					Line49:
>1eb5	39 32 35 20 20 38 38 35			.text '925  885"STNTBS" STR$(/V5K6J( 8.22 1385 M2$1115-9.29< 325=N2L6/ Q3=EXIT -0.25 E2X7B>',0
>1ebd	22 53 54 4e 54 42 53 22 20 53 54 52 24 28 2f 56
>1ecd	35 4b 36 4a 28 20 38 2e 32 32 20 31 33 38 35 20
>1edd	4d 32 24 31 31 31 35 2d 39 2e 32 39 3c 20 33 32
>1eed	35 3d 4e 32 4c 36 2f 20 51 33 3d 45 58 49 54 20
>1efd	2d 30 2e 32 35 20 45 32 58 37 42 3e 00
.1f0a					Line50:
>1f0a	34 34 35 20 20 2f 31 31			.text '445  /1195(-3.82 6.28 EVENT(875 N2P5W 4.03 "HB"LET 0.16 K9 965 6.54 J3S1U(',0
>1f12	39 35 28 2d 33 2e 38 32 20 36 2e 32 38 20 45 56
>1f22	45 4e 54 28 38 37 35 20 4e 32 50 35 57 20 34 2e
>1f32	30 33 20 22 48 42 22 4c 45 54 20 30 2e 31 36 20
>1f42	4b 39 20 39 36 35 20 36 2e 35 34 20 4a 33 53 31
>1f52	55 28 00
.1f55					Line51:
>1f55	38 38 35 20 2a 20 31 32			.text '885 * 1285 =V7= CALL U4E5F= "AGZG"865 585"MB"1255+ 335 +T1K( "YMPQABOF""V"1085 C$ASSERT/',0
>1f5d	38 35 20 3d 56 37 3d 20 43 41 4c 4c 20 55 34 45
>1f6d	35 46 3d 20 22 41 47 5a 47 22 38 36 35 20 35 38
>1f7d	35 22 4d 42 22 31 32 35 35 2b 20 33 33 35 20 2b
>1f8d	54 31 4b 28 20 22 59 4d 50 51 41 42 4f 46 22 22
>1f9d	56 22 31 30 38 35 20 43 24 41 53 53 45 52 54 2f
>1fad	00
.1fae					Line52:
>1fae	35 39 35 20 37 2e 33 31			.text '595 7.31 4.4 G8"@X""FDLDQGNT""HHCGVYXM"LOOP RUN Y8$ -1.93 5.33 FRAC(1365"BWRZVSZ" ( 635 1455< -2.62 1205 7.61 /-Y8$1305 *315 /705"EKG"',0
>1fb6	20 34 2e 34 20 47 38 22 40 58 22 22 46 44 4c 44
>1fc6	51 47 4e 54 22 22 48 48 43 47 56 59 58 4d 22 4c
>1fd6	4f 4f 50 20 52 55 4e 20 59 38 24 20 2d 31 2e 39
>1fe6	33 20 35 2e 33 33 20 46 52 41 43 28 31 33 36 35
>1ff6	22 42 57 52 5a 56 53 5a 22 20 28 20 36 33 35 20
>2006	31 34 35 35 3c 20 2d 32 2e 36 32 20 31 32 30 35
>2016	20 37 2e 36 31 20 2f 2d 59 38 24 31 33 30 35 20
>2026	2a 33 31 35 20 2f 37 30 35 22 45 4b 47 22 00
.2035					Line53:
>2035	31 33 37 35 20 4d 32 47			.text '1375 M2G7R6< + RND(1195-Q3Z/ "OOQGQDY""JSOEDN@" "UKG"ASSERT ""FRAC(445 "UPBCYXB"*8.8(8.84 4.92',0
>203d	37 52 36 3c 20 2b 20 52 4e 44 28 31 31 39 35 2d
>204d	51 33 5a 2f 20 22 4f 4f 51 47 51 44 59 22 22 4a
>205d	53 4f 45 44 4e 40 22 20 22 55 4b 47 22 41 53 53
>206d	45 52 54 20 22 22 46 52 41 43 28 34 34 35 20 22
>207d	55 50 42 43 59 58 42 22 2a 38 2e 38 28 38 2e 38
>208d	34 20 34 2e 39 32 00
.2094					Line54:
>2094	31 31 31 35 20 2d 31 2e			.text '1115 -1.81 <>1225 N9O6K5 S0Z9Y$ "SEELRJP"Q$445 P4F6-8.1 R8F9M7 N0T1F1 P4F6 1355 RIGHT$(-5.65 305 8.84 "S@"1365 1.62 """MYXF"',0
>209c	38 31 20 3c 3e 31 32 32 35 20 4e 39 4f 36 4b 35
>20ac	20 53 30 5a 39 59 24 20 22 53 45 45 4c 52 4a 50
>20bc	22 51 24 34 34 35 20 50 34 46 36 2d 38 2e 31 20
>20cc	52 38 46 39 4d 37 20 4e 30 54 31 46 31 20 50 34
>20dc	46 36 20 31 33 35 35 20 52 49 47 48 54 24 28 2d
>20ec	35 2e 36 35 20 33 30 35 20 38 2e 38 34 20 22 53
>20fc	40 22 31 33 36 35 20 31 2e 36 32 20 22 22 22 4d
>210c	59 58 46 22 00
.2111					Line55:
>2111	35 34 35 20 22 49 4a 48			.text '545 "IJHGPWB" + >(9.66 --1.79 "FY" 415 815 LEFT$("WOMDMC"495 455',0
>2119	47 50 57 42 22 20 2b 20 3e 28 39 2e 36 36 20 2d
>2129	2d 31 2e 37 39 20 22 46 59 22 20 34 31 35 20 38
>2139	31 35 20 4c 45 46 54 24 28 22 57 4f 4d 44 4d 43
>2149	22 34 39 35 20 34 35 35 00
.2152					Line56:
>2152	35 38 35 00				.text '585',0
.2156					Line57:
>2156	38 33 35 20 20 52 49 47			.text '835  RIGHT$("""HVA@""QUZP" -1.17 + / INKEY$(""D6(-R7J5',0
>215e	48 54 24 28 22 22 22 48 56 41 40 22 22 51 55 5a
>216e	50 22 20 2d 31 2e 31 37 20 2b 20 2f 20 49 4e 4b
>217e	45 59 24 28 22 22 44 36 28 2d 52 37 4a 35 00
.218d					Line58:
>218d	31 31 30 35 20 20 58 4f			.text '1105  XOR 0.91- )"JKVUU" 9.8 TIME 3.05-4.77 ELSE 415 8.3/ "VN@YSP"W("FI""KG""KKHE"',0
>2195	52 20 30 2e 39 31 2d 20 29 22 4a 4b 56 55 55 22
>21a5	20 39 2e 38 20 54 49 4d 45 20 33 2e 30 35 2d 34
>21b5	2e 37 37 20 45 4c 53 45 20 34 31 35 20 38 2e 33
>21c5	2f 20 22 56 4e 40 59 53 50 22 57 28 22 46 49 22
>21d5	22 4b 47 22 22 4b 4b 48 45 22 00
.21e0					Line59:
>21e0	39 36 35 20 31 34 36 35			.text '965 1465 3.18 K7L3Y*-2.87 A0F4U0 REPEAT 1395 T1K(475"GSTAE@E" "JGEB"-1.85 Z0D LEN( P1 LEN("SRWKAZ"TO P1 P3T3V/ 1255 1235<>645',0
>21e8	20 33 2e 31 38 20 4b 37 4c 33 59 2a 2d 32 2e 38
>21f8	37 20 41 30 46 34 55 30 20 52 45 50 45 41 54 20
>2208	31 33 39 35 20 54 31 4b 28 34 37 35 22 47 53 54
>2218	41 45 40 45 22 20 22 4a 47 45 42 22 2d 31 2e 38
>2228	35 20 5a 30 44 20 4c 45 4e 28 20 50 31 20 4c 45
>2238	4e 28 22 53 52 57 4b 41 5a 22 54 4f 20 50 31 20
>2248	50 33 54 33 56 2f 20 31 32 35 35 20 31 32 33 35
>2258	3c 3e 36 34 35 00
.225e					Line60:
>225e	31 30 37 35 20 20 2b 20			.text '1075  + MID$(2.82 1385 F9J0G9<> -9.88 1415',0
>2266	4d 49 44 24 28 32 2e 38 32 20 31 33 38 35 20 46
>2276	39 4a 30 47 39 3c 3e 20 2d 39 2e 38 38 20 31 34
>2286	31 35 00
.2289					Line61:
>2289	39 37 35 20 20 35 2e 30			.text '975  5.04 HEX$(NEXT MOD"QXDSTAY"1.87"FQ" (C8F0 P0V3M <6.47 Q3Z/ELSE V9F4D0 1125',0
>2291	34 20 48 45 58 24 28 4e 45 58 54 20 4d 4f 44 22
>22a1	51 58 44 53 54 41 59 22 31 2e 38 37 22 46 51 22
>22b1	20 28 43 38 46 30 20 50 30 56 33 4d 20 3c 36 2e
>22c1	34 37 20 51 33 5a 2f 45 4c 53 45 20 56 39 46 34
>22d1	44 30 20 31 31 32 35 00
.22d9					Line62:
>22d9	37 30 35 20 20 2d 38 2e			.text '705  -8.54 5.62"R" P0K"LITDZMB" "FVVVXX"- "WC"-5.9"RC" 0.15',0
>22e1	35 34 20 35 2e 36 32 22 52 22 20 50 30 4b 22 4c
>22f1	49 54 44 5a 4d 42 22 20 22 46 56 56 56 58 58 22
>2301	2d 20 22 57 43 22 2d 35 2e 39 22 52 43 22 20 30
>2311	2e 31 35 00
.2315					Line63:
>2315	36 35 35 20 47 38 20 54			.text '655 G8 T - UNTIL 765 "WYQMNTA"DEEK(- PRINT STR$(B(( STR$(3.18 -6.37 -5.06/ -7.81 -5.88-5.41 N8J1O HEX$("FEGU""M"K9 PEEK( P0K )= 9.3',0
>231d	20 2d 20 55 4e 54 49 4c 20 37 36 35 20 22 57 59
>232d	51 4d 4e 54 41 22 44 45 45 4b 28 2d 20 50 52 49
>233d	4e 54 20 53 54 52 24 28 42 28 28 20 53 54 52 24
>234d	28 33 2e 31 38 20 2d 36 2e 33 37 20 2d 35 2e 30
>235d	36 2f 20 2d 37 2e 38 31 20 2d 35 2e 38 38 2d 35
>236d	2e 34 31 20 4e 38 4a 31 4f 20 48 45 58 24 28 22
>237d	46 45 47 55 22 22 4d 22 4b 39 20 50 45 45 4b 28
>238d	20 50 30 4b 20 29 3d 20 39 2e 33 00
.2399					Line64:
>2399	36 39 35 20 59 20 3e 22			.text '695 Y >"SHEVNQER"=1345-6.48 >-1.37 5.19 ="ETECO" >F9J0G9 "U"W3$ X2I2H NEW 4.01 1315 F9J0G9 505"RBOBOYHE"N2L6',0
>23a1	53 48 45 56 4e 51 45 52 22 3d 31 33 34 35 2d 36
>23b1	2e 34 38 20 3e 2d 31 2e 33 37 20 35 2e 31 39 20
>23c1	3d 22 45 54 45 43 4f 22 20 3e 46 39 4a 30 47 39
>23d1	20 22 55 22 57 33 24 20 58 32 49 32 48 20 4e 45
>23e1	57 20 34 2e 30 31 20 31 33 31 35 20 46 39 4a 30
>23f1	47 39 20 35 30 35 22 52 42 4f 42 4f 59 48 45 22
>2401	4e 32 4c 36 00
.2406					Line65:
>2406	36 37 35 20 3d 54 49 4d			.text '675 =TIME 345> LOOP( 1105"AETN"1025 B5',0
>240e	45 20 33 34 35 3e 20 4c 4f 4f 50 28 20 31 31 30
>241e	35 22 41 45 54 4e 22 31 30 32 35 20 42 35 00
.242d					Line66:
>242d	31 33 39 35 00				.text '1395',0
.2432					Line67:
>2432	36 32 35 00				.text '625',0
.2436					Line68:
>2436	36 39 35 00				.text '695',0
.243a					Line69:
>243a	31 32 36 35 00				.text '1265',0
.243f					Line70:
>243f	36 37 35 20 49 4e 50 55			.text '675 INPUT -9.58 1425(:"AFKGLEL" THEN E6O4R2(E1D5-5.21 7.87 1.0<AND"RGHFV"5.0"ZV" RIGHT$(665/"" "BDKLLGLW"6.37',0
>2447	54 20 2d 39 2e 35 38 20 31 34 32 35 28 3a 22 41
>2457	46 4b 47 4c 45 4c 22 20 54 48 45 4e 20 45 36 4f
>2467	34 52 32 28 45 31 44 35 2d 35 2e 32 31 20 37 2e
>2477	38 37 20 31 2e 30 3c 41 4e 44 22 52 47 48 46 56
>2487	22 35 2e 30 22 5a 56 22 20 52 49 47 48 54 24 28
>2497	36 36 35 2f 22 22 20 22 42 44 4b 4c 4c 47 4c 57
>24a7	22 36 2e 33 37 00
.24ad					Line71:
>24ad	37 31 35 20 20 31 33 33			.text '715  1335 7.29 1215 P1H4S "U" "RWJZBK"="@TU@"625*S P5 775 2.96<K7L3Y *"GYKXKTV" <N8J1O "KNBNHFRP" PEEK(625 855 U4E5F"OOE") +',0
>24b5	35 20 37 2e 32 39 20 31 32 31 35 20 50 31 48 34
>24c5	53 20 22 55 22 20 22 52 57 4a 5a 42 4b 22 3d 22
>24d5	40 54 55 40 22 36 32 35 2a 53 20 50 35 20 37 37
>24e5	35 20 32 2e 39 36 3c 4b 37 4c 33 59 20 2a 22 47
>24f5	59 4b 58 4b 54 56 22 20 3c 4e 38 4a 31 4f 20 22
>2505	4b 4e 42 4e 48 46 52 50 22 20 50 45 45 4b 28 36
>2515	32 35 20 38 35 35 20 55 34 45 35 46 22 4f 4f 45
>2525	22 29 20 2b 00
.252a					Line72:
>252a	31 31 39 35 20 3c 3d 39			.text '1195 <=9.54 B1$INPUT$9.79 ) 465-8.31"YU" -9.01',0
>2532	2e 35 34 20 42 31 24 49 4e 50 55 54 24 39 2e 37
>2542	39 20 29 20 34 36 35 2d 38 2e 33 31 22 59 55 22
>2552	20 2d 39 2e 30 31 00
.2559					Line73:
>2559	35 38 35 20 4e 45 57 00			.text '585 NEW',0
.2561					Line74:
>2561	34 38 35 20 20 2d 34 2e			.text '485  -4.46 DOKE 9.89"TPQPJ" REM E3C2B2 I2C6B 1025',0
>2569	34 36 20 44 4f 4b 45 20 39 2e 38 39 22 54 50 51
>2579	50 4a 22 20 52 45 4d 20 45 33 43 32 42 32 20 49
>2589	32 43 36 42 20 31 30 32 35 00
.2593					Line75:
>2593	31 31 39 35 20 29 20 2b			.text '1195 ) + 8.36 F9R8H N2L6)INKEY$(A0F4U0 3.4 1405"" "XRVT"605"L@@IC"',0
>259b	20 38 2e 33 36 20 46 39 52 38 48 20 4e 32 4c 36
>25ab	29 49 4e 4b 45 59 24 28 41 30 46 34 55 30 20 33
>25bb	2e 34 20 31 34 30 35 22 22 20 22 58 52 56 54 22
>25cb	36 30 35 22 4c 40 40 49 43 22 00
.25d6					Line76:
>25d6	31 32 34 35 20 5a 30 44			.text '1245 Z0D',0
>25de	00
.25df					Line77:
>25df	31 31 35 35 20 20 2b 20			.text '1155  + ;705 - 1235"ZJC"E3C2B2 "" 1415',0
>25e7	3b 37 30 35 20 2d 20 31 32 33 35 22 5a 4a 43 22
>25f7	45 33 43 32 42 32 20 22 22 20 31 34 31 35 00
.2606					Line78:
>2606	31 34 35 35 20 2d 35 2e			.text '1455 -5.55= Y3A NEXT 2.57 1435 8.25*XOR -3.19 B0W0A6(325 V7"X@UZX"',0
>260e	35 35 3d 20 59 33 41 20 4e 45 58 54 20 32 2e 35
>261e	37 20 31 34 33 35 20 38 2e 32 35 2a 58 4f 52 20
>262e	2d 33 2e 31 39 20 42 30 57 30 41 36 28 33 32 35
>263e	20 56 37 22 58 40 55 5a 58 22 00
.2649					Line79:
>2649	38 31 35 20 35 2e 39 35			.text '815 5.95 RIGHT$("HRHTTNN"( "QUYPF" C8F0 )-2.47',0
>2651	20 52 49 47 48 54 24 28 22 48 52 48 54 54 4e 4e
>2661	22 28 20 22 51 55 59 50 46 22 20 43 38 46 30 20
>2671	29 2d 32 2e 34 37 00
.2678					Line80:
>2678	31 30 35 35 00				.text '1055',0
.267d					Line81:
>267d	37 37 35 20 3e 39 2e 39			.text '775 >9.9 *=-9.5 1375 995<9.35 PROC M("FDEXICQ" 6.8 9.58 U -3.67 1115+',0
>2685	20 2a 3d 2d 39 2e 35 20 31 33 37 35 20 39 39 35
>2695	3c 39 2e 33 35 20 50 52 4f 43 20 4d 28 22 46 44
>26a5	45 58 49 43 51 22 20 36 2e 38 20 39 2e 35 38 20
>26b5	55 20 2d 33 2e 36 37 20 31 31 31 35 2b 00
.26c3					Line82:
>26c3	31 31 33 35 20 2a 3e 00			.text '1135 *>',0
.26cb					Line83:
>26cb	37 35 35 20 2a 20 51 20			.text '755 * Q N+ POKE-',0
>26d3	4e 2b 20 50 4f 4b 45 2d 00
.26dc					Line84:
>26dc	31 33 37 35 20 59 38 24			.text '1375 Y8$= + 0.22=9.68-0.64-1.15 1185 LEFT$(( R8F9M7 "LAKK@F"',0
>26e4	3d 20 2b 20 30 2e 32 32 3d 39 2e 36 38 2d 30 2e
>26f4	36 34 2d 31 2e 31 35 20 31 31 38 35 20 4c 45 46
>2704	54 24 28 28 20 52 38 46 39 4d 37 20 22 4c 41 4b
>2714	4b 40 46 22 00
.2719					Line85:
>2719	33 31 35 20 46 39 4a 30			.text '315 F9J0G9 N2-POKE"PP"-2.44"MOAFETV""LNTX"O ("YG"<>415 295-4.57 V1J2A / Y8D PRINT 345 "Y">G8 975"VJEGUIR"=',0
>2721	47 39 20 4e 32 2d 50 4f 4b 45 22 50 50 22 2d 32
>2731	2e 34 34 22 4d 4f 41 46 45 54 56 22 22 4c 4e 54
>2741	58 22 4f 20 28 22 59 47 22 3c 3e 34 31 35 20 32
>2751	39 35 2d 34 2e 35 37 20 56 31 4a 32 41 20 2f 20
>2761	59 38 44 20 50 52 49 4e 54 20 33 34 35 20 22 59
>2771	22 3e 47 38 20 39 37 35 22 56 4a 45 47 55 49 52
>2781	22 3d 00
.2784					Line86:
>2784	33 34 35 20 20 39 30 35			.text '345  905 -0.27 "QOQ"-"UOSEWZEH"/-6.58 *C1I8 "CLODWLZ" 875 ELSE D1L2$* E1D5 TO 1365 645 X-5.42-4.4 LEFT$(-4.58"QEFRGVYC"',0
>278c	20 2d 30 2e 32 37 20 22 51 4f 51 22 2d 22 55 4f
>279c	53 45 57 5a 45 48 22 2f 2d 36 2e 35 38 20 2a 43
>27ac	31 49 38 20 22 43 4c 4f 44 57 4c 5a 22 20 38 37
>27bc	35 20 45 4c 53 45 20 44 31 4c 32 24 2a 20 45 31
>27cc	44 35 20 54 4f 20 31 33 36 35 20 36 34 35 20 58
>27dc	2d 35 2e 34 32 2d 34 2e 34 20 4c 45 46 54 24 28
>27ec	2d 34 2e 35 38 22 51 45 46 52 47 56 59 43 22 00
.27fc					Line87:
>27fc	36 31 35 20 2d 35 2e 32			.text '615 -5.23 -(935 O 6.85) 645 < 1.84 XOR 615 -2.4 V0R7Z( 4.37"HXROPE" WEND DIV 2.65 LIST K7L3Y SYS/ "PUFC"-0.61 -7.46 ("A@NGSV"',0
>2804	33 20 2d 28 39 33 35 20 4f 20 36 2e 38 35 29 20
>2814	36 34 35 20 3c 20 31 2e 38 34 20 58 4f 52 20 36
>2824	31 35 20 2d 32 2e 34 20 56 30 52 37 5a 28 20 34
>2834	2e 33 37 22 48 58 52 4f 50 45 22 20 57 45 4e 44
>2844	20 44 49 56 20 32 2e 36 35 20 4c 49 53 54 20 4b
>2854	37 4c 33 59 20 53 59 53 2f 20 22 50 55 46 43 22
>2864	2d 30 2e 36 31 20 2d 37 2e 34 36 20 28 22 41 40
>2874	4e 47 53 56 22 00
.287a					Line88:
>287a	39 32 35 20 20 28 20 34			.text '925  ( 435 SYS 975 4.62 7.26 405-8.64"LLQC""EJWE" 475 K9 RUN "LQI"1205 625 -3.8 N7 1465 1095 -5.99"IEK"5.87"O" >685 1465 "MWDGIJ"-',0
>2882	33 35 20 53 59 53 20 39 37 35 20 34 2e 36 32 20
>2892	37 2e 32 36 20 34 30 35 2d 38 2e 36 34 22 4c 4c
>28a2	51 43 22 22 45 4a 57 45 22 20 34 37 35 20 4b 39
>28b2	20 52 55 4e 20 22 4c 51 49 22 31 32 30 35 20 36
>28c2	32 35 20 2d 33 2e 38 20 4e 37 20 31 34 36 35 20
>28d2	31 30 39 35 20 2d 35 2e 39 39 22 49 45 4b 22 35
>28e2	2e 38 37 22 4f 22 20 3e 36 38 35 20 31 34 36 35
>28f2	20 22 4d 57 44 47 49 4a 22 2d 00
.28fd					Line89:
>28fd	31 30 31 35 20 28 20 38			.text '1015 ( 8.13 9.32 CHR$("HC@PJMGN"705 "M" /P0A8$ 835 > "IS"+K9"M"',0
>2905	2e 31 33 20 39 2e 33 32 20 43 48 52 24 28 22 48
>2915	43 40 50 4a 4d 47 4e 22 37 30 35 20 22 4d 22 20
>2925	2f 50 30 41 38 24 20 38 33 35 20 3e 20 22 49 53
>2935	22 2b 4b 39 22 4d 22 00
.293d					Line90:
>293d	31 34 36 35 20 3d 20 22			.text '1465 = "R"G9P0V 6.29 U9N2L7$U "QVCMKNT"< "ULJMZHO"385 >-6.65* STEP B4B3"CZJT"',0
>2945	52 22 47 39 50 30 56 20 36 2e 32 39 20 55 39 4e
>2955	32 4c 37 24 55 20 22 51 56 43 4d 4b 4e 54 22 3c
>2965	20 22 55 4c 4a 4d 5a 48 4f 22 33 38 35 20 3e 2d
>2975	36 2e 36 35 2a 20 53 54 45 50 20 42 34 42 33 22
>2985	43 5a 4a 54 22 00
.298b					Line91:
>298b	31 32 37 35 20 29 2b 20			.text '1275 )+ "P"6.16(+IF 1.51"" "HDQGG""" +"VGTUXSF"435-6.58 825 P0A8$/325',0
>2993	22 50 22 36 2e 31 36 28 2b 49 46 20 31 2e 35 31
>29a3	22 22 20 22 48 44 51 47 47 22 22 22 20 2b 22 56
>29b3	47 54 55 58 53 46 22 34 33 35 2d 36 2e 35 38 20
>29c3	38 32 35 20 50 30 41 38 24 2f 33 32 35 00
.29d1					Line92:
>29d1	34 34 35 20 43 41 4c 4c			.text '445 CALL"DABE" RIGHT$(1255 LIST-7.3 555 W(NEW CHR$( "ROJXQJHY" =1475',0
>29d9	22 44 41 42 45 22 20 52 49 47 48 54 24 28 31 32
>29e9	35 35 20 4c 49 53 54 2d 37 2e 33 20 35 35 35 20
>29f9	57 28 4e 45 57 20 43 48 52 24 28 20 22 52 4f 4a
>2a09	58 51 4a 48 59 22 20 3d 31 34 37 35 00
.2a16					Line93:
>2a16	39 36 35 20 42 28 20 29			.text '965 B( )+ 4.15"YLYHZES""SXOZ"775-1.9 1325 8.29 2.71 "P""NO" 4.37-6.68"@RFVKT"R8F9M7 905-7.61+ A0F4U0 END"GWAUQ"',0
>2a1e	2b 20 34 2e 31 35 22 59 4c 59 48 5a 45 53 22 22
>2a2e	53 58 4f 5a 22 37 37 35 2d 31 2e 39 20 31 33 32
>2a3e	35 20 38 2e 32 39 20 32 2e 37 31 20 22 50 22 22
>2a4e	4e 4f 22 20 34 2e 33 37 2d 36 2e 36 38 22 40 52
>2a5e	46 56 4b 54 22 52 38 46 39 4d 37 20 39 30 35 2d
>2a6e	37 2e 36 31 2b 20 41 30 46 34 55 30 20 45 4e 44
>2a7e	22 47 57 41 55 51 22 00
.2a86					Line94:
>2a86	31 32 36 35 20 3d 3d 20			.text '1265 == ( 675',0
>2a8e	28 20 36 37 35 00
.2a94					Line95:
>2a94	36 35 35 20 20 22 47 52			.text '655  "GRGDZY"* 7.05 D6(""1485 795 "K" "LRFPDBZU"*O"GNMVK"E6O4R2(525 1205-1445-7.83',0
>2a9c	47 44 5a 59 22 2a 20 37 2e 30 35 20 44 36 28 22
>2aac	22 31 34 38 35 20 37 39 35 20 22 4b 22 20 22 4c
>2abc	52 46 50 44 42 5a 55 22 2a 4f 22 47 4e 4d 56 4b
>2acc	22 45 36 4f 34 52 32 28 35 32 35 20 31 32 30 35
>2adc	2d 31 34 34 35 2d 37 2e 38 33 00
.2ae7					Line96:
>2ae7	31 31 32 35 20 34 2e 33			.text '1125 4.37-9.85( 325"WQDC" SGN( LOOP -8.01 9.64 <1195-0.69 1145',0
>2aef	37 2d 39 2e 38 35 28 20 33 32 35 22 57 51 44 43
>2aff	22 20 53 47 4e 28 20 4c 4f 4f 50 20 2d 38 2e 30
>2b0f	31 20 39 2e 36 34 20 3c 31 31 39 35 2d 30 2e 36
>2b1f	39 20 31 31 34 35 00
.2b26					Line97:
>2b26	31 34 31 35 20 2f 20 4c			.text '1415 / LEFT$(-2.02 LOAD( 6.69 M( V9F4D0 1015 ABS( "NEHQXPI""EBJXDSJ" +N 4.3 SAVE "ZMGV"B9I4U( )B(',0
>2b2e	45 46 54 24 28 2d 32 2e 30 32 20 4c 4f 41 44 28
>2b3e	20 36 2e 36 39 20 4d 28 20 56 39 46 34 44 30 20
>2b4e	31 30 31 35 20 41 42 53 28 20 22 4e 45 48 51 58
>2b5e	50 49 22 22 45 42 4a 58 44 53 4a 22 20 2b 4e 20
>2b6e	34 2e 33 20 53 41 56 45 20 22 5a 4d 47 56 22 42
>2b7e	39 49 34 55 28 20 29 42 28 00
.2b88					Line98:
>2b88	31 32 33 35 20 20 37 39			.text '1235  795 9.76 "TTJJ"1455"""SSURXQA"STOP-8.32 565"UPTH"B("PAGW@M"HEX$(565-3.52 /-4.73>)2.28"FZKS"825"FRD"',0
>2b90	35 20 39 2e 37 36 20 22 54 54 4a 4a 22 31 34 35
>2ba0	35 22 22 22 53 53 55 52 58 51 41 22 53 54 4f 50
>2bb0	2d 38 2e 33 32 20 35 36 35 22 55 50 54 48 22 42
>2bc0	28 22 50 41 47 57 40 4d 22 48 45 58 24 28 35 36
>2bd0	35 2d 33 2e 35 32 20 2f 2d 34 2e 37 33 3e 29 32
>2be0	2e 32 38 22 46 5a 4b 53 22 38 32 35 22 46 52 44
>2bf0	22 00
.2bf2					Line99:
>2bf2	36 31 35 00				.text '615',0
.2bf6					Line100:
>2bf6	39 39 35 00				.text '995',0
.2bfa					Line101:
>2bfa	34 35 35 20 22 59 4f 4b			.text '455 "YOKGV" "OQEGGU"*"""CKZC"-0.46 -3.31 -1.16 ""STOP RAND(I9X',0
>2c02	47 56 22 20 22 4f 51 45 47 47 55 22 2a 22 22 22
>2c12	43 4b 5a 43 22 2d 30 2e 34 36 20 2d 33 2e 33 31
>2c22	20 2d 31 2e 31 36 20 22 22 53 54 4f 50 20 52 41
>2c32	4e 44 28 49 39 58 00
.2c39					Line102:
>2c39	35 33 35 20 20 2a 35 2e			.text '535  *5.33+( -1.98 865> >"I@PR" =-4.52 1225""Z0D"F"<3.6"F""PPEHLK""W"0.12 S V9F4D0 4.86 B5 T"DSIHM"',0
>2c41	33 33 2b 28 20 2d 31 2e 39 38 20 38 36 35 3e 20
>2c51	3e 22 49 40 50 52 22 20 3d 2d 34 2e 35 32 20 31
>2c61	32 32 35 22 22 5a 30 44 22 46 22 3c 33 2e 36 22
>2c71	46 22 22 50 50 45 48 4c 4b 22 22 57 22 30 2e 31
>2c81	32 20 53 20 56 39 46 34 44 30 20 34 2e 38 36 20
>2c91	42 35 20 54 22 44 53 49 48 4d 22 00
.2c9d					Line103:
>2c9d	31 30 37 35 20 20 2d 36			.text '1075  -6.96 Q3Z F9J0G9"RKEBKHAP" / -5.82 865>-6.71 445 7.28 865 1195 0.71-2.85 E2X7B -6.77"VFJ"',0
>2ca5	2e 39 36 20 51 33 5a 20 46 39 4a 30 47 39 22 52
>2cb5	4b 45 42 4b 48 41 50 22 20 2f 20 2d 35 2e 38 32
>2cc5	20 38 36 35 3e 2d 36 2e 37 31 20 34 34 35 20 37
>2cd5	2e 32 38 20 38 36 35 20 31 31 39 35 20 30 2e 37
>2ce5	31 2d 32 2e 38 35 20 45 32 58 37 42 20 2d 36 2e
>2cf5	37 37 22 56 46 4a 22 00
.2cfd					Line104:
>2cfd	31 34 35 35 20 31 32 34			.text '1455 1245""(F9R8H"MYTTYBKP"-1.26 G',0
>2d05	35 22 22 28 46 39 52 38 48 22 4d 59 54 54 59 42
>2d15	4b 50 22 2d 31 2e 32 36 20 47 00
.2d20					Line105:
>2d20	31 30 32 35 20 36 2e 37			.text '1025 6.74 1025 1225)N2 DO(9.24 "AZZUQBPH""MAHQQAV"NEW N2P5W 1385 /R$605- * INPUT 1275-"C" 1005 8.14',0
>2d28	34 20 31 30 32 35 20 31 32 32 35 29 4e 32 20 44
>2d38	4f 28 39 2e 32 34 20 22 41 5a 5a 55 51 42 50 48
>2d48	22 22 4d 41 48 51 51 41 56 22 4e 45 57 20 4e 32
>2d58	50 35 57 20 31 33 38 35 20 2f 52 24 36 30 35 2d
>2d68	20 2a 20 49 4e 50 55 54 20 31 32 37 35 2d 22 43
>2d78	22 20 31 30 30 35 20 38 2e 31 34 00
.2d84					Line106:
>2d84	39 36 35 20 20 28 3d 20			.text '965  (= ENDPROC "YCLXZFKO""TPPIDDI"- 355 3.64 O3 $-5.65 B1A 1035/ 845 1255 "IJA"LEFT$( 3.97/ STR$(7.76 Y8$ -785 CALL 1315 (2.07',0
>2d8c	45 4e 44 50 52 4f 43 20 22 59 43 4c 58 5a 46 4b
>2d9c	4f 22 22 54 50 50 49 44 44 49 22 2d 20 33 35 35
>2dac	20 33 2e 36 34 20 4f 33 20 24 2d 35 2e 36 35 20
>2dbc	42 31 41 20 31 30 33 35 2f 20 38 34 35 20 31 32
>2dcc	35 35 20 22 49 4a 41 22 4c 45 46 54 24 28 20 33
>2ddc	2e 39 37 2f 20 53 54 52 24 28 37 2e 37 36 20 59
>2dec	38 24 20 2d 37 38 35 20 43 41 4c 4c 20 31 33 31
>2dfc	35 20 28 32 2e 30 37 00
.2e04					Line107:
>2e04	37 34 35 20 35 39 35 22			.text '745 595"" REM -7.7',0
>2e0c	22 20 52 45 4d 20 2d 37 2e 37 00
.2e17					Line108:
>2e17	39 39 35 20 20 30 2e 35			.text '995  0.51 H><= 5.59-0.63 CHR$( "",* -8.34+<)G8 455 "DWBWPD"CHR$( C1 -8.01 665 STEP RIGHT$( 1105 X2I2H"GLDD"',0
>2e1f	31 20 48 3e 3c 3d 20 35 2e 35 39 2d 30 2e 36 33
>2e2f	20 43 48 52 24 28 20 22 22 2c 2a 20 2d 38 2e 33
>2e3f	34 2b 3c 29 47 38 20 34 35 35 20 22 44 57 42 57
>2e4f	50 44 22 43 48 52 24 28 20 43 31 20 2d 38 2e 30
>2e5f	31 20 36 36 35 20 53 54 45 50 20 52 49 47 48 54
>2e6f	24 28 20 31 31 30 35 20 58 32 49 32 48 22 47 4c
>2e7f	44 44 22 00
.2e83					Line109:
>2e83	37 37 35 20 2f 00			.text '775 /',0
.2e89					Line110:
>2e89	37 34 35 20 28 20 2d 36			.text '745 ( -6.46 *""< M2G7R6 "WMXL"M2G7R6 1165 THEN*"WKOB"-2.18 385 O3=THEN N0/REM 605 8.6 6.55',0
>2e91	2e 34 36 20 2a 22 22 3c 20 4d 32 47 37 52 36 20
>2ea1	22 57 4d 58 4c 22 4d 32 47 37 52 36 20 31 31 36
>2eb1	35 20 54 48 45 4e 2a 22 57 4b 4f 42 22 2d 32 2e
>2ec1	31 38 20 33 38 35 20 4f 33 3d 54 48 45 4e 20 4e
>2ed1	30 2f 52 45 4d 20 36 30 35 20 38 2e 36 20 36 2e
>2ee1	35 35 00
.2ee4					Line111:
>2ee4	31 33 38 35 00				.text '1385',0
.2ee9					Line112:
>2ee9	31 31 35 35 20 45 4c 53			.text '1155 ELSE "WWSOBF"Q$"ESJ"/LEN(STEP 1185"DLBBA"B0W0A6(END-7.88 6.44 925 DIM 5.56 5.9 645"" "Q" -2.21 1.15/ Q"@M"8.76 4.07 EXIT',0
>2ef1	45 20 22 57 57 53 4f 42 46 22 51 24 22 45 53 4a
>2f01	22 2f 4c 45 4e 28 53 54 45 50 20 31 31 38 35 22
>2f11	44 4c 42 42 41 22 42 30 57 30 41 36 28 45 4e 44
>2f21	2d 37 2e 38 38 20 36 2e 34 34 20 39 32 35 20 44
>2f31	49 4d 20 35 2e 35 36 20 35 2e 39 20 36 34 35 22
>2f41	22 20 22 51 22 20 2d 32 2e 32 31 20 31 2e 31 35
>2f51	2f 20 51 22 40 4d 22 38 2e 37 36 20 34 2e 30 37
>2f61	20 45 58 49 54 00
.2f67					Line113:
>2f67	31 30 38 35 20 20 35 34			.text '1085  545 995""295 R$R REPEAT 9.86<',0
>2f6f	35 20 39 39 35 22 22 32 39 35 20 52 24 52 20 52
>2f7f	45 50 45 41 54 20 39 2e 38 36 3c 00
.2f8b					Line114:
>2f8b	34 30 35 20 50 31 20 30			.text '405 P1 0.12"YT"-0.53 L9Z2J"CYRR" +"FDDW") -2.78 595-C8J7 C8F0 865 5.66-1.25 - 395 8.92 1205""1035 "VDTW"',0
>2f93	2e 31 32 22 59 54 22 2d 30 2e 35 33 20 4c 39 5a
>2fa3	32 4a 22 43 59 52 52 22 20 2b 22 46 44 44 57 22
>2fb3	29 20 2d 32 2e 37 38 20 35 39 35 2d 43 38 4a 37
>2fc3	20 43 38 46 30 20 38 36 35 20 35 2e 36 36 2d 31
>2fd3	2e 32 35 20 2d 20 33 39 35 20 38 2e 39 32 20 31
>2fe3	32 30 35 22 22 31 30 33 35 20 22 56 44 54 57 22
>2ff3	00
.2ff4					Line115:
>2ff4	33 30 35 00				.text '305',0
.2ff8					Line116:
>2ff8	36 30 35 20 20 22 4c 40			.text '605  "L@"1055 W(335 1035"YMPFAOW" )>= =F ) Q6P8$ G8>IF',0
>3000	22 31 30 35 35 20 57 28 33 33 35 20 31 30 33 35
>3010	22 59 4d 50 46 41 4f 57 22 20 29 3e 3d 20 3d 46
>3020	20 29 20 51 36 50 38 24 20 47 38 3e 49 46 00
.302f					Line117:
>302f	31 31 33 35 20 20 38 36			.text '1135  865"I"""355 1215 465""RND(DIV 0.46 7.84 525 515 +-6.11"L"',0
>3037	35 22 49 22 22 22 33 35 35 20 31 32 31 35 20 34
>3047	36 35 22 22 52 4e 44 28 44 49 56 20 30 2e 34 36
>3057	20 37 2e 38 34 20 35 32 35 20 35 31 35 20 2b 2d
>3067	36 2e 31 31 22 4c 22 00
.306f					Line118:
>306f	31 32 30 35 20 20 4c 4f			.text '1205  LOAD--5.02 8.24 LEFT$("MYK@LS"CHR$( 925 RUN 925-1245 >="JLUII"AND/)""B4B3 495 G1X4O8 E"AJLZW" "F"-9.46 G5Q-6.23 345 645',0
>3077	41 44 2d 2d 35 2e 30 32 20 38 2e 32 34 20 4c 45
>3087	46 54 24 28 22 4d 59 4b 40 4c 53 22 43 48 52 24
>3097	28 20 39 32 35 20 52 55 4e 20 39 32 35 2d 31 32
>30a7	34 35 20 3e 3d 22 4a 4c 55 49 49 22 41 4e 44 2f
>30b7	29 22 22 42 34 42 33 20 34 39 35 20 47 31 58 34
>30c7	4f 38 20 45 22 41 4a 4c 5a 57 22 20 22 46 22 2d
>30d7	39 2e 34 36 20 47 35 51 2d 36 2e 32 33 20 33 34
>30e7	35 20 36 34 35 00
.30ed					Line119:
>30ed	36 33 35 20 20 28 44 39			.text '635  (D9Z 7.83/X2I2H 1215 C1"@" M2$-5.98 405',0
>30f5	5a 20 37 2e 38 33 2f 58 32 49 32 48 20 31 32 31
>3105	35 20 43 31 22 40 22 20 4d 32 24 2d 35 2e 39 38
>3115	20 34 30 35 00

;******  Return to file: src/program/testing/testing.asmx

.311a					TOKOneLine:
.311a	86 22		stx $22				stx 	zTemp2
.311c	84 23		sty $23				sty 	zTemp2+1
.311e	a2 34		ldx #$34			ldx 	#TOKGetSource & $FF
.3120	a0 31		ldy #$31			ldy 	#TOKGetSource >> 8
.3122	38		sec				sec
.3123	20 8e 3e	jsr $3e8e			jsr 	TOKTokenise
.3126	20 69 3d	jsr $3d69			jsr 	PGMDeleteLine
.3129	ad 01 04	lda $0401			lda 	TOKLineSize
.312c	c9 04		cmp #$04			cmp 	#4
.312e	f0 03		beq $3133			beq 	_TOKNoInsert
.3130	20 b3 3d	jsr $3db3			jsr 	PGMInsertLine
.3133					_TOKNoInsert:
.3133	60		rts				rts
.3134					TOKGetSource:
.3134	b2 22		lda ($22)			lda 	(zTemp2)
.3136	90 06		bcc $313e			bcc 	_GSNoIncrement
.3138	e6 22		inc $22				inc 	zTemp2
.313a	d0 02		bne $313e			bne 	_GSNoIncrement
.313c	e6 23		inc $23				inc 	zTemp2+1
.313e					_GSNoIncrement:
.313e	c9 00		cmp #$00			cmp 	#0
.3140	60		rts				rts
.0400					SrcPosition:
>0400							.fill 		1

;******  Return to file: basic.asm

.3141	4c db 33	jmp $33db			jmp 	Command_RUN

;******  Processing file: include.files


;******  Processing file: src/data.inc

.001c					codePtr:
>001c							.fill 	2
.001e					zTemp0:
>001e							.fill 	2
.0020					zTemp1:
>0020							.fill 	2
.0022					zTemp2:
>0022							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/generated/token_const.inc

=$80					PR_STRUCTURE_FIRST = $80
=$80					PR_REPEAT = $80
=$81					PR_UNTIL = $81
=$82					PR_WHILE = $82
=$83					PR_WEND = $83
=$84					PR_IF = $84
=$85					PR_ENDIF = $85
=$86					PR_DO = $86
=$87					PR_LOOP = $87
=$88					PR_PROC = $88
=$89					PR_ENDPROC = $89
=$8a					PR_FOR = $8a
=$8b					PR_NEXT = $8b
=$8b					PR_STRUCTURE_LAST = $8b
=$8c					PR_STANDARD_FIRST = $8c
=$8c					PR_LSQLSQENDRSQRSQ = $8c
=$8d					PR_LSQLSQSHIFTRSQRSQ = $8d
=$8e					PR_ELSE = $8e
=$8f					PR_THEN = $8f
=$90					PR_TO = $90
=$91					PR_STEP = $91
=$92					PR_LET = $92
=$93					PR_PRINT = $93
=$94					PR_INPUT = $94
=$95					PR_CALL = $95
=$96					PR_SYS = $96
=$97					PR_REM = $97
=$98					PR_EXIT = $98
=$99					PR_COMMA = $99
=$9a					PR_SEMICOLON = $9a
=$9b					PR_COLON = $9b
=$9c					PR_SQUOTE = $9c
=$9d					PR_RPAREN = $9d
=$9e					PR_DIM = $9e
=$9f					PR_CLEAR = $9f
=$a0					PR_NEW = $a0
=$a1					PR_RUN = $a1
=$a2					PR_STOP = $a2
=$a3					PR_END = $a3
=$a4					PR_ASSERT = $a4
=$a5					PR_LIST = $a5
=$a6					PR_SAVE = $a6
=$a7					PR_LOAD = $a7
=$a8					PR_POKE = $a8
=$a9					PR_DOKE = $a9
=$a9					PR_STANDARD_LAST = $a9
=$d5					PR_DEEKLPAREN = $d5
=$d5					PR_UNARY_FIRST = $d5
=$d6					PR_PEEKLPAREN = $d6
=$d7					PR_RIGHTDOLLARLPAREN = $d7
=$d8					PR_LEFTDOLLARLPAREN = $d8
=$d9					PR_MIDDOLLARLPAREN = $d9
=$da					PR_STRDOLLARLPAREN = $da
=$db					PR_VALLPAREN = $db
=$dc					PR_SGNLPAREN = $dc
=$dd					PR_ABSLPAREN = $dd
=$de					PR_LENLPAREN = $de
=$df					PR_SQRLPAREN = $df
=$e0					PR_CHRDOLLARLPAREN = $e0
=$e1					PR_ASCLPAREN = $e1
=$e2					PR_INKEYDOLLARLPAREN = $e2
=$e3					PR_EVENTLPAREN = $e3
=$e4					PR_TIME = $e4
=$e5					PR_INTLPAREN = $e5
=$e6					PR_FRACLPAREN = $e6
=$e7					PR_DECLPAREN = $e7
=$e8					PR_HEXDOLLARLPAREN = $e8
=$e9					PR_RNDLPAREN = $e9
=$ea					PR_RANDLPAREN = $ea
=$eb					PR_LPAREN = $eb
=$ec					PR_DOLLAR = $ec
=$ed					PR_LSQLSQDECIMALRSQRSQ = $ed
=$ee					PR_UNARY_LAST = $ee
=$ee					PR_LSQLSQSTRINGRSQRSQ = $ee
=$ef					PR_EQUAL = $ef
=$ef					PR_BINARY_FIRST = $ef
=$f0					PR_LESSGREATER = $f0
=$f1					PR_LESSEQUAL = $f1
=$f2					PR_LESS = $f2
=$f3					PR_GREATEREQUAL = $f3
=$f4					PR_GREATER = $f4
=$f5					PR_XOR = $f5
=$f6					PR_OR = $f6
=$f7					PR_AND = $f7
=$f8					PR_DIV = $f8
=$f9					PR_MOD = $f9
=$fa					PR_LESSLESS = $fa
=$fb					PR_GREATERGREATER = $fb
=$fc					PR_SLASH = $fc
=$fd					PR_ASTERISK = $fd
=$fe					PR_MINUS = $fe
=$ff					PR_BINARY_LAST = $ff
=$ff					PR_PLUS = $ff

;******  Return to file: include.files


;******  Processing file: src/program/data.inc

.0401					TOKLineSize:
>0401							.fill 	1
.0402					TOKLineNumber:
>0402							.fill 	2
.0404					TOKBuffer:
>0404							.fill 	256

;******  Return to file: include.files


;******  Processing file: src/support/errors/generated/errors.inc


;******  Return to file: include.files


;******  Processing file: src/support/stack/stack.inc

=$02					STK_REPEAT = $02
=$12					STK_WHILE = $12
=$22					STK_DO = $22
=$37					STK_FOR = $37
=$42					STK_CALL = $42

;******  Return to file: include.files


;******  Processing file: src/commands/assert.asm

.3144					Command_ASSERT:
.3144	20 03 36	jsr $3603			jsr 	EXPEvalNumber
.3147	a2 0c		ldx #$0c			ldx 	#IFR0
.3149	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero
.314c	f0 01		beq $314f			beq 	_CAFail
.314e	60		rts				rts
.314f					_CAFail:
.314f	4c 1f 44	jmp $441f		jmp	ErrorV_assert

;******  Return to file: include.files


;******  Processing file: src/commands/clear.asm

.3152					Command_CLEAR:
.3152	20 1c 3e	jsr $3e1c			jsr 	PGMEndProgram 				; end program => zTemp0
.3155	64 24		stz $24				stz 	freeMemory 					; start on next free page
.3157	a5 1f		lda $1f				lda 	zTemp0+1
.3159	1a		inc a				inc 	a
.315a	85 25		sta $25				sta 	freeMemory+1
.315c	20 d8 47	jsr $47d8			jsr 	VARClearHashTables
.315f	ad 11 05	lda $0511			lda 	PGMEndMemoryHigh
.3162	20 bc 45	jsr $45bc			jsr 	StackReset
.3165	20 1b 46	jsr $461b			jsr 	StringSystemInitialise
.3168	20 3b 43	jsr $433b			jsr 	ScanProcedures
.316b	60		rts				rts
.316c					AllocateMemory:
.316c	5a		phy				phy 								; save Y
.316d	a4 24		ldy $24				ldy 	freeMemory 					; save addr.low
.316f	5a		phy				phy
.3170	a4 25		ldy $25				ldy 	freeMemory+1 				; save addr.high
.3172	5a		phy				phy
.3173	a8		tay				tay 								; count is now in XY
.3174					_AllocateLoop:
.3174	e0 00		cpx #$00			cpx 	#0 							; allocate count is zero ?
.3176	d0 04		bne $317c			bne 	_AllocateOne
.3178	c0 00		cpy #$00			cpy 	#0
.317a	f0 15		beq $3191			beq 	_AllocateExit
.317c					_AllocateOne:
.317c	a9 00		lda #$00			lda 	#0 							; zero byte
.317e	92 24		sta ($24)			sta 	(freeMemory)
.3180	e6 24		inc $24				inc 	freeMemory 					; bump pointer
.3182	d0 05		bne $3189			bne 	_AllocateSkipCarry
.3184	e6 25		inc $25				inc 	freeMemory+1
.3186	20 95 31	jsr $3195			jsr 	ClearCheckMemory
.3189					_AllocateSkipCarry:
.3189	c0 00		cpy #$00			cpy 	#0 							; decrement XY
.318b	d0 01		bne $318e			bne 	_AllocateSkipBorrow
.318d	ca		dex				dex
.318e					_AllocateSkipBorrow:
.318e	88		dey				dey
.318f	80 e3		bra $3174			bra 	_AllocateLoop
.3191					_AllocateExit:
.3191	fa		plx				plx 								; restore address
.3192	68		pla				pla
.3193	7a		ply				ply 								; restore Y
.3194	60		rts				rts
.3195					ClearCheckMemory:
.3195	a5 25		lda $25				lda 	freeMemory+1
.3197	1a		inc a				inc 	a
.3198	1a		inc a				inc 	a
.3199	cd 19 06	cmp $0619			cmp 	stringMemory+1
.319c	b0 01		bcs $319f			bcs  	_CCMError
.319e	60		rts				rts
.319f					_CCMError:
.319f	4c b1 44	jmp $44b1		jmp	ErrorV_memory
.0024					freeMemory:
>0024							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/commands/dim.asm

.31a2					CommandDIM:
.31a2	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; check identifier follows.
.31a4	29 c0		and #$c0			and 	#$C0
.31a6	c9 40		cmp #$40			cmp 	#$40
.31a8	d0 39		bne $31e3			bne 	_CDSyntax
.31aa	20 8f 47	jsr $478f			jsr 	VARGetInfo 					; get information
.31ad	ad 1f 06	lda $061f			lda 	VARType 					; check array.
.31b0	29 02		and #$02			and 	#2
.31b2	f0 2f		beq $31e3			beq 	_CDSyntax
.31b4	20 41 47	jsr $4741			jsr 	VARFind 					; does it already exist
.31b7	b0 2d		bcs $31e6			bcs 	_CDExists
.31b9	20 ed 46	jsr $46ed			jsr 	VARCreate 					; create it - returns data ptr in XA
.31bc	da		phx				phx 								; save target address
.31bd	48		pha				pha
.31be	ad 1f 06	lda $061f			lda 	VARType 					; type ID.
.31c1	29 01		and #$01			and 	#1 							; 0 = Number, 1 = String.
.31c3	20 e9 31	jsr $31e9			jsr 	CreateArray 				; create array to XA
.31c6	84 20		sty $20				sty 	zTemp1 						; save Y
.31c8	7a		ply				ply 								; restore target to zTemp0
.31c9	84 1e		sty $1e				sty 	zTemp0
.31cb	7a		ply				ply
.31cc	84 1f		sty $1f				sty 	zTemp0+1
.31ce	92 1e		sta ($1e)			sta 	(zTemp0) 					; save new array
.31d0	a0 01		ldy #$01			ldy 	#1
.31d2	8a		txa				txa
.31d3	91 1e		sta ($1e),y			sta 	(zTemp0),y
.31d5	a4 20		ldy $20				ldy 	zTemp1 						; restore zTemp1
.31d7	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 				; check )
.31da	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; if a comma, consume and go round again.
.31dc	c8		iny				iny
.31dd	c9 99		cmp #$99			cmp 	#PR_COMMA
.31df	f0 c1		beq $31a2			beq 	CommandDIM
.31e1	88		dey				dey
.31e2	60		rts				rts
.31e3					_CDSyntax:
.31e3	4c ce 43	jmp $43ce		jmp	ErrorV_syntax
.31e6					_CDExists:
.31e6	4c 8b 44	jmp $448b		jmp	ErrorV_redefine
.31e9					CreateArray:
.31e9	8d 04 05	sta $0504			sta 	CAType						; save type
.31ec	20 15 36	jsr $3615			jsr 	EXPEvalInteger16 			; get array dimension to R0
.31ef	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; does a comma follow, if so, 2 dimensions
.31f1	c9 99		cmp #$99			cmp 	#PR_COMMA
.31f3	f0 04		beq $31f9			beq 	_CATwoDimensions
.31f5	20 45 32	jsr $3245			jsr 	CreateSingleArray 			; create a lowest level array (e.g. data)
.31f8	60		rts				rts
.31f9					_CATwoDimensions:
.31f9	a5 0d		lda $0d				lda 	IFR0+IM1 					; copy outer dimension to CADim1
.31fb	8d 06 05	sta $0506			sta 	CADim1+1
.31fe	a5 0c		lda $0c				lda 	IFR0+IM0
.3200	8d 05 05	sta $0505			sta 	CADim1+0
.3203	20 55 45	jsr $4555			jsr 	ERRCheckComma 				; check comma
.3206	20 15 36	jsr $3615			jsr 	EXPEvalInteger16 			; calculate size of 2nd dimension.
.3209	5a		phy				phy 								; save Y position
.320a	18		clc				clc 								; allocate the outer array of pointers.
.320b	ae 06 05	ldx $0506			ldx 	CADim1+1
.320e	ad 05 05	lda $0505			lda 	CADim1
.3211	20 84 32	jsr $3284			jsr 	CSAAllocate 				; allocate the outer array
.3214	da		phx				phx									; save this address on the stack
.3215	48		pha				pha
.3216	86 23		stx $23				stx 	zTemp2+1					; and in zTemp2
.3218	85 22		sta $22				sta 	zTemp2
.321a					_CACreateSubLoop:
.321a	38		sec				sec
.321b	20 45 32	jsr $3245			jsr 	CreateSingleArray 			; create data array of required size.
.321e	a0 02		ldy #$02			ldy 	#2 							; save two on missing the two byte header.
.3220	91 22		sta ($22),y			sta 	(zTemp2),y
.3222	8a		txa				txa
.3223	c8		iny				iny
.3224	91 22		sta ($22),y			sta 	(zTemp2),y
.3226	18		clc				clc  								; next slot.
.3227	a5 22		lda $22				lda 	zTemp2
.3229	69 02		adc #$02			adc 	#2
.322b	85 22		sta $22				sta 	zTemp2
.322d	90 02		bcc $3231			bcc 	_CACNoCarry
.322f	e6 23		inc $23				inc 	zTemp2+1
.3231					_CACNoCarry:
.3231	ad 05 05	lda $0505			lda 	CADim1 						; use DIM1 as a counter
.3234	d0 03		bne $3239			bne 	_CACNoBorrow
.3236	ce 06 05	dec $0506			dec 	CADim1+1
.3239					_CACNoBorrow:
.3239	ce 05 05	dec $0505			dec 	CADim1
.323c	ad 06 05	lda $0506			lda 	CADim1+1 					; but do one more.
.323f	10 d9		bpl $321a			bpl 	_CACreateSubLoop
.3241	68		pla				pla
.3242	fa		plx				plx
.3243	7a		ply				ply
.3244	60		rts				rts
.3245					CreateSingleArray:
.3245	5a		phy				phy
.3246	38		sec				sec 								; allocate memory block all zeros.
.3247	a5 0c		lda $0c				lda 	IFR0+IM0
.3249	a6 0d		ldx $0d				ldx 	IFR0+IM1
.324b	20 84 32	jsr $3284			jsr 	CSAAllocate
.324e	ac 04 05	ldy $0504			ldy 	CAType 						; if numbers, we don't need to initialise.
.3251	f0 2f		beq $3282			beq 	_CSANoInit
.3253	da		phx				phx 								; save address of new array
.3254	48		pha				pha
.3255	85 1e		sta $1e				sta 	zTemp0 						; address in zTemp0
.3257	86 1f		stx $1f				stx 	zTemp0+1
.3259	a0 01		ldy #$01			ldy 	#1 							; count in YX - cannot be zero.
.325b	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.325d	a8		tay				tay
.325e	b2 1e		lda ($1e)			lda 	(zTemp0)
.3260	aa		tax				tax
.3261					_CSAEraseString:
.3261	5a		phy				phy
.3262	a0 05		ldy #$05			ldy 	#5 							; 2 initial + 3 on
.3264	a9 80		lda #$80			lda 	#$80
.3266	91 1e		sta ($1e),y			sta 	(zTemp0),y
.3268	7a		ply				ply
.3269	18		clc				clc 								; add 4 to next slot.
.326a	a5 1e		lda $1e				lda 	zTemp0
.326c	69 04		adc #$04			adc 	#4
.326e	85 1e		sta $1e				sta 	zTemp0
.3270	90 02		bcc $3274			bcc 	_CSAENoCarry
.3272	e6 1f		inc $1f				inc 	zTemp0+1
.3274					_CSAENoCarry:
.3274	e0 00		cpx #$00			cpx 	#0
.3276	d0 01		bne $3279			bne 	_CSANoBorrow
.3278	88		dey				dey
.3279					_CSANoBorrow:
.3279	ca		dex				dex
.327a	d0 e5		bne $3261			bne 	_CSAEraseString
.327c	c0 00		cpy #$00			cpy 	#0
.327e	d0 e1		bne $3261			bne 	_CSAEraseString
.3280	68		pla				pla
.3281	fa		plx				plx
.3282					_CSANoInit:
.3282	7a		ply				ply
.3283	60		rts				rts
.3284					CSAAllocate:
.3284	08		php				php 								; save type flag.
.3285	1a		inc a				inc 	a 							; add 1 because we store the size of the array block
.3286	d0 01		bne $3289			bne 	_CSAANoCarry 				; for A(10) this is 11 elements.
.3288	e8		inx				inx
.3289					_CSAANoCarry:
.3289	e0 20		cpx #$20			cpx 	#$20 						; basic range check
.328b	b0 2e		bcs $32bb			bcs 	_CSARange
.328d	28		plp				plp 								; restore type flag
.328e	08		php				php 								; save it back again.
.328f	da		phx				phx 								; save size.
.3290	48		pha				pha
.3291	86 1f		stx $1f				stx  	zTemp0+1 					; now in ztemp0+1:X
.3293	90 03		bcc $3298			bcc 	_CSAATimes2 				; if flag on entry clear multiply by 2, otherwise by 4.
.3295	0a		asl a				asl 	a
.3296	26 1f		rol $1f				rol 	zTemp0+1
.3298					_CSAATimes2:
.3298	0a		asl a				asl 	a
.3299	26 1f		rol $1f				rol 	zTemp0+1
.329b	18		clc				clc
.329c	69 02		adc #$02			adc 	#2 							; add 2 bytes for size.
.329e	90 02		bcc $32a2			bcc 	_CSAANoCarry2
.32a0	e6 1f		inc $1f				inc 	zTemp0+1
.32a2					_CSAANoCarry2:
.32a2	a6 1f		ldx $1f				ldx 	zTemp0+1 					; XA is the bytes required.
.32a4	20 6c 31	jsr $316c			jsr 	AllocateMemory 				; allocate memory to XA
.32a7	86 1f		stx $1f				stx 	zTemp0+1 					; save pointers
.32a9	85 1e		sta $1e				sta 	zTemp0
.32ab	68		pla				pla  								; write element count to first 2 bytes
.32ac	92 1e		sta ($1e)			sta 	(zTemp0)
.32ae	68		pla				pla 								; msb of element count
.32af	28		plp				plp 								; CC if pointer array
.32b0	b0 02		bcs $32b4			bcs 	_CSAAIsData
.32b2	09 80		ora #$80			ora 	#$80 						; set bit 7 of MSB indicating has sub arrays.
.32b4					_CSAAIsData:
.32b4	a0 01		ldy #$01			ldy 	#1
.32b6	91 1e		sta ($1e),y			sta 	(zTemp0),y
.32b8	a5 1e		lda $1e				lda 	zTemp0 						; fix XA back up again
.32ba	60		rts				rts
.32bb					_CSARange:
.32bb	4c de 43	jmp $43de		jmp	ErrorV_range
.0504					CAType:
>0504							.fill 	1
.0505					CADim1:
>0505							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/commands/dokepoke.asm

.32be					Command_Doke:
.32be	38		sec				sec
.32bf	80 01		bra $32c2			bra 	DPCommon
.32c1					Command_Poke:
.32c1	18		clc				clc
.32c2					DPCommon:
.32c2	08		php				php 								; CS if DOKE
.32c3	20 15 36	jsr $3615			jsr 	EXPEvalInteger16 			; address
.32c6	a5 0c		lda $0c				lda 	IFR0+IM0 					; push on stack
.32c8	48		pha				pha
.32c9	a5 0d		lda $0d				lda 	IFR0+IM1
.32cb	48		pha				pha
.32cc	20 55 45	jsr $4555			jsr 	ERRCheckComma 				; [dp]oke address,data
.32cf	20 15 36	jsr $3615			jsr 	EXPEvalInteger16
.32d2	68		pla				pla 								; get address back
.32d3	85 1f		sta $1f				sta 	zTemp0+1
.32d5	68		pla				pla
.32d6	85 1e		sta $1e				sta 	zTemp0
.32d8	a5 0c		lda $0c				lda 	IFR0+IM0
.32da	92 1e		sta ($1e)			sta 	(zTemp0)
.32dc	28		plp				plp
.32dd	90 08		bcc $32e7			bcc 	_DPExit
.32df	5a		phy				phy
.32e0	a5 0d		lda $0d				lda 	IFR0+IM1
.32e2	a0 01		ldy #$01			ldy 	#1
.32e4	91 1e		sta ($1e),y			sta 	(zTemp0),y
.32e6	7a		ply				ply
.32e7					_DPExit:
.32e7	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/inputprint.asm

.32e8					Command_Print:
.32e8					Command_IP_Main:
.32e8	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.32e9					_CPLoop:
.32e9	08		php				php 								; save last action flag
.32ea	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get next character
.32ec	c9 8c		cmp #$8c			cmp  	#PR_LSQLSQENDRSQRSQ 		; end of line or colon, exit now.
.32ee	f0 3e		beq $332e			beq 	_CPExit 					; without consuming
.32f0	c9 9b		cmp #$9b			cmp 	#PR_COLON
.32f2	f0 3a		beq $332e			beq 	_CPExit
.32f4	68		pla				pla 								; throw last action flag
.32f5	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; next character and bump
.32f7	c8		iny				iny
.32f8	c9 9a		cmp #$9a			cmp 	#PR_SEMICOLON				; is it a semicolon
.32fa	f0 2f		beq $332b			beq 	_CPContinueWithSameLine
.32fc	c9 99		cmp #$99			cmp 	#PR_COMMA 					; comma
.32fe	f0 26		beq $3326			beq 	_CPTab
.3300	88		dey				dey 								; undo the get.
.3301	20 c3 35	jsr $35c3			jsr 	EXPEvaluateExpression 		; evaluate expression.
.3304	24 0f		bit $0f				bit 	IFR0+IExp 					; is it a number ?
.3306	10 14		bpl $331c			bpl 	_CPNumber
.3308	5a		phy				phy
.3309	18		clc				clc 								; string address to YX
.330a	a5 0c		lda $0c				lda 	IFR0+IM0
.330c	aa		tax				tax
.330d	a5 0d		lda $0d				lda 	IFR0+IM1
.330f	a8		tay				tay
.3310	e8		inx				inx 								; point to 1st character
.3311	d0 01		bne $3314			bne 	_CPNoCarry
.3313	c8		iny				iny
.3314					_CPNoCarry:
.3314	b2 0c		lda ($0c)			lda 	(IFR0+IM0)					; length to A
.3316	20 37 33	jsr $3337			jsr 	CPPrintAYX 					; print AYX
.3319	7a		ply				ply
.331a	80 cc		bra $32e8			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.331c					_CPNumber:
.331c	5a		phy				phy
.331d	20 4b 4c	jsr $4c4b			jsr 	IFloatFloatToStringR0 		; convert to string at YX length A
.3320	20 37 33	jsr $3337			jsr 	CPPrintAYX 					; print AYX
.3323	7a		ply				ply
.3324	80 c2		bra $32e8			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.3326					_CPTab:
.3326	a9 09		lda #$09			lda 	#9 							; print TAB
.3328	20 4a 33	jsr $334a			jsr 	CPPrintA
.332b					_CPContinueWithSameLine:
.332b	38		sec				sec 								; loop round with carry set, which
.332c	80 bb		bra $32e9			bra 	_CPLoop 					; will inhibit final CR
.332e					_CPExit:
.332e	28		plp				plp 								; get last action flag
.332f	b0 05		bcs $3336			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.3331	a9 0d		lda #$0d			lda 	#13 						; print new line
.3333	20 4a 33	jsr $334a			jsr 	CPPrintA
.3336					_CPExit2:
.3336	60		rts				rts
.3337					CPPrintAYX:
.3337	86 1e		stx $1e				stx 	zTemp0
.3339	84 1f		sty $1f				sty 	zTemp0+1
.333b	aa		tax				tax
.333c	f0 0b		beq $3349			beq 	_CPPrintExit
.333e	a0 00		ldy #$00			ldy 	#0
.3340					_CPPrintAYXLoop:
.3340	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3342	20 4a 33	jsr $334a			jsr 	CPPrintA
.3345	c8		iny				iny
.3346	ca		dex				dex
.3347	d0 f7		bne $3340			bne 	_CPPrintAYXLoop
.3349					_CPPrintExit:
.3349	60		rts				rts
.334a					CPPrintA:
.334a	4c f1 ff	jmp $fff1			jmp 	OSWriteScreen

;******  Return to file: include.files


;******  Processing file: src/commands/let.asm

.334d					CommandLET:
.334d	20 8b 36	jsr $368b			jsr 	EXPTermR0 					; get term
.3350	90 6d		bcc $33bf			bcc 	_CLError 					; must be a reference term.
.3352	a5 0c		lda $0c				lda 	IFR0+IM0 					; push address and type onto stack
.3354	48		pha				pha
.3355	a5 0d		lda $0d				lda 	IFR0+IM1
.3357	48		pha				pha
.3358	a5 0f		lda $0f				lda 	IFR0+IExp
.335a	48		pha				pha
.335b	a9 ef		lda #$ef			lda 	#PR_EQUAL 					; equals for syntax
.335d	20 5d 45	jsr $455d			jsr 	ERRCheckA
.3360	20 c3 35	jsr $35c3			jsr 	EXPEvaluateExpression 		; right hand side.
.3363	68		pla				pla 								; type of l-expr
.3364	45 0f		eor $0f				eor 	IFR0+IExp 					; check types match
.3366	30 5a		bmi $33c2			bmi 	_CLType
.3368	fa		plx				plx 	 							; pop target address to zTemp0
.3369	86 1f		stx $1f				stx 	zTemp0+1
.336b	fa		plx				plx
.336c	86 1e		stx $1e				stx 	zTemp0
.336e	a5 0f		lda $0f				lda 	IFR0+IExp 					; string assignment
.3370	30 15		bmi $3387			bmi 	_CLStringAssign
.3372	5a		phy				phy
.3373	a0 03		ldy #$03			ldy 	#3
.3375	91 1e		sta ($1e),y			sta 	(zTemp0),y
.3377	88		dey				dey
.3378	a5 0e		lda $0e				lda 	IFR0+IM2
.337a	91 1e		sta ($1e),y			sta 	(zTemp0),y
.337c	88		dey				dey
.337d	a5 0d		lda $0d				lda 	IFR0+IM1
.337f	91 1e		sta ($1e),y			sta 	(zTemp0),y
.3381	a5 0c		lda $0c				lda 	IFR0+IM0
.3383	92 1e		sta ($1e)			sta 	(zTemp0)
.3385	7a		ply				ply
.3386	60		rts				rts
.3387					_CLStringAssign:
.3387	5a		phy				phy
.3388	a0 01		ldy #$01			ldy 	#1 							; check if any concreted string.
.338a	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.338c	12 1e		ora ($1e)			ora 	(zTemp0)
.338e	f0 23		beq $33b3			beq 	_CLConcreteString
.3390	b2 1e		lda ($1e)			lda 	(zTemp0) 					; copy address of string to zTemp1
.3392	85 20		sta $20				sta 	zTemp1
.3394	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3396	85 21		sta $21				sta 	zTemp1+1
.3398	b2 20		lda ($20)			lda 	(zTemp1) 					; bytes available in the new slot
.339a	38		sec				sec 								; we want 3 for slot size, status, string size.
.339b	e9 03		sbc #$03			sbc 	#3
.339d	d2 0c		cmp ($0c)			cmp 	(IFR0) 						; compare against string size.
.339f	90 12		bcc $33b3			bcc 	_CLConcreteString 			; if so, concrete the string again.
.33a1	b2 0c		lda ($0c)			lda 	(IFR0) 						; copy size + 1 bytes (for the length byte.)
.33a3	1a		inc a				inc 	a
.33a4	aa		tax				tax
.33a5	a0 00		ldy #$00			ldy 	#0 							; offset in replacement string.
.33a7					_CLReplaceString:
.33a7	b1 0c		lda ($0c),y			lda 	(IFR0),y 					; copy new string into previous space.
.33a9	c8		iny				iny
.33aa	c8		iny				iny
.33ab	91 20		sta ($20),y			sta 	(zTemp1),y
.33ad	88		dey				dey
.33ae	ca		dex				dex
.33af	d0 f6		bne $33a7			bne 	_CLReplaceString
.33b1	80 0a		bra $33bd			bra 	_CLExit
.33b3					_CLConcreteString:
.33b3	20 d0 45	jsr $45d0			jsr 	StringConcrete  			; concreted string in XA.
.33b6	a0 01		ldy #$01			ldy 	#1 							; store the address
.33b8	92 1e		sta ($1e)			sta 	(zTemp0)
.33ba	8a		txa				txa
.33bb	91 1e		sta ($1e),y			sta 	(zTemp0),y
.33bd					_CLExit:
.33bd	7a		ply				ply
.33be	60		rts				rts
.33bf					_CLError:
.33bf	4c f1 44	jmp $44f1		jmp	ErrorV_variable
.33c2					_CLType:
.33c2	4c fb 43	jmp $43fb		jmp	ErrorV_type

;******  Return to file: include.files


;******  Processing file: src/commands/new.asm

.33c5					Command_NEW:
.33c5	20 10 3e	jsr $3e10			jsr 	PGMNewProgram
.33c8	20 52 31	jsr $3152			jsr 	Command_CLEAR
.33cb	4c 28 34	jmp $3428			jmp 	Command_END

;******  Return to file: include.files


;******  Processing file: src/commands/rem.asm

.33ce					Command_REM:
.33ce					Command_REM2:
.33ce	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; optional string parameter
.33d0	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ
.33d2	d0 06		bne $33da			bne 	_CRExit
.33d4	c8		iny				iny 								; skip over it, it's a comment.
.33d5	98		tya				tya
.33d6	38		sec				sec
.33d7	71 1c		adc ($1c),y			adc 	(codePtr),y
.33d9	a8		tay				tay
.33da					_CRExit:
.33da	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/run.asm

.33db					Command_RUN:
.33db	20 52 31	jsr $3152			jsr 	Command_CLEAR 				; clear everything out.
.33de	ad 10 05	lda $0510			lda 	PGMBaseHigh 				; back to the program start
.33e1	85 1d		sta $1d				sta 	codePtr+1
.33e3	64 1c		stz $1c				stz 	codePtr
.33e5	80 0b		bra $33f2			bra 	RUNNewLine
.33e7					RUNEndOfLine:
.33e7	18		clc				clc 								; advance to next line.
.33e8	b2 1c		lda ($1c)			lda 	(codePtr)
.33ea	65 1c		adc $1c				adc 	codePtr
.33ec	85 1c		sta $1c				sta 	codePtr
.33ee	90 02		bcc $33f2			bcc 	_RELNoCarry
.33f0	e6 1d		inc $1d				inc 	codePtr+1
.33f2					_RELNoCarry:
.33f2					RUNNewLine:
.33f2	a2 ff		ldx #$ff			ldx 	#$FF 						; 6502 stack reset.
.33f4	9a		txs				txs
.33f5	b2 1c		lda ($1c)			lda 	(codePtr) 					; check off end of program
.33f7	f0 2f		beq $3428			beq 	Command_END
.33f9	a0 03		ldy #$03			ldy 	#3 							; offset into codePtr for start of line.
.33fb					RUNNewCommand:
.33fb	9c 17 06	stz $0617			stz 	stringInitialised 			; reset string system.
.33fe	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get next token
.3400	10 1a		bpl $341c			bpl		_RUNNotToken 				; probably an identifier
.3402	c8		iny				iny 								; consume token
.3403	c9 9b		cmp #$9b			cmp 	#PR_COLON 					; fast skip colon
.3405	f0 f4		beq $33fb			beq 	RUNNewCommand
.3407	c9 aa		cmp #$aa			cmp 	#PR_STANDARD_LAST+1 		; check unary function
.3409	b0 0e		bcs $3419			bcs 	_RUNSyntax
.340b	c9 80		cmp #$80			cmp 	#PR_STRUCTURE_FIRST 		; adjust for binaries at start.
.340d	90 0a		bcc $3419			bcc 	_RUNSyntax
.340f	0a		asl a				asl 	a 							; double into X.
.3410	aa		tax				tax
.3411	20 16 34	jsr $3416			jsr 	_RUNDispatchMain			; call the main dispatcher
.3414	80 e5		bra $33fb			bra 	RUNNewCommand
.3416					_RUNDispatchMain:
.3416	7c 26 3b	jmp ($3b26,x)			jmp 	(VectorTable,x)
.3419					_RUNSyntax:
.3419	4c ce 43	jmp $43ce		jmp	ErrorV_syntax
.341c					_RUNNotToken:
.341c	c9 40		cmp #$40			cmp 	#$40 						; 00-3F is a syntax error
.341e	90 f9		bcc $3419			bcc 	_RUNSyntax
.3420	20 4d 33	jsr $334d			jsr 	CommandLET 					; assignment
.3423	80 d6		bra $33fb			bra 	RUNNewCommand 				; loop round.
.3425					Command_Shift_Handler:
.3425	4c 0c 44	jmp $440c		jmp	ErrorV_unimplemented
.3428					Command_END:
.3428	4c ff ff	jmp $ffff			jmp 	$FFFF

;******  Return to file: include.files


;******  Processing file: src/commands/stop.asm

.342b					Command_STOP:
.342b	4c 69 44	jmp $4469		jmp	ErrorV_stop

;******  Return to file: include.files


;******  Processing file: src/commands/sys.asm

.342e					Command_Sys:
.342e	20 15 36	jsr $3615			jsr 	EXPEvalInteger16 			; execution address
.3431	5a		phy				phy
.3432	ad 62 06	lda $0662			lda 	('A'-'A')*4 + FastVariables ; load AXY
.3435	ae be 06	ldx $06be			ldx 	('X'-'A')*4 + FastVariables
.3438	ac c2 06	ldy $06c2			ldy 	('Y'-'A')*4 + FastVariables
.343b	20 40 34	jsr $3440			jsr 	_CSCallIFR0 				; call the code
.343e	7a		ply				ply
.343f	60		rts				rts
.3440					_CSCallIFR0:
.3440	6c 0c 00	jmp ($000c)			jmp 	(IFR0+IM0)

;******  Return to file: include.files


;******  Processing file: src/commands/unused.asm

.3443					NoExec01:
.3443					NoExec02:
.3443					NoExec03:
.3443					NoExec04:
.3443					NoExec05:
.3443					NoExec06:
.3443					NoExec07:
.3443					NoExec08:
.3443	4c ce 43	jmp $43ce		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/binary/basic.asm

.3446					EXPBinAdd:
.3446	24 0f		bit $0f				bit 	IFR0+IExp
.3448	30 6f		bmi $34b9			bmi 	EXPConcatenate
.344a	a2 10		ldx #$10			ldx 	#IFR1
.344c	4c 44 48	jmp $4844			jmp 	IFloatAdd
.344f					EXPBinSub:
.344f	24 0f		bit $0f				bit 	IFR0+IExp
.3451	30 3f		bmi $3492			bmi 	EXPTypeError
.3453	a2 10		ldx #$10			ldx 	#IFR1
.3455	4c 3d 48	jmp $483d			jmp 	IFloatSubtract
.3458					EXPBinMul:
.3458	24 0f		bit $0f				bit 	IFR0+IExp
.345a	30 36		bmi $3492			bmi 	EXPTypeError
.345c	a2 10		ldx #$10			ldx 	#IFR1
.345e	4c ee 48	jmp $48ee			jmp 	IFloatMultiply
.3461					EXPBinFDiv:
.3461	24 0f		bit $0f				bit 	IFR0+IExp
.3463	30 2d		bmi $3492			bmi 	EXPTypeError
.3465	a2 10		ldx #$10			ldx 	#IFR1
.3467	20 71 4b	jsr $4b71			jsr 	IFloatDivideFloat
.346a	b0 0f		bcs $347b			bcs 	EXPDZero
.346c	60		rts				rts
.346d					EXPBinIDiv:
.346d	24 0f		bit $0f				bit 	IFR0+IExp
.346f	30 21		bmi $3492			bmi 	EXPTypeError
.3471	a2 10		ldx #$10			ldx 	#IFR1
.3473	20 71 4b	jsr $4b71			jsr 	IFloatDivideFloat
.3476	b0 03		bcs $347b			bcs 	EXPDZero
.3478	4c 4e 4b	jmp $4b4e			jmp 	IFloatIntegerR0
.347b					EXPDZero:
.347b	4c 40 44	jmp $4440		jmp	ErrorV_divzero
.347e					EXPBinIMod:
.347e	24 0f		bit $0f				bit 	IFR0+IExp
.3480	30 10		bmi $3492			bmi 	EXPTypeError
.3482	a2 10		ldx #$10			ldx 	#IFR1
.3484	5a		phy				phy
.3485	20 86 4a	jsr $4a86			jsr 	IFPreProcessBitwise 		; set up everything.
.3488	d0 05		bne $348f			bne 	EXPDRange
.348a	20 bf 49	jsr $49bf			jsr 	IFloatModulusInteger
.348d	7a		ply				ply
.348e	60		rts				rts
.348f					EXPDRange:
.348f	4c de 43	jmp $43de		jmp	ErrorV_range
.3492					EXPTypeError:
.3492	4c fb 43	jmp $43fb		jmp	ErrorV_type
.3495					EXPBinAnd:
.3495	24 0f		bit $0f				bit 	IFR0+IExp
.3497	30 f9		bmi $3492			bmi 	EXPTypeError
.3499	a2 10		ldx #$10			ldx 	#IFR1
.349b	20 41 4a	jsr $4a41			jsr 	IFloatBitwiseAnd
.349e	b0 ef		bcs $348f			bcs 	EXPDRange
.34a0	60		rts				rts
.34a1					EXPBinOr:
.34a1	24 0f		bit $0f				bit 	IFR0+IExp
.34a3	30 ed		bmi $3492			bmi 	EXPTypeError
.34a5	a2 10		ldx #$10			ldx 	#IFR1
.34a7	20 58 4a	jsr $4a58			jsr 	IFloatBitwiseOr
.34aa	b0 e3		bcs $348f			bcs 	EXPDRange
.34ac	60		rts				rts
.34ad					EXPBinXor:
.34ad	24 0f		bit $0f				bit 	IFR0+IExp
.34af	30 e1		bmi $3492			bmi 	EXPTypeError
.34b1	a2 10		ldx #$10			ldx 	#IFR1
.34b3	20 6f 4a	jsr $4a6f			jsr 	IFloatBitwiseXor
.34b6	b0 d7		bcs $348f			bcs 	EXPDRange
.34b8	60		rts				rts
.34b9					EXPConcatenate:
.34b9	18		clc				clc
.34ba	b2 0c		lda ($0c)			lda 	(IFR0) 	 					; work out total length
.34bc	72 10		adc ($10)			adc 	(IFR1)
.34be	b0 2d		bcs $34ed			bcs 	_EXPCError
.34c0	a6 0c		ldx $0c				ldx 	IFR0 						; push R0 string on stack.
.34c2	da		phx				phx
.34c3	a6 0d		ldx $0d				ldx 	IFR0+1
.34c5	da		phx				phx
.34c6	20 43 46	jsr $4643			jsr 	StringTempAllocate 			; allocate string, set up return
.34c9	a6 11		ldx $11				ldx 	IFR1+1 						; copy first string.
.34cb	a5 10		lda $10				lda 	IFR1
.34cd	20 d6 34	jsr $34d6			jsr 	_EXPCCopyXA
.34d0	fa		plx				plx 								; copy second string
.34d1	68		pla				pla
.34d2	20 d6 34	jsr $34d6			jsr 	_EXPCCopyXA
.34d5	60		rts				rts
.34d6					_EXPCCopyXA:
.34d6	86 1f		stx $1f				stx 	zTemp0+1 					; save address to zTemp0
.34d8	85 1e		sta $1e				sta 	zTemp0
.34da	b2 1e		lda ($1e)			lda 	(zTemp0)					; length
.34dc	f0 0e		beq $34ec			beq 	_EXPCCExit 					; nothing.
.34de	aa		tax				tax 								; count
.34df	5a		phy				phy 								; start positioin
.34e0	a0 01		ldy #$01			ldy 	#1
.34e2					_EXPCCLoop:
.34e2	b1 1e		lda ($1e),y			lda 	(zTemp0),y 					; write characters one at a time.
.34e4	20 78 46	jsr $4678			jsr 	StringTempWrite
.34e7	c8		iny				iny
.34e8	ca		dex				dex
.34e9	d0 f7		bne $34e2			bne 	_EXPCCLoop
.34eb	7a		ply				ply
.34ec					_EXPCCExit:
.34ec	60		rts				rts
.34ed					_EXPCError:
.34ed	4c dc 44	jmp $44dc		jmp	ErrorV_string

;******  Return to file: include.files


;******  Processing file: src/expression/binary/compare.asm

.34f0					EXPReturnTrue:
.34f0	a2 0c		ldx #$0c			ldx 	#IFR0
.34f2	a9 01		lda #$01			lda 	#1
.34f4	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.34f7	20 59 4e	jsr $4e59			jsr 	IFloatNegate
.34fa	60		rts				rts
.34fb					EXPReturnFalse:
.34fb	a2 0c		ldx #$0c			ldx 	#IFR0
.34fd	4c 4e 4e	jmp $4e4e			jmp 	IFloatSetZero
.3500					EXPCompareEqual:
.3500	20 36 35	jsr $3536			jsr 	EXPCompareBaseCode
.3503	c9 00		cmp #$00			cmp 	#0
.3505	f0 e9		beq $34f0			beq 	EXPReturnTrue
.3507	80 f2		bra $34fb			bra 	EXPReturnFalse
.3509					EXPCompareLess:
.3509	20 36 35	jsr $3536			jsr 	EXPCompareBaseCode
.350c	c9 ff		cmp #$ff			cmp 	#$FF
.350e	f0 e0		beq $34f0			beq 	EXPReturnTrue
.3510	80 e9		bra $34fb			bra 	EXPReturnFalse
.3512					EXPCompareGreater:
.3512	20 36 35	jsr $3536			jsr 	EXPCompareBaseCode
.3515	c9 01		cmp #$01			cmp 	#1
.3517	f0 d7		beq $34f0			beq 	EXPReturnTrue
.3519	80 e0		bra $34fb			bra 	EXPReturnFalse
.351b					EXPCompareNotEqual:
.351b	20 36 35	jsr $3536			jsr 	EXPCompareBaseCode
.351e	c9 00		cmp #$00			cmp 	#0
.3520	d0 ce		bne $34f0			bne 	EXPReturnTrue
.3522	80 d7		bra $34fb			bra 	EXPReturnFalse
.3524					EXPCompareLessEqual:
.3524	20 36 35	jsr $3536			jsr 	EXPCompareBaseCode
.3527	c9 01		cmp #$01			cmp 	#1
.3529	d0 c5		bne $34f0			bne 	EXPReturnTrue
.352b	80 ce		bra $34fb			bra 	EXPReturnFalse
.352d					EXPCompareGreaterEqual:
.352d	20 36 35	jsr $3536			jsr 	EXPCompareBaseCode
.3530	c9 ff		cmp #$ff			cmp 	#$FF
.3532	d0 bc		bne $34f0			bne 	EXPReturnTrue
.3534	80 c5		bra $34fb			bra 	EXPReturnFalse
.3536					EXPCompareBaseCode:
.3536	24 0f		bit $0f				bit 	IFR0+IExp 					; string compare ?
.3538	30 10		bmi $354a			bmi 	_EXCBCString
.353a	a2 10		ldx #$10			ldx 	#IFR1						; float compare
.353c	20 1c 4b	jsr $4b1c			jsr 	IFloatCompare
.353f	a5 0c		lda $0c				lda 	IFR0+IM0
.3541	f0 06		beq $3549			beq 	_EXCBCExit 					; return 0 if zero
.3543	24 0f		bit $0f				bit 	IFR0+IExp 					; return 1 if +ve
.3545	50 02		bvc $3549			bvc 	_EXCBCExit
.3547	a9 ff		lda #$ff			lda 	#255 						; return $FF if -ve
.3549					_EXCBCExit:
.3549	60		rts				rts
.354a					_EXCBCString:
.354a	5a		phy				phy
.354b	b2 0c		lda ($0c)			lda 	(IFR0) 						; length of smaller of the two in X.
.354d	d2 10		cmp ($10)			cmp 	(IFR1)
.354f	90 02		bcc $3553			bcc 	_EXCBCSmaller
.3551	b2 10		lda ($10)			lda 	(IFR1)
.3553					_EXCBCSmaller:
.3553	aa		tax				tax
.3554	f0 0d		beq $3563			beq 	_EXCBCMatches 				; if zero common length matches
.3556	a0 00		ldy #$00			ldy 	#0 							; match the strings.
.3558					_EXCBCCheckSmallerMatches:
.3558	c8		iny				iny 								; compare directly as far as common length
.3559	38		sec				sec
.355a	b1 10		lda ($10),y			lda 	(IFR1),y
.355c	f1 0c		sbc ($0c),y			sbc 	(IFR0),y
.355e	d0 08		bne $3568			bne 	_EXCBCExit2
.3560	ca		dex				dex
.3561	d0 f5		bne $3558			bne 	_EXCBCCheckSmallerMatches
.3563					_EXCBCMatches:
.3563	38		sec				sec
.3564	b2 10		lda ($10)			lda 	(IFR1) 						; common length matches. If same length equal
.3566	f2 0c		sbc ($0c)			sbc 	(IFR0)						; if len(r1) > len(r0) then r1 is longer
.3568					_EXCBCExit2:
.3568	7a		ply				ply
.3569	c9 00		cmp #$00			cmp 	#0
.356b	f0 04		beq $3571			beq 	_EXCBCReturn
.356d	30 03		bmi $3572			bmi 	_EXCBCFF
.356f	a9 01		lda #$01			lda 	#1
.3571					_EXCBCReturn:
.3571	60		rts				rts
.3572					_EXCBCFF:
.3572	a9 ff		lda #$ff			lda 	#$FF
.3574	60		rts				rts
.3575					_EXCBCRange:
.3575	4c de 43	jmp $43de		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/binary/shift.asm

.3578					EXPBinLeft:
.3578	a9 ff		lda #$ff			lda 	#$FF
.357a	8d 07 05	sta $0507			sta 	EXPShiftLeftFlag
.357d	4c 83 35	jmp $3583			jmp 	EXPShiftCommon
.3580					EXPBinRight:
.3580	9c 07 05	stz $0507			stz 	EXPShiftLeftFlag
.3583					EXPShiftCommon:
.3583	a5 0f		lda $0f				lda 	IFR0+IExp 					; both integers
.3585	05 13		ora $13				ora 	IFR1+IExp
.3587	29 7f		and #$7f			and 	#$7F
.3589	d0 35		bne $35c0			bne 	_EXPSRange
.358b	a5 0c		lda $0c				lda 	IFR0+IM0					; check shift >= 32
.358d	29 e0		and #$e0			and 	#$E0
.358f	05 0d		ora $0d				ora 	IFR0+IM1
.3591	05 0e		ora $0e				ora 	IFR0+IM2
.3593	d0 25		bne $35ba			bne 	_EXPSShiftZero 				; if so return zero
.3595	5a		phy				phy
.3596	a5 0c		lda $0c				lda 	IFR0+IM0 					; get shift
.3598	29 1f		and #$1f			and 	#$1F
.359a	f0 17		beq $35b3			beq 	_EXPSExit 					; exit if zero
.359c	a8		tay				tay
.359d					_EXPSLoop:
.359d	a2 10		ldx #$10			ldx 	#IFR1
.359f	2c 07 05	bit $0507			bit 	EXPShiftLeftFlag
.35a2	30 05		bmi $35a9			bmi 	_EXPSShiftLeft
.35a4	20 7d 4e	jsr $4e7d			jsr 	IFloatShiftRight
.35a7	80 07		bra $35b0			bra 	_EXPSContinue
.35a9					_EXPSShiftLeft:
.35a9	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.35ac	24 0e		bit $0e				bit 	IFR0+IM2 					; too many shifts
.35ae	30 10		bmi $35c0			bmi 	_EXPSRange
.35b0					_EXPSContinue:
.35b0	88		dey				dey
.35b1	d0 ea		bne $359d			bne 	_EXPSLoop
.35b3					_EXPSExit:
.35b3	a2 10		ldx #$10			ldx 	#IFR1
.35b5	20 df 4d	jsr $4ddf			jsr 	IFloatCopyFromRegister
.35b8	7a		ply				ply
.35b9	60		rts				rts
.35ba					_EXPSShiftZero:
.35ba	a2 0c		ldx #$0c			ldx 	#IFR0
.35bc	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.35bf	60		rts				rts
.35c0					_EXPSRange:
.35c0	4c de 43	jmp $43de		jmp	ErrorV_range
.0507					EXPShiftLeftFlag:
>0507							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/expression/expression.asm

.35c3					EXPEvaluateExpression:
.35c3	a9 00		lda #$00			lda 	#0 							; current precedence
.35c5					EXPEvaluateExpressionPrecedenceA:
.35c5	48		pha				pha
.35c6	20 40 36	jsr $3640			jsr 	EXPTermValueR0				; do first term.
.35c9					_EELoop:
.35c9	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; what follows needs to be a binary operator
.35cb	c9 ef		cmp #$ef			cmp 	#PR_BINARY_FIRST 			; binary tokens are the last ones up to $FF
.35cd	90 31		bcc $3600			bcc 	_EEExit
.35cf	aa		tax				tax 								; access the precedence of the operator.
.35d0	68		pla				pla 								; restore precedence.if >= operator precedence then exit
.35d1	dd 7e 38	cmp $387e,x			cmp 	BinaryPrecedence-PR_BINARY_FIRST,x
.35d4	b0 2b		bcs $3601			bcs 	_EEExit2
.35d6	48		pha				pha 								; save current precedence.
.35d7	da		phx				phx 								; save operator
.35d8	c8		iny				iny 								; consume operator
.35d9	da		phx				phx
.35da	a2 0c		ldx #$0c			ldx 	#IFR0 						; push R0 on the stack
.35dc	20 9d 4d	jsr $4d9d			jsr 	IFloatPushRx
.35df	fa		plx				plx
.35e0	bd 7e 38	lda $387e,x			lda 	BinaryPrecedence-PR_BINARY_FIRST,x
.35e3	20 c5 35	jsr $35c5			jsr 	EXPEvaluateExpressionPrecedenceA
.35e6	a2 10		ldx #$10			ldx 	#IFR1 						; pop LHS to R1.
.35e8	20 be 4d	jsr $4dbe			jsr 	IFloatPullRx
.35eb	fa		plx				plx 								; operator
.35ec	a5 0f		lda $0f				lda 	IFR0+IExp 					; if check types match.
.35ee	45 13		eor $13				eor 	IFR1+IExp
.35f0	30 08		bmi $35fa			bmi 	_EEType
.35f2					_EETypeOkay:
.35f2	8a		txa				txa
.35f3	0a		asl a				asl 	a 							; double -> X
.35f4	aa		tax				tax
.35f5	20 fd 35	jsr $35fd			jsr 	_EECallBinary 				; call the operator R0 := R1 <op> R0
.35f8	80 cf		bra $35c9			bra 	_EELoop
.35fa					_EEType:
.35fa	4c fb 43	jmp $43fb		jmp	ErrorV_type
.35fd					_EECallBinary:
.35fd	7c 26 3b	jmp ($3b26,x)			jmp 	(VectorTable,x)
.3600					_EEExit:
.3600	68		pla				pla 								; throw precedence
.3601					_EEExit2:
.3601	18		clc				clc
.3602	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/exprutils.asm

.3603					EXPEvalNumber:
.3603	20 c3 35	jsr $35c3			jsr 	EXPEvaluateExpression
.3606	24 0f		bit $0f				bit 	IFR0+IExp
.3608	30 01		bmi $360b			bmi 	EVUType
.360a	60		rts				rts
.360b					EVUType:
.360b	4c fb 43	jmp $43fb		jmp	ErrorV_type
.360e					EXPEvalInteger:
.360e	20 03 36	jsr $3603			jsr 	EXPEvalNumber 				; get number, coeerce to integer.
.3611	20 4e 4b	jsr $4b4e			jsr 	IFloatIntegerR0
.3614	60		rts				rts
.3615					EXPEvalInteger16:
.3615	20 0e 36	jsr $360e			jsr 	EXPEvalInteger
.3618	a5 0e		lda $0e				lda 	IFR0+IM2
.361a	d0 21		bne $363d			bne 	EVURange
.361c	a6 0d		ldx $0d				ldx 	IFR0+IM1
.361e	a5 0c		lda $0c				lda 	IFR0+IM0
.3620	60		rts				rts
.3621					EXPEvalInteger8:
.3621	20 0e 36	jsr $360e			jsr 	EXPEvalInteger
.3624	a5 0e		lda $0e				lda 	IFR0+IM2
.3626	05 0d		ora $0d				ora 	IFR0+IM1
.3628	d0 13		bne $363d			bne 	EVURange
.362a	a5 0c		lda $0c				lda 	IFR0+IM0
.362c	60		rts				rts
.362d					EXPEvalString:
.362d	20 c3 35	jsr $35c3			jsr 	EXPEvaluateExpression
.3630	24 0f		bit $0f				bit 	IFR0+IExp
.3632	10 d7		bpl $360b			bpl 	EVUType
.3634	a6 0d		ldx $0d				ldx 	IFR0+IM1
.3636	86 1f		stx $1f				stx 	zTemp0+1
.3638	a5 0c		lda $0c				lda 	IFR0+IM0
.363a	85 1e		sta $1e				sta 	zTemp0
.363c	60		rts				rts
.363d					EVURange:
.363d	4c de 43	jmp $43de		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/term.asm

.3640					EXPTermValueR0:
.3640	20 8b 36	jsr $368b			jsr 	EXPTermR0 					; get term
.3643	90 45		bcc $368a			bcc 	_ETVNotReference 			; exit if value.
.3645	5a		phy				phy
.3646	a0 03		ldy #$03			ldy 	#3 							; get type
.3648	b1 0c		lda ($0c),y			lda 	(IFR0),y
.364a	30 14		bmi $3660			bmi 	_ETVDereferenceString
.364c	85 0f		sta $0f				sta 	IFR0+IExp 					; dereference to R0
.364e	88		dey				dey
.364f	b1 0c		lda ($0c),y			lda 	(IFR0),y
.3651	85 0e		sta $0e				sta 	IFR0+IM2
.3653	88		dey				dey
.3654	b1 0c		lda ($0c),y			lda 	(IFR0),y
.3656	aa		tax				tax
.3657	b2 0c		lda ($0c)			lda 	(IFR0)
.3659	86 0d		stx $0d				stx 	IFR0+IM1
.365b	85 0c		sta $0c				sta 	IFR0+IM0
.365d	7a		ply				ply
.365e	18		clc				clc
.365f	60		rts				rts
.3660					_ETVDereferenceString:
.3660	a0 01		ldy #$01			ldy 	#1 							; check if it is as yet unassigned.
.3662	b1 0c		lda ($0c),y			lda 	(IFR0),y
.3664	12 0c		ora ($0c)			ora 	(IFR0)
.3666	f0 11		beq $3679			beq 	_ETVNull
.3668	b1 0c		lda ($0c),y			lda 	(IFR0),y 					; load address of string to XA
.366a	aa		tax				tax
.366b	b2 0c		lda ($0c)			lda 	(IFR0)
.366d	18		clc				clc 								; add two so points to actual string.
.366e	69 02		adc #$02			adc 	#2
.3670	90 01		bcc $3673			bcc 	_EVDSNoCarry
.3672	e8		inx				inx
.3673					_EVDSNoCarry:
.3673	86 0d		stx $0d				stx 	IFR0+IM1 					; save in slots
.3675	85 0c		sta $0c				sta 	IFR0
.3677	80 08		bra $3681			bra 	_ETVFillExit 				; tidy up and exit.
.3679					_ETVNull:
.3679	a9 89		lda #$89			lda 	#_EVTNString & $FF
.367b	85 0c		sta $0c				sta 	IFR0+IM0
.367d	a9 36		lda #$36			lda 	#_EVTNString >> 8
.367f	85 0d		sta $0d				sta 	IFR0+IM1
.3681					_ETVFillExit:
.3681	64 0e		stz $0e				stz 	IFR0+IM2
.3683	a9 80		lda #$80			lda 	#$80
.3685	85 0f		sta $0f				sta 	IFR0+IExp
.3687	7a		ply				ply
.3688	60		rts				rts
.3689					_EVTNString:
>3689	00						.byte 	0
.368a					_ETVNotReference:
.368a	60		rts				rts
.368b					EXPTermR0:
.368b	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get next token/element
.368d	30 10		bmi $369f			bmi 	_ETMIsUnaryOrMinus 			; if it's a token, it's a unary function, maybe -
.368f	c8		iny				iny 								; consume element
.3690	c9 40		cmp #$40			cmp 	#$40 						; 40-7F are identifiers.
.3692	b0 08		bcs $369c			bcs 	_ETMIdentifier
.3694	20 c3 36	jsr $36c3			jsr 	EXPExtractTokenisedInteger 	; pull out tokenised integer to R0
.3697	20 f6 36	jsr $36f6			jsr 	EXPCheckDecimalFollows 		; check for decimals.
.369a	18		clc				clc 								; return value
.369b	60		rts				rts
.369c					_ETMIdentifier:
.369c	4c e5 47	jmp $47e5			jmp 	VARCheckSimple 				; check simple variables A-Z
.369f					_ETMIsUnaryOrMinus:
.369f	c8		iny				iny 								; consume element
.36a0	c9 fe		cmp #$fe			cmp 	#PR_MINUS 					; handle - seperately as it has two roles.
.36a2	d0 0a		bne $36ae			bne 	_ETMCheckUnary
.36a4	20 40 36	jsr $3640			jsr 	EXPTermValueR0 				; get a term to negate
.36a7	a2 0c		ldx #$0c			ldx 	#IFR0 						; and negate it
.36a9	20 59 4e	jsr $4e59			jsr 	IFloatNegate
.36ac	18		clc				clc
.36ad	60		rts				rts
.36ae					_ETMCheckUnary:
.36ae	c9 d5		cmp #$d5			cmp 	#PR_UNARY_FIRST 			; check unary function.
.36b0	90 0e		bcc $36c0			bcc 	_ETMUnarySyntax
.36b2	c9 ef		cmp #$ef			cmp 	#PR_UNARY_LAST+1
.36b4	b0 0a		bcs $36c0			bcs 	_ETMUnarySyntax
.36b6	0a		asl a				asl 	a
.36b7	aa		tax				tax
.36b8	20 bd 36	jsr $36bd			jsr 	_ETMCallUnaryFunction
.36bb	18		clc				clc
.36bc	60		rts				rts
.36bd					_ETMCallUnaryFunction:
.36bd	7c 26 3b	jmp ($3b26,x)			jmp 	(VectorTable,x)
.36c0					_ETMUnarySyntax:
.36c0	4c ce 43	jmp $43ce		jmp	ErrorV_syntax
.36c3					EXPExtractTokenisedInteger:
.36c3	85 0c		sta $0c				sta 	IFR0+IM0 					; initial value in IM0
.36c5	64 0f		stz $0f				stz 	IFR0+IExp
.36c7	64 0d		stz $0d				stz 	IFR0+IM1
.36c9	64 0e		stz $0e				stz 	IFR0+IM2
.36cb					_ETMConstant:
.36cb	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; what follows.
.36cd	c9 40		cmp #$40			cmp 	#$40 						; continuing constant
.36cf	b0 24		bcs $36f5			bcs 	_ETMCExit 					; no.
.36d1	a6 0e		ldx $0e				ldx 	IFR0+IM2 					; x 256 into A:M2 M1 M0
.36d3	a5 0d		lda $0d				lda 	IFR0+IM1
.36d5	85 0e		sta $0e				sta 	IFR0+IM2
.36d7	a5 0c		lda $0c				lda 	IFR0+IM0
.36d9	85 0d		sta $0d				sta 	IFR0+IM1
.36db	64 0c		stz $0c				stz 	IFR0+IM0
.36dd	8a		txa				txa
.36de	4a		lsr a				lsr 	a 							; shift right twice, e.g. whole thing is x 64
.36df	66 0e		ror $0e				ror 	IFR0+IM2
.36e1	66 0d		ror $0d				ror 	IFR0+IM1
.36e3	66 0c		ror $0c				ror 	IFR0+IM0
.36e5	4a		lsr a				lsr 	a
.36e6	66 0e		ror $0e				ror 	IFR0+IM2
.36e8	66 0d		ror $0d				ror 	IFR0+IM1
.36ea	66 0c		ror $0c				ror 	IFR0+IM0
.36ec	a5 0c		lda $0c				lda 	IFR0+IM0 					; LSB in.
.36ee	11 1c		ora ($1c),y			ora 	(codePtr),y
.36f0	85 0c		sta $0c				sta 	IFR0+IM0
.36f2	c8		iny				iny 								; consume, loop back
.36f3	80 d6		bra $36cb			bra 	_ETMConstant
.36f5					_ETMCExit:
.36f5	60		rts				rts
.36f6					EXPCheckDecimalFollows:
.36f6	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; check for decimal
.36f8	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ
.36fa	d0 19		bne $3715			bne 	_ETMCDExit
.36fc	c8		iny				iny 								; consume token.
.36fd	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get count
.36ff	5a		phy				phy									; save current position
.3700	48		pha				pha 								; save count of chars.
.3701	38		sec				sec 								; address into YX : y + codePtr+1
.3702	98		tya				tya
.3703	65 1c		adc $1c				adc 	codePtr
.3705	aa		tax				tax
.3706	a5 1d		lda $1d				lda 	codePtr+1
.3708	69 00		adc #$00			adc 	#0
.370a	a8		tay				tay
.370b	68		pla				pla 								; get count.
.370c	20 f2 4c	jsr $4cf2			jsr 	IFloatAddDecimalToR0 		; add the decimal to R0
.370f	7a		ply				ply 								; go to next token.
.3710	98		tya				tya
.3711	38		sec				sec
.3712	71 1c		adc ($1c),y			adc 	(codePtr),y
.3714	a8		tay				tay
.3715					_ETMCDExit:
.3715	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/abs.asm

.3716					EXPUnaryAbs:
.3716	20 03 36	jsr $3603			jsr 	EXPEvalNumber 					; number to R0
.3719	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.371c	20 92 4a	jsr $4a92			jsr 	IFloatAbsoluteR0
.371f	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/asc.asm

.3720					EXPUnaryAsc:
.3720	20 2d 36	jsr $362d			jsr 	EXPEvalString 					; string to R0, zTemp0
.3723	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.3726	b2 1e		lda ($1e)			lda 	(zTemp0) 						; length 0 ?
.3728	f0 06		beq $3730			beq 	_EXAZero 						; if so return 0
.372a	5a		phy				phy 									; otherwise get first character
.372b	a0 01		ldy #$01			ldy 	#1
.372d	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.372f	7a		ply				ply
.3730					_EXAZero:
.3730	a2 0c		ldx #$0c			ldx 	#IFR0
.3732	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.3735	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/chr.asm

.3736					EXPUnaryChr:
.3736	20 21 36	jsr $3621			jsr 	EXPEvalInteger8 				; expr
.3739	48		pha				pha 									; push on stack
.373a	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.373d	a9 01		lda #$01			lda 	#1 								; alloc temp mem for result
.373f	20 43 46	jsr $4643			jsr 	StringTempAllocate
.3742	68		pla				pla
.3743	20 78 46	jsr $4678			jsr 	StringTempWrite
.3746	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/dec.asm

.3747					EXPUnaryDec:
.3747	20 2d 36	jsr $362d			jsr 	EXPEvalString 					; string to R0, zTemp0
.374a	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.374d	5a		phy				phy
.374e	a2 0c		ldx #$0c			ldx 	#IFR0 							; zero the result
.3750	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.3753	b2 1e		lda ($1e)			lda 	(zTemp0)						; read the length to X
.3755	f0 3b		beq $3792			beq 	_EUDError 						; empty string
.3757	aa		tax				tax
.3758	a0 01		ldy #$01			ldy 	#1 								; start at offset 1
.375a					_EUDLoop:
.375a	b1 1e		lda ($1e),y			lda 	(zTemp0),y 						; get next
.375c	c9 61		cmp #$61			cmp 	#"a" 							; l/c -> u/c
.375e	90 02		bcc $3762			bcc 	_EUDNoCase
.3760	e9 20		sbc #$20			sbc 	#$20
.3762					_EUDNoCase:
.3762	c9 30		cmp #$30			cmp 	#'0' 							; check 0..9
.3764	90 2c		bcc $3792			bcc 	_EUDError
.3766	c9 3a		cmp #$3a			cmp 	#'9'+1
.3768	90 0a		bcc $3774			bcc 	_EUDOkay
.376a	c9 41		cmp #$41			cmp 	#'A'							; check A-F
.376c	90 24		bcc $3792			bcc 	_EUDError
.376e	c9 47		cmp #$47			cmp 	#'F'+1
.3770	b0 20		bcs $3792			bcs 	_EUDError
.3772	e9 06		sbc #$06			sbc 	#6 								; hex adjust
.3774					_EUDOkay:
.3774	29 0f		and #$0f			and 	#15 							; make constant
.3776	da		phx				phx
.3777	48		pha				pha
.3778	a2 0c		ldx #$0c			ldx 	#IFR0 							; multiply R0 x 16
.377a	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.377d	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3780	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3783	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3786	68		pla				pla 									; pop constant and OR in
.3787	fa		plx				plx
.3788	05 0c		ora $0c				ora 	IFR0+IM0
.378a	85 0c		sta $0c				sta 	IFR0+IM0
.378c	c8		iny				iny 									; next
.378d	ca		dex				dex
.378e	d0 ca		bne $375a			bne 	_EUDLoop
.3790	7a		ply				ply
.3791	60		rts				rts
.3792					_EUDError:
.3792	4c ee 43	jmp $43ee		jmp	ErrorV_value

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/decimal.asm

.3795					EXPUnaryInlineDec:
.3795	4c ce 43	jmp $43ce		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/deekpeek.asm

.3798					EXPUnaryPeek:
.3798	20 15 36	jsr $3615			jsr 	EXPEvalInteger16 				; number to R0
.379b	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.379e	b2 0c		lda ($0c)			lda 	(IFR0)
.37a0	a2 0c		ldx #$0c			ldx 	#IFR0
.37a2	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.37a5	60		rts				rts
.37a6					EXPUnaryDeek:
.37a6	20 15 36	jsr $3615			jsr 	EXPEvalInteger16 				; number to R0
.37a9	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.37ac	5a		phy				phy
.37ad	a0 01		ldy #$01			ldy 	#1
.37af	b1 0c		lda ($0c),y			lda 	(IFR0),y
.37b1	7a		ply				ply
.37b2	48		pha				pha
.37b3	b2 0c		lda ($0c)			lda 	(IFR0)
.37b5	a2 0c		ldx #$0c			ldx 	#IFR0
.37b7	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.37ba	68		pla				pla
.37bb	85 0d		sta $0d				sta 	IFR0+IM1
.37bd	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/dollar.asm

.37be					EXPUnaryNull:
.37be	20 40 36	jsr $3640			jsr 	EXPTermValueR0
.37c1	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/fractional.asm

.37c2					EXPUnaryFrac:
.37c2	20 03 36	jsr $3603			jsr 	EXPEvalNumber 					; number to R0
.37c5	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.37c8	20 f8 4a	jsr $4af8			jsr 	IFloatFractionalR0
.37cb	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/intfn.asm

.37cc					EXPUnaryInt:
.37cc	20 03 36	jsr $3603			jsr 	EXPEvalNumber 					; number to R0
.37cf	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.37d2	20 4e 4b	jsr $4b4e			jsr 	IFloatIntegerR0
.37d5	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/len.asm

.37d6					EXPUnaryLen:
.37d6	20 2d 36	jsr $362d			jsr 	EXPEvalString 					; string to R0, zTemp0
.37d9	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.37dc	b2 1e		lda ($1e)			lda 	(zTemp0)
.37de	a2 0c		ldx #$0c			ldx 	#IFR0
.37e0	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.37e3	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/parenthesis.asm

.37e4					EXPUnaryParenthesis:
.37e4	20 03 36	jsr $3603			jsr 	EXPEvalNumber 					; number to R0
.37e7	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.37ea	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/random.asm

.37eb					EXPUnaryRnd:
.37eb	20 03 36	jsr $3603			jsr 	EXPEvalNumber 				; number to R0
.37ee	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 				; )
.37f1	a2 0c		ldx #$0c			ldx 	#IFR0
.37f3	20 0a 38	jsr $380a			jsr 	EXPLoadInRandom
.37f6	a9 29		lda #$29			lda 	#64-23 						; hack the exponent to make it work.
.37f8	85 0f		sta $0f				sta 	IFR0+IExp
.37fa	60		rts				rts
.37fb					ExpUnaryRand:
.37fb	20 0e 36	jsr $360e			jsr 	EXPEvalInteger 				; integer to R0
.37fe	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 				; )
.3801	a2 10		ldx #$10			ldx 	#IFR1 						; random to R1
.3803	20 0a 38	jsr $380a			jsr 	EXPLoadInRandom
.3806	20 bf 49	jsr $49bf			jsr 	IFloatModulusInteger 		; calculate mod r1,r2
.3809	60		rts				rts
.380a					EXPLoadInRandom:
.380a	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.380d	20 1f 38	jsr $381f			jsr 	EXPRandom32
.3810	95 00		sta $00,x			sta 	IM0,x
.3812	20 1f 38	jsr $381f			jsr 	EXPRandom32
.3815	95 01		sta $01,x			sta 	IM1,x
.3817	20 1f 38	jsr $381f			jsr 	EXPRandom32
.381a	29 7f		and #$7f			and 	#$7F
.381c	95 02		sta $02,x			sta 	IM2,x
.381e	60		rts				rts
.381f					EXPRandom32:
.381f	5a		phy				phy
.3820	a0 08		ldy #$08			ldy 	#8
.3822	ad 08 05	lda $0508			lda 	EXPSeed+0
.3825	0d 09 05	ora $0509			ora 	EXPSeed+1
.3828	0d 0a 05	ora $050a			ora 	EXPSeed+2
.382b	0d 0b 05	ora $050b			ora 	EXPSeed+3
.382e	d0 08		bne $3838			bne 	_EXPRNoReset
.3830	ee 08 05	inc $0508			inc 	EXPSeed+0
.3833	a0 10		ldy #$10			ldy 	#16
.3835	8c 0b 05	sty $050b			sty 	EXPSeed+3
.3838					_EXPRNoReset:
.3838	ad 08 05	lda $0508			lda 	EXPSeed+0
.383b					_EXPRLoop:
.383b	0a		asl a				asl		a
.383c	2e 09 05	rol $0509			rol 	EXPSeed+1
.383f	2e 0a 05	rol $050a			rol 	EXPSeed+2
.3842	2e 0b 05	rol $050b			rol 	EXPSeed+3
.3845	90 02		bcc $3849			bcc 	_EXPRNoEOR
.3847	49 c5		eor #$c5			eor 	#$C5
.3849					_EXPRNoEOR:
.3849	88		dey				dey
.384a	d0 ef		bne $383b			bne 	_EXPRLoop
.384c	8d 08 05	sta $0508			sta 	EXPSeed+0
.384f	7a		ply				ply
.3850	60		rts				rts
.0508					EXPSeed:
>0508							.fill 	4

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sgn.asm

.3851					EXPUnarySgn:
.3851	20 03 36	jsr $3603			jsr 	EXPEvalNumber 					; number to R0
.3854	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.3857	a2 10		ldx #$10			ldx 	#IFR1 							; copy to R1
.3859	20 f0 4d	jsr $4df0			jsr 	IFloatCopyToRegister
.385c	a2 0c		ldx #$0c			ldx 	#IFR0 							; R0 = 0
.385e	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.3861	a2 10		ldx #$10			ldx 	#IFR1
.3863	20 1c 4b	jsr $4b1c			jsr 	IFloatCompare 					; compare R1 vs 0.
.3866	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sqr.asm

.3867					EXPUnarySqr:
.3867	20 03 36	jsr $3603			jsr 	EXPEvalNumber 					; number to R0
.386a	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.386d	20 9a 4a	jsr $4a9a			jsr 	IFloatSquareRootR0 				; square root.
.3870	b0 01		bcs $3873			bcs 	_EUSValue
.3872	60		rts				rts
.3873					_EUSValue:
.3873	4c de 43	jmp $43de		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/strhex.asm

.3876					EXPUnaryHex:
.3876	20 0e 36	jsr $360e			jsr 	EXPEvalInteger 					; expr
.3879	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.387c	5a		phy				phy
.387d	a9 10		lda #$10			lda 	#16
.387f	20 ef 4b	jsr $4bef			jsr 	IFloatIntegerToStringR0
.3882	80 0a		bra $388e			bra 	EUSMain
.3884					EXPUnaryStr:
.3884	20 03 36	jsr $3603			jsr 	EXPEvalNumber 					; expr
.3887	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.388a	5a		phy				phy
.388b	20 4b 4c	jsr $4c4b			jsr 	IFloatFloatToStringR0 			; convert to string
.388e					EUSMain:
.388e	b0 18		bcs $38a8			bcs 	_EUSError
.3890	86 1e		stx $1e				stx 	zTemp0 							; save string address
.3892	84 1f		sty $1f				sty 	zTemp0+1
.3894	48		pha				pha 									; save count
.3895	a9 20		lda #$20			lda 	#32 							; allocate space for result.
.3897	20 43 46	jsr $4643			jsr 	StringTempAllocate
.389a	fa		plx				plx 									; count in X
.389b	a0 00		ldy #$00			ldy 	#0
.389d					_EUSCopy:
.389d	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.389f	c8		iny				iny
.38a0	20 78 46	jsr $4678			jsr 	StringTempWrite
.38a3	ca		dex				dex
.38a4	d0 f7		bne $389d			bne	 	_EUSCopy
.38a6	7a		ply				ply
.38a7	60		rts				rts
.38a8					_EUSError:
.38a8	4c de 43	jmp $43de		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/string.asm

.38ab					EXPUnaryInlineString:
.38ab	18		clc				clc 								; physical address -> IM0,1
.38ac	98		tya				tya
.38ad	65 1c		adc $1c				adc 	codePtr
.38af	85 0c		sta $0c				sta 	IFR0+IM0
.38b1	a5 1d		lda $1d				lda 	codePtr+1
.38b3	69 00		adc #$00			adc 	#0
.38b5	85 0d		sta $0d				sta 	IFR0+IM1
.38b7	64 0e		stz $0e				stz 	IFR0+IM2 					; fill in rest
.38b9	a9 80		lda #$80			lda 	#$80
.38bb	85 0f		sta $0f				sta 	IFR0+IExp
.38bd	98		tya				tya	 								; skip over it.
.38be	38		sec				sec
.38bf	71 1c		adc ($1c),y			adc 	(codePtr),y
.38c1	a8		tay				tay
.38c2	60		rts				rts
.38c3					_EXPUISRange:
.38c3	4c de 43	jmp $43de		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/substring.asm

.38c6					EXPUnaryLeft:
.38c6	20 0c 39	jsr $390c			jsr 	EXPCommonStart 					; <string>,
.38c9	48		pha				pha 									; save string address on stack
.38ca	da		phx				phx
.38cb	a9 00		lda #$00			lda 	#0 								; start position (zero offset)
.38cd	48		pha				pha
.38ce	20 21 36	jsr $3621			jsr 	EXPEvalInteger8 				; characters to do
.38d1	80 44		bra $3917			bra 	EXPSubstringCommon
.38d3					EXPUnaryRight:
.38d3	20 0c 39	jsr $390c			jsr 	EXPCommonStart 					; <string>,
.38d6	48		pha				pha 									; save string address on stack
.38d7	da		phx				phx
.38d8	b2 0c		lda ($0c)			lda 	(IFR0) 							; the string length => stack.
.38da	48		pha				pha
.38db	20 21 36	jsr $3621			jsr 	EXPEvalInteger8 				; characters to do
.38de	85 1e		sta $1e				sta 	zTemp0 							; calculate length - required, start point.
.38e0	68		pla				pla
.38e1	38		sec				sec
.38e2	e5 1e		sbc $1e				sbc 	zTemp0
.38e4	b0 02		bcs $38e8			bcs 	_EUROffLeft
.38e6	a9 00		lda #$00			lda 	#0
.38e8					_EUROffLeft:
.38e8	48		pha				pha 									; start pos
.38e9	a9 ff		lda #$ff			lda 	#255
.38eb	80 2a		bra $3917			bra 	EXPSubstringCommon
.38ed					EXPUnaryMid:
.38ed	20 0c 39	jsr $390c			jsr 	EXPCommonStart 					; <string>,
.38f0	48		pha				pha 									; save string address on stack
.38f1	da		phx				phx
.38f2	20 21 36	jsr $3621			jsr 	EXPEvalInteger8 				; characters start
.38f5	f0 12		beq $3909			beq 	_EUSError 						; 1 is left
.38f7	3a		dec a				dec 	a 								; zero based.
.38f8	48		pha				pha
.38f9	b1 1c		lda ($1c),y			lda 	(codePtr),y 					; comma follows
.38fb	c9 99		cmp #$99			cmp 	#PR_COMMA
.38fd	f0 04		beq $3903			beq 	_EUMLength 						; if so m is provided
.38ff	a9 ff		lda #$ff			lda 	#255 							; default m
.3901	80 14		bra $3917			bra 	EXPSubstringCommon
.3903					_EUMLength:
.3903	c8		iny				iny 									; consume comma
.3904	20 21 36	jsr $3621			jsr 	EXPEvalInteger8 				; characters to do
.3907	80 0e		bra $3917			bra 	EXPSubstringCommon
.3909					_EUSError:
.3909	4c ee 43	jmp $43ee		jmp	ErrorV_value
.390c					EXPCommonStart:
.390c	20 2d 36	jsr $362d			jsr 	EXPEvalString
.390f	20 55 45	jsr $4555			jsr 	ERRCheckComma
.3912	a5 0c		lda $0c				lda 	IFR0+IM0
.3914	a6 0d		ldx $0d				ldx 	IFR0+IM1
.3916	60		rts				rts
.3917					EXPSubstringCommon:
.3917	85 20		sta $20				sta 	zTemp1 							; count to do in zTemp1.
.3919	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; check right bracket.
.391c	68		pla				pla 									; start position
.391d	85 21		sta $21				sta 	zTemp1+1 						; save in zTemp1+1
.391f	fa		plx				plx 									; get string address to zTemp2.
.3920	86 23		stx $23				stx 	zTemp2+1
.3922	68		pla				pla
.3923	85 22		sta $22				sta 	zTemp2
.3925	38		sec				sec 									; length - start is the max count of chars
.3926	b2 22		lda ($22)			lda 	(zTemp2)
.3928	e5 21		sbc $21				sbc 	zTemp1+1
.392a	c5 20		cmp $20				cmp 	zTemp1 							; if available < count
.392c	b0 02		bcs $3930			bcs 	_EXPSSNoTrim
.392e	85 20		sta $20				sta 	zTemp1 							; update count with available
.3930					_EXPSSNoTrim:
.3930	a5 20		lda $20				lda 	zTemp1 							; chars required.
.3932	20 43 46	jsr $4643			jsr 	StringTempAllocate 				; allocate memory for it.
.3935	a5 20		lda $20				lda 	zTemp1 							; zero length string
.3937	f0 15		beq $394e			beq 	_EXPSSExit
.3939	a5 21		lda $21				lda 	zTemp1+1 						; if length >= start exit
.393b	d2 22		cmp ($22)			cmp 	(zTemp2)
.393d	b0 0f		bcs $394e			bcs 	_EXPSSExit
.393f	5a		phy				phy
.3940	a4 21		ldy $21				ldy 	zTemp1+1 						; start position
.3942	c8		iny				iny 									; +1 for the length byte
.3943					_EXPSSCopy:
.3943	b1 22		lda ($22),y			lda 	(zTemp2),y
.3945	20 78 46	jsr $4678			jsr 	StringTempWrite
.3948	c8		iny				iny
.3949	c6 20		dec $20				dec 	zTemp1
.394b	d0 f6		bne $3943			bne 	_EXPSSCopy
.394d	7a		ply				ply
.394e					_EXPSSExit:
.394e	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/val.asm

.394f					EXPUnaryVal:
.394f	20 2d 36	jsr $362d			jsr 	EXPEvalString 					; string to R0, zTemp0
.3952	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 					; )
.3955	5a		phy				phy
.3956	18		clc				clc
.3957	a5 1e		lda $1e				lda		zTemp0 							; point XY to the text
.3959	69 01		adc #$01			adc 	#1
.395b	aa		tax				tax
.395c	a5 1f		lda $1f				lda 	zTemp0+1
.395e	69 00		adc #$00			adc 	#0
.3960	a8		tay				tay
.3961	b2 1e		lda ($1e)			lda 	(zTemp0) 						; get length.
.3963	20 b2 4c	jsr $4cb2			jsr 	IFloatStringToFloatR0 			; do conversion
.3966	b0 02		bcs $396a			bcs 	_EUVError
.3968	7a		ply				ply
.3969	60		rts				rts
.396a					_EUVError:
.396a	4c ee 43	jmp $43ee		jmp	ErrorV_value

;******  Return to file: include.files


;******  Processing file: src/generated/precedence_table.asm

.396d					BinaryPrecedence:
>396d	02					.byte	 2	; $ef =
>396e	02					.byte	 2	; $f0 <>
>396f	02					.byte	 2	; $f1 <=
>3970	02					.byte	 2	; $f2 <
>3971	02					.byte	 2	; $f3 >=
>3972	02					.byte	 2	; $f4 >
>3973	01					.byte	 1	; $f5 XOR
>3974	01					.byte	 1	; $f6 OR
>3975	01					.byte	 1	; $f7 AND
>3976	04					.byte	 4	; $f8 DIV
>3977	04					.byte	 4	; $f9 MOD
>3978	04					.byte	 4	; $fa <<
>3979	04					.byte	 4	; $fb >>
>397a	04					.byte	 4	; $fc /
>397b	04					.byte	 4	; $fd *
>397c	03					.byte	 3	; $fe -
>397d	03					.byte	 3	; $ff +

;******  Return to file: include.files


;******  Processing file: src/generated/structure_table.asm

.397e					StructureOffsets:
>397e	01					.byte	1  	; $80 REPEAT
>397f	ff					.byte	255	; $81 UNTIL
>3980	01					.byte	1  	; $82 WHILE
>3981	ff					.byte	255	; $83 WEND
>3982	01					.byte	1  	; $84 IF
>3983	ff					.byte	255	; $85 ENDIF
>3984	01					.byte	1  	; $86 DO
>3985	ff					.byte	255	; $87 LOOP
>3986	01					.byte	1  	; $88 PROC
>3987	ff					.byte	255	; $89 ENDPROC
>3988	01					.byte	1  	; $8a FOR
>3989	ff					.byte	255	; $8b NEXT

;******  Return to file: include.files


;******  Processing file: src/generated/token_text.asm

.398a					StandardTokens:
>398a	06 52 45 50 45 41 54			.byte	$06,$52,$45,$50,$45,$41,$54             	; $80 repeat
>3991	05 55 4e 54 49 4c			.byte	$05,$55,$4e,$54,$49,$4c                 	; $81 until
>3997	05 57 48 49 4c 45			.byte	$05,$57,$48,$49,$4c,$45                 	; $82 while
>399d	04 57 45 4e 44				.byte	$04,$57,$45,$4e,$44                     	; $83 wend
>39a2	02 49 46				.byte	$02,$49,$46                             	; $84 if
>39a5	05 45 4e 44 49 46			.byte	$05,$45,$4e,$44,$49,$46                 	; $85 endif
>39ab	02 44 4f				.byte	$02,$44,$4f                             	; $86 do
>39ae	04 4c 4f 4f 50				.byte	$04,$4c,$4f,$4f,$50                     	; $87 loop
>39b3	04 50 52 4f 43				.byte	$04,$50,$52,$4f,$43                     	; $88 proc
>39b8	07 45 4e 44 50 52 4f 43			.byte	$07,$45,$4e,$44,$50,$52,$4f,$43         	; $89 endproc
>39c0	03 46 4f 52				.byte	$03,$46,$4f,$52                         	; $8a for
>39c4	04 4e 45 58 54				.byte	$04,$4e,$45,$58,$54                     	; $8b next
>39c9	00					.byte	$00                                     	; $8c [[end]]
>39ca	00					.byte	$00                                     	; $8d [[shift]]
>39cb	04 45 4c 53 45				.byte	$04,$45,$4c,$53,$45                     	; $8e else
>39d0	04 54 48 45 4e				.byte	$04,$54,$48,$45,$4e                     	; $8f then
>39d5	02 54 4f				.byte	$02,$54,$4f                             	; $90 to
>39d8	04 53 54 45 50				.byte	$04,$53,$54,$45,$50                     	; $91 step
>39dd	03 4c 45 54				.byte	$03,$4c,$45,$54                         	; $92 let
>39e1	05 50 52 49 4e 54			.byte	$05,$50,$52,$49,$4e,$54                 	; $93 print
>39e7	05 49 4e 50 55 54			.byte	$05,$49,$4e,$50,$55,$54                 	; $94 input
>39ed	04 43 41 4c 4c				.byte	$04,$43,$41,$4c,$4c                     	; $95 call
>39f2	03 53 59 53				.byte	$03,$53,$59,$53                         	; $96 sys
>39f6	03 52 45 4d				.byte	$03,$52,$45,$4d                         	; $97 rem
>39fa	04 45 58 49 54				.byte	$04,$45,$58,$49,$54                     	; $98 exit
>39ff	01 2c					.byte	$01,$2c                                 	; $99 ,
>3a01	01 3b					.byte	$01,$3b                                 	; $9a ;
>3a03	01 3a					.byte	$01,$3a                                 	; $9b :
>3a05	01 27					.byte	$01,$27                                 	; $9c '
>3a07	01 29					.byte	$01,$29                                 	; $9d )
>3a09	03 44 49 4d				.byte	$03,$44,$49,$4d                         	; $9e dim
>3a0d	05 43 4c 45 41 52			.byte	$05,$43,$4c,$45,$41,$52                 	; $9f clear
>3a13	03 4e 45 57				.byte	$03,$4e,$45,$57                         	; $a0 new
>3a17	03 52 55 4e				.byte	$03,$52,$55,$4e                         	; $a1 run
>3a1b	04 53 54 4f 50				.byte	$04,$53,$54,$4f,$50                     	; $a2 stop
>3a20	03 45 4e 44				.byte	$03,$45,$4e,$44                         	; $a3 end
>3a24	06 41 53 53 45 52 54			.byte	$06,$41,$53,$53,$45,$52,$54             	; $a4 assert
>3a2b	04 4c 49 53 54				.byte	$04,$4c,$49,$53,$54                     	; $a5 list
>3a30	04 53 41 56 45				.byte	$04,$53,$41,$56,$45                     	; $a6 save
>3a35	04 4c 4f 41 44				.byte	$04,$4c,$4f,$41,$44                     	; $a7 load
>3a3a	04 50 4f 4b 45				.byte	$04,$50,$4f,$4b,$45                     	; $a8 poke
>3a3f	04 44 4f 4b 45				.byte	$04,$44,$4f,$4b,$45                     	; $a9 doke
>3a44	00					.byte	0											; $aa
>3a45	00					.byte	0											; $ab
>3a46	00					.byte	0											; $ac
>3a47	00					.byte	0											; $ad
>3a48	00					.byte	0											; $ae
>3a49	00					.byte	0											; $af
>3a4a	00					.byte	0											; $b0
>3a4b	00					.byte	0											; $b1
>3a4c	00					.byte	0											; $b2
>3a4d	00					.byte	0											; $b3
>3a4e	00					.byte	0											; $b4
>3a4f	00					.byte	0											; $b5
>3a50	00					.byte	0											; $b6
>3a51	00					.byte	0											; $b7
>3a52	00					.byte	0											; $b8
>3a53	00					.byte	0											; $b9
>3a54	00					.byte	0											; $ba
>3a55	00					.byte	0											; $bb
>3a56	00					.byte	0											; $bc
>3a57	00					.byte	0											; $bd
>3a58	00					.byte	0											; $be
>3a59	00					.byte	0											; $bf
>3a5a	00					.byte	0											; $c0
>3a5b	00					.byte	0											; $c1
>3a5c	00					.byte	0											; $c2
>3a5d	00					.byte	0											; $c3
>3a5e	00					.byte	0											; $c4
>3a5f	00					.byte	0											; $c5
>3a60	00					.byte	0											; $c6
>3a61	00					.byte	0											; $c7
>3a62	00					.byte	0											; $c8
>3a63	00					.byte	0											; $c9
>3a64	00					.byte	0											; $ca
>3a65	00					.byte	0											; $cb
>3a66	00					.byte	0											; $cc
>3a67	00					.byte	0											; $cd
>3a68	00					.byte	0											; $ce
>3a69	00					.byte	0											; $cf
>3a6a	00					.byte	0											; $d0
>3a6b	00					.byte	0											; $d1
>3a6c	00					.byte	0											; $d2
>3a6d	00					.byte	0											; $d3
>3a6e	00					.byte	0											; $d4
>3a6f	05 44 45 45 4b 28			.byte	$05,$44,$45,$45,$4b,$28                 	; $d5 deek(
>3a75	05 50 45 45 4b 28			.byte	$05,$50,$45,$45,$4b,$28                 	; $d6 peek(
>3a7b	07 52 49 47 48 54 24 28			.byte	$07,$52,$49,$47,$48,$54,$24,$28         	; $d7 right$(
>3a83	06 4c 45 46 54 24 28			.byte	$06,$4c,$45,$46,$54,$24,$28             	; $d8 left$(
>3a8a	05 4d 49 44 24 28			.byte	$05,$4d,$49,$44,$24,$28                 	; $d9 mid$(
>3a90	05 53 54 52 24 28			.byte	$05,$53,$54,$52,$24,$28                 	; $da str$(
>3a96	04 56 41 4c 28				.byte	$04,$56,$41,$4c,$28                     	; $db val(
>3a9b	04 53 47 4e 28				.byte	$04,$53,$47,$4e,$28                     	; $dc sgn(
>3aa0	04 41 42 53 28				.byte	$04,$41,$42,$53,$28                     	; $dd abs(
>3aa5	04 4c 45 4e 28				.byte	$04,$4c,$45,$4e,$28                     	; $de len(
>3aaa	04 53 51 52 28				.byte	$04,$53,$51,$52,$28                     	; $df sqr(
>3aaf	05 43 48 52 24 28			.byte	$05,$43,$48,$52,$24,$28                 	; $e0 chr$(
>3ab5	04 41 53 43 28				.byte	$04,$41,$53,$43,$28                     	; $e1 asc(
>3aba	07 49 4e 4b 45 59 24 28			.byte	$07,$49,$4e,$4b,$45,$59,$24,$28         	; $e2 inkey$(
>3ac2	06 45 56 45 4e 54 28			.byte	$06,$45,$56,$45,$4e,$54,$28             	; $e3 event(
>3ac9	04 54 49 4d 45				.byte	$04,$54,$49,$4d,$45                     	; $e4 time
>3ace	04 49 4e 54 28				.byte	$04,$49,$4e,$54,$28                     	; $e5 int(
>3ad3	05 46 52 41 43 28			.byte	$05,$46,$52,$41,$43,$28                 	; $e6 frac(
>3ad9	04 44 45 43 28				.byte	$04,$44,$45,$43,$28                     	; $e7 dec(
>3ade	05 48 45 58 24 28			.byte	$05,$48,$45,$58,$24,$28                 	; $e8 hex$(
>3ae4	04 52 4e 44 28				.byte	$04,$52,$4e,$44,$28                     	; $e9 rnd(
>3ae9	05 52 41 4e 44 28			.byte	$05,$52,$41,$4e,$44,$28                 	; $ea rand(
>3aef	01 28					.byte	$01,$28                                 	; $eb (
>3af1	01 24					.byte	$01,$24                                 	; $ec $
>3af3	00					.byte	$00                                     	; $ed [[decimal]]
>3af4	00					.byte	$00                                     	; $ee [[string]]
>3af5	01 3d					.byte	$01,$3d                                 	; $ef =
>3af7	02 3c 3e				.byte	$02,$3c,$3e                             	; $f0 <>
>3afa	02 3c 3d				.byte	$02,$3c,$3d                             	; $f1 <=
>3afd	01 3c					.byte	$01,$3c                                 	; $f2 <
>3aff	02 3e 3d				.byte	$02,$3e,$3d                             	; $f3 >=
>3b02	01 3e					.byte	$01,$3e                                 	; $f4 >
>3b04	03 58 4f 52				.byte	$03,$58,$4f,$52                         	; $f5 xor
>3b08	02 4f 52				.byte	$02,$4f,$52                             	; $f6 or
>3b0b	03 41 4e 44				.byte	$03,$41,$4e,$44                         	; $f7 and
>3b0f	03 44 49 56				.byte	$03,$44,$49,$56                         	; $f8 div
>3b13	03 4d 4f 44				.byte	$03,$4d,$4f,$44                         	; $f9 mod
>3b17	02 3c 3c				.byte	$02,$3c,$3c                             	; $fa <<
>3b1a	02 3e 3e				.byte	$02,$3e,$3e                             	; $fb >>
>3b1d	01 2f					.byte	$01,$2f                                 	; $fc /
>3b1f	01 2a					.byte	$01,$2a                                 	; $fd *
>3b21	01 2d					.byte	$01,$2d                                 	; $fe -
>3b23	01 2b					.byte	$01,$2b                                 	; $ff +
>3b25	ff					.byte	$FF

;******  Return to file: include.files


;******  Processing file: src/generated/vector_table.asm

.3b26					VectorTable:
>3b26	c2 42					.word	Command_REPEAT           ; $80 REPEAT
>3b28	cb 42					.word	Command_UNTIL            ; $81 UNTIL
>3b2a	a3 43					.word	Command_WHILE            ; $82 WHILE
>3b2c	c2 43					.word	Command_WEND             ; $83 WEND
>3b2e	9a 42					.word	IfCommand                ; $84 IF
>3b30	c1 42					.word	EndIf                    ; $85 ENDIF
>3b32	37 41					.word	Command_DO               ; $86 DO
>3b34	4f 41					.word	Command_LOOP             ; $87 LOOP
>3b36	43 34					.word	NoExec08                 ; $88 PROC
>3b38	2b 41					.word	Command_ENDPROC          ; $89 ENDPROC
>3b3a	58 41					.word	Command_FOR              ; $8a FOR
>3b3c	e5 41					.word	Command_NEXT             ; $8b NEXT
>3b3e	e7 33					.word	RUNEndOfLine             ; $8c [[END]]
>3b40	25 34					.word	Command_Shift_Handler    ; $8d [[SHIFT]]
>3b42	ba 42					.word	ElseCode                 ; $8e ELSE
>3b44	43 34					.word	NoExec01                 ; $8f THEN
>3b46	43 34					.word	NoExec02                 ; $90 TO
>3b48	43 34					.word	NoExec03                 ; $91 STEP
>3b4a	4d 33					.word	CommandLET               ; $92 LET
>3b4c	e8 32					.word	Command_Print            ; $93 PRINT
>3b4e	2c 4f					.word	NotImplemented           ; $94 INPUT
>3b50	ef 40					.word	Command_CALL             ; $95 CALL
>3b52	2e 34					.word	Command_Sys              ; $96 SYS
>3b54	ce 33					.word	Command_REM              ; $97 REM
>3b56	40 41					.word	Command_EXIT             ; $98 EXIT
>3b58	43 34					.word	NoExec04                 ; $99 ,
>3b5a	43 34					.word	NoExec05                 ; $9a ;
>3b5c	43 34					.word	NoExec06                 ; $9b :
>3b5e	ce 33					.word	Command_REM2             ; $9c '
>3b60	43 34					.word	NoExec07                 ; $9d )
>3b62	a2 31					.word	CommandDIM               ; $9e DIM
>3b64	52 31					.word	Command_CLEAR            ; $9f CLEAR
>3b66	c5 33					.word	Command_NEW              ; $a0 NEW
>3b68	db 33					.word	Command_RUN              ; $a1 RUN
>3b6a	2b 34					.word	Command_STOP             ; $a2 STOP
>3b6c	28 34					.word	Command_END              ; $a3 END
>3b6e	44 31					.word	Command_ASSERT           ; $a4 ASSERT
>3b70	2c 4f					.word	NotImplemented           ; $a5 LIST
>3b72	2c 4f					.word	NotImplemented           ; $a6 SAVE
>3b74	2c 4f					.word	NotImplemented           ; $a7 LOAD
>3b76	c1 32					.word	Command_Poke             ; $a8 POKE
>3b78	be 32					.word	Command_Doke             ; $a9 DOKE
>3b7a	2c 4f					.word	NotImplemented           ; $aa
>3b7c	2c 4f					.word	NotImplemented           ; $ab
>3b7e	2c 4f					.word	NotImplemented           ; $ac
>3b80	2c 4f					.word	NotImplemented           ; $ad
>3b82	2c 4f					.word	NotImplemented           ; $ae
>3b84	2c 4f					.word	NotImplemented           ; $af
>3b86	2c 4f					.word	NotImplemented           ; $b0
>3b88	2c 4f					.word	NotImplemented           ; $b1
>3b8a	2c 4f					.word	NotImplemented           ; $b2
>3b8c	2c 4f					.word	NotImplemented           ; $b3
>3b8e	2c 4f					.word	NotImplemented           ; $b4
>3b90	2c 4f					.word	NotImplemented           ; $b5
>3b92	2c 4f					.word	NotImplemented           ; $b6
>3b94	2c 4f					.word	NotImplemented           ; $b7
>3b96	2c 4f					.word	NotImplemented           ; $b8
>3b98	2c 4f					.word	NotImplemented           ; $b9
>3b9a	2c 4f					.word	NotImplemented           ; $ba
>3b9c	2c 4f					.word	NotImplemented           ; $bb
>3b9e	2c 4f					.word	NotImplemented           ; $bc
>3ba0	2c 4f					.word	NotImplemented           ; $bd
>3ba2	2c 4f					.word	NotImplemented           ; $be
>3ba4	2c 4f					.word	NotImplemented           ; $bf
>3ba6	2c 4f					.word	NotImplemented           ; $c0
>3ba8	2c 4f					.word	NotImplemented           ; $c1
>3baa	2c 4f					.word	NotImplemented           ; $c2
>3bac	2c 4f					.word	NotImplemented           ; $c3
>3bae	2c 4f					.word	NotImplemented           ; $c4
>3bb0	2c 4f					.word	NotImplemented           ; $c5
>3bb2	2c 4f					.word	NotImplemented           ; $c6
>3bb4	2c 4f					.word	NotImplemented           ; $c7
>3bb6	2c 4f					.word	NotImplemented           ; $c8
>3bb8	2c 4f					.word	NotImplemented           ; $c9
>3bba	2c 4f					.word	NotImplemented           ; $ca
>3bbc	2c 4f					.word	NotImplemented           ; $cb
>3bbe	2c 4f					.word	NotImplemented           ; $cc
>3bc0	2c 4f					.word	NotImplemented           ; $cd
>3bc2	2c 4f					.word	NotImplemented           ; $ce
>3bc4	2c 4f					.word	NotImplemented           ; $cf
>3bc6	2c 4f					.word	NotImplemented           ; $d0
>3bc8	2c 4f					.word	NotImplemented           ; $d1
>3bca	2c 4f					.word	NotImplemented           ; $d2
>3bcc	2c 4f					.word	NotImplemented           ; $d3
>3bce	2c 4f					.word	NotImplemented           ; $d4
>3bd0	a6 37					.word	EXPUnaryDeek             ; $d5 DEEK(
>3bd2	98 37					.word	EXPUnaryPeek             ; $d6 PEEK(
>3bd4	d3 38					.word	EXPUnaryRight            ; $d7 RIGHT$(
>3bd6	c6 38					.word	EXPUnaryLeft             ; $d8 LEFT$(
>3bd8	ed 38					.word	EXPUnaryMid              ; $d9 MID$(
>3bda	84 38					.word	EXPUnaryStr              ; $da STR$(
>3bdc	4f 39					.word	EXPUnaryVal              ; $db VAL(
>3bde	51 38					.word	EXPUnarySgn              ; $dc SGN(
>3be0	16 37					.word	EXPUnaryAbs              ; $dd ABS(
>3be2	d6 37					.word	EXPUnaryLen              ; $de LEN(
>3be4	67 38					.word	EXPUnarySqr              ; $df SQR(
>3be6	36 37					.word	EXPUnaryChr              ; $e0 CHR$(
>3be8	20 37					.word	EXPUnaryAsc              ; $e1 ASC(
>3bea	2c 4f					.word	NotImplemented           ; $e2 INKEY$(
>3bec	2c 4f					.word	NotImplemented           ; $e3 EVENT(
>3bee	2c 4f					.word	NotImplemented           ; $e4 TIME
>3bf0	cc 37					.word	EXPUnaryInt              ; $e5 INT(
>3bf2	c2 37					.word	EXPUnaryFrac             ; $e6 FRAC(
>3bf4	47 37					.word	EXPUnaryDec              ; $e7 DEC(
>3bf6	76 38					.word	EXPUnaryHex              ; $e8 HEX$(
>3bf8	eb 37					.word	EXPUnaryRnd              ; $e9 RND(
>3bfa	fb 37					.word	ExpUnaryRand             ; $ea RAND(
>3bfc	e4 37					.word	EXPUnaryParenthesis      ; $eb (
>3bfe	be 37					.word	EXPUnaryNull             ; $ec $
>3c00	95 37					.word	EXPUnaryInlineDec        ; $ed [[DECIMAL]]
>3c02	ab 38					.word	EXPUnaryInlineString     ; $ee [[STRING]]
>3c04	00 35					.word	EXPCompareEqual          ; $ef =
>3c06	1b 35					.word	EXPCompareNotEqual       ; $f0 <>
>3c08	24 35					.word	EXPCompareLessEqual      ; $f1 <=
>3c0a	09 35					.word	EXPCompareLess           ; $f2 <
>3c0c	2d 35					.word	EXPCompareGreaterEqual   ; $f3 >=
>3c0e	12 35					.word	EXPCompareGreater        ; $f4 >
>3c10	ad 34					.word	EXPBinXor                ; $f5 XOR
>3c12	a1 34					.word	EXPBinOr                 ; $f6 OR
>3c14	95 34					.word	EXPBinAnd                ; $f7 AND
>3c16	6d 34					.word	EXPBinIDiv               ; $f8 DIV
>3c18	7e 34					.word	EXPBinIMod               ; $f9 MOD
>3c1a	78 35					.word	EXPBinLeft               ; $fa <<
>3c1c	80 35					.word	EXPBinRight              ; $fb >>
>3c1e	61 34					.word	EXPBinFDiv               ; $fc /
>3c20	58 34					.word	EXPBinMul                ; $fd *
>3c22	4f 34					.word	EXPBinSub                ; $fe -
>3c24	46 34					.word	EXPBinAdd                ; $ff +

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/detokenise.asm

.3c26					TOKDetokenise:
.3c26	86 22		stx $22				stx 	zTemp2 						; save tokenised code in zTemp2
.3c28	84 23		sty $23				sty 	zTemp2+1
.3c2a	9c 0e 05	stz $050e			stz		TOKLastCharacter 			; clear last character
.3c2d					_TOKDLoop:
.3c2d	20 5c 3c	jsr $3c5c			jsr 	TOKDGet 					; get next
.3c30	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ			; end of line
.3c32	f0 26		beq $3c5a			beq 	_TOKDExit
.3c34	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ		; is it a string/integer with additional data.
.3c36	f0 1d		beq $3c55			beq 	_TOKDDataItem
.3c38	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ
.3c3a	f0 19		beq $3c55			beq 	_TOKDDataItem
.3c3c	c9 00		cmp #$00			cmp 	#0 							; is it a token 80-FF
.3c3e	10 05		bpl $3c45			bpl 	_TOKDNotToken
.3c40	20 24 3d	jsr $3d24			jsr 	TOKDToken 					; token to text.
.3c43	80 e8		bra $3c2d			bra 	_TOKDLoop
.3c45					_TOKDNotToken:
.3c45	c9 40		cmp #$40			cmp 	#$40  						; 40-7F Identifier
.3c47	90 05		bcc $3c4e			bcc 	_TOKDNotIdentifier
.3c49	20 97 3c	jsr $3c97			jsr 	TOKDIdentifier
.3c4c	80 df		bra $3c2d			bra 	_TOKDLoop
.3c4e					_TOKDNotIdentifier:
.3c4e	a0 0a		ldy #$0a			ldy 	#10
.3c50	20 e0 3c	jsr $3ce0			jsr 	TOKDInteger
.3c53	80 d8		bra $3c2d			bra 	_TOKDLoop
.3c55					_TOKDDataItem:
.3c55	20 72 3c	jsr $3c72			jsr 	TOKDDataItem
.3c58	80 d3		bra $3c2d			bra 	_TOKDLoop
.3c5a					_TOKDExit:
.3c5a	18		clc				clc
.3c5b	60		rts				rts
.3c5c	b2 22		lda ($22)	TOKDGet:lda 	(zTemp2)
.3c5e	e6 22		inc $22				inc 	zTemp2
.3c60	d0 02		bne $3c64			bne 	_TKDGExit
.3c62	e6 23		inc $23				inc 	zTemp2+1
.3c64					_TKDGExit:
.3c64	60		rts				rts
.3c65					TOKDOutput:
.3c65	8d 0e 05	sta $050e			sta 	TOKLastCharacter
.3c68	6c 0c 05	jmp ($050c)			jmp 	(TOKOutputMethod)
.3c6b					TOKSetDetokeniseOutput:
.3c6b	8e 0c 05	stx $050c			stx 	TOKOutputMethod
.3c6e	8c 0d 05	sty $050d			sty 	TOKOutputMethod+1
.3c71	60		rts				rts
.050c					TOKOutputMethod:
>050c							.fill 	2
.050e					TOKLastCharacter:
>050e							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkdataitem.asm

.3c72					TOKDDataItem:
.3c72	a8		tay				tay 								; type in Y
.3c73	a9 22		lda #$22			lda 	#'"'						; start with " or .
.3c75	c0 ee		cpy #$ee			cpy 	#PR_LSQLSQSTRINGRSQRSQ
.3c77	f0 02		beq $3c7b			beq 	_TOKDDIsString
.3c79	a9 2e		lda #$2e			lda 	#'.'
.3c7b					_TOKDDIsString:
.3c7b	20 65 3c	jsr $3c65			jsr 	TOKDOutput 					; dump it
.3c7e	20 5c 3c	jsr $3c5c			jsr 	TOKDGet 					; get length into X
.3c81	aa		tax				tax
.3c82					_TOKDDOutput:
.3c82	ca		dex				dex 								; are we complete
.3c83	30 08		bmi $3c8d			bmi 	_TOKDDEnd
.3c85	20 5c 3c	jsr $3c5c			jsr 	TOKDGet 					; get character and output it
.3c88	20 65 3c	jsr $3c65			jsr 	TOKDOutput
.3c8b	80 f5		bra $3c82			bra 	_TOKDDOutput
.3c8d					_TOKDDEnd:
.3c8d	c0 ee		cpy #$ee			cpy 	#PR_LSQLSQSTRINGRSQRSQ 		; if string, do closing quote
.3c8f	d0 05		bne $3c96			bne 	_TOKDDNotString
.3c91	a9 22		lda #$22			lda 	#'"'
.3c93	20 65 3c	jsr $3c65			jsr 	TOKDOutput
.3c96					_TOKDDNotString:
.3c96	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkidentifier.asm

.3c97					TOKDIdentifier:
.3c97	a0 ff		ldy #$ff			ldy 	#$FF
.3c99	8c 0f 05	sty $050f			sty 	TOKDIFirstChar
.3c9c					_TOKDLoop:
.3c9c	a8		tay				tay 								; token in Y
.3c9d	a9 2e		lda #$2e			lda 	#'.' 						; handle special cases.
.3c9f	c0 64		cpy #$64			cpy 	#$64
.3ca1	f0 11		beq $3cb4			beq 	_TOKDIOutput
.3ca3	a9 5f		lda #$5f			lda 	#'_'
.3ca5	c0 65		cpy #$65			cpy 	#$65
.3ca7	f0 0b		beq $3cb4			beq 	_TOKDIOutput
.3ca9	98		tya				tya 								; handle a-z
.3caa	18		clc				clc
.3cab	69 21		adc #$21			adc	 	#$21
.3cad	c0 5a		cpy #$5a			cpy 	#$5A
.3caf	90 03		bcc $3cb4			bcc 	_TOKDIOutput
.3cb1	38		sec				sec 								; handle 0-9
.3cb2	e9 4b		sbc #$4b			sbc 	#$4B
.3cb4					_TOKDIOutput:
.3cb4	2c 0f 05	bit $050f			bit 	TOKDIFirstChar
.3cb7	10 08		bpl $3cc1			bpl 	_TOKDINoSpacing
.3cb9	48		pha				pha
.3cba	20 56 3d	jsr $3d56			jsr 	TOKDSpacing
.3cbd	9c 0f 05	stz $050f			stz 	TOKDIFirstChar
.3cc0	68		pla				pla
.3cc1					_TOKDINoSpacing:
.3cc1	20 65 3c	jsr $3c65			jsr 	TOKDOutput
.3cc4	20 5c 3c	jsr $3c5c			jsr 	TOKDGet 					; get next token
.3cc7	c9 7c		cmp #$7c			cmp 	#$7C
.3cc9	90 d1		bcc $3c9c			bcc 	_TOKDLoop
.3ccb	f0 12		beq $3cdf			beq 	_TOKDIExit 					; it's a number, no tail.
.3ccd	4a		lsr a				lsr 	a 							; string ?
.3cce	90 07		bcc $3cd7			bcc 	_TOKDICheckArray
.3cd0	48		pha				pha
.3cd1	a9 24		lda #$24			lda 	#"$"
.3cd3	20 65 3c	jsr $3c65			jsr 	TOKDOutput
.3cd6	68		pla				pla
.3cd7					_TOKDICheckArray:
.3cd7	4a		lsr a				lsr 	a 							; array ?
.3cd8	90 05		bcc $3cdf			bcc 	_TOKDIExit
.3cda	a9 28		lda #$28			lda 	#"("
.3cdc	20 65 3c	jsr $3c65			jsr 	TOKDOutput
.3cdf					_TOKDIExit:
.3cdf	60		rts				rts
.050f					TOKDIFirstChar:
>050f							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkinteger.asm

.3ce0					TOKDInteger:
.3ce0	5a		phy				phy 								; save base
.3ce1	a2 0c		ldx #$0c			ldx 	#IFR0 						; set into R0
.3ce3	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.3ce6					_TOKDILoop:
.3ce6	b2 22		lda ($22)			lda 	(zTemp2) 					; followed by a 00-3F
.3ce8	c9 40		cmp #$40			cmp 	#$40
.3cea	b0 1d		bcs $3d09			bcs 	_TOKDIHaveInteger
.3cec	a2 0c		ldx #$0c			ldx 	#IFR0 						; R0 << 6
.3cee	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3cf1	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3cf4	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3cf7	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3cfa	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3cfd	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3d00	20 5c 3c	jsr $3c5c			jsr 	TOKDGet 					; OR byte in.
.3d03	05 0c		ora $0c				ora 	IFR0+IM0
.3d05	85 0c		sta $0c				sta 	IFR0+IM0
.3d07	80 dd		bra $3ce6			bra 	_TOKDILoop
.3d09					_TOKDIHaveInteger:
.3d09	7a		ply				ply 								; restore base
.3d0a	98		tya				tya 								; base in A
.3d0b	20 ef 4b	jsr $4bef			jsr 	IFloatIntegerToStringR0
.3d0e	86 1e		stx $1e				stx 	zTemp0
.3d10	84 1f		sty $1f				sty 	zTemp0+1
.3d12	b2 1e		lda ($1e)			lda 	(zTemp0)
.3d14	20 56 3d	jsr $3d56			jsr 	TOKDSpacing 				; check spacing okay.
.3d17	a0 00		ldy #$00			ldy 	#0 							; output buffer.
.3d19					_TOKDOutput:
.3d19	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3d1b	20 65 3c	jsr $3c65			jsr 	TOKDOutput
.3d1e	c8		iny				iny
.3d1f	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3d21	d0 f6		bne $3d19			bne 	_TOKDOutput
.3d23	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtktoken.asm

.3d24					TOKDToken:
.3d24	a2 8a		ldx #$8a			ldx 	#StandardTokens & $FF
.3d26	a0 39		ldy #$39			ldy 	#StandardTokens >> 8
.3d28					_TOKDSearch:
.3d28	86 1e		stx $1e				stx 	zTemp0 						; put table in zTemp0
.3d2a	84 1f		sty $1f				sty 	zTemp0+1
.3d2c	aa		tax				tax 								; token ID in X.
.3d2d					_TOKDFind:
.3d2d	ca		dex				dex 								; reached the start
.3d2e	10 0d		bpl $3d3d			bpl 	_TOKDFound
.3d30	38		sec				sec 								; go to next entry
.3d31	b2 1e		lda ($1e)			lda 	(zTemp0)
.3d33	65 1e		adc $1e				adc 	zTemp0
.3d35	85 1e		sta $1e				sta 	zTemp0
.3d37	90 f4		bcc $3d2d			bcc 	_TOKDFind
.3d39	e6 1f		inc $1f				inc 	zTemp0+1
.3d3b	80 f0		bra $3d2d			bra 	_TOKDFind
.3d3d					_TOKDFound:
.3d3d	b2 1e		lda ($1e)			lda 	(zTemp0) 					; length to X
.3d3f	f0 14		beq $3d55			beq 	_TOKDExit
.3d41	aa		tax				tax
.3d42	a0 01		ldy #$01			ldy 	#1 							; output the token.
.3d44	b1 1e		lda ($1e),y			lda 	(zTemp0),y 					; check spacing
.3d46	20 56 3d	jsr $3d56			jsr 	TOKDSpacing
.3d49					_TOKDOutput:
.3d49	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3d4b	20 aa 40	jsr $40aa			jsr 	TOKToLower
.3d4e	20 65 3c	jsr $3c65			jsr 	TOKDOutput
.3d51	c8		iny				iny
.3d52	ca		dex				dex
.3d53	d0 f4		bne $3d49			bne 	_TOKDOutput
.3d55					_TOKDExit:
.3d55	60		rts				rts
.3d56					TOKDSpacing:
.3d56	20 c1 40	jsr $40c1			jsr 	TOKIsIdentifierElement		; next character alphanumeric
.3d59	90 0d		bcc $3d68			bcc 	_TOKDSExit
.3d5b	ad 0e 05	lda $050e			lda 	TOKLastCharacter			; and last character also alphanumeric
.3d5e	20 c1 40	jsr $40c1			jsr 	TOKIsIdentifierElement
.3d61	90 05		bcc $3d68			bcc 	_TOKDSExit
.3d63	a9 20		lda #$20			lda 	#" " 						; we need a space.
.3d65	20 65 3c	jsr $3c65			jsr 	TOKDOutput
.3d68					_TOKDSExit:
.3d68	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/editing/delete.asm

.3d69					PGMDeleteLine:
.3d69	20 1c 3e	jsr $3e1c			jsr 	PGMEndProgram 				; end of program into zTemp0
.3d6c	64 20		stz $20				stz 	zTemp1						; copy base address of code to zTemp1
.3d6e	ad 10 05	lda $0510			lda 	PGMBaseHigh
.3d71	85 21		sta $21				sta 	zTemp1+1
.3d73					_PGMDLoop:
.3d73	b2 20		lda ($20)			lda 	(zTemp1) 					; finished, not found ?
.3d75	38		sec				sec
.3d76	f0 3a		beq $3db2			beq 	_PGMDExit
.3d78	a0 01		ldy #$01			ldy 	#1 							; found line number ?
.3d7a	b1 20		lda ($20),y			lda 	(zTemp1),y
.3d7c	cd 02 04	cmp $0402			cmp 	TOKLineNumber
.3d7f	d0 08		bne $3d89			bne 	_PGMDNext
.3d81	c8		iny				iny
.3d82	b1 20		lda ($20),y			lda 	(zTemp1),y
.3d84	cd 03 04	cmp $0403			cmp 	TOKLineNumber+1
.3d87	f0 0d		beq $3d96			beq 	_PGMDDelete
.3d89					_PGMDNext:
.3d89	18		clc				clc
.3d8a	b2 20		lda ($20)			lda 	(zTemp1)
.3d8c	65 20		adc $20				adc 	zTemp1
.3d8e	85 20		sta $20				sta 	zTemp1
.3d90	90 e1		bcc $3d73			bcc 	_PGMDLoop
.3d92	e6 21		inc $21				inc 	zTemp1+1
.3d94	80 dd		bra $3d73			bra 	_PGMDLoop
.3d96					_PGMDDelete:
.3d96	b2 20		lda ($20)			lda 	(zTemp1) 					; offset to next in Y
.3d98	a8		tay				tay
.3d99					_PGMDCopy:
.3d99	b1 20		lda ($20),y			lda 	(zTemp1),y 					; copy down.
.3d9b	92 20		sta ($20)			sta 	(zTemp1)
.3d9d	a5 20		lda $20				lda 	zTemp1 						; reached the end ?
.3d9f	c5 1e		cmp $1e				cmp 	zTemp0
.3da1	d0 07		bne $3daa			bne 	_PGMDNext2
.3da3	a5 21		lda $21				lda 	zTemp1+1
.3da5	c5 1f		cmp $1f				cmp 	zTemp0+1
.3da7	18		clc				clc
.3da8	f0 08		beq $3db2			beq 	_PGMDExit
.3daa					_PGMDNext2:
.3daa	e6 20		inc $20				inc 	zTemp1 						; advance pointer.
.3dac	d0 eb		bne $3d99			bne 	_PGMDCopy
.3dae	e6 21		inc $21				inc 	zTemp1+1
.3db0	80 e7		bra $3d99			bra 	_PGMDCopy
.3db2					_PGMDExit:
.3db2	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/editing/insert.asm

.3db3					PGMInsertLine:
.3db3	20 1c 3e	jsr $3e1c			jsr 	PGMEndProgram 				; end of program into zTemp0
.3db6	64 20		stz $20				stz 	zTemp1						; copy base address of code to zTemp1
.3db8	ad 10 05	lda $0510			lda 	PGMBaseHigh
.3dbb	85 21		sta $21				sta 	zTemp1+1
.3dbd					_PGMILoop:
.3dbd	b2 20		lda ($20)			lda 	(zTemp1) 					; reached the end, it goes here on the end.
.3dbf	f0 1c		beq $3ddd			beq 	_PGMIInsert
.3dc1	a0 01		ldy #$01			ldy 	#1 							; compare in-program line vs token line.
.3dc3	b1 20		lda ($20),y			lda 	(zTemp1),y
.3dc5	cd 02 04	cmp $0402			cmp 	TOKLineNumber
.3dc8	c8		iny				iny
.3dc9	b1 20		lda ($20),y			lda 	(zTemp1),y
.3dcb	ed 03 04	sbc $0403			sbc 	TOKLineNumber+1
.3dce	b0 0d		bcs $3ddd			bcs 	_PGMIInsert 				; insert here.
.3dd0	18		clc				clc
.3dd1	b2 20		lda ($20)			lda 	(zTemp1)
.3dd3	65 20		adc $20				adc 	zTemp1
.3dd5	85 20		sta $20				sta 	zTemp1
.3dd7	90 e4		bcc $3dbd			bcc 	_PGMILoop
.3dd9	e6 21		inc $21				inc 	zTemp1+1
.3ddb	80 e0		bra $3dbd			bra 	_PGMILoop
.3ddd					_PGMIInsert:
.3ddd	ac 01 04	ldy $0401			ldy 	TOKLineSize 				; space required
.3de0					_PGMIInsertLoop:
.3de0	b2 1e		lda ($1e)			lda 	(zTemp0)
.3de2	91 1e		sta ($1e),y			sta 	(zTemp0),y
.3de4	a5 20		lda $20				lda 	zTemp1 						; reached insert point
.3de6	c5 1e		cmp $1e				cmp 	zTemp0
.3de8	d0 06		bne $3df0			bne 	_PGMINext
.3dea	a5 21		lda $21				lda 	zTemp1+1
.3dec	c5 1f		cmp $1f				cmp 	zTemp0+1
.3dee	f0 0a		beq $3dfa			beq 	_PGMIInserted
.3df0					_PGMINext:
.3df0	a5 1e		lda $1e				lda 	zTemp0
.3df2	d0 02		bne $3df6			bne 	_PGMINoBorrow
.3df4	c6 1f		dec $1f				dec 	zTemp0+1
.3df6					_PGMINoBorrow:
.3df6	c6 1e		dec $1e				dec 	zTemp0
.3df8	80 e6		bra $3de0			bra 	_PGMIInsertLoop
.3dfa					_PGMIInserted:
.3dfa	a0 00		ldy #$00			ldy 	#0 							; copy tokenbuffer to insert point
.3dfc					_PGMICopyLoop:
.3dfc	b9 01 04	lda $0401,y			lda 	TOKLineSize,y
.3dff	91 20		sta ($20),y			sta 	(zTemp1),y
.3e01	c8		iny				iny
.3e02	cc 01 04	cpy $0401			cpy 	TOKLineSize
.3e05	d0 f5		bne $3dfc			bne 	_PGMICopyLoop
.3e07	18		clc				clc
.3e08	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/setup.asm

.3e09					PGMSetBaseAddress:
.3e09	8e 10 05	stx $0510			stx 	PGMBaseHigh
.3e0c	8c 11 05	sty $0511			sty 	PGMEndMemoryHigh
.3e0f	60		rts				rts
.3e10					PGMNewProgram:
.3e10	64 1e		stz $1e				stz 	zTemp0						; copy base address to zTemp0
.3e12	ad 10 05	lda $0510			lda 	PGMBaseHigh
.3e15	85 1f		sta $1f				sta 	zTemp0+1
.3e17	a9 00		lda #$00			lda 	#0 							; overwrite the offset
.3e19	92 1e		sta ($1e)			sta 	(zTemp0)
.3e1b	60		rts				rts
.3e1c					PGMEndProgram:
.3e1c	64 1e		stz $1e				stz 	zTemp0 						; copy base address to zTemp0
.3e1e	ad 10 05	lda $0510			lda 	PGMBaseHigh
.3e21	85 1f		sta $1f				sta 	zTemp0+1
.3e23					_PGMEPLoop:
.3e23	b2 1e		lda ($1e)			lda 	(zTemp0)
.3e25	f0 0b		beq $3e32			beq 	_PGMEPExit
.3e27	18		clc				clc
.3e28	65 1e		adc $1e				adc 	zTemp0
.3e2a	85 1e		sta $1e				sta 	zTemp0
.3e2c	90 f5		bcc $3e23			bcc 	_PGMEPLoop
.3e2e	e6 1f		inc $1f				inc 	zTemp0+1
.3e30	80 f1		bra $3e23			bra 	_PGMEPLoop
.3e32					_PGMEPExit:
.3e32	60		rts				rts
.0510					PGMBaseHigh:
>0510							.fill 	1
.0511					PGMEndMemoryHigh:
>0511							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokbuffer.asm

.3e33					TOKResetElement:
.3e33	9c 12 05	stz $0512			stz 	TOKElement
.3e36	60		rts				rts
.3e37					TOKWriteElement:
.3e37	da		phx				phx
.3e38	ae 12 05	ldx $0512			ldx 	TOKElement
.3e3b	9d 13 05	sta $0513,x			sta 	TOKElementText,x
.3e3e	9e 14 05	stz $0514,x			stz 	TOKElementText+1,x
.3e41	fa		plx				plx
.3e42	ee 12 05	inc $0512			inc 	TOKElement
.3e45	60		rts				rts
.0512					TOKElement:
>0512							.fill 	1
.0513					TOKElementText:
>0513							.fill 	255

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokconstant.asm

.3e46					TOKTokeniseConstant:
.3e46	a5 0c		lda $0c				lda 	IFR0+IM0 					; check > 64
.3e48	48		pha				pha 								; save on stack
.3e49	29 c0		and #$c0			and 	#$C0
.3e4b	05 0d		ora $0d				ora 	IFR0+IM1
.3e4d	05 0e		ora $0e				ora 	IFR0+IM2
.3e4f	f0 10		beq $3e61			beq 	_TTCLess
.3e51	da		phx				phx
.3e52	a2 06		ldx #$06			ldx 	#6 							; divide by 64
.3e54					_TTCShiftRight:
.3e54	46 0e		lsr $0e				lsr 	IFR0+IM2
.3e56	66 0d		ror $0d				ror 	IFR0+IM1
.3e58	66 0c		ror $0c				ror 	IFR0+IM0
.3e5a	ca		dex				dex
.3e5b	d0 f7		bne $3e54			bne 	_TTCShiftRight
.3e5d	fa		plx				plx
.3e5e	20 46 3e	jsr $3e46			jsr 	TOKTokeniseConstant
.3e61					_TTCLess:
.3e61	68		pla				pla
.3e62	29 3f		and #$3f			and 	#$3F 						; lower 6 bits
.3e64	20 fd 3e	jsr $3efd			jsr 	TOKWriteA
.3e67	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokdecimal.asm

.3e68					TOKTokeniseDecimals:
.3e68	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext 					; consume the .
.3e6b	20 37 40	jsr $4037			jsr 	TOKExtractInteger 			; pull an integer out as text.
.3e6e	a9 ed		lda #$ed			lda 	#PR_LSQLSQDECIMALRSQRSQ	 	; decimal token
.3e70	20 fd 3e	jsr $3efd			jsr 	TOKWriteA
.3e73	20 78 3e	jsr $3e78			jsr 	TOKOutputElementBuffer 		; then the buffer
.3e76	18		clc				clc
.3e77	60		rts				rts
.3e78					TOKOutputElementBuffer:
.3e78	ad 12 05	lda $0512			lda 	TOKElement 					; get count and write that
.3e7b	20 fd 3e	jsr $3efd			jsr 	TOKWriteA
.3e7e	a8		tay				tay 								; put in Y
.3e7f	f0 0c		beq $3e8d			beq 	_TOEExit 					; exit if empty which is okay.
.3e81	a2 01		ldx #$01			ldx 	#1
.3e83					_TOELoop:
.3e83	bd 12 05	lda $0512,x			lda 	TOKElement,x
.3e86	20 fd 3e	jsr $3efd			jsr 	TOKWriteA
.3e89	e8		inx				inx
.3e8a	88		dey				dey
.3e8b	d0 f6		bne $3e83			bne 	_TOELoop
.3e8d					_TOEExit:
.3e8d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokenise.asm

.3e8e					TOKTokenise:
.3e8e	8c 13 06	sty $0613			sty 	TOKDataSource+1 			; save source routine pointer
.3e91	8e 12 06	stx $0612			stx 	TOKDataSource
.3e94	a9 01		lda #$01			lda 	#1 							; set first element flag.
.3e96	8d 14 06	sta $0614			sta 	TOKIsFirstElement
.3e99	a9 03		lda #$03			lda 	#3 							; set the line length to three for the
.3e9b	8d 01 04	sta $0401			sta 	TOKLineSize 				; line length itself and the line numbers.
.3e9e					_TOKMainLoop:
.3e9e	20 09 3f	jsr $3f09			jsr 	TOKGet 						; what follows.
.3ea1	c9 00		cmp #$00			cmp 	#0 							; if zero, we are complete
.3ea3	f0 4f		beq $3ef4			beq 	_TOKExit
.3ea5	c9 20		cmp #$20			cmp 	#' '						; space, consume and loop back.
.3ea7	d0 05		bne $3eae			bne 	_TOKElement
.3ea9	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext
.3eac	80 f0		bra $3e9e			bra 	_TOKMainLoop
.3eae					_TOKElement:
.3eae	20 b5 40	jsr $40b5			jsr 	TOKIsDigit 					; is it 0..9
.3eb1	90 0a		bcc $3ebd			bcc 	_TOKNotDigit
.3eb3	20 0e 40	jsr $400e			jsr 	TOKTokeniseInteger 			; get integer
.3eb6	b0 43		bcs $3efb			bcs 	_TOKFail 					; did it fail ?
.3eb8	9c 14 06	stz $0614			stz 	TOKIsFirstElement 			; clear first element flag
.3ebb	80 e1		bra $3e9e			bra 	_TOKMainLoop
.3ebd					_TOKNotDigit:
.3ebd	9c 14 06	stz $0614			stz 	TOKIsFirstElement 			; clear first element flag
.3ec0	c9 24		cmp #$24			cmp 	#"$"						; check for hexadecimal ?
.3ec2	d0 07		bne $3ecb			bne 	_TOKNotHex
.3ec4	20 56 3f	jsr $3f56			jsr 	TOKTokeniseHexadecimal
.3ec7	b0 32		bcs $3efb			bcs 	_TOKFail
.3ec9	80 d3		bra $3e9e			bra 	_TOKMainLoop
.3ecb					_TOKNotHex:
.3ecb	c9 2e		cmp #$2e			cmp 	#"."						; is it decimal e.g. .012345 etc.
.3ecd	d0 07		bne $3ed6			bne 	_TOKNotDecimal
.3ecf	20 68 3e	jsr $3e68			jsr 	TOKTokeniseDecimals
.3ed2	b0 27		bcs $3efb			bcs 	_TOKFail
.3ed4	80 c8		bra $3e9e			bra 	_TOKMainLoop
.3ed6					_TOKNotDecimal:
.3ed6	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.3ed8	d0 07		bne $3ee1			bne 	_TOKNotString
.3eda	20 7c 40	jsr $407c			jsr 	TOKTokeniseString
.3edd	b0 1c		bcs $3efb			bcs 	_TOKFail
.3edf	80 bd		bra $3e9e			bra 	_TOKMainLoop
.3ee1					_TOKNotString:
.3ee1	20 d2 40	jsr $40d2			jsr 	TOKIsAlpha 					; identifier ?
.3ee4	b0 07		bcs $3eed			bcs 	_TOKIdentifier
.3ee6	20 4b 40	jsr $404b			jsr 	TOKTokenisePunctuation 		; punctuation
.3ee9	b0 10		bcs $3efb			bcs 	_TOKFail
.3eeb	80 b1		bra $3e9e			bra 	_TOKMainLoop
.3eed					_TOKIdentifier:
.3eed	20 90 3f	jsr $3f90			jsr 	TOKTokeniseIdentifier 		; identifier/token.
.3ef0	b0 09		bcs $3efb			bcs 	_TOKFail
.3ef2	80 aa		bra $3e9e			bra 	_TOKMainLoop
.3ef4					_TOKExit:
.3ef4	a9 8c		lda #$8c			lda 	#PR_LSQLSQENDRSQRSQ 		; write EOL
.3ef6	20 fd 3e	jsr $3efd			jsr 	TOKWriteA
.3ef9	18		clc				clc									; return with carry set.
.3efa	60		rts				rts
.3efb					_TOKFail:
.3efb	38		sec				sec
.3efc	60		rts				rts
.3efd					TOKWriteA:
.3efd	da		phx				phx
.3efe	ae 01 04	ldx $0401			ldx 	TOKLineSize
.3f01	9d 01 04	sta $0401,x			sta 	TOKLineSize,x
.3f04	fa		plx				plx
.3f05	ee 01 04	inc $0401			inc 	TOKLineSize
.3f08	60		rts				rts
.3f09					TOKGet:
.3f09	18		clc				clc
.3f0a	6c 12 06	jmp ($0612)			jmp 	(TOKDataSource)
.3f0d					TOKGetNext:
.3f0d	38		sec				sec
.3f0e	6c 12 06	jmp ($0612)			jmp 	(TOKDataSource)
.0612					TOKDataSource:
>0612							.fill 	2
.0614					TOKIsFirstElement:
>0614							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokfind.asm

.3f11					TOKFindToken:
.3f11	a2 8a		ldx #$8a			ldx 	#StandardTokens & $FF 		; do this table
.3f13	a0 39		ldy #$39			ldy 	#StandardTokens >> 8
.3f15	20 20 3f	jsr $3f20			jsr 	TOKFindTokenXY 				; find it, or not
.3f18	90 04		bcc $3f1e			bcc 	_TOKFTFail
.3f1a	a2 00		ldx #$00			ldx 	#0
.3f1c	38		sec				sec
.3f1d	60		rts				rts
.3f1e					_TOKFTFail
.3f1e	18		clc				clc
.3f1f	60		rts				rts
.3f20					TOKFindTokenXY:
.3f20	86 1e		stx $1e				stx 	zTemp0 						; save token table address
.3f22	84 1f		sty $1f				sty 	zTemp0+1
.3f24	a9 80		lda #$80			lda 	#$80 						; table starts at $80
.3f26	8d 15 06	sta $0615			sta 	TOKCurrent
.3f29					_TOKFindLoop:
.3f29	b2 1e		lda ($1e)			lda 	(zTemp0) 					; get token length from table
.3f2b	18		clc				clc 		 						; clear carry in case of fail
.3f2c	30 17		bmi $3f45			bmi 	_TOKExit 					; end of table, fail, so return CC.
.3f2e	cd 12 05	cmp $0512			cmp 	TOKElement 					; compare against the element length
.3f31	d0 13		bne $3f46			bne 	_TOKNext 					; different, try next.
.3f33	aa		tax				tax 								; number of chars to compare.
.3f34	a0 01		ldy #$01			ldy 	#1 							; offset to actual text.
.3f36					_TOKCompare:
.3f36	b1 1e		lda ($1e),y			lda 	(zTemp0),y 					; compare the characters
.3f38	d9 12 05	cmp $0512,y			cmp 	TOKElementText-1,y
.3f3b	d0 09		bne $3f46			bne 	_TOKNext 					; different ? try next
.3f3d	c8		iny				iny 								; compare next two
.3f3e	ca		dex				dex
.3f3f	d0 f5		bne $3f36			bne 	_TOKCompare 				; until done X characters.
.3f41	38		sec				sec
.3f42	ad 15 06	lda $0615			lda 	TOKCurrent 					; return current ID.
.3f45					_TOKExit:
.3f45	60		rts				rts
.3f46					_TOKNext:
.3f46	ee 15 06	inc $0615			inc 	TOKCurrent 					; increment token #
.3f49	38		sec				sec 								; add length+1 to ptr
.3f4a	b2 1e		lda ($1e)			lda 	(zTemp0)
.3f4c	65 1e		adc $1e				adc 	zTemp0
.3f4e	85 1e		sta $1e				sta 	zTemp0
.3f50	90 d7		bcc $3f29			bcc 	_TOKFindLoop
.3f52	e6 1f		inc $1f				inc 	zTemp0+1
.3f54	80 d3		bra $3f29			bra 	_TOKFindLoop
.0615					TOKCurrent:
>0615							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokhexadecimal.asm

.3f56					TOKTokeniseHexadecimal:
.3f56	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext 					; consume the $
.3f59	a2 0c		ldx #$0c			ldx 	#IFR0
.3f5b	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero 				; set R0 = 0
.3f5e					_TTHLoop:
.3f5e	20 09 3f	jsr $3f09			jsr 	TOKGet 						; keep getting and copying while numeric.
.3f61	20 df 40	jsr $40df			jsr 	TOKIsHexadecimal
.3f64	90 20		bcc $3f86			bcc 	_TTHDone
.3f66	a2 0c		ldx #$0c			ldx 	#IFR0 						; shift R0 right 4
.3f68	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3f6b	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3f6e	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3f71	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.3f74	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext
.3f77	38		sec				sec 								; convert to decimal.
.3f78	e9 30		sbc #$30			sbc 	#48
.3f7a	c9 0a		cmp #$0a			cmp 	#10
.3f7c	90 02		bcc $3f80			bcc 	_TTHNotAlpha
.3f7e	e9 07		sbc #$07			sbc 	#7
.3f80					_TTHNotAlpha:
.3f80	05 0c		ora $0c				ora 	IFR0+IM0 					; OR in
.3f82	85 0c		sta $0c				sta 	IFR0+IM0
.3f84	80 d8		bra $3f5e			bra 	_TTHLoop
.3f86					_TTHDone:
.3f86	a9 ec		lda #$ec			lda 	#PR_DOLLAR 					; write $ function out
.3f88	20 fd 3e	jsr $3efd			jsr 	TOKWriteA
.3f8b	20 46 3e	jsr $3e46			jsr 	TOKTokeniseConstant 		; write integer out.
.3f8e	18		clc				clc
.3f8f	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokidentifier.asm

.3f90					TOKTokeniseIdentifier:
.3f90	20 33 3e	jsr $3e33			jsr 	TOKResetElement 			; extract an identifier
.3f93					_TOKGetIdentifier:
.3f93	20 09 3f	jsr $3f09			jsr 	TOKGet
.3f96	20 9f 40	jsr $409f			jsr 	TOKToUpper
.3f99	20 c1 40	jsr $40c1			jsr 	TOKIsIdentifierElement
.3f9c	90 08		bcc $3fa6			bcc 	_TOKEndIdent
.3f9e	20 37 3e	jsr $3e37			jsr		TOKWriteElement
.3fa1	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext
.3fa4	80 ed		bra $3f93			bra 	_TOKGetIdentifier
.3fa6					_TOKEndIdent:
.3fa6	c9 24		cmp #$24			cmp 	#"$" 						; last one $
.3fa8	d0 06		bne $3fb0			bne 	_TOKNotString
.3faa	20 37 3e	jsr $3e37			jsr 	TOKWriteElement 			; add it
.3fad	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext 					; consume it
.3fb0					_TOKNotString:
.3fb0	20 09 3f	jsr $3f09			jsr 	TOKGet 						; finally check for (
.3fb3	c9 28		cmp #$28			cmp 	#"("
.3fb5	d0 06		bne $3fbd			bne 	_TOKNoArray
.3fb7	20 37 3e	jsr $3e37			jsr 	TOKWriteElement 			; add it
.3fba	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext 					; consume it
.3fbd					_TOKNoArray:
.3fbd	20 11 3f	jsr $3f11			jsr 	TOKFindToken 				; find it
.3fc0	90 05		bcc $3fc7			bcc		_TOKIsVariable 				; it must be a variable or proc name if not found
.3fc2	20 fd 3e	jsr $3efd			jsr 	TOKWriteA
.3fc5	18		clc				clc
.3fc6	60		rts				rts
.3fc7					_TOKIsVariable:
.3fc7	a2 00		ldx #$00			ldx 	#0 							; output element buffer
.3fc9					_TOKOutputBuffer:
.3fc9	bd 13 05	lda $0513,x			lda 	TOKElementText,x 			; output it translated.
.3fcc	20 f5 3f	jsr $3ff5			jsr 	TOKTranslateIdentifier
.3fcf	20 fd 3e	jsr $3efd			jsr 	TOKWriteA
.3fd2	e8		inx				inx
.3fd3	bd 13 05	lda $0513,x			lda 	TOKElementText,x
.3fd6	20 c1 40	jsr $40c1			jsr 	TOKIsIdentifierElement
.3fd9	b0 ee		bcs $3fc9			bcs 	_TOKOutputBuffer
.3fdb	a8		tay				tay 								; last char in Y
.3fdc	a9 7c		lda #$7c			lda 	#$7C 						; token is $7C
.3fde	c0 00		cpy #$00			cpy 	#0 							; if no modifier use this
.3fe0	f0 0e		beq $3ff0			beq 	_TOKIVExit
.3fe2	c0 24		cpy #$24			cpy 	#'$'						; array mod ?
.3fe4	d0 04		bne $3fea			bne 	_TOKIVCheckArray 			; no, check for (
.3fe6	1a		inc a				inc 	a 							; token is $7D
.3fe7	bc 14 05	ldy $0514,x			ldy 	TOKElementText+1,x 			; get next one.
.3fea					_TOKIVCheckArray:
.3fea	c0 28		cpy #$28			cpy 	#'('						; is it ( ?
.3fec	d0 02		bne $3ff0			bne 	_TOKIVExit 					; yes, then add 2 more, so 7C->7E and 7D->7F
.3fee	1a		inc a				inc 	a
.3fef	1a		inc a				inc 	a
.3ff0					_TOKIVExit:
.3ff0	20 fd 3e	jsr $3efd			jsr 	TOKWriteA 					; ending token
.3ff3	18		clc				clc
.3ff4	60		rts				rts
.3ff5					TOKTranslateIdentifier:
.3ff5	c9 2e		cmp #$2e			cmp 	#"." 						; . is 0x64
.3ff7	f0 0f		beq $4008			beq 	_TTI64
.3ff9	c9 5f		cmp #$5f			cmp 	#"_"						; _ is 0x65
.3ffb	f0 0e		beq $400b			beq 	_TTI65
.3ffd	38		sec				sec
.3ffe	e9 41		sbc #$41			sbc 	#"A" 						; map A-Z onto 0-25
.4000	10 03		bpl $4005			bpl 	_TTIExit
.4002	18		clc				clc 								; map 09 onto 26-35
.4003	69 2b		adc #$2b			adc 	#"A"-"0"+26
.4005					_TTIExit:
.4005	09 40		ora #$40			ora 	#$40 						; correct range.
.4007	60		rts				rts
.4008	a9 64		lda #$64	_TTI64:	lda 	#$64
.400a	60		rts				rts
.400b	a9 65		lda #$65	_TTI65:	lda 	#$65
.400d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokinteger.asm

.400e					TOKTokeniseInteger:
.400e	20 37 40	jsr $4037			jsr 	TOKExtractInteger 			; pull an integer out as text.
.4011	a2 13		ldx #$13			ldx 	#TOKElementText & $FF
.4013	a0 05		ldy #$05			ldy 	#TOKElementText >> 8
.4015	ad 12 05	lda $0512			lda		TOKElement
.4018	20 b2 4c	jsr $4cb2			jsr 	IFloatStringToFloatR0 		; convert to R0 integer
.401b	ad 14 06	lda $0614			lda 	TOKIsFirstElement 			; first element ?
.401e	f0 12		beq $4032			beq 	_TOKNotLineNumber
.4020	a5 0e		lda $0e				lda 	IFR0+IM2 					; check it's a 2 digit number
.4022	d0 0c		bne $4030			bne 	_TOKBadLineNumeber
.4024	a5 0c		lda $0c				lda 	IFR0+IM0 					; copy it to the line number section.
.4026	8d 02 04	sta $0402			sta 	TOKLineNumber
.4029	a5 0d		lda $0d				lda 	IFR0+IM1
.402b	8d 03 04	sta $0403			sta 	TOKLineNumber+1
.402e	18		clc				clc
.402f	60		rts				rts
.4030					_TOKBadLineNumeber:
.4030	38		sec				sec
.4031	60		rts				rts
.4032					_TOKNotLineNumber:
.4032	20 46 3e	jsr $3e46			jsr 	TOKTokeniseConstant 		; tokenise the constant in R0
.4035	18		clc				clc
.4036	60		rts				rts
.4037					TOKExtractInteger:
.4037	20 33 3e	jsr $3e33			jsr 	TOKResetElement 			; restart
.403a					_TTILoop:
.403a	20 09 3f	jsr $3f09			jsr 	TOKGet 						; keep getting and copying while numeric.
.403d	20 b5 40	jsr $40b5			jsr 	TOKIsDigit
.4040	90 08		bcc $404a			bcc 	_TOKEIExit
.4042	20 37 3e	jsr $3e37			jsr 	TOKWriteElement
.4045	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext
.4048	80 f0		bra $403a			bra 	_TTILoop
.404a					_TOKEIExit:
.404a	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokpunctuation.asm

.404b					TOKTokenisePunctuation:
.404b	20 33 3e	jsr $3e33			jsr 	TOKResetElement 			; copy first punctuation character into element.
.404e	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext
.4051	20 37 3e	jsr $3e37			jsr 	TOKWriteElement
.4054	20 09 3f	jsr $3f09			jsr 	TOKGet 						; what follows ?
.4057	c9 20		cmp #$20			cmp 	#' '						; space, not 2 character
.4059	f0 10		beq $406b			beq 	_TTPOne
.405b	20 c9 40	jsr $40c9			jsr 	TOKIsAlphaNumeric 			; if alphanumeric don't bother doing 2 character
.405e	b0 0b		bcs $406b			bcs 	_TTPOne 					; these speed things up a bit.
.4060	20 37 3e	jsr $3e37			jsr 	TOKWriteElement 			; this is what we will search for.
.4063	20 11 3f	jsr $3f11			jsr 	TOKFindToken
.4066	b0 0a		bcs $4072			bcs 	_TTPConsumeExit 			; it was found, consume, generate, exit.
.4068	ce 12 05	dec $0512			dec 	TOKElement 					; make it a single character
.406b					_TTPOne:
.406b	20 11 3f	jsr $3f11			jsr 	TOKFindToken 				; look for one character punctuation
.406e	b0 07		bcs $4077			bcs 	_TTPOutputExit 				; we found it
.4070	38		sec				sec 								; not recognised.
.4071	60		rts				rts
.4072					_TTPConsumeExit:
.4072	48		pha				pha
.4073	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext 					; get the 2nd char out.
.4076	68		pla				pla
.4077					_TTPOutputExit:
.4077	20 fd 3e	jsr $3efd			jsr  	TOKWriteA 					; write token out
.407a	18		clc				clc
.407b	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokstring.asm

.407c					TOKTokeniseString:
.407c	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext 					; consume the "
.407f	20 33 3e	jsr $3e33			jsr 	TOKResetElement 			; start getting the string
.4082					_TOKTSLoop:
.4082	20 09 3f	jsr $3f09			jsr 	TOKGet 						; check EOL
.4085	c9 00		cmp #$00			cmp 	#0
.4087	f0 0c		beq $4095			beq 	_TOKTSExit
.4089	20 0d 3f	jsr $3f0d			jsr 	TOKGetNext 					; get and consume
.408c	c9 22		cmp #$22			cmp 	#'"' 						; exit if " consumed
.408e	f0 05		beq $4095			beq 	_TOKTSExit
.4090	20 37 3e	jsr $3e37			jsr 	TOKWriteElement
.4093	80 ed		bra $4082			bra 	_TOKTSLoop
.4095					_TOKTSExit:
.4095	a9 ee		lda #$ee			lda 	#PR_LSQLSQSTRINGRSQRSQ
.4097	20 fd 3e	jsr $3efd			jsr 	TOKWriteA
.409a	20 78 3e	jsr $3e78			jsr 	TOKOutputElementBuffer
.409d	18		clc				clc
.409e	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/toktypes.asm

.409f					TOKToUpper:
.409f	c9 61		cmp #$61			cmp 	#"a"
.40a1	90 06		bcc $40a9			bcc 	_TTUNotLower
.40a3	c9 7b		cmp #$7b			cmp 	#"z"+1
.40a5	b0 02		bcs $40a9			bcs 	_TTUNotLower
.40a7	49 20		eor #$20			eor 	#$20
.40a9					_TTUNotLower:
.40a9	60		rts				rts
.40aa					TOKToLower:
.40aa	c9 41		cmp #$41			cmp 	#"A"
.40ac	90 06		bcc $40b4			bcc 	_TTUNotUpper
.40ae	c9 5b		cmp #$5b			cmp 	#"Z"+1
.40b0	b0 02		bcs $40b4			bcs 	_TTUNotUpper
.40b2	49 20		eor #$20			eor 	#$20
.40b4					_TTUNotUpper:
.40b4	60		rts				rts
.40b5					TOKIsDigit:
.40b5	c9 30		cmp #$30			cmp 	#"0"
.40b7	90 06		bcc $40bf			bcc 	TOKFail
.40b9	c9 3a		cmp #$3a			cmp 	#"9"+1
.40bb	b0 02		bcs $40bf			bcs 	TOKFail
.40bd					TOKSucceed:
.40bd	38		sec				sec
.40be	60		rts				rts
.40bf					TOKFail:
.40bf	18		clc				clc
.40c0	60		rts				rts
.40c1					TOKIsIdentifierElement:
.40c1	c9 2e		cmp #$2e			cmp 	#"." 						; true if . or _
.40c3	f0 f8		beq $40bd			beq 	TOKSucceed
.40c5	c9 5f		cmp #$5f			cmp 	#"_"
.40c7	f0 f4		beq $40bd			beq 	TOKSucceed 					; else fall through to alphanumeric
.40c9					TOKIsAlphaNumeric:
.40c9	20 d2 40	jsr $40d2			jsr 	TOKIsAlpha
.40cc	b0 ef		bcs $40bd			bcs 	TOKSucceed
.40ce	20 b5 40	jsr $40b5			jsr 	TOKIsDigit
.40d1	60		rts				rts
.40d2					TOKIsAlpha:
.40d2	20 9f 40	jsr $409f			jsr 	TOKToUpper
.40d5	c9 41		cmp #$41			cmp 	#"A"
.40d7	90 e6		bcc $40bf			bcc 	TOKFail
.40d9	c9 5b		cmp #$5b			cmp 	#"Z"+1
.40db	b0 e2		bcs $40bf			bcs 	TOKFail
.40dd	80 de		bra $40bd			bra 	TOKSucceed
.40df					TOKIsHexadecimal:
.40df	20 b5 40	jsr $40b5			jsr		TOKIsDigit
.40e2	b0 d9		bcs $40bd			bcs 	TOKSucceed
.40e4	20 d2 40	jsr $40d2			jsr 	TOKIsAlpha
.40e7	90 d6		bcc $40bf			bcc 	TOKFail
.40e9	c9 47		cmp #$47			cmp 	#"F"+1
.40eb	b0 d2		bcs $40bf			bcs 	TOKFail
.40ed	80 ce		bra $40bd			bra 	TOKSucceed

;******  Return to file: include.files


;******  Processing file: src/structures/call.asm

.40ef					Command_CALL:
.40ef	a9 42		lda #$42			lda 	#STK_CALL
.40f1	20 66 45	jsr $4566			jsr 	StackOpen
.40f4	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; check identifier follows.
.40f6	29 c0		and #$c0			and 	#$C0
.40f8	c9 40		cmp #$40			cmp 	#$40
.40fa	d0 29		bne $4125			bne 	_CCSyntax
.40fc	20 8f 47	jsr $478f			jsr 	VARGetInfo 					; get the information
.40ff	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 				; check right bracket follows.
.4102	20 41 47	jsr $4741			jsr 	VARFind 					; exists ?
.4105	90 21		bcc $4128			bcc 	_CCUnknown
.4107	86 1f		stx $1f				stx 	zTemp0+1 					; save target in XA
.4109	85 1e		sta $1e				sta 	zTemp0
.410b	20 9a 45	jsr $459a			jsr 	STKSaveCodePosition 		; save return address on stack.
.410e	a0 03		ldy #$03			ldy 	#3 							; check $FF marker
.4110	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.4112	c9 ff		cmp #$ff			cmp 	#$FF
.4114	d0 12		bne $4128			bne 	_CCUnknown
.4116	88		dey				dey 								; get Y offset to stack
.4117	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.4119	48		pha				pha
.411a	88		dey				dey 								; get address
.411b	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.411d	85 1d		sta $1d				sta 	codePtr+1
.411f	b2 1e		lda ($1e)			lda 	(zTemp0)
.4121	85 1c		sta $1c				sta 	codePtr
.4123	7a		ply				ply 								; restore Y
.4124	60		rts				rts
.4125					_CCSyntax:
.4125	4c ce 43	jmp $43ce		jmp	ErrorV_syntax
.4128					_CCUnknown:
.4128	4c 30 45	jmp $4530		jmp	ErrorV_unknown
.412b					Command_ENDPROC:
.412b	a9 42		lda #$42			lda 	#STK_CALL
.412d	20 92 45	jsr $4592			jsr 	StackCheckFrame
.4130	20 ac 45	jsr $45ac			jsr 	STKLoadCodePosition 		; return
.4133	20 84 45	jsr $4584			jsr 	StackClose
.4136	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/do.asm

.4137					Command_DO:
.4137	a9 22		lda #$22			lda 	#STK_DO
.4139	20 66 45	jsr $4566			jsr 	StackOpen
.413c	20 9a 45	jsr $459a			jsr 	STKSaveCodePosition 		; save loop position
.413f	60		rts				rts
.4140					Command_EXIT:
.4140	a9 22		lda #$22			lda 	#STK_DO 					; check in LOOP
.4142	20 92 45	jsr $4592			jsr 	StackCheckFrame
.4145	20 84 45	jsr $4584			jsr 	StackClose 					; close it
.4148	a9 87		lda #$87			lda 	#PR_LOOP 					; forward to LOOP
.414a	aa		tax				tax
.414b	20 e0 42	jsr $42e0			jsr 	ScanForward
.414e	60		rts				rts
.414f					Command_LOOP:
.414f	a9 22		lda #$22			lda 	#STK_DO
.4151	20 92 45	jsr $4592			jsr 	StackCheckFrame
.4154	20 ac 45	jsr $45ac			jsr 	STKLoadCodePosition 		; loop back
.4157	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/for.asm

.4158					Command_FOR:
.4158	a9 37		lda #$37			lda 	#STK_FOR 					; create frame
.415a	20 66 45	jsr $4566			jsr 	StackOpen
.415d	20 4d 33	jsr $334d			jsr 	CommandLET 					; do "I = 1" bit
.4160	5a		phy				phy 								; save variable address to +4,+5
.4161	a0 04		ldy #$04			ldy 	#4
.4163	a5 1e		lda $1e				lda 	zTemp0
.4165	91 26		sta ($26),y			sta 	(basicStack),y
.4167	c8		iny				iny
.4168	a5 1f		lda $1f				lda 	zTemp0+1
.416a	91 26		sta ($26),y			sta 	(basicStack),y
.416c	7a		ply				ply
.416d	a9 90		lda #$90			lda 	#PR_TO 						; TO symbol required.
.416f	20 5d 45	jsr $455d			jsr 	ERRCheckA
.4172	20 03 36	jsr $3603			jsr 	EXPEvalNumber 				; evaluate the terminal value.
.4175	a9 0a		lda #$0a			lda 	#10 						; save in slots 10-13
.4177	a2 0c		ldx #$0c			ldx 	#IFR0
.4179	20 ce 41	jsr $41ce			jsr 	CFSaveR0X
.417c	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; STEP here ?
.417e	c9 91		cmp #$91			cmp 	#PR_STEP
.4180	d0 06		bne $4188			bne 	_CFStep1
.4182	c8		iny				iny 								; consume step
.4183	20 03 36	jsr $3603			jsr 	EXPEvalNumber 				; evaluate STEP
.4186	80 24		bra $41ac			bra 	_CFWriteStep
.4188					_CFStep1:
.4188	a2 0c		ldx #$0c			ldx 	#IFR0 						; default R0, 1
.418a	a9 01		lda #$01			lda 	#1
.418c	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.418f	5a		phy				phy 								; check for fast loop,step 1, integer start/end.
.4190	a0 04		ldy #$04			ldy 	#4 							; get variable address
.4192	b1 26		lda ($26),y			lda 	(basicStack),y
.4194	85 1e		sta $1e				sta 	zTemp0
.4196	c8		iny				iny
.4197	b1 26		lda ($26),y			lda 	(basicStack),y
.4199	85 1f		sta $1f				sta 	zTemp0+1
.419b	a0 03		ldy #$03			ldy 	#IExp 						; check that's an integer
.419d	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.419f	d0 0a		bne $41ab			bne 	_CFNotOptimised
.41a1	a0 0d		ldy #$0d			ldy 	#13 						; check terminal value is integer.
.41a3	b1 26		lda ($26),y			lda 	(basicStack),y
.41a5	d0 04		bne $41ab			bne 	_CFNotOptimised
.41a7	a9 80		lda #$80			lda 	#$80 						; set the step so it's a string/
.41a9	85 0f		sta $0f				sta 	IFR0+IExp
.41ab					_CFNotOptimised:
.41ab	7a		ply				ply
.41ac					_CFWriteStep:
.41ac	a2 0c		ldx #$0c			ldx 	#IFR0 						; Write to additive.
.41ae	a9 06		lda #$06			lda 	#6
.41b0	20 ce 41	jsr $41ce			jsr 	CFSaveR0X
.41b3	20 9a 45	jsr $459a			jsr 	STKSaveCodePosition 		; save loop position
.41b6	60		rts				rts
.41b7					CFLoadR0X:
.41b7	5a		phy				phy
.41b8	a8		tay				tay
.41b9	b1 26		lda ($26),y			lda 	(basicStack),y
.41bb	95 00		sta $00,x			sta 	IM0,x
.41bd	c8		iny				iny
.41be	b1 26		lda ($26),y			lda 	(basicStack),y
.41c0	95 01		sta $01,x			sta 	IM1,x
.41c2	c8		iny				iny
.41c3	b1 26		lda ($26),y			lda 	(basicStack),y
.41c5	95 02		sta $02,x			sta 	IM2,x
.41c7	c8		iny				iny
.41c8	b1 26		lda ($26),y			lda 	(basicStack),y
.41ca	95 03		sta $03,x			sta 	IExp,x
.41cc	7a		ply				ply
.41cd	60		rts				rts
.41ce					CFSaveR0X:
.41ce	5a		phy				phy
.41cf	a8		tay				tay
.41d0	b5 00		lda $00,x			lda 	IM0,x
.41d2	91 26		sta ($26),y			sta 	(basicStack),y
.41d4	c8		iny				iny
.41d5	b5 01		lda $01,x			lda 	IM1,x
.41d7	91 26		sta ($26),y			sta 	(basicStack),y
.41d9	c8		iny				iny
.41da	b5 02		lda $02,x			lda 	IM2,x
.41dc	91 26		sta ($26),y			sta 	(basicStack),y
.41de	c8		iny				iny
.41df	b5 03		lda $03,x			lda 	IExp,x
.41e1	91 26		sta ($26),y			sta 	(basicStack),y
.41e3	7a		ply				ply
.41e4	60		rts				rts
.41e5					Command_NEXT:
.41e5	a9 37		lda #$37			lda 	#STK_FOR
.41e7	20 92 45	jsr $4592			jsr 	StackCheckFrame
.41ea	5a		phy				phy 								; check optimised loop
.41eb	a0 09		ldy #$09			ldy 	#9
.41ed	b1 26		lda ($26),y			lda 	(basicStack),y
.41ef	7a		ply				ply
.41f0	0a		asl a				asl 	a
.41f1	b0 35		bcs $4228			bcs 	_CNOptimised
.41f3	20 5f 42	jsr $425f			jsr 	_CNLoadValue 				; load index value to R0.
.41f6	a2 10		ldx #$10			ldx 	#IFR1 						; load adding value to R1.
.41f8	a9 06		lda #$06			lda 	#6
.41fa	20 b7 41	jsr $41b7			jsr 	CFLoadR0X
.41fd	20 44 48	jsr $4844			jsr 	IFloatAdd 					; add them together and write back.
.4200	20 82 42	jsr $4282			jsr 	_CNSaveValue
.4203	a9 0a		lda #$0a			lda 	#10 						; terminal value in R1
.4205	a2 10		ldx #$10			ldx 	#IFR1
.4207	20 b7 41	jsr $41b7			jsr 	CFLoadR0X
.420a	20 1c 4b	jsr $4b1c			jsr 	IFloatCompare 				; compare terminal vs current
.420d	a2 0c		ldx #$0c			ldx 	#IFR0 						; if zero, e.g. equal, loop back.
.420f	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero
.4212	f0 10		beq $4224			beq 	_CNLoopBack
.4214	a5 0f		lda $0f				lda 	IFR0+IExp 					; if sign compare and sign add match, loop back.
.4216	5a		phy				phy
.4217	a0 09		ldy #$09			ldy 	#6+IExp
.4219	51 26		eor ($26),y			eor 	(basicStack),y
.421b	7a		ply				ply
.421c	29 40		and #$40			and 	#IFSign
.421e	f0 04		beq $4224			beq 	_CNLoopBack
.4220					_CNExitLoop:
.4220	20 84 45	jsr $4584			jsr 	StackClose		 			; return
.4223	60		rts				rts
.4224					_CNLoopBack:
.4224	20 ac 45	jsr $45ac			jsr 	STKLoadCodePosition 		; loop back
.4227	60		rts				rts
.4228					_CNOptimised:
.4228	5a		phy				phy
.4229	a0 04		ldy #$04			ldy 	#4 							; copy address of index variable to zTemp2
.422b	b1 26		lda ($26),y			lda 	(basicStack),y
.422d	85 22		sta $22				sta 	zTemp2
.422f	c8		iny				iny
.4230	b1 26		lda ($26),y			lda 	(basicStack),y
.4232	85 23		sta $23				sta 	zTemp2+1
.4234	a0 ff		ldy #$ff			ldy 	#$FF 						; increment that value. this won't go round
.4236					_CNIncrement:
.4236	c8		iny				iny
.4237	b1 22		lda ($22),y			lda 	(zTemp2),y
.4239	1a		inc a				inc 	a
.423a	91 22		sta ($22),y			sta 	(zTemp2),y
.423c	f0 f8		beq $4236			beq 	_CNIncrement
.423e	18		clc				clc 								; point zTemp0 to terminal value
.423f	a5 26		lda $26				lda 	basicStack
.4241	69 0a		adc #$0a			adc 	#10
.4243	85 1e		sta $1e				sta 	zTemp0
.4245	a5 27		lda $27				lda 	basicStack+1
.4247	69 00		adc #$00			adc 	#0
.4249	85 1f		sta $1f				sta 	zTemp0+1
.424b	a0 01		ldy #$01			ldy 	#1 							; compare value to terminal.
.424d	b2 22		lda ($22)			lda 	(zTemp2)
.424f	d2 1e		cmp ($1e)			cmp 	(zTemp0)
.4251	b1 22		lda ($22),y			lda 	(zTemp2),y
.4253	f1 1e		sbc ($1e),y			sbc 	(zTemp0),y
.4255	c8		iny				iny
.4256	b1 22		lda ($22),y			lda 	(zTemp2),y
.4258	f1 1e		sbc ($1e),y			sbc 	(zTemp0),y
.425a	7a		ply				ply
.425b	b0 c3		bcs $4220			bcs 	_CNExitLoop
.425d	80 c5		bra $4224			bra 	_CNLoopBack
.425f					_CNLoadValue:
.425f	5a		phy				phy
.4260	a0 04		ldy #$04			ldy 	#4 							; copy address to zTemp2
.4262	b1 26		lda ($26),y			lda 	(basicStack),y
.4264	85 22		sta $22				sta 	zTemp2
.4266	c8		iny				iny
.4267	b1 26		lda ($26),y			lda 	(basicStack),y
.4269	85 23		sta $23				sta 	zTemp2+1
.426b	a0 00		ldy #$00			ldy 	#0 							; copy dword at zTemp2 to IFR0
.426d	b1 22		lda ($22),y			lda 	(zTemp2),y
.426f	85 0c		sta $0c				sta 	IFR0+IM0
.4271	c8		iny				iny
.4272	b1 22		lda ($22),y			lda 	(zTemp2),y
.4274	85 0d		sta $0d				sta 	IFR0+IM1
.4276	c8		iny				iny
.4277	b1 22		lda ($22),y			lda 	(zTemp2),y
.4279	85 0e		sta $0e				sta 	IFR0+IM2
.427b	c8		iny				iny
.427c	b1 22		lda ($22),y			lda 	(zTemp2),y
.427e	85 0f		sta $0f				sta 	IFR0+IExp
.4280	7a		ply				ply
.4281	60		rts				rts
.4282					_CNSaveValue:
.4282	5a		phy				phy
.4283	a0 00		ldy #$00			ldy 	#0
.4285	a5 0c		lda $0c				lda 	IFR0+IM0
.4287	91 22		sta ($22),y			sta 	(zTemp2),y
.4289	c8		iny				iny
.428a	a5 0d		lda $0d				lda 	IFR0+IM1
.428c	91 22		sta ($22),y			sta 	(zTemp2),y
.428e	c8		iny				iny
.428f	a5 0e		lda $0e				lda 	IFR0+IM2
.4291	91 22		sta ($22),y			sta 	(zTemp2),y
.4293	c8		iny				iny
.4294	a5 0f		lda $0f				lda 	IFR0+IExp
.4296	91 22		sta ($22),y			sta 	(zTemp2),y
.4298	7a		ply				ply
.4299	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/if.asm

.429a					IfCommand:
.429a	20 03 36	jsr $3603			jsr 	EXPEvalNumber 				; Get the if test.
.429d	b1 1c		lda ($1c),y			lda 	(codePtr),y					; what follows ?
.429f	c9 8f		cmp #$8f			cmp 	#PR_THEN  					; could be THEN <stuff>
.42a1	d0 0a		bne $42ad			bne 	_IfStructured 				; we still support it.
.42a3	c8		iny				iny 								; consume THEN
.42a4	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero 			; is it zero
.42a7	f0 01		beq $42aa			beq 	_IfFail 					; if fail, go to next line
.42a9	60		rts				rts 								; if THEN just continue
.42aa					_IfFail:
.42aa	4c e7 33	jmp $33e7			jmp 	RUNEndOfLine
.42ad					_IfStructured:
.42ad	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero 			; is it zero
.42b0	d0 07		bne $42b9			bne 	_IfExit 					; if not, then continue normally.
.42b2	a9 8e		lda #$8e			lda 	#PR_ELSE 					; look for else/endif
.42b4	a2 85		ldx #$85			ldx 	#PR_ENDIF
.42b6	20 e0 42	jsr $42e0			jsr 	ScanForward 				; and run from there
.42b9					_IfExit:
.42b9	60		rts				rts
.42ba					ElseCode:
.42ba	a9 85		lda #$85			lda 	#PR_ENDIF 					; else is only run after the if clause succeeds
.42bc	aa		tax				tax 								; so just go to the structure exit
.42bd	20 e0 42	jsr $42e0			jsr 	ScanForward
.42c0	60		rts				rts
.42c1					EndIf:
.42c1	60		rts				rts 								; endif code does nothing

;******  Return to file: include.files


;******  Processing file: src/structures/repeat.asm

.42c2					Command_REPEAT:
.42c2	a9 02		lda #$02			lda 	#STK_REPEAT
.42c4	20 66 45	jsr $4566			jsr 	StackOpen
.42c7	20 9a 45	jsr $459a			jsr 	STKSaveCodePosition 		; save loop position
.42ca	60		rts				rts
.42cb					Command_UNTIL:
.42cb	a9 02		lda #$02			lda 	#STK_REPEAT
.42cd	20 92 45	jsr $4592			jsr 	StackCheckFrame
.42d0	20 03 36	jsr $3603			jsr 	EXPEvalNumber 				; work out the test
.42d3	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero 			; check if zero
.42d6	f0 04		beq $42dc			beq 	_CULoopBack 				; if so keep looping
.42d8	20 84 45	jsr $4584			jsr 	StackClose		 			; return
.42db	60		rts				rts
.42dc					_CULoopBack:
.42dc	20 ac 45	jsr $45ac			jsr 	STKLoadCodePosition 		; loop back
.42df	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/scanforward.asm

.42e0					ScanForward:
.42e0	85 1e		sta $1e				sta 	zTemp0 						; save scan options in zTemp0
.42e2	86 1f		stx $1f				stx 	zTemp0+1
.42e4	64 20		stz $20				stz 	zTemp1 						; clear structure count.
.42e6					_ScanForwardLoop:
.42e6	a5 20		lda $20				lda 	zTemp1 						; if structure count non zero, don't check for end.
.42e8	d0 0a		bne $42f4			bne 	_ScanNoCheck
.42ea	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; reached either target token.
.42ec	c5 1e		cmp $1e				cmp 	zTemp0
.42ee	f0 49		beq $4339			beq 	_ScanExit
.42f0	c5 1f		cmp $1f				cmp 	zTemp0+1
.42f2	f0 45		beq $4339			beq 	_ScanExit
.42f4					_ScanNoCheck:
.42f4	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get the token and consume it.
.42f6	c8		iny				iny
.42f7	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ 	; check for special multi-byte elements
.42f9	f0 37		beq $4332			beq		_ScanDataItem
.42fb	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ
.42fd	f0 33		beq $4332			beq 	_ScanDataItem
.42ff	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; handle end of line.
.4301	f0 1b		beq $431e			beq 	_ScanNextLine
.4303	c9 8d		cmp #$8d			cmp 	#PR_LSQLSQSHIFTRSQRSQ 		; if shift, skip one.
.4305	d0 01		bne $4308			bne 	_ScanNoShift
.4307	c8		iny				iny
.4308					_ScanNoShift:
.4308	c9 8c		cmp #$8c			cmp 	#PR_STRUCTURE_LAST+1 		; nested structures
.430a	b0 da		bcs $42e6			bcs 	_ScanForwardLoop
.430c	c9 80		cmp #$80			cmp 	#PR_STRUCTURE_FIRST
.430e	90 d6		bcc $42e6			bcc 	_ScanForwardLoop
.4310	aa		tax				tax 								; access the table to get the adjustment.
.4311	18		clc				clc
.4312	a5 20		lda $20				lda 	zTemp1 						; add it to structure count.
.4314	7d fe 38	adc $38fe,x			adc 	StructureOffsets-PR_STRUCTURE_FIRST,x
.4317	85 20		sta $20				sta 	zTemp1
.4319	10 cb		bpl $42e6			bpl		_ScanForwardLoop 			; error if -ve ?
.431b	4c 52 44	jmp $4452		jmp	ErrorV_structure
.431e					_ScanNextLine:
.431e	18		clc				clc	 								; forward to next line.
.431f	b2 1c		lda ($1c)			lda 	(codePtr)
.4321	65 1c		adc $1c				adc 	codePtr
.4323	85 1c		sta $1c				sta 	codePtr
.4325	90 02		bcc $4329			bcc 	_ScanNoCarry
.4327	e6 1d		inc $1d				inc 	codePtr+1
.4329					_ScanNoCarry:
.4329	a0 03		ldy #$03			ldy 	#3
.432b	b2 1c		lda ($1c)			lda 	(codePtr) 					; off end of program ?
.432d	d0 b7		bne $42e6			bne 	_ScanForwardLoop
.432f	4c 52 44	jmp $4452		jmp	ErrorV_structure
.4332					_ScanDataItem:
.4332	98		tya				tya
.4333	38		sec				sec
.4334	71 1c		adc ($1c),y			adc 	(codePtr),y
.4336	a8		tay				tay
.4337	80 ad		bra $42e6			bra 	_ScanForwardLoop
.4339					_ScanExit:
.4339	c8		iny				iny 								; consume final token.
.433a	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/scanproc.asm

.433b					ScanProcedures:
.433b	a5 1c		lda $1c				lda 	codePtr 					; push codePtr on the stack
.433d	48		pha				pha
.433e	a5 1d		lda $1d				lda 	codePtr+1
.4340	48		pha				pha
.4341	5a		phy				phy
.4342	ad 10 05	lda $0510			lda 	PGMBaseHigh 				; back to the program start
.4345	85 1d		sta $1d				sta 	codePtr+1
.4347	64 1c		stz $1c				stz 	codePtr
.4349					_SPLoop:
.4349	b2 1c		lda ($1c)			lda 	(codePtr) 					; end of program
.434b	f0 18		beq $4365			beq 	_SPExit
.434d	a0 03		ldy #$03			ldy 	#3 							; first token PROC
.434f	b1 1c		lda ($1c),y			lda 	(codePtr),y
.4351	c9 88		cmp #$88			cmp 	#PR_PROC
.4353	d0 03		bne $4358			bne 	_SPNext
.4355	20 6d 43	jsr $436d			jsr 	_SPSetupRecord
.4358					_SPNext:
.4358	18		clc				clc 								; forward to next
.4359	b2 1c		lda ($1c)			lda 	(codePtr)
.435b	65 1c		adc $1c				adc 	codePtr
.435d	85 1c		sta $1c				sta 	codePtr
.435f	90 e8		bcc $4349			bcc 	_SPLoop
.4361	e6 1d		inc $1d				inc 	codePtr+1
.4363	80 e4		bra $4349			bra 	_SPLoop
.4365					_SPExit:
.4365	7a		ply				ply
.4366	68		pla				pla
.4367	85 1d		sta $1d				sta 	codePtr+1
.4369	68		pla				pla
.436a	85 1c		sta $1c				sta 	codePtr
.436c	60		rts				rts
.436d					_SPSetupRecord:
.436d	c8		iny				iny 								; check identifier follows
.436e	b1 1c		lda ($1c),y			lda 	(codePtr),y
.4370	29 c0		and #$c0			and 	#$C0
.4372	c9 40		cmp #$40			cmp 	#$40
.4374	d0 27		bne $439d			bne 	_SPSyntax
.4376	20 8f 47	jsr $478f			jsr 	VARGetInfo 					; get the information
.4379	20 4d 45	jsr $454d			jsr 	ERRCheckRParen 				; check right bracket follows.
.437c	20 41 47	jsr $4741			jsr 	VARFind 					; already exists ?
.437f	b0 1f		bcs $43a0			bcs 	_SPUsed 					; error !
.4381	20 ed 46	jsr $46ed			jsr 	VARCreate 					; create, XA points to the data.
.4384	85 1e		sta $1e				sta 	zTemp0
.4386	86 1f		stx $1f				stx 	zTemp0+1
.4388	5a		phy				phy 								; save Y pos on stack
.4389	a0 01		ldy #$01			ldy 	#1
.438b	a5 1c		lda $1c				lda 	codePtr 					; save codePtr/Y
.438d	92 1e		sta ($1e)			sta 	(zTemp0)
.438f	a5 1d		lda $1d				lda 	codePtr+1
.4391	91 1e		sta ($1e),y			sta 	(zTemp0),y
.4393	c8		iny				iny
.4394	68		pla				pla
.4395	91 1e		sta ($1e),y			sta 	(zTemp0),y
.4397	c8		iny				iny
.4398	a9 ff		lda #$ff			lda 	#$FF 						; fill rest with $FF
.439a	91 1e		sta ($1e),y			sta 	(zTemp0),y
.439c	60		rts				rts
.439d					_SPSyntax:
.439d	4c ce 43	jmp $43ce		jmp	ErrorV_syntax
.43a0					_SPUsed:
.43a0	4c 13 45	jmp $4513		jmp	ErrorV_dupproc

;******  Return to file: include.files


;******  Processing file: src/structures/while.asm

.43a3					Command_WHILE:
.43a3	5a		phy				phy 								; save position of the test
.43a4	20 03 36	jsr $3603			jsr 	EXPEvalNumber 				; work out the while test.
.43a7	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero 			; check if zero
.43aa	f0 0e		beq $43ba			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.43ac	98		tya				tya 								; position *after* test.
.43ad	7a		ply				ply 								; restore position before test, at WHILE
.43ae	88		dey				dey 								; so we execute the WHILE command again.
.43af	48		pha				pha 								; push after test on the stack
.43b0	a9 12		lda #$12			lda 	#STK_WHILE 					; open while frame
.43b2	20 66 45	jsr $4566			jsr 	StackOpen
.43b5	20 9a 45	jsr $459a			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.43b8	7a		ply				ply 								; restore the position *after* the test
.43b9	60		rts				rts
.43ba					_WHExitLoop:
.43ba	68		pla				pla 								; throw post loop position
.43bb	a9 83		lda #$83			lda 	#PR_WEND 					; scan forward past WEND
.43bd	aa		tax				tax
.43be	20 e0 42	jsr $42e0			jsr 	ScanForward
.43c1	60		rts				rts
.43c2					Command_WEND:
.43c2	a9 12		lda #$12			lda 	#STK_WHILE 					; check WHILE is TOS e.g. in a while loop :)
.43c4	20 92 45	jsr $4592			jsr 	StackCheckFrame
.43c7	20 ac 45	jsr $45ac			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.43ca	20 84 45	jsr $4584			jsr 	StackClose		 			; erase the frame
.43cd	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/support/errors/generated/errors.asm

.43ce					ErrorV_syntax:
.43ce	20 30 4f	jsr $4f30		jsr	ErrorHandler
>43d1	53 79 6e 74 61 78 20 45			.text	"Syntax Error",0
>43d9	72 72 6f 72 00
.43de					ErrorV_range:
.43de	20 30 4f	jsr $4f30		jsr	ErrorHandler
>43e1	4f 75 74 20 4f 66 20 52			.text	"Out Of Range",0
>43e9	61 6e 67 65 00
.43ee					ErrorV_value:
.43ee	20 30 4f	jsr $4f30		jsr	ErrorHandler
>43f1	42 61 64 20 56 61 6c 75			.text	"Bad Value",0
>43f9	65 00
.43fb					ErrorV_type:
.43fb	20 30 4f	jsr $4f30		jsr	ErrorHandler
>43fe	54 79 70 65 20 4d 69 73			.text	"Type Mismatch",0
>4406	6d 61 74 63 68 00
.440c					ErrorV_unimplemented:
.440c	20 30 4f	jsr $4f30		jsr	ErrorHandler
>440f	4e 6f 74 20 49 6d 70 6c			.text	"Not Implemented",0
>4417	65 6d 65 6e 74 65 64 00
.441f					ErrorV_assert:
.441f	20 30 4f	jsr $4f30		jsr	ErrorHandler
>4422	41 73 73 65 72 74 20 46			.text	"Assert Fail",0
>442a	61 69 6c 00
.442e					ErrorV_internal:
.442e	20 30 4f	jsr $4f30		jsr	ErrorHandler
>4431	49 6e 74 65 72 6e 61 6c			.text	"Internal Error",0
>4439	20 45 72 72 6f 72 00
.4440					ErrorV_divzero:
.4440	20 30 4f	jsr $4f30		jsr	ErrorHandler
>4443	44 69 76 69 64 65 20 42			.text	"Divide By Zero",0
>444b	79 20 5a 65 72 6f 00
.4452					ErrorV_structure:
.4452	20 30 4f	jsr $4f30		jsr	ErrorHandler
>4455	53 74 72 75 63 74 75 72			.text	"Structure Imbalance",0
>445d	65 20 49 6d 62 61 6c 61 6e 63 65 00
.4469					ErrorV_stop:
.4469	20 30 4f	jsr $4f30		jsr	ErrorHandler
>446c	50 72 6f 67 72 61 6d 20			.text	"Program Stopped",0
>4474	53 74 6f 70 70 65 64 00
.447c					ErrorV_data:
.447c	20 30 4f	jsr $4f30		jsr	ErrorHandler
>447f	4f 75 74 20 4f 66 20 44			.text	"Out Of Data",0
>4487	61 74 61 00
.448b					ErrorV_redefine:
.448b	20 30 4f	jsr $4f30		jsr	ErrorHandler
>448e	41 72 72 61 79 20 52 65			.text	"Array Redefined",0
>4496	64 65 66 69 6e 65 64 00
.449e					ErrorV_index:
.449e	20 30 4f	jsr $4f30		jsr	ErrorHandler
>44a1	42 61 64 20 41 72 72 61			.text	"Bad Array Index",0
>44a9	79 20 49 6e 64 65 78 00
.44b1					ErrorV_memory:
.44b1	20 30 4f	jsr $4f30		jsr	ErrorHandler
>44b4	4f 75 74 20 4f 66 20 4d			.text	"Out Of Memory",0
>44bc	65 6d 6f 72 79 00
.44c2					ErrorV_uninitialised:
.44c2	20 30 4f	jsr $4f30		jsr	ErrorHandler
>44c5	56 61 72 69 61 62 6c 65			.text	"Variable Uninitialised",0
>44cd	20 55 6e 69 6e 69 74 69 61 6c 69 73 65 64 00
.44dc					ErrorV_string:
.44dc	20 30 4f	jsr $4f30		jsr	ErrorHandler
>44df	42 61 64 20 53 74 72 69			.text	"Bad String Length",0
>44e7	6e 67 20 4c 65 6e 67 74 68 00
.44f1					ErrorV_variable:
.44f1	20 30 4f	jsr $4f30		jsr	ErrorHandler
>44f4	56 61 72 69 61 62 6c 65			.text	"Variable Missing",0
>44fc	20 4d 69 73 73 69 6e 67 00
.4505					ErrorV_stack:
.4505	20 30 4f	jsr $4f30		jsr	ErrorHandler
>4508	53 74 61 63 6b 20 46 75			.text	"Stack Full",0
>4510	6c 6c 00
.4513					ErrorV_dupproc:
.4513	20 30 4f	jsr $4f30		jsr	ErrorHandler
>4516	50 72 6f 63 65 64 75 72			.text	"Procedure Identifier Used",0
>451e	65 20 49 64 65 6e 74 69 66 69 65 72 20 55 73 65
>452e	64 00
.4530					ErrorV_unknown:
.4530	20 30 4f	jsr $4f30		jsr	ErrorHandler
>4533	55 6e 6b 6e 6f 77 6e 20			.text	"Unknown Procedure",0
>453b	50 72 6f 63 65 64 75 72 65 00

;******  Return to file: include.files


;******  Processing file: src/support/errors/syntax.asm

.4545					ERRCheckLParen:
.4545	b1 1c		lda ($1c),y			lda 	(codePtr),y
.4547	c9 eb		cmp #$eb			cmp 	#PR_LPAREN
.4549	d0 18		bne $4563			bne 	ERRSyntaxError
.454b	c8		iny				iny
.454c	60		rts				rts
.454d					ERRCheckRParen:
.454d	b1 1c		lda ($1c),y			lda 	(codePtr),y
.454f	c9 9d		cmp #$9d			cmp 	#PR_RPAREN
.4551	d0 10		bne $4563			bne 	ERRSyntaxError
.4553	c8		iny				iny
.4554	60		rts				rts
.4555					ERRCheckComma:
.4555	b1 1c		lda ($1c),y			lda 	(codePtr),y
.4557	c9 99		cmp #$99			cmp 	#PR_COMMA
.4559	d0 08		bne $4563			bne 	ERRSyntaxError
.455b	c8		iny				iny
.455c	60		rts				rts
.455d					ERRCheckA:
.455d	d1 1c		cmp ($1c),y			cmp 	(codePtr),y
.455f	d0 02		bne $4563			bne 	ERRSyntaxError
.4561	c8		iny				iny
.4562	60		rts				rts
.4563					ERRSyntaxError:
.4563	4c ce 43	jmp $43ce		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/support/stack/frames.asm

.4566					StackOpen:
.4566	48		pha				pha 								; save frame byte
.4567	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.4569	0a		asl a				asl 	a 							; claim twice this for storage
.456a	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.456c	38		sec				sec 								; so basically subtracting from
.456d	65 26		adc $26				adc 	basicStack 	 				; basicStack
.456f	85 26		sta $26				sta 	basicStack
.4571	b0 0a		bcs $457d			bcs 	_SONoBorrow
>4573	db						.byte 	$DB
.4574	c6 27		dec $27				dec 	basicStack+1
.4576	a5 27		lda $27				lda 	basicStack+1 				; reached the bottom ?
.4578	cd 16 06	cmp $0616			cmp 	basicStackEnd
.457b	f0 04		beq $4581			beq 	_SOMemory
.457d					_SONoBorrow:
.457d	68		pla				pla 								; get marker back and write at TOS
.457e	92 26		sta ($26)			sta 	(basicStack)
.4580	60		rts				rts
.4581					_SOMemory:
.4581	4c 05 45	jmp $4505		jmp	ErrorV_stack
.4584					StackClose:
.4584	b2 26		lda ($26)			lda 	(basicStack) 				; get TOS marker
.4586	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.4588	0a		asl a				asl 	a 							; claim twice this.
.4589	65 26		adc $26				adc 	basicStack 					; add to the stack pointer.
.458b	85 26		sta $26				sta 	basicStack
.458d	90 02		bcc $4591			bcc 	_SCExit
.458f	e6 27		inc $27				inc 	basicStack+1
.4591					_SCExit:
.4591	60		rts				rts
.4592					StackCheckFrame:
.4592	d2 26		cmp ($26)			cmp		(basicStack) 				; check  frames match
.4594	d0 01		bne $4597			bne 	_SCFError 					; different, we have structures mixed up
.4596	60		rts				rts
.4597					_SCFError:
.4597	4c 52 44	jmp $4452		jmp	ErrorV_structure

;******  Return to file: include.files


;******  Processing file: src/support/stack/location.asm

.459a					STKSaveCodePosition:
.459a	5a		phy				phy
.459b	98		tya				tya 								; save Y at offset 1.
.459c	a0 01		ldy #$01			ldy 	#1
.459e	91 26		sta ($26),y			sta 	(basicStack),y
.45a0	a5 1c		lda $1c				lda 	codePtr 					; save code (low) at 2
.45a2	c8		iny				iny
.45a3	91 26		sta ($26),y			sta 	(basicStack),y
.45a5	a5 1d		lda $1d				lda 	codePtr+1 					; save code (high) at 3
.45a7	c8		iny				iny
.45a8	91 26		sta ($26),y			sta 	(basicStack),y
.45aa	7a		ply				ply
.45ab	60		rts				rts
.45ac					STKLoadCodePosition:
.45ac	a0 03		ldy #$03			ldy 	#3 							; load code pointer back
.45ae	b1 26		lda ($26),y			lda 	(basicStack),y
.45b0	85 1d		sta $1d				sta 	codePtr+1
.45b2	88		dey				dey
.45b3	b1 26		lda ($26),y			lda 	(basicStack),y
.45b5	85 1c		sta $1c				sta 	codePtr
.45b7	88		dey				dey
.45b8	b1 26		lda ($26),y			lda 	(basicStack),y 				; line offset to Y
.45ba	a8		tay				tay
.45bb	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/support/stack/setup.asm

.45bc					StackReset:
.45bc	48		pha				pha 								; save top of memory
.45bd	3a		dec a				dec 	a  							; end of stack = previous byte
.45be	85 27		sta $27				sta 	basicStack+1
.45c0	a9 ff		lda #$ff			lda 	#$FF
.45c2	85 26		sta $26				sta 	basicStack
.45c4	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.45c6	92 26		sta ($26)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.45c8	68		pla				pla 								; allocate pages for stack.
.45c9	38		sec				sec
.45ca	e9 02		sbc #$02			sbc 	#STACKPAGES
.45cc	8d 16 06	sta $0616			sta 	basicStackEnd 				; when stack MSB hits this, it's out of memory.
.45cf	60		rts				rts
.0026					basicStack:
>0026							.fill 	2
.0616					basicStackEnd:
>0616							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/support/strings/concrete.asm

.45d0					StringConcrete:
.45d0	5a		phy				phy 								; save position on stack
.45d1	b2 0c		lda ($0c)			lda 	(IFR0) 						; get string length
.45d3	c9 fd		cmp #$fd			cmp 	#253 						; string too long - cannot concrete.
.45d5	b0 41		bcs $4618			bcs 	_SALengthError
.45d7	18		clc				clc 								; length of the new string
.45d8	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.45da	90 02		bcc $45de			bcc 	_SAHaveLength
.45dc	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.45de					_SAHaveLength:
.45de	48		pha				pha 								; save length to be allocated for concreting.
.45df	38		sec				sec
.45e0	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.45e2	6d 18 06	adc $0618			adc 	stringMemory
.45e5	8d 18 06	sta $0618			sta 	stringMemory
.45e8	85 22		sta $22				sta 	zTemp2 						; update storage address
.45ea	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.45ec	6d 19 06	adc $0619			adc 	stringMemory+1
.45ef	8d 19 06	sta $0619			sta 	stringMemory+1
.45f2	85 23		sta $23				sta 	zTemp2+1
.45f4	68		pla				pla 								; save length allocated in +0
.45f5	92 22		sta ($22)			sta 	(zTemp2)
.45f7	a9 00		lda #$00			lda 	#0 							; clear the status byte in +1
.45f9	a0 01		ldy #$01			ldy 	#1
.45fb	91 22		sta ($22),y			sta 	(zTemp2),y
.45fd					_SACopyNewString:
.45fd	b2 0c		lda ($0c)			lda 	(IFR0) 						; copy length at +2
.45ff	a0 02		ldy #$02			ldy 	#2
.4601	91 22		sta ($22),y			sta 	(zTemp2),y
.4603	aa		tax				tax 								; bytes to copy
.4604	f0 0c		beq $4612			beq 	_SACopyExit
.4606	a0 01		ldy #$01			ldy 	#1 							; first character from here
.4608					_SACopyNSLoop:
.4608	b1 0c		lda ($0c),y			lda 	(IFR0),y 					; get character from here
.460a	c8		iny				iny 								; write two on in string storage
.460b	c8		iny				iny
.460c	91 22		sta ($22),y			sta 	(zTemp2),y
.460e	88		dey				dey
.460f	ca		dex				dex									; until copied all the string lengths.
.4610	d0 f6		bne $4608			bne 	_SACopyNSLoop
.4612					_SACopyExit:
.4612	a6 23		ldx $23				ldx 	zTemp2+1 					; XA contain the concreted string.
.4614	a5 22		lda $22				lda 	zTemp2
.4616	7a		ply				ply
.4617	60		rts				rts
.4618					_SALengthError:
.4618	4c dc 44	jmp $44dc		jmp	ErrorV_string

;******  Return to file: include.files


;******  Processing file: src/support/strings/stringalloc.asm

.461b					StringSystemInitialise:
.461b	3a		dec a				dec 	a 							; make last byte of previous page.
.461c	8d 19 06	sta $0619			sta 	stringMemory+1
.461f	85 1f		sta $1f				sta 	zTemp0+1
.4621	a9 ff		lda #$ff			lda 	#$FF
.4623	8d 18 06	sta $0618			sta 	stringMemory
.4626	85 1e		sta $1e				sta 	zTemp0
.4628	a9 00		lda #$00			lda 	#0 							; put a zero at the end, so know end of string memory.
.462a	92 1e		sta ($1e)			sta 	(zTemp0)
.462c	60		rts				rts
.462d					StringSpaceInitialise:
.462d	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.462f	8d 17 06	sta $0617			sta 	stringInitialised
.4632	ad 18 06	lda $0618			lda 	stringMemory 				; allocate 256 bytes for one concreted string
.4635	8d 1a 06	sta $061a			sta 	stringTempPointer 			; so temporary string space is allocated below that.
.4638	ad 19 06	lda $0619			lda 	stringMemory+1
.463b	3a		dec a				dec 	a
.463c	8d 1b 06	sta $061b			sta 	stringTempPointer+1
.463f	20 95 31	jsr $3195			jsr 	ClearCheckMemory
.4642	60		rts				rts
.4643					StringTempAllocate:
.4643	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.4645	b0 2e		bcs $4675			bcs 	_STALength
.4647	2c 17 06	bit $0617			bit 	stringInitialised 			; already initialised
.464a	30 05		bmi $4651			bmi 	_STAAllocate
.464c	48		pha				pha 								; save value to subtract.
.464d	20 2d 46	jsr $462d			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.4650	68		pla				pla 								; restore it
.4651					_STAAllocate:
.4651	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.4653	18		clc				clc  								; deliberate allows one more
.4654	6d 1a 06	adc $061a			adc 	stringTempPointer 			; subtract from temp pointer
.4657	8d 1a 06	sta $061a			sta 	stringTempPointer
.465a	85 0c		sta $0c				sta 	IFR0+IM0 					; address in mantissa too
.465c	85 28		sta $28				sta 	zsTemp 						; and zsTemp
.465e	ad 1b 06	lda $061b			lda 	stringTempPointer+1
.4661	69 ff		adc #$ff			adc 	#$FF
.4663	8d 1b 06	sta $061b			sta 	stringTempPointer+1
.4666	85 29		sta $29				sta 	zsTemp+1
.4668	85 0d		sta $0d				sta 	IFR0+IM1
.466a	64 0e		stz $0e				stz 	IFR0+IM2 					; set the typing data and the upper address bytes.
.466c	a9 80		lda #$80			lda 	#$80
.466e	85 0f		sta $0f				sta 	IFR0+IExp
.4670	a9 00		lda #$00			lda 	#0 							; clear the target string
.4672	92 28		sta ($28)			sta 	(zsTemp)
.4674	60		rts				rts
.4675					_STALength:
.4675	4c dc 44	jmp $44dc		jmp	ErrorV_string
.4678					StringTempWrite:
.4678	5a		phy				phy
.4679	48		pha				pha
.467a	b2 28		lda ($28)			lda 	(zsTemp)
.467c	1a		inc a				inc 	a
.467d	92 28		sta ($28)			sta 	(zsTemp)
.467f	a8		tay				tay
.4680	68		pla				pla
.4681	91 28		sta ($28),y			sta 	(zsTemp),y
.4683	7a		ply				ply
.4684	60		rts				rts
.0028					zsTemp:
>0028							.fill 	2
.0617					stringInitialised:
>0617							.fill 	1
.0618					stringMemory:
>0618							.fill 	2
.061a					stringTempPointer:
>061a							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/variables/array.asm

.4685					VARArrayLookup:
.4685	85 1e		sta $1e				sta 	zTemp0 						; save the array address pointer in zTemp0
.4687	86 1f		stx $1f				stx 	zTemp0+1
.4689	b2 1e		lda ($1e)			lda 	(zTemp0)
.468b	48		pha				pha
.468c	5a		phy				phy
.468d	a0 01		ldy #$01			ldy 	#1
.468f	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.4691	7a		ply				ply
.4692	48		pha				pha
.4693	20 15 36	jsr $3615			jsr 	EXPEvalInteger16 			; R0 now contains the index
.4696	68		pla				pla 								; array address to zTemp0
.4697	85 1f		sta $1f				sta 	zTemp0+1
.4699	68		pla				pla
.469a	85 1e		sta $1e				sta 	zTemp0
.469c	5a		phy				phy 								; save codePtr position.
.469d	a0 01		ldy #$01			ldy 	#1 							; get 14-8 of size.
.469f	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.46a1	48		pha				pha 								; save bit 15 on stack.
.46a2	29 7f		and #$7f			and 	#$7F
.46a4	85 20		sta $20				sta 	zTemp1
.46a6	a5 0c		lda $0c				lda 	IFR0+IM0 					; check range of index
.46a8	d2 1e		cmp ($1e)			cmp 	(zTemp0)
.46aa	a5 0d		lda $0d				lda 	IFR0+IM1
.46ac	e5 20		sbc $20				sbc 	zTemp1
.46ae	b0 3a		bcs $46ea			bcs 	_VALIndex
.46b0	a5 0d		lda $0d				lda 	IFR0+IM1  					; sanity check
.46b2	c9 40		cmp #$40			cmp 	#$40
.46b4	b0 34		bcs $46ea			bcs 	_VALIndex
.46b6	06 0c		asl $0c				asl 	IFR0+IM0 					; index x 2 (has sub arrays) x 4 (is data)
.46b8	26 0d		rol $0d				rol 	IFR0+IM1
.46ba	fa		plx				plx 								; get msb of size -> X
.46bb	30 04		bmi $46c1			bmi 	_VARNotX4 					; if bit 15 set its an array of pointers so x 2
.46bd	06 0c		asl $0c				asl 	IFR0+IM0
.46bf	26 0d		rol $0d				rol 	IFR0+IM1
.46c1					_VARNotX4:
.46c1	18		clc				clc 								; add the two for the size bytes
.46c2	a5 0c		lda $0c				lda 	IFR0+IM0
.46c4	69 02		adc #$02			adc 	#2
.46c6	85 0c		sta $0c				sta 	IFR0+IM0
.46c8	90 02		bcc $46cc			bcc 	_VARNoCarry1
.46ca	e6 0d		inc $0d				inc 	IFR0+IM1
.46cc					_VARNoCarry1:
.46cc	18		clc				clc 								; calculate the element address and push to stack.
.46cd	a5 0c		lda $0c				lda 	IFR0+IM0
.46cf	65 1e		adc $1e				adc 	zTemp0
.46d1	48		pha				pha
.46d2	a5 0d		lda $0d				lda 	IFR0+IM1
.46d4	65 1f		adc $1f				adc 	zTemp0+1
.46d6	e0 00		cpx #$00			cpx 	#0 							; do we have a sub level ?
.46d8	30 04		bmi $46de			bmi 	_VARHasSubLevel
.46da	aa		tax				tax 								; address in XA
.46db	68		pla				pla
.46dc	7a		ply				ply 								; restore Y and exit
.46dd	60		rts				rts
.46de					_VARHasSubLevel:
.46de	aa		tax				tax 								; get link address in XA
.46df	68		pla				pla
.46e0	7a		ply				ply 								; restore code position.
.46e1	48		pha				pha
.46e2	20 55 45	jsr $4555			jsr 	ERRCheckComma 				; comma required.
.46e5	68		pla				pla
.46e6	20 85 46	jsr $4685			jsr 	VARArrayLookup 				; call it recursively
.46e9	60		rts				rts
.46ea					_VALIndex:
.46ea	4c 9e 44	jmp $449e		jmp	ErrorV_index

;******  Return to file: include.files


;******  Processing file: src/variables/create.asm

.46ed					VARCreate:
.46ed	5a		phy				phy
.46ee	a9 09		lda #$09			lda 	#9 							; create 9 bytes of space
.46f0	a2 00		ldx #$00			ldx 	#0
.46f2	20 6c 31	jsr $316c			jsr 	AllocateMemory
.46f5	85 20		sta $20				sta 	zTemp1 						; save new address in zTemp1
.46f7	86 21		stx $21				stx 	zTemp1+1
.46f9	a0 02		ldy #$02			ldy 	#2 							; put hash into +2
.46fb	ad 1e 06	lda $061e			lda 	VARHash
.46fe	91 20		sta ($20),y			sta 	(zTemp1),y
.4700	c8		iny				iny 								; put address of name into +3,+4
.4701	ad 1c 06	lda $061c			lda 	VARNameAddress
.4704	91 20		sta ($20),y			sta 	(zTemp1),y
.4706	c8		iny				iny
.4707	ad 1d 06	lda $061d			lda 	VARNameAddress+1
.470a	91 20		sta ($20),y			sta 	(zTemp1),y
.470c	ad 1f 06	lda $061f			lda 	VARType
.470f	29 01		and #$01			and 	#1
.4711	f0 06		beq $4719			beq 	_CVNotString
.4713	a0 08		ldy #$08			ldy 	#5+3
.4715	a9 80		lda #$80			lda 	#$80
.4717	91 20		sta ($20),y			sta 	(zTemp1),y
.4719					_CVNotString:
.4719	ad 40 06	lda $0640			lda 	VARHashEntry 				; hash table ptr -> zTemp0
.471c	85 1e		sta $1e				sta 	zTemp0
.471e	ad 41 06	lda $0641			lda 	VARHashEntry+1
.4721	85 1f		sta $1f				sta 	zTemp0+1
.4723	a0 01		ldy #$01			ldy 	#1 							; put current head into link.
.4725	b2 1e		lda ($1e)			lda 	(zTemp0)
.4727	92 20		sta ($20)			sta 	(zTemp1)
.4729	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.472b	91 20		sta ($20),y			sta 	(zTemp1),y
.472d	a5 20		lda $20				lda 	zTemp1 						; address of the new record into head
.472f	92 1e		sta ($1e)			sta 	(zTemp0)
.4731	a5 21		lda $21				lda 	zTemp1+1
.4733	91 1e		sta ($1e),y			sta 	(zTemp0),y
.4735	a5 20		lda $20				lda 	zTemp1 						; new record to XA
.4737	a6 21		ldx $21				ldx 	zTemp1+1
.4739	18		clc				clc 								; add 5 to point to the data.
.473a	69 05		adc #$05			adc 	#5
.473c	90 01		bcc $473f			bcc 	_VCNoCarry
.473e	e8		inx				inx
.473f					_VCNoCarry:
.473f	7a		ply				ply
.4740	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/variables/find.asm

.4741					VARFind:
.4741	5a		phy				phy
.4742	a0 01		ldy #$01			ldy 	#1 							; get first link -> zTemp1
.4744	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.4746	85 21		sta $21				sta 	zTemp1+1
.4748	f0 1c		beq $4766			beq 	_VFExitFail 				; first link is 00xx, so nothing in that list.
.474a	b2 1e		lda ($1e)			lda 	(zTemp0)
.474c	85 20		sta $20				sta 	zTemp1
.474e					_VFLoop:
.474e	a0 02		ldy #$02			ldy 	#2 							; check hashes match
.4750	b1 20		lda ($20),y			lda 	(zTemp1),y
.4752	cd 1e 06	cmp $061e			cmp 	VARHash
.4755	f0 12		beq $4769			beq 	_VFHashesMatch 				; if so, check the name.
.4757					_VFNext:
.4757	b2 20		lda ($20)			lda 	(zTemp1) 					; next link to AX
.4759	aa		tax				tax
.475a	a0 01		ldy #$01			ldy 	#1
.475c	b1 20		lda ($20),y			lda 	(zTemp1),y
.475e	85 21		sta $21				sta 	zTemp1+1
.4760	86 20		stx $20				stx 	zTemp1
.4762	c9 00		cmp #$00			cmp 	#0 							; if msb non zero, try again
.4764	d0 e8		bne $474e			bne 	_VFLoop
.4766					_VFExitFail:
.4766	7a		ply				ply
.4767	18		clc				clc
.4768	60		rts				rts
.4769					_VFHashesMatch:
.4769	a0 03		ldy #$03			ldy 	#3 							; get address of name -> zTemp2
.476b	b1 20		lda ($20),y			lda 	(zTemp1),y
.476d	85 22		sta $22				sta 	zTemp2
.476f	c8		iny				iny
.4770	b1 20		lda ($20),y			lda 	(zTemp1),y
.4772	85 23		sta $23				sta 	zTemp2+1
.4774	a0 ff		ldy #$ff			ldy 	#$FF 						; now compare
.4776					_VFNameCompLoop:
.4776	c8		iny				iny 								; char at a time
.4777	b9 20 06	lda $0620,y			lda 	VARBuffer,y
.477a	d1 22		cmp ($22),y			cmp 	(zTemp2),y
.477c	d0 d9		bne $4757			bne 	_VFNext						; next entry if different.
.477e	c9 7c		cmp #$7c			cmp 	#$7C
.4780	90 f4		bcc $4776			bcc 	_VFNameCompLoop 			; until done the whole lot.
.4782	18		clc				clc
.4783	a5 20		lda $20				lda 	zTemp1
.4785	a6 21		ldx $21				ldx 	zTemp1+1
.4787	69 05		adc #$05			adc 	#5
.4789	90 01		bcc $478c			bcc 	_VFNNoCarry
.478b	e8		inx				inx
.478c					_VFNNoCarry:
.478c	7a		ply				ply
.478d	38		sec				sec
.478e	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/variables/info.asm

.478f					VARGetInfo:
.478f	98		tya				tya 								; calculate the address of the identifier start.
.4790	18		clc				clc
.4791	65 1c		adc $1c				adc 	codePtr
.4793	8d 1c 06	sta $061c			sta 	VARNameAddress
.4796	a5 1d		lda $1d				lda 	codePtr+1
.4798	69 00		adc #$00			adc 	#0
.479a	8d 1d 06	sta $061d			sta 	VARNameAddress+1
.479d	9c 1e 06	stz $061e			stz 	VARHash
.47a0	a2 00		ldx #$00			ldx 	#0
.47a2					_VARCopyName:
.47a2	18		clc				clc 								; update the sum hash.
.47a3	ad 1e 06	lda $061e			lda 	VARHash
.47a6	71 1c		adc ($1c),y			adc 	(codePtr),y
.47a8	8d 1e 06	sta $061e			sta 	VARHash
.47ab	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get character and save it in buffer
.47ad	c8		iny				iny
.47ae	9d 20 06	sta $0620,x			sta 	VARBuffer,x
.47b1	e8		inx				inx
.47b2	c9 7c		cmp #$7c			cmp 	#$7C 						; until copied the type byte
.47b4	90 ec		bcc $47a2			bcc 	_VARCopyName
.47b6	8d 1f 06	sta $061f			sta 	VARType 					; save type byte
.47b9	29 03		and #$03			and 	#3 							; type is 0-3
.47bb	0a		asl a				asl 	a
.47bc	0a		asl a				asl 	a
.47bd	85 1e		sta $1e				sta 	zTemp0
.47bf	ad 1e 06	lda $061e			lda 	VARHash 					; force into range of hash entries per type.
.47c2	29 03		and #$03			and		#(VARHashEntriesPerType-1)
.47c4	65 1e		adc $1e				adc 	zTemp0 						; index of hash table
.47c6	0a		asl a				asl 	a 							; offset as 2 bytes / word.
.47c7	69 42		adc #$42			adc 	#VARHashTables & $FF 		; address of hash table start to zTemp0 & VARHashEntry
.47c9	85 1e		sta $1e				sta 	zTemp0
.47cb	8d 40 06	sta $0640			sta 	VARHashEntry
.47ce	a9 06		lda #$06			lda 	#VARHashTables >> 8
.47d0	69 00		adc #$00			adc 	#0
.47d2	85 1f		sta $1f				sta 	zTemp0+1
.47d4	8d 41 06	sta $0641			sta 	VARHashEntry+1
.47d7	60		rts				rts
.47d8					VARClearHashTables:
.47d8	a2 00		ldx #$00			ldx 	#0
.47da					_VCHRLoop:
.47da	a9 00		lda #$00			lda 	#0
.47dc	9d 42 06	sta $0642,x			sta 	VARHashTables,x
.47df	e8		inx				inx
.47e0	e0 20		cpx #$20			cpx 	#VARHashEntriesPerType*4*2
.47e2	d0 f6		bne $47da			bne 	_VCHRLoop
.47e4	60		rts				rts
.061c					VARNameAddress:
>061c							.fill 	2
.061e					VARHash:
>061e							.fill 	1
.061f					VARType:
>061f							.fill 	1
.0620					VARBuffer:
>0620							.fill 	32
.0640					VARHashEntry:
>0640							.fill 	2
=4					VARHashEntriesPerType = 4 					; hash entries for each of the 4 types.
.0642					VARHashTables:
>0642							.fill 	VARHashEntriesPerType*4*2

;******  Return to file: include.files


;******  Processing file: src/variables/variables.asm

.47e5					VARCheckSimple:
.47e5	aa		tax				tax 								; save in X
.47e6	b1 1c		lda ($1c),y			lda 	(codePtr),y
.47e8	c9 7c		cmp #$7c			cmp 	#$7C
.47ea	d0 15		bne $4801			bne 	_VCSComplex
.47ec	c8		iny				iny 								; consume the second byte, the type.
.47ed	8a		txa				txa  								; character (40-7F) x 4
.47ee	0a		asl a				asl 	a
.47ef	0a		asl a				asl  	a
.47f0	18		clc				clc
.47f1	69 62		adc #$62			adc 	#FastVariables & $FF
.47f3	85 0c		sta $0c				sta 	IFR0+IM0
.47f5	a9 06		lda #$06			lda 	#FastVariables >> 8
.47f7	69 00		adc #$00			adc 	#0
.47f9	85 0d		sta $0d				sta 	IFR0+IM1
.47fb	64 0e		stz $0e				stz 	IFR0+IM2
.47fd	64 0f		stz $0f				stz 	IFR0+IExp
.47ff	38		sec				sec 								; it's a reference
.4800	60		rts				rts
.4801					_VCSComplex:
.4801	88		dey				dey	 								; extract information.
.4802	20 8f 47	jsr $478f			jsr 	VARGetInfo
.4805	20 41 47	jsr $4741			jsr 	VARFind 					; search for variable
.4808	b0 0a		bcs $4814			bcs 	_VCSHaveVariable
.480a	ad 1f 06	lda $061f			lda 	VARType 					; error if arrays, cannot autocreate
.480d	29 02		and #$02			and 	#2
.480f	d0 25		bne $4836			bne 	_VCNoCreate
.4811	20 ed 46	jsr $46ed			jsr 	VARCreate 					; create variable
.4814					_VCSHaveVariable:
.4814	48		pha				pha 								; save LSB on the stack
.4815	ad 1f 06	lda $061f			lda 	VARType 					; get var type, and shift bit 1 into carry
.4818	6a		ror a				ror 	a
.4819	6a		ror a				ror 	a
.481a	68		pla				pla 								; restore LSB
.481b	90 08		bcc $4825			bcc 	_VCSNotArray 				; skip if not an array
.481d	20 85 46	jsr $4685			jsr 	VARArrayLookup 				; look for subscripts.
.4820	48		pha				pha 								; check )
.4821	20 4d 45	jsr $454d			jsr 	ERRCheckRParen
.4824	68		pla				pla
.4825					_VCSNotArray:
.4825	86 0d		stx $0d				stx 	IFR0+IM1 					; save address
.4827	85 0c		sta $0c				sta 	IFR0+IM0
.4829	64 0e		stz $0e				stz 	IFR0+IM2 					; clear the unused byte.
.482b	ad 1f 06	lda $061f			lda 	VARType 					; number/string bit into carry
.482e	6a		ror a				ror 	a
.482f	a9 00		lda #$00			lda 	#0
.4831	6a		ror a				ror 	a 							; now $00 or $80
.4832	85 0f		sta $0f				sta 	IFR0+IExp
.4834	38		sec				sec 								; it's a reference
.4835	60		rts				rts
.4836					_VCNoCreate:
.4836	4c c2 44	jmp $44c2		jmp	ErrorV_uninitialised
.0662					FastVariables:
>0662							.fill	26*4

;******  Return to file: include.files


;******  Return to file: basic.asm


;******  Processing file: build/libmathslib.asmlib

=0					IM0 = 0
=1					IM1 = 1
=2					IM2 = 2
=3					IExp = 3
=$3f					IFXMask = $3F
=$40					IFSign = $40
.4839					IFInitialise:
.4839	9c d2 06	stz $06d2			stz 	IFStackIndex
.483c	60		rts				rts
.483d					IFloatSubtract:
.483d	da		phx				phx
.483e	a2 0c		ldx #$0c			ldx 	#IFR0
.4840	20 59 4e	jsr $4e59			jsr 	IFloatNegate 				; negate R0 and fall through to add.
.4843	fa		plx				plx
.4844					IFloatAdd:
.4844	b5 03		lda $03,x			lda 	IExp,x 						; check if both exponents are zero.
.4846	05 0f		ora $0f				ora 	IFR0+IExp
.4848	29 3f		and #$3f			and 	#IFXMask 					; if not, then we have to do the
.484a	d0 4e		bne $489a			bne 	_IFloatAddDecimals 			; decimal version.
.484c					_IFAddSubMantissa:
.484c	b5 03		lda $03,x			lda 	IExp,x 						; are the signs different ?
.484e	45 0f		eor $0f				eor 	IFR0+IExp
.4850	29 40		and #$40			and 	#IFSign
.4852	d0 21		bne $4875			bne 	_IFloatSubMantissa
.4854	18		clc				clc 								; do the actual addition
.4855	a5 0c		lda $0c			lda 	IFR0+IM0
.4857	75 00		adc $00,x		adc 		IM0,x
.4859	85 0c		sta $0c			sta 	IFR0+IM0
.485b	a5 0d		lda $0d			lda 	IFR0+IM1
.485d	75 01		adc $01,x		adc 		IM1,x
.485f	85 0d		sta $0d			sta 	IFR0+IM1
.4861	a5 0e		lda $0e			lda 	IFR0+IM2
.4863	75 02		adc $02,x		adc 		IM2,x
.4865	85 0e		sta $0e			sta 	IFR0+IM2
.4867	10 29		bpl $4892			bpl 	_IFloatAddExit 				; if no carry through to bit 23, then exit.
.4869	a2 0c		ldx #$0c			ldx 	#IFR0						; shift R0 right, divide by 2
.486b	20 7d 4e	jsr $4e7d			jsr 	IFloatShiftRight
.486e	20 a7 4e	jsr $4ea7			jsr 	IFloatIncExponent
.4871	d0 1f		bne $4892			bne 	_IFloatAddExit
.4873	38		sec				sec 								; overflowed numerically.
.4874	60		rts				rts
.4875					_IFloatSubMantissa:
.4875	38		sec				sec 								; do the subtraction R0-Rx
.4876	a5 0c		lda $0c			lda 	IFR0+IM0
.4878	f5 00		sbc $00,x		sbc 		IM0,x
.487a	85 0c		sta $0c			sta 	IFR0+IM0
.487c	a5 0d		lda $0d			lda 	IFR0+IM1
.487e	f5 01		sbc $01,x		sbc 		IM1,x
.4880	85 0d		sta $0d			sta 	IFR0+IM1
.4882	a5 0e		lda $0e			lda 	IFR0+IM2
.4884	f5 02		sbc $02,x		sbc 		IM2,x
.4886	85 0e		sta $0e			sta 	IFR0+IM2
.4888	b0 08		bcs $4892			bcs 	_IFloatAddExit 				; no borrow so we are done.
.488a	a2 0c		ldx #$0c			ldx 	#IFR0
.488c	20 61 4e	jsr $4e61			jsr 	IFloatMantissaNegate 		; 2's complement negate the mantissa
.488f	20 59 4e	jsr $4e59			jsr 	IFloatNegate 				; negate
.4892					_IFloatAddExit:
.4892	18		clc				clc
.4893	60		rts				rts
.4894					_IFloatZeroAdd:
.4894	fa		plx				plx 								; return this value in R0
.4895	20 df 4d	jsr $4ddf			jsr 	IFloatCopyFromRegister
.4898	18		clc				clc
.4899	60		rts				rts
.489a					_IFloatAddDecimals:
.489a	20 47 4e	jsr $4e47			jsr		IFloatCheckZero 			; if RX = 0 then exit with R0
.489d	f0 f3		beq $4892			beq 	_IFloatAddExit
.489f	20 85 4e	jsr $4e85			jsr 	IFloatNormalise 			; normalise RX
.48a2	da		phx				phx 								; normalise R0
.48a3	a2 0c		ldx #$0c			ldx 	#IFR0
.48a5	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero
.48a8	f0 ea		beq $4894			beq 	_IFloatZeroAdd
.48aa	20 85 4e	jsr $4e85			jsr 	IFloatNormalise
.48ad	fa		plx				plx
.48ae	a5 0f		lda $0f				lda 	IFR0+IExp 					; get the exponent of R0
.48b0	29 3f		and #$3f			and 	#IFXMask
.48b2	38		sec				sec
.48b3	e9 20		sbc #$20			sbc 	#$20 						; map 20..3F..00..1F to 00..0F..E0..FF e.g. scaled unsigned
.48b5	85 0a		sta $0a				sta 	iTemp0
.48b7	b5 03		lda $03,x			lda 	IExp,x 						; repeat for exponent of Rx
.48b9	29 3f		and #$3f			and 	#IFXMask
.48bb	38		sec				sec
.48bc	e9 20		sbc #$20			sbc 	#$20
.48be	c5 0a		cmp $0a				cmp 	iTemp0 						; get the larger adjusted
.48c0	b0 02		bcs $48c4			bcs 	_IFloatHaveLarger
.48c2	a5 0a		lda $0a				lda 	iTemp0
.48c4					_IFloatHaveLarger:
.48c4	18		clc				clc 								; get the actual one back.
.48c5	69 20		adc #$20			adc 	#$20 						; shift both to that.
.48c7	20 d4 48	jsr $48d4			jsr 	_IFShiftXToA
.48ca	da		phx				phx
.48cb	a2 0c		ldx #$0c			ldx 	#IFR0
.48cd	20 d4 48	jsr $48d4			jsr 	_IFShiftXToA
.48d0	fa		plx				plx
.48d1	4c 4c 48	jmp $484c			jmp 	_IFAddSubMantissa 			; do the adding bit.
.48d4					_IFShiftXToA:
.48d4	8d ca 06	sta $06ca			sta 	IFTarget
.48d7	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero 			; check adding zero ?
.48da	f0 11		beq $48ed			beq 	_IFSXExit
.48dc					_IFSXLoop:
.48dc	b5 03		lda $03,x			lda 	IExp,x 	 					; shifted to the right level yet ?
.48de	29 3f		and #$3f			and 	#IFXMask
.48e0	cd ca 06	cmp $06ca			cmp 	IFTarget
.48e3	f0 08		beq $48ed			beq 	_IFSXExit
.48e5	20 7d 4e	jsr $4e7d			jsr 	IFloatShiftRight
.48e8	20 a7 4e	jsr $4ea7			jsr 	IFloatIncExponent
.48eb	80 ef		bra $48dc			bra 	_IFSXLoop
.48ed					_IFSXExit:
.48ed	60		rts				rts
.06ca					IFTarget:
>06ca							.fill 	1
.48ee					IFloatMultiply:
.48ee	8e ca 06	stx $06ca			stx 	IFTarget 					; save the multiplier (RX) which is "adder"
.48f1	20 a9 49	jsr $49a9			jsr 	IFCalculateNewSign
.48f4	b5 03		lda $03,x			lda 	IExp,x 						; check two positive 8 bit integers
.48f6	05 0f		ora $0f				ora 	IFR0+IExp
.48f8	29 3f		and #$3f			and 	#IFXMask
.48fa	15 01		ora $01,x			ora 	IM1,x
.48fc	05 0d		ora $0d				ora 	IFR0+IM1
.48fe	15 02		ora $02,x			ora 	IM2,x
.4900	05 0e		ora $0e				ora 	IFR0+IM2
.4902	d0 0a		bne $490e			bne 	_IFMStandard
.4904	20 2a 4e	jsr $4e2a			jsr 	IFloatMultiply8BitRx
.4907	ad cc 06	lda $06cc			lda 	IFNewSign
.490a	85 0f		sta $0f				sta 	IFR0+IExp
.490c	18		clc				clc
.490d	60		rts				rts
.490e					_IFMStandard:
.490e	b5 03		lda $03,x			lda 	IExp,x 						; add the two exponents sign extended
.4910	20 a0 49	jsr $49a0			jsr 	IFMSignExtend
.4913	8d cb 06	sta $06cb			sta 	IFNewExponent
.4916	a5 0f		lda $0f				lda 	IFR0+IExp
.4918	20 a0 49	jsr $49a0			jsr 	IFMSignExtend
.491b	18		clc				clc
.491c	6d cb 06	adc $06cb			adc 	IFNewExponent
.491f	8d cb 06	sta $06cb			sta 	IFNewExponent
.4922	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy R0 to RTemp which is "shifter"
.4924	20 f0 4d	jsr $4df0			jsr 	IFloatCopyToRegister
.4927	a2 0c		ldx #$0c			ldx 	#IFR0 						; zero R0 (the result)
.4929	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.492c					_IFMLoop:
.492c	a2 18		ldx #$18			ldx 	#IFRTemp
.492e	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero
.4931	f0 3a		beq $496d			beq 	_IFMExit
.4933	ae ca 06	ldx $06ca			ldx 	IFTarget 					; look at adder MSB
.4936	b5 02		lda $02,x			lda 	IM2,x 						; if it is set we need to shift everything
.4938	10 03		bpl $493d			bpl	 	_IFMTargetOkay
.493a	20 91 49	jsr $4991			jsr 	_IFMShiftAll
.493d					_IFMTargetOkay:
.493d	a5 18		lda $18				lda 	IFRTemp+0 					; is bit 0 of the shifter (RTemp) set
.493f	29 01		and #$01			and 	#1
.4941	f0 16		beq $4959			beq 	_IFMNoAdd
.4943	ae ca 06	ldx $06ca			ldx 	IFTarget 					; add adder
.4946	18		clc				clc
.4947	a5 0c		lda $0c			lda 	IFR0+IM0
.4949	75 00		adc $00,x		adc 		IM0,x
.494b	85 0c		sta $0c			sta 	IFR0+IM0
.494d	a5 0d		lda $0d			lda 	IFR0+IM1
.494f	75 01		adc $01,x		adc 		IM1,x
.4951	85 0d		sta $0d			sta 	IFR0+IM1
.4953	a5 0e		lda $0e			lda 	IFR0+IM2
.4955	75 02		adc $02,x		adc 		IM2,x
.4957	85 0e		sta $0e			sta 	IFR0+IM2
.4959					_IFMNoAdd:
.4959	a5 0e		lda $0e				lda 	IFR0+IM2
.495b	10 03		bpl $4960			bpl 	_IFMResultOkay
.495d	20 91 49	jsr $4991			jsr 	_IFMShiftAll
.4960					_IFMResultOkay:
.4960	a2 18		ldx #$18			ldx 	#IFRTemp
.4962	20 7d 4e	jsr $4e7d			jsr 	IFloatShiftRight
.4965	ae ca 06	ldx $06ca			ldx 	IFTarget
.4968	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.496b	80 bf		bra $492c			bra 	_IFMLoop
.496d					_IFMExit:
.496d	ad cb 06	lda $06cb			lda 	IFNewExponent 				; validate new exponent.
.4970	c9 20		cmp #$20			cmp 	#$20 						; valid exponent 00-1F E0-FF
.4972	90 0f		bcc $4983			bcc 	_IFMOkay
.4974	c9 e0		cmp #$e0			cmp 	#$E0
.4976	b0 0b		bcs $4983			bcs 	_IFMOkay
.4978	29 80		and #$80			and 	#$80 						; if +ve exponent then error overflow.
.497a	f0 13		beq $498f			beq 	_IFMError
.497c	a2 0c		ldx #$0c			ldx 	#IFR0 						; return zero underflow
.497e	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.4981	18		clc				clc
.4982	60		rts				rts
.4983					_IFMOkay:
.4983	29 3f		and #$3f			and 	#IFXMask 					; work out exponent + sign and exit
.4985	0d cc 06	ora $06cc			ora 	IFNewSign
.4988	85 0f		sta $0f				sta 	IFR0+IExp
.498a	18		clc				clc
.498b	60		rts				rts
.498c	4c ff ff	jmp $ffff			jmp 	$FFFF
.498f					_IFMError:
.498f	38		sec				sec
.4990	60		rts				rts
.4991					_IFMShiftAll:
.4991	a2 0c		ldx #$0c			ldx 	#IFR0
.4993	20 7d 4e	jsr $4e7d			jsr 	IFloatShiftRight
.4996	ae ca 06	ldx $06ca			ldx 	IFTarget
.4999	20 7d 4e	jsr $4e7d			jsr 	IFloatShiftRight
.499c	ee cb 06	inc $06cb			inc 	IFNewExponent
.499f	60		rts				rts
.49a0					IFMSignExtend:
.49a0	29 3f		and #$3f			and 	#IFXMask
.49a2	c9 1f		cmp #$1f			cmp 	#(IFXMask >> 1)
.49a4	90 02		bcc $49a8			bcc 	_IFMNoSXX
.49a6	09 c0		ora #$c0			ora 	#IFXMask ^ $FF
.49a8					_IFMNoSXX:
.49a8	60		rts				rts
.49a9					IFCalculateNewSign:
.49a9	b5 03		lda $03,x			lda 	IExp,x
.49ab	45 0f		eor $0f				eor 	IFR0+IExp
.49ad	29 40		and #$40			and 	#IFSign
.49af	8d cc 06	sta $06cc			sta 	IFNewSign
.49b2	60		rts				rts
.06cb					IFNewExponent:
>06cb							.fill 	1
.06cc					IFNewSign:
>06cc							.fill 	1
.49b3					IFloatDivideInteger:
.49b3	20 cc 49	jsr $49cc			jsr 	IFloatDivideIntegerCommon 	; do the common code.
.49b6	b0 06		bcs $49be			bcs 	_IFDIExit
.49b8	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy result from register.
.49ba	20 df 4d	jsr $4ddf			jsr 	IFloatCopyFromRegister
.49bd	18		clc				clc
.49be					_IFDIExit:
.49be	60		rts				rts
.49bf					IFloatModulusInteger:
.49bf	20 cc 49	jsr $49cc			jsr 	IFloatDivideIntegerCommon
.49c2	b0 07		bcs $49cb			bcs 	_IFMIExit
.49c4	ae ca 06	ldx $06ca			ldx 	IFTarget
.49c7	20 df 4d	jsr $4ddf			jsr 	IFloatCopyFromRegister
.49ca	18		clc				clc
.49cb					_IFMIExit:
.49cb	60		rts				rts
.49cc					IFloatDivideIntegerCommon:
.49cc	8e ca 06	stx $06ca			stx 	IFTarget  					; this is s1, s0 = R0
.49cf	20 a9 49	jsr $49a9			jsr 	IFCalculateNewSign 			; calculate sign of result
.49d2	20 fa 49	jsr $49fa			jsr 	IFDCopyRXToRTemp 			; copy S1 to RTemp
.49d5	a2 0c		ldx #$0c			ldx 	#IFR0 						; check divide by zero
.49d7	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero
.49da	f0 1c		beq $49f8			beq 	_IFDIDivZero
.49dc	ae ca 06	ldx $06ca			ldx 	IFTarget 					; zero Rx (S1)
.49df	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.49e2	5a		phy				phy
.49e3	a0 18		ldy #$18			ldy 	#24
.49e5					_IFDILoop:
.49e5	20 0b 4a	jsr $4a0b			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.49e8	20 17 4a	jsr $4a17			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.49eb	88		dey				dey
.49ec	d0 f7		bne $49e5			bne 	_IFDILoop 					; do it 24 times
.49ee	7a		ply				ply
.49ef	ad cc 06	lda $06cc			lda 	IFNewSign 					; set sign of result.
.49f2	29 40		and #$40			and 	#IFSign
.49f4	85 1b		sta $1b				sta 	IFRTemp+IExp
.49f6	18		clc				clc 								; is okay.
.49f7	60		rts				rts
.49f8					_IFDIDivZero:
.49f8	38		sec				sec
.49f9	60		rts				rts
.49fa					IFDCopyRXToRTemp:
.49fa	b5 00		lda $00,x			lda 	IM0,x
.49fc	85 18		sta $18				sta 	IFRTemp+IM0
.49fe	b5 01		lda $01,x			lda 	IM1,x
.4a00	85 19		sta $19				sta 	IFRTemp+IM1
.4a02	b5 02		lda $02,x			lda 	IM2,x
.4a04	85 1a		sta $1a				sta 	IFRTemp+IM2
.4a06	b5 03		lda $03,x			lda 	IExp,x
.4a08	85 1b		sta $1b				sta 	IFRTemp+IExp
.4a0a	60		rts				rts
.4a0b					IFDShiftSTempS1Left:
.4a0b	a2 18		ldx #$18			ldx 	#IFRTemp
.4a0d	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft
.4a10	ae ca 06	ldx $06ca			ldx 	IFTarget
.4a13	20 76 4e	jsr $4e76			jsr 	IFloatRotateLeft
.4a16	60		rts				rts
.4a17					IFDTrySubtract:
.4a17	ae ca 06	ldx $06ca			ldx 	IFTarget 					; s1 = Rx
.4a1a	38		sec				sec 								; subtract, saving the results on the stack.
.4a1b	b5 00		lda $00,x			lda 	IM0,x
.4a1d	e5 0c		sbc $0c				sbc 	IFR0+IM0
.4a1f	48		pha				pha
.4a20	b5 01		lda $01,x			lda 	IM1,x
.4a22	e5 0d		sbc $0d				sbc 	IFR0+IM1
.4a24	48		pha				pha
.4a25	b5 02		lda $02,x			lda 	IM2,x
.4a27	e5 0e		sbc $0e				sbc 	IFR0+IM2
.4a29	b0 03		bcs $4a2e			bcs 	_IFDCanSubtract
.4a2b	68		pla				pla 								; cannot subtract, so pop intermediate and exit.
.4a2c	68		pla				pla
.4a2d	60		rts				rts
.4a2e					_IFDCanSubtract:
.4a2e	95 02		sta $02,x			sta 	IM2,x 						; write back to S1.Mantissa
.4a30	68		pla				pla
.4a31	95 01		sta $01,x			sta 	IM1,x
.4a33	68		pla				pla
.4a34	95 00		sta $00,x			sta 	IM0,x
.4a36	e6 18		inc $18				inc 	IFRTemp+IM0 				; increment temp
.4a38	d0 06		bne $4a40			bne 	_IFDCSExit
.4a3a	e6 19		inc $19				inc 	IFRTemp+IM1
.4a3c	d0 02		bne $4a40			bne 	_IFDCSExit
.4a3e	e6 1a		inc $1a				inc 	IFRTemp+IM2
.4a40					_IFDCSExit:
.4a40	60		rts				rts
.4a41					IFloatBitwiseAnd:
.4a41	5a		phy				phy
.4a42	20 86 4a	jsr $4a86			jsr 	IFPreProcessBitwise 		; set up everything.
.4a45	d0 0f		bne $4a56			bne 	_IFBAExit
.4a47					_IFBALoop:
.4a47	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.4a4a	35 00		and $00,x			and 	IM0,x
.4a4c	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.4a4f	e8		inx				inx
.4a50	c8		iny				iny
.4a51	c0 03		cpy #$03			cpy 	#3
.4a53	d0 f2		bne $4a47			bne 	_IFBALoop
.4a55	18		clc				clc
.4a56					_IFBAExit:
.4a56	7a		ply				ply
.4a57	60		rts				rts
.4a58					IFloatBitwiseOr:
.4a58	5a		phy				phy
.4a59	20 86 4a	jsr $4a86			jsr 	IFPreProcessBitwise 		; set up everything.
.4a5c	d0 0f		bne $4a6d			bne 	_IFBAExit
.4a5e					_IFBALoop:
.4a5e	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.4a61	15 00		ora $00,x			ora 	IM0,x
.4a63	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.4a66	e8		inx				inx
.4a67	c8		iny				iny
.4a68	c0 03		cpy #$03			cpy 	#3
.4a6a	d0 f2		bne $4a5e			bne 	_IFBALoop
.4a6c	18		clc				clc
.4a6d					_IFBAExit:
.4a6d	7a		ply				ply
.4a6e	60		rts				rts
.4a6f					IFloatBitwiseXor:
.4a6f	5a		phy				phy
.4a70	20 86 4a	jsr $4a86			jsr 	IFPreProcessBitwise 		; set up everything.
.4a73	d0 0f		bne $4a84			bne 	_IFBAExit
.4a75					_IFBALoop:
.4a75	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.4a78	55 00		eor $00,x			eor 	IM0,x
.4a7a	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.4a7d	e8		inx				inx
.4a7e	c8		iny				iny
.4a7f	c0 03		cpy #$03			cpy 	#3
.4a81	d0 f2		bne $4a75			bne 	_IFBALoop
.4a83	18		clc				clc
.4a84					_IFBAExit:
.4a84	7a		ply				ply
.4a85	60		rts				rts
.4a86					IFPreProcessBitwise:
.4a86	a0 00		ldy #$00			ldy 	#0 							; set index.
.4a88	a5 0f		lda $0f				lda 	IFR0+IExp 					; OR exponents
.4a8a	15 03		ora $03,x			ora 	IExp,x
.4a8c	74 03		stz $03,x			stz 	IExp,x 						; zero the result exponent anyway.
.4a8e	29 3f		and #$3f			and 	#IFXMask 					; NZ if error e.g. not integer
.4a90	38		sec				sec 								; carry set just in cases.
.4a91	60		rts				rts
.4a92					IFloatAbsoluteR0:
.4a92	a5 0f		lda $0f				lda 	IFR0+IExp					; reset the sign bit.
.4a94	29 bf		and #$bf			and 	#IFSign ^ 255
.4a96	85 0f		sta $0f				sta 	IFR0+IExp
.4a98	18		clc				clc
.4a99	60		rts				rts
.4a9a					IFloatSquareRootR0:
.4a9a	a2 0c		ldx #$0c			ldx 	#IFR0 						; if zero, return zero.
.4a9c	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero
.4a9f	a5 0f		lda $0f				lda	 	IFR0+IExp 					; if negative fail.
.4aa1	29 40		and #$40			and 	#IFSign
.4aa3	d0 2f		bne $4ad4			bne 	_IFSRFail
.4aa5	20 85 4e	jsr $4e85			jsr 	IFloatNormalise 			; it will work better !
.4aa8	a2 10		ldx #$10			ldx 	#IFR1 						; R1 contains original throughout
.4aaa	20 f0 4d	jsr $4df0			jsr 	IFloatCopyToRegister
.4aad	a5 0f		lda $0f				lda 	IFR0+IExp 					; if exponent is $2A..$3F * 64 otherwise is / 64
.4aaf	20 a0 49	jsr $49a0			jsr 	IFMSignExtend 				; sign extended version of the exponent
.4ab2	18		clc				clc
.4ab3	69 17		adc #$17			adc 	#23 						; this makes it a 0.xxx mantissa
.4ab5	85 0f		sta $0f				sta 	IFR0+IExp
.4ab7	4a		lsr a				lsr 	a 							; which we can halve.
.4ab8	38		sec				sec 								; convert back
.4ab9	e9 17		sbc #$17			sbc 	#23
.4abb	29 3f		and #$3f			and 	#IFXMask 					; make appropriate
.4abd	85 0f		sta $0f				sta 	IFR0+IExp 					; to R0
.4abf	20 d6 4a	jsr $4ad6			jsr 	_IFSRNewton
.4ac2	20 d6 4a	jsr $4ad6			jsr 	_IFSRNewton
.4ac5	20 d6 4a	jsr $4ad6			jsr 	_IFSRNewton
.4ac8	20 d6 4a	jsr $4ad6			jsr 	_IFSRNewton
.4acb	18		clc				clc
.4acc	60		rts				rts
.4acd					_IFSRZero:
.4acd	a2 0c		ldx #$0c			ldx 	#IFR0
.4acf	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.4ad2	18		clc				clc
.4ad3	60		rts				rts
.4ad4					_IFSRFail:
.4ad4	38		sec				sec
.4ad5	60		rts				rts
.4ad6					_IFSRNewton:
.4ad6	a2 10		ldx #$10			ldx 	#IFR1 						; push original value (R3) on the stack
.4ad8	20 9d 4d	jsr $4d9d			jsr 	IFloatPushRx
.4adb	a2 0c		ldx #$0c			ldx 	#IFR0 						; push current guess (R0) on the stack.
.4add	20 9d 4d	jsr $4d9d			jsr 	IFloatPushRx
.4ae0	a2 10		ldx #$10			ldx 	#IFR1 						; guess = original / guess
.4ae2	20 71 4b	jsr $4b71			jsr 	IFloatDivideFloat
.4ae5	a2 10		ldx #$10			ldx 	#IFR1 						; restore current guess (was in R0) to R3
.4ae7	20 be 4d	jsr $4dbe			jsr 	IFloatPullRx
.4aea	20 44 48	jsr $4844			jsr 	IFloatAdd 					; now guess + original/guess
.4aed	a2 0c		ldx #$0c			ldx 	#IFR0 						; divide by 2
.4aef	20 7d 4e	jsr $4e7d			jsr 	IFloatShiftRight
.4af2	a2 10		ldx #$10			ldx 	#IFR1
.4af4	20 be 4d	jsr $4dbe			jsr 	IFloatPullRx 				; Finally pull the oeifinal
.4af7	60		rts				rts
.4af8					IFloatFractionalR0:
.4af8	a5 0f		lda $0f				lda 	IFR0+IExp					; is it integer already ?
.4afa	29 3f		and #$3f			and 	#IFXMask
.4afc	f0 17		beq $4b15			beq 	_FIPZero 					; if so, return with zero as no fractional part.
.4afe	20 92 4a	jsr $4a92			jsr 	IFloatAbsoluteR0 			; absolute value R9
.4b01	a2 0c		ldx #$0c			ldx 	#IFR0
.4b03	20 85 4e	jsr $4e85			jsr 	IFloatNormalise 			; normalise R0
.4b06	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy to RTemp
.4b08	20 f0 4d	jsr $4df0			jsr 	IFloatCopyToRegister
.4b0b	20 4e 4b	jsr $4b4e			jsr 	IFloatIntegerR0 			; take integer part of R0
.4b0e	a2 18		ldx #$18			ldx 	#IFRTemp 					; subtract
.4b10	20 3d 48	jsr $483d			jsr 	IFloatSubtract
.4b13	80 05		bra $4b1a			bra 	_FIPExit
.4b15					_FIPZero:
.4b15	a2 0c		ldx #$0c			ldx 	#IFR0
.4b17	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.4b1a					_FIPExit:
.4b1a	18		clc				clc
.4b1b	60		rts				rts
.4b1c					IFloatCompare:
.4b1c	20 3d 48	jsr $483d			jsr 	IFloatSubtract 				; subtract R0 from RX.
.4b1f	b5 03		lda $03,x			lda 	IExp,x 						; check if integer comparison
.4b21	05 0f		ora $0f				ora 	IFR0+IExp
.4b23	a2 0c		ldx #$0c			ldx 	#IFR0 						; only using R0 from now on.
.4b25	29 3f		and #$3f			and 	#IFXMask
.4b27	d0 19		bne $4b42			bne 	_IFCNonInteger
.4b29	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero 			; check if zero
.4b2c	f0 0f		beq $4b3d			beq 	_IFCZero
.4b2e					_IFCReturnSign:
.4b2e	a5 0f		lda $0f				lda 	IFR0+IExp 					; get the sign bit/unused -> stack.
.4b30	29 c0		and #$c0			and 	#(IFXMask ^ $FF)
.4b32	48		pha				pha
.4b33	a9 01		lda #$01			lda 	#1
.4b35	20 50 4e	jsr $4e50			jsr 	IFloatSetByte 				; return to +1
.4b38	68		pla				pla 								; sign bit back
.4b39	85 0f		sta $0f				sta 	IFR0+IExp					; set that sign
.4b3b	18		clc				clc
.4b3c	60		rts				rts
.4b3d					_IFCZero:
.4b3d	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.4b40	18		clc				clc
.4b41	60		rts				rts
.4b42					_IFCNonInteger:
.4b42	a5 0c		lda $0c				lda 	IFR0+IM0
.4b44	29 00		and #$00			and		#$00
.4b46	05 0d		ora $0d				ora 	IFR0+IM1
.4b48	05 0e		ora $0e				ora 	IFR0+IM2
.4b4a	f0 f1		beq $4b3d			beq 	_IFCZero 					; near enough !
.4b4c	80 e0		bra $4b2e			bra 	_IFCReturnSign 				; return the sign of the difference.
.4b4e					IFloatIntegerR0:
.4b4e	a5 0f		lda $0f				lda 	IFR0+IExp					; is it integer already ?
.4b50	29 3f		and #$3f			and 	#IFXMask
.4b52	f0 1b		beq $4b6f			beq 	_FIPExit 					; if so do nothing
.4b54	a2 0c		ldx #$0c			ldx 	#IFR0
.4b56	20 85 4e	jsr $4e85			jsr 	IFloatNormalise 			; normalise
.4b59	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero 			; is it zero ?
.4b5c	f0 0e		beq $4b6c			beq 	_FIPZero 					; if so return zero.
.4b5e					_FIPShift:
.4b5e	a5 0f		lda $0f				lda 	IFR0+IExp 					; if Exponent >= 0 exit.
.4b60	29 20		and #$20			and 	#$20 						; still -ve
.4b62	f0 0b		beq $4b6f			beq 	_FIPExit
.4b64	20 7d 4e	jsr $4e7d			jsr 	IFloatShiftRight 			; shift mantissa right
.4b67	20 a7 4e	jsr $4ea7			jsr 	IFloatIncExponent 			; bump exponent
.4b6a	80 f2		bra $4b5e			bra 	_FIPShift
.4b6c					_FIPZero:
.4b6c	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.4b6f					_FIPExit:
.4b6f	18		clc				clc
.4b70	60		rts				rts
.4b71					IFloatDivideFloat:
.4b71	8e ca 06	stx $06ca			stx 	IFTarget  					; this is s1, s0 = R0
.4b74	20 a9 49	jsr $49a9			jsr 	IFCalculateNewSign 			; calculate sign of result
.4b77	20 85 4e	jsr $4e85			jsr 	IFloatNormalise 			; normalise RX
.4b7a	a2 0c		ldx #$0c			ldx 	#IFR0 						; normalise R0
.4b7c	20 85 4e	jsr $4e85			jsr 	IFloatNormalise
.4b7f	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero
.4b82	f0 56		beq $4bda			beq 	_IFDFDivZero 				; exit if this normalised to zero.
.4b84	a5 0f		lda $0f				lda 	IFR0+IExp 					; calculate s0.exponent
.4b86	20 a0 49	jsr $49a0			jsr 	IFMSignExtend
.4b89	8d cb 06	sta $06cb			sta 	IFNewExponent
.4b8c	ae ca 06	ldx $06ca			ldx 	IFTarget 					; calculate s1.exponent
.4b8f	b5 03		lda $03,x			lda 	IExp,x
.4b91	20 a0 49	jsr $49a0			jsr 	IFMSignExtend
.4b94	38		sec				sec
.4b95	ed cb 06	sbc $06cb			sbc 	IFNewExponent 				; s1.exponent - s0.exponent - 23
.4b98	38		sec				sec
.4b99	e9 17		sbc #$17			sbc 	#23
.4b9b	8d cb 06	sta $06cb			sta 	IFNewExponent
.4b9e	20 dc 4b	jsr $4bdc			jsr 	IFloatDivideSupport 		; call the support routine (see maths.py)
.4ba1	a5 1a		lda $1a				lda 	IFRTemp+IM2 				; result has overflowed ?
.4ba3	10 08		bpl $4bad			bpl 	_IFDFNoShiftResult
.4ba5	a2 18		ldx #$18			ldx 	#IFRTemp 					; if so, fix it up.
.4ba7	20 7d 4e	jsr $4e7d			jsr 	IFloatShiftRight
.4baa	ee cb 06	inc $06cb			inc 	IFNewExponent
.4bad					_IFDFNoShiftResult:
.4bad	ad cb 06	lda $06cb			lda 	IFNewExponent 				; underflow/overflow check.
.4bb0	30 06		bmi $4bb8			bmi 	_IFDFCheckUnderflow
.4bb2	c9 20		cmp #$20			cmp 	#$20 						; overflow in division
.4bb4	b0 24		bcs $4bda			bcs 	_IFDFDivZero
.4bb6	80 11		bra $4bc9			bra		_IFDFExit
.4bb8					_IFDFCheckUnderflow:
.4bb8	ad cb 06	lda $06cb			lda 	IFNewExponent 				; shift into a legal exponent.
.4bbb	c9 e0		cmp #$e0			cmp 	#$E0 						; if exponent < -32.
.4bbd	b0 0a		bcs $4bc9			bcs 	_IFDFExit
.4bbf	ee cb 06	inc $06cb			inc 	IFNewExponent
.4bc2	a2 18		ldx #$18			ldx 	#IFRTemp
.4bc4	20 7d 4e	jsr $4e7d			jsr 	IFloatShiftRight
.4bc7	80 ef		bra $4bb8			bra 	_IFDFCheckUnderflow
.4bc9					_IFDFExit:
.4bc9	ad cb 06	lda $06cb			lda 	IFNewExponent 				; combine exponent and sign.
.4bcc	29 3f		and #$3f			and 	#IFXMask
.4bce	0d cc 06	ora $06cc			ora 	IFNewSign
.4bd1	85 1b		sta $1b				sta 	IFRTemp+IExp
.4bd3	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy RTemp to R0.
.4bd5	20 df 4d	jsr $4ddf			jsr 	IFloatCopyFromRegister
.4bd8	18		clc				clc
.4bd9	60		rts				rts
.4bda					_IFDFDivZero:
.4bda	38		sec				sec
.4bdb	60		rts				rts
.4bdc					IFloatDivideSupport:
.4bdc	a2 18		ldx #$18			ldx 	#IFRTemp 					; zero RTemp
.4bde	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.4be1	5a		phy				phy 								; main division loop x 23
.4be2	a0 17		ldy #$17			ldy 	#23
.4be4					_IFDSLoop:
.4be4	20 17 4a	jsr $4a17			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.4be7	20 0b 4a	jsr $4a0b			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.4bea	88		dey				dey
.4beb	d0 f7		bne $4be4			bne 	_IFDSLoop 					; do it 24 times
.4bed	7a		ply				ply
.4bee	60		rts				rts
.4bef					IFloatIntegerToStringR0:
.4bef	8d cd 06	sta $06cd			sta 	IFBase 						; save base to use.
.4bf2	20 cf 4e	jsr $4ecf			jsr 	IFloatBufferReset			; empty buffer
.4bf5	a5 0f		lda $0f				lda 	IFR0+IExp					; check integer
.4bf7	29 3f		and #$3f			and 	#IFXMask
.4bf9	d0 1e		bne $4c19			bne 	_IFIFail
.4bfb	a2 0c		ldx #$0c			ldx 	#IFR0 						; skip - check if zero.
.4bfd	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero
.4c00	f0 0e		beq $4c10			beq 	_IFINotNegative
.4c02	a5 0f		lda $0f				lda 	IFR0+IExp 					; is signed ?
.4c04	29 40		and #$40			and 	#IFSign
.4c06	f0 08		beq $4c10			beq 	_IFINotNegative
.4c08	a9 2d		lda #$2d			lda 	#"-"						; output -
.4c0a	20 de 4e	jsr $4ede			jsr 	IFloatBufferWrite
.4c0d	20 59 4e	jsr $4e59			jsr 	IFloatNegate 				; tidy up !
.4c10					_IFINotNegative:
.4c10	20 1b 4c	jsr $4c1b			jsr 	_IFIRecursiveConvert 		; start converting
.4c13	20 d6 4e	jsr $4ed6			jsr 	IFloatGetBufferAddress
.4c16	18		clc				clc
.4c17	80 01		bra $4c1a			bra 	_IFIExit
.4c19					_IFIFail:
.4c19	38		sec				sec
.4c1a					_IFIExit:
.4c1a	60		rts				rts
.4c1b					_IFIRecursiveConvert:
.4c1b	a2 10		ldx #$10			ldx 	#IFR1
.4c1d	20 f0 4d	jsr $4df0			jsr 	IFloatCopyToRegister 		; R0->R1
.4c20	a2 0c		ldx #$0c			ldx 	#IFR0
.4c22	ad cd 06	lda $06cd			lda 	IFBase 						; Base -> R0
.4c25	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.4c28	a2 10		ldx #$10			ldx 	#IFR1 						; R0 = R1 / R0
.4c2a	20 b3 49	jsr $49b3			jsr 	IFloatDivideInteger
.4c2d	a2 0c		ldx #$0c			ldx 	#IFR0 						; if result <> 0
.4c2f	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero
.4c32	f0 09		beq $4c3d			beq 	_IFIOutDigit
.4c34	a5 10		lda $10				lda 	IFR1+IM0 					; save remainder
.4c36	48		pha				pha
.4c37	20 1b 4c	jsr $4c1b			jsr 	_IFIRecursiveConvert 		; convert the divider
.4c3a	68		pla				pla
.4c3b	85 10		sta $10				sta 	IFR1+IM0 					; restore remainder
.4c3d					_IFIOutDigit:
.4c3d	a5 10		lda $10				lda 	IFR1+IM0 					; get remainder.
.4c3f	c9 0a		cmp #$0a			cmp	 	#10
.4c41	90 02		bcc $4c45			bcc 	_IFINotHex
.4c43	69 06		adc #$06			adc 	#6
.4c45					_IFINotHex:
.4c45	69 30		adc #$30			adc 	#48
.4c47	20 de 4e	jsr $4ede			jsr 	IFloatBufferWrite
.4c4a	60		rts				rts
.06cd					IFBase:
>06cd							.fill 	1
.4c4b					IFloatFloatToStringR0:
.4c4b	a2 14		ldx #$14			ldx 	#IFR2 						; copy R2 to stack,value to R2
.4c4d	20 9d 4d	jsr $4d9d			jsr 	IFloatPushRx
.4c50	20 f0 4d	jsr $4df0			jsr 	IFloatCopyToRegister
.4c53	20 4e 4b	jsr $4b4e			jsr 	IFloatIntegerR0				; make R0 integer
.4c56	a9 0a		lda #$0a			lda 	#10 						; base 10.
.4c58	20 ef 4b	jsr $4bef			jsr 	IFloatIntegerToStringR0 	; do the integer part.
.4c5b	9c ce 06	stz $06ce			stz 	IFloatDecimalCount 			; zero the decimal count.
.4c5e	a5 17		lda $17				lda 	IFR2+IExp 					; is integer.
.4c60	29 3f		and #$3f			and 	#IFXMask
.4c62	f0 44		beq $4ca8			beq 	_IFFSExit
.4c64					_IFloatFracLoop:
.4c64	a2 14		ldx #$14			ldx 	#IFR2 						; R0 = fractional part of R2
.4c66	20 df 4d	jsr $4ddf			jsr 	IFloatCopyFromRegister
.4c69	20 f8 4a	jsr $4af8			jsr 	IFloatFractionalR0
.4c6c	20 85 4e	jsr $4e85			jsr 	IFloatNormalise
.4c6f	a2 14		ldx #$14			ldx 	#IFR2
.4c71	20 f0 4d	jsr $4df0			jsr 	IFloatCopyToRegister 		; copy to R2
.4c74	a2 14		ldx #$14			ldx 	#IFR2 						; set R2 to 10
.4c76	a9 0a		lda #$0a			lda 	#10
.4c78	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.4c7b	a2 14		ldx #$14			ldx 	#IFR2						; R0,R2 = R2 * 10
.4c7d	20 ee 48	jsr $48ee			jsr 	IFloatMultiply
.4c80	a2 14		ldx #$14			ldx 	#IFR2
.4c82	20 f0 4d	jsr $4df0			jsr 	IFloatCopyToRegister
.4c85	20 4e 4b	jsr $4b4e			jsr 	IFloatIntegerR0 			; get integer part of R0
.4c88	ad ce 06	lda $06ce			lda 	IFloatDecimalCount 			; done 5 dp, no more
.4c8b	c9 03		cmp #$03			cmp 	#3
.4c8d	f0 16		beq $4ca5			beq 	_IFFSExitStripZero
.4c8f	ad ce 06	lda $06ce			lda 	IFloatDecimalCount 			; written the DP yet ?
.4c92	d0 05		bne $4c99			bne 	_IFloatNotFirst
.4c94	a9 2e		lda #$2e			lda 	#"." 						; write decimal point
.4c96	20 de 4e	jsr $4ede			jsr 	IFloatBufferWrite
.4c99					_IFloatNotFirst:
.4c99	ee ce 06	inc $06ce			inc 	IFloatDecimalCount
.4c9c	a5 0c		lda $0c				lda 	IFR0+IM0 					; get digit
.4c9e	09 30		ora #$30			ora 	#"0"						; ASCII
.4ca0	20 de 4e	jsr $4ede			jsr 	IFloatBufferWrite 			; write to the buffer.
.4ca3	80 bf		bra $4c64			bra 	_IFloatFracLoop
.4ca5					_IFFSExitStripZero:
.4ca5	20 ed 4e	jsr $4eed			jsr 	IFloatStripTrailingZeros
.4ca8					_IFFSExit:
.4ca8	a2 14		ldx #$14			ldx 	#IFR2 						; restore R2
.4caa	20 be 4d	jsr $4dbe			jsr 	IFloatPullRx
.4cad	20 d6 4e	jsr $4ed6			jsr 	IFloatGetBufferAddress
.4cb0	18		clc				clc
.4cb1	60		rts				rts
.06ce					IFloatDecimalCount:
>06ce							.fill 	1
.4cb2					IFloatStringToFloatR0:
.4cb2	8d cf 06	sta $06cf			sta 	IFCount 					; save it out.
.4cb5	86 0a		stx $0a				stx 	iTemp0
.4cb7	84 0b		sty $0b				sty 	iTemp0+1
.4cb9	a2 0c		ldx #$0c			ldx 	#IFR0 						; reset the current value.
.4cbb	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.4cbe	9c d0 06	stz $06d0			stz 	IFSignFlag 					; clear the sign flag
.4cc1	20 4e 4d	jsr $4d4e			jsr 	IFSTFGetNext 				; get first
.4cc4	f0 1b		beq $4ce1			beq 	_IFSTFFail 					; no character
.4cc6	90 10		bcc $4cd8			bcc 	_IFSTFHaveChar 				; legitimate character, go do it.
.4cc8	c9 2d		cmp #$2d			cmp 	#"-" 						; if not -, fail
.4cca	d0 15		bne $4ce1			bne 	_IFSTFFail
.4ccc	a9 40		lda #$40			lda 	#IFSign 					; set sign flag
.4cce	8d d0 06	sta $06d0			sta 	IFSignFlag
.4cd1					_IFSTFLoop:
.4cd1	20 4e 4d	jsr $4d4e			jsr 	IFSTFGetNext 				; get next
.4cd4	b0 0b		bcs $4ce1			bcs 	_IFSTFFail 					; bad character.
.4cd6	f0 11		beq $4ce9			beq 	_IFSTFExit 					; end of data
.4cd8					_IFSTFHaveChar:
.4cd8	c9 2e		cmp #$2e			cmp 	#"."						; decimal point ?
.4cda	f0 08		beq $4ce4			beq 	_IFSTFDecimal
.4cdc	20 72 4d	jsr $4d72			jsr 	IFSTFAddR0 					; add number in
.4cdf	80 f0		bra $4cd1			bra 	_IFSTFLoop 					; keep going until . or end.
.4ce1					_IFSTFFail:
.4ce1	38		sec				sec
.4ce2	80 0d		bra $4cf1			bra 	_IFSTFReturn
.4ce4					_IFSTFDecimal:
.4ce4	20 f9 4c	jsr $4cf9			jsr 	IFSTFDecimal 				; call the decimal places code.
.4ce7	b0 08		bcs $4cf1			bcs 	_IFSTFReturn 				; error
.4ce9					_IFSTFExit:
.4ce9	a5 0f		lda $0f				lda 	IFR0+IExp 					; copy sign flag in.
.4ceb	0d d0 06	ora $06d0			ora 	IFSignFlag
.4cee	85 0f		sta $0f				sta 	IFR0+IExp
.4cf0	18		clc				clc
.4cf1					_IFSTFReturn:
.4cf1	60		rts				rts
.4cf2					IFloatAddDecimalToR0:
.4cf2	8d cf 06	sta $06cf			sta 	IFCount 					; save it out.
.4cf5	86 0a		stx $0a				stx 	iTemp0
.4cf7	84 0b		sty $0b				sty 	iTemp0+1
.4cf9					IFSTFDecimal:
.4cf9	a2 0c		ldx #$0c			ldx 	#IFR0 						; push integer part on stack
.4cfb	20 9d 4d	jsr $4d9d			jsr 	IFloatPushRx
.4cfe	a2 0c		ldx #$0c			ldx 	#IFR0 						; R0 is the decimal digits so far.
.4d00	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero
.4d03	9c d1 06	stz $06d1			stz 	IFDecimalPlaces
.4d06					_IFSTDLoop:
.4d06	20 4e 4d	jsr $4d4e			jsr 	IFSTFGetNext 				; get next
.4d09	b0 41		bcs $4d4c			bcs 	_IFSTFFail2 				; bad character.
.4d0b	f0 11		beq $4d1e			beq 	_IFSTFComplete 				; end of data, work out the result.
.4d0d	c9 2e		cmp #$2e			cmp 	#"."						; only one decimal
.4d0f	f0 39		beq $4d4a			beq 	_IFSTFExit2
.4d11	20 72 4d	jsr $4d72			jsr 	IFSTFAddR0 					; add number in
.4d14	ee d1 06	inc $06d1			inc 	IFDecimalPlaces 			; count decimals
.4d17	ad d1 06	lda $06d1			lda 	IFDecimalPlaces 			; no more than 3 DP used.
.4d1a	c9 03		cmp #$03			cmp 	#3
.4d1c	90 e8		bcc $4d06			bcc 	_IFSTDLoop
.4d1e					_IFSTFComplete:
.4d1e	ad d1 06	lda $06d1			lda 	IFDecimalPlaces 			; decimals x 4 as accessing multiplier from a LUT.
.4d21	f0 27		beq $4d4a			beq 	_IFSTFExit2					; if none, this is syntactically fine, just ignore
.4d23	3a		dec a				dec 	a 							; table indexed from 1.
.4d24	0a		asl a				asl 	a
.4d25	0a		asl a				asl 	a
.4d26	aa		tax				tax
.4d27	bd 89 4d	lda $4d89,x			lda 	TableTen,x 					; copy table entry into R0 - these are 0.1,0.01,0.001
.4d2a	85 10		sta $10				sta  	IFR1+IM0 					; 0.0001 etc, up to 5 decimals.
.4d2c	bd 8a 4d	lda $4d8a,x			lda 	TableTen+1,x
.4d2f	85 11		sta $11				sta  	IFR1+IM1
.4d31	bd 8b 4d	lda $4d8b,x			lda 	TableTen+2,x
.4d34	85 12		sta $12				sta  	IFR1+IM2
.4d36	bd 8c 4d	lda $4d8c,x			lda 	TableTen+3,x
.4d39	85 13		sta $13				sta  	IFR1+IExp
.4d3b	a2 10		ldx #$10			ldx 	#IFR1 						; multiply into result
.4d3d	20 ee 48	jsr $48ee			jsr 	IFloatMultiply
.4d40	a2 10		ldx #$10			ldx 	#IFR1  						; pop and add the decimal.
.4d42	20 be 4d	jsr $4dbe			jsr 	IFloatPullRx
.4d45	a2 10		ldx #$10			ldx 	#IFR1
.4d47	20 44 48	jsr $4844			jsr 	IFloatAdd
.4d4a					_IFSTFExit2:
.4d4a	18		clc				clc
.4d4b	60		rts				rts
.4d4c					_IFSTFFail2:
.4d4c	38		sec				sec
.4d4d	60		rts				rts
.4d4e					IFSTFGetNext:
.4d4e	ad cf 06	lda $06cf			lda 	IFCount  					; if count is zero, return with Z set.
.4d51	f0 19		beq $4d6c			beq 	_IFSTFReturnOk
.4d53	b2 0a		lda ($0a)			lda 	(iTemp0) 					; get next character
.4d55	e6 0a		inc $0a				inc 	iTemp0 						; point at next.
.4d57	d0 02		bne $4d5b			bne 	_IFSTFGNNoCarry
.4d59	e6 0b		inc $0b				inc 	iTemp0+1
.4d5b					_IFSTFGNNoCarry:
.4d5b	ce cf 06	dec $06cf			dec 	IFCount 					; dec count.
.4d5e	c9 2e		cmp #$2e			cmp 	#"."	 					; check, dp is allowed.
.4d60	f0 08		beq $4d6a			beq 	_IFSTFGOkay
.4d62	c9 30		cmp #$30			cmp 	#"0"						; < 0 fail.
.4d64	90 08		bcc $4d6e			bcc 	_IFSTFGFail
.4d66	c9 3a		cmp #$3a			cmp 	#"9"+1 						; > 9 fail.
.4d68	b0 04		bcs $4d6e			bcs 	_IFSTFGFail
.4d6a					_IFSTFGOkay:
.4d6a	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.4d6c					_IFSTFReturnOk:
.4d6c	18		clc				clc
.4d6d	60		rts				rts
.4d6e					_IFSTFGFail:
.4d6e	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.4d70	38		sec				sec
.4d71	60		rts				rts
.4d72					IFSTFAddR0:
.4d72	29 0f		and #$0f			and 	#15 						; to int value
.4d74	48		pha				pha 								; save it.
.4d75	a9 0a		lda #$0a			lda 	#10
.4d77	a2 10		ldx #$10			ldx 	#IFR1
.4d79	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.4d7c	20 ee 48	jsr $48ee			jsr 	IFloatMultiply
.4d7f	68		pla				pla
.4d80	a2 10		ldx #$10			ldx 	#IFR1
.4d82	20 50 4e	jsr $4e50			jsr 	IFloatSetByte
.4d85	20 44 48	jsr $4844			jsr 	IFloatAdd
.4d88	60		rts				rts
.06cf					IFCount:
>06cf							.fill 	1
.06d0					IFSignFlag:
>06d0							.fill 	1
.06d1					IFDecimalPlaces:
>06d1							.fill 	1
.4d89					TableTen:
>4d89	9a 19 00 30				.byte	$9a,$19,$00,$30 ; 0.10001
>4d8d	8f 02 00 30				.byte	$8f,$02,$00,$30 ; 0.00999
>4d91	42 00 00 30				.byte	$42,$00,$00,$30 ; 0.00101
>4d95	07 00 00 30				.byte	$07,$00,$00,$30 ; 0.00011
>4d99	01 00 00 30				.byte	$01,$00,$00,$30 ; 2e-05
.4d9d					IFloatPushRx:
.4d9d	5a		phy				phy
.4d9e	ac d2 06	ldy $06d2			ldy 	IFStackIndex
.4da1	b5 00		lda $00,x			lda 	IM0,x
.4da3	99 d3 06	sta $06d3,y			sta 	IFStack,y
.4da6	b5 01		lda $01,x			lda 	IM1,x
.4da8	99 d4 06	sta $06d4,y			sta 	IFStack+1,y
.4dab	b5 02		lda $02,x			lda 	IM2,x
.4dad	99 d5 06	sta $06d5,y			sta 	IFStack+2,y
.4db0	b5 03		lda $03,x			lda 	IExp,x
.4db2	99 d6 06	sta $06d6,y			sta 	IFStack+3,y
.4db5	c8		iny				iny
.4db6	c8		iny				iny
.4db7	c8		iny				iny
.4db8	c8		iny				iny
.4db9	8c d2 06	sty $06d2			sty 	IFStackIndex
.4dbc	7a		ply				ply
.4dbd	60		rts				rts
.4dbe					IFloatPullRx:
.4dbe	5a		phy				phy
.4dbf	ac d2 06	ldy $06d2			ldy 	IFStackIndex
.4dc2	88		dey				dey
.4dc3	88		dey				dey
.4dc4	88		dey				dey
.4dc5	88		dey				dey
.4dc6	b9 d3 06	lda $06d3,y			lda 	IFStack,y
.4dc9	95 00		sta $00,x			sta 	IM0,x
.4dcb	b9 d4 06	lda $06d4,y			lda 	IFStack+1,y
.4dce	95 01		sta $01,x			sta 	IM1,x
.4dd0	b9 d5 06	lda $06d5,y			lda 	IFStack+2,y
.4dd3	95 02		sta $02,x			sta 	IM2,x
.4dd5	b9 d6 06	lda $06d6,y			lda 	IFStack+3,y
.4dd8	95 03		sta $03,x			sta 	IExp,x
.4dda	8c d2 06	sty $06d2			sty 	IFStackIndex
.4ddd	7a		ply				ply
.4dde	60		rts				rts
.06d2					IFStackIndex:
>06d2							.fill 	1
.06d3					IFStack:
>06d3							.fill 	16*4
.4ddf					IFloatCopyFromRegister:
.4ddf	b5 00		lda $00,x			lda 	0,x
.4de1	85 0c		sta $0c				sta 	IFR0
.4de3	b5 01		lda $01,x			lda 	1,x
.4de5	85 0d		sta $0d				sta 	IFR0+1
.4de7	b5 02		lda $02,x			lda 	2,x
.4de9	85 0e		sta $0e				sta 	IFR0+2
.4deb	b5 03		lda $03,x			lda 	3,x
.4ded	85 0f		sta $0f				sta 	IFR0+3
.4def	60		rts				rts
.4df0					IFloatCopyToRegister:
.4df0	a5 0c		lda $0c				lda 	IFR0
.4df2	95 00		sta $00,x			sta 	0,x
.4df4	a5 0d		lda $0d				lda 	IFR0+1
.4df6	95 01		sta $01,x			sta 	1,x
.4df8	a5 0e		lda $0e				lda 	IFR0+2
.4dfa	95 02		sta $02,x			sta 	2,x
.4dfc	a5 0f		lda $0f				lda 	IFR0+3
.4dfe	95 03		sta $03,x			sta 	3,x
.4e00	60		rts				rts
.4e01					IFloatLoadInline:
.4e01	68		pla				pla 								; pop address off to iTemp0
.4e02	85 0a		sta $0a				sta 	iTemp0
.4e04	68		pla				pla
.4e05	85 0b		sta $0b				sta 	iTemp0+1
.4e07	a0 01		ldy #$01			ldy 	#1
.4e09	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 0
.4e0b	95 00		sta $00,x			sta 	0,x
.4e0d	c8		iny				iny
.4e0e	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 1
.4e10	95 01		sta $01,x			sta 	1,x
.4e12	c8		iny				iny
.4e13	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 2
.4e15	95 02		sta $02,x			sta 	2,x
.4e17	c8		iny				iny
.4e18	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 3
.4e1a	95 03		sta $03,x			sta 	3,x
.4e1c	18		clc				clc 								; inc pointer, 1 for return, 4 for data
.4e1d	a5 0a		lda $0a				lda 	iTemp0
.4e1f	69 05		adc #$05			adc 	#5
.4e21	85 0a		sta $0a				sta 	iTemp0
.4e23	90 02		bcc $4e27			bcc 	_IFLINoCarry
.4e25	e6 0b		inc $0b				inc 	iTemp0+1
.4e27					_IFLINoCarry:
.4e27	6c 0a 00	jmp ($000a)			jmp 	(iTemp0)					; effectively RTS
.4e2a					IFloatMultiply8BitRx:
.4e2a	5a		phy		        phy
.4e2b	b5 00		lda $00,x	        lda     IM0,x                       ; AY are the two values
.4e2d	a4 0c		ldy $0c		        ldy     IFR0+IM0
.4e2f	4a		lsr a		        lsr     a                           ; prime the carry bit for the loop
.4e30	85 0c		sta $0c		        sta     IFR0+IM0
.4e32	84 0d		sty $0d		        sty     IFR0+IM1
.4e34	a9 00		lda #$00	        lda     #0
.4e36	a0 08		ldy #$08	        ldy     #8
.4e38					_IFMLoop:
.4e38	90 03		bcc $4e3d	        bcc     _IFMNoAdd
.4e3a	18		clc		        clc
.4e3b	65 0d		adc $0d		        adc     IFR0+IM1
.4e3d					_IFMNoAdd:
.4e3d	6a		ror a		        ror     a
.4e3e	66 0c		ror $0c		        ror     IFR0+IM0                    ; pull another bit out for the next iteration
.4e40	88		dey		        dey
.4e41	d0 f5		bne $4e38	        bne     _IFMLoop
.4e43	85 0d		sta $0d		        sta     IFR0+IM1                    ; write MSB out
.4e45	7a		ply		        ply
.4e46	60		rts		        rts
.4e47					IFloatCheckZero:
.4e47	b5 00		lda $00,x			lda 	IM0,x
.4e49	15 01		ora $01,x			ora 	IM1,x
.4e4b	15 02		ora $02,x			ora 	IM2,x
.4e4d	60		rts				rts
.4e4e					IFloatSetZero:
.4e4e	a9 00		lda #$00			lda 	#0
.4e50					IFloatSetByte:
.4e50	95 00		sta $00,x			sta 	IM0,x 						; set mantissa to 00A
.4e52	74 01		stz $01,x			stz 	IM1,x
.4e54	74 02		stz $02,x			stz 	IM2,x
.4e56	74 03		stz $03,x			stz 	IExp,x 						; zero the exponent.
.4e58	60		rts				rts
.4e59					IFloatNegate:
.4e59	b5 03		lda $03,x			lda 	IExp,x
.4e5b	49 40		eor #$40			eor 	#IFSign
.4e5d	95 03		sta $03,x			sta 	IExp,x
.4e5f	18		clc				clc
.4e60	60		rts				rts
.4e61					IFloatMantissaNegate:
.4e61	38		sec				sec
.4e62	a9 00		lda #$00			lda 	#0
.4e64	f5 00		sbc $00,x			sbc 	IM0,x
.4e66	95 00		sta $00,x			sta 	IM0,x
.4e68	a9 00		lda #$00			lda 	#0
.4e6a	f5 01		sbc $01,x			sbc 	IM1,x
.4e6c	95 01		sta $01,x			sta 	IM1,x
.4e6e	a9 00		lda #$00			lda 	#0
.4e70	f5 02		sbc $02,x			sbc 	IM2,x
.4e72	95 02		sta $02,x			sta 	IM2,x
.4e74	60		rts				rts
.4e75					IFloatShiftLeft:
.4e75	18		clc				clc
.4e76					IFloatRotateLeft:
.4e76	36 00		rol $00,x			rol 	IM0,x
.4e78	36 01		rol $01,x			rol 	IM1,x
.4e7a	36 02		rol $02,x			rol 	IM2,x
.4e7c	60		rts				rts
.4e7d					IFloatShiftRight:
.4e7d	18		clc				clc
.4e7e					IFloatRotateRight:
.4e7e	76 02		ror $02,x			ror 	IM2,x
.4e80	76 01		ror $01,x			ror 	IM1,x
.4e82	76 00		ror $00,x			ror 	IM0,x
.4e84	60		rts				rts
.4e85					IFloatNormalise:
.4e85	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero 			; is it zero
.4e88	f0 18		beq $4ea2			beq 	_IFNExitZero 				; if so exit
.4e8a					_IFNLoop:
.4e8a	b5 02		lda $02,x			lda 	IM2,x 						; is it normalised e.g. bits 7/6 are 01
.4e8c	29 c0		and #$c0			and 	#$C0
.4e8e	c9 40		cmp #$40			cmp 	#$40
.4e90	f0 13		beq $4ea5			beq 	_IFNExitOkay 				; if so , then we are done.
.4e92	b5 03		lda $03,x			lda 	IExp,x 						; check exponent is not -32 already.
.4e94	29 3f		and #$3f			and 	#$3F
.4e96	c9 20		cmp #$20			cmp 	#$20
.4e98	f0 0b		beq $4ea5			beq 	_IFNExitOkay 				; if so, then we cannot normalise any more.
.4e9a	20 bb 4e	jsr $4ebb			jsr 	IFloatDecExponent
.4e9d	20 75 4e	jsr $4e75			jsr 	IFloatShiftLeft 			; shift mantissa left, e.g. multiply by 2
.4ea0	80 e8		bra $4e8a			bra 	_IFNLoop
.4ea2					_IFNExitZero:
.4ea2	20 4e 4e	jsr $4e4e			jsr 	IFloatSetZero 				; set the result to zero
.4ea5					_IFNExitOkay:
.4ea5	18		clc				clc  								; return with CC.
.4ea6	60		rts				rts
.4ea7					IFloatIncExponent:
.4ea7	b5 03		lda $03,x			lda 	IExp,x
.4ea9	48		pha				pha
.4eaa	29 c0		and #$c0			and 	#$C0
.4eac	8d 13 07	sta $0713			sta 	IFXTemp
.4eaf	68		pla				pla
.4eb0	1a		inc a				inc 	a
.4eb1	29 3f		and #$3f			and 	#$3F
.4eb3	48		pha				pha
.4eb4	0d 13 07	ora $0713			ora 	IFXTemp
.4eb7	95 03		sta $03,x			sta 	IExp,x
.4eb9	68		pla				pla
.4eba	60		rts				rts
.4ebb					IFloatDecExponent:
.4ebb	b5 03		lda $03,x			lda 	IExp,x
.4ebd	48		pha				pha
.4ebe	29 c0		and #$c0			and 	#$C0
.4ec0	8d 13 07	sta $0713			sta 	IFXTemp
.4ec3	68		pla				pla
.4ec4	3a		dec a				dec 	a
.4ec5	29 3f		and #$3f			and 	#$3F
.4ec7	48		pha				pha
.4ec8	0d 13 07	ora $0713			ora 	IFXTemp
.4ecb	95 03		sta $03,x			sta 	IExp,x
.4ecd	68		pla				pla
.4ece	60		rts				rts
.0713					IFXTemp:
>0713							.fill 	1
.4ecf					IFloatBufferReset:
.4ecf	9c 14 07	stz $0714			stz 	IFBufferCount
.4ed2	9c 15 07	stz $0715			stz 	IFBuffer
.4ed5	60		rts				rts
.4ed6					IFloatGetBufferAddress:
.4ed6	a0 07		ldy #$07			ldy 	#(IFBuffer >> 8)
.4ed8	a2 15		ldx #$15			ldx 	#(IFBuffer & $FF)
.4eda	ad 14 07	lda $0714			lda 	IFBufferCount
.4edd	60		rts				rts
.4ede					IFloatBufferWrite:
.4ede	da		phx				phx
.4edf	ae 14 07	ldx $0714			ldx 	IFBufferCount
.4ee2	9d 15 07	sta $0715,x			sta 	IFBuffer,x
.4ee5	9e 16 07	stz $0716,x			stz 	IFBuffer+1,x
.4ee8	ee 14 07	inc $0714			inc 	IFBufferCount
.4eeb	fa		plx				plx
.4eec	60		rts				rts
.4eed					IFloatStripTrailingZeros:
.4eed	ae 14 07	ldx $0714			ldx 	IFBufferCount
.4ef0	bd 14 07	lda $0714,x			lda 	IFBuffer-1,x
.4ef3	c9 30		cmp #$30			cmp		#"0"
.4ef5	d0 0f		bne $4f06			bne 	_IFSTExit
.4ef7	bd 13 07	lda $0713,x			lda 	IFBuffer-2,x
.4efa	c9 2e		cmp #$2e			cmp 	#"."
.4efc	f0 08		beq $4f06			beq 	_IFSTExit
.4efe	ce 14 07	dec $0714			dec 	IFBufferCount
.4f01	9e 14 07	stz $0714,x			stz 	IFBuffer-1,x
.4f04	80 e7		bra $4eed			bra 	IFloatStripTrailingZeros
.4f06					_IFSTExit:
.4f06	60		rts				rts
.0714					IFBufferCount:
>0714							.fill 	1
.0715					IFBuffer:
>0715							.fill 	25
.4f07					IFloatCheck:
.4f07	a5 0f		lda $0f				lda 	IFR0+IExp					; force it negative
.4f09	09 40		ora #$40			ora 	#IFSign
.4f0b	85 0f		sta $0f				sta 	IFR0+IExp
.4f0d	20 44 48	jsr $4844			jsr 	IFloatAdd 					; add allowed to error.
.4f10	a2 0c		ldx #$0c			ldx 	#IFR0
.4f12	20 47 4e	jsr $4e47			jsr 	IFloatCheckZero 			; error if < 0
.4f15	f0 06		beq $4f1d			beq 	_IFAOkay
.4f17	a5 0f		lda $0f				lda 	IFR0+IExp
.4f19	29 40		and #$40			and 	#IFSign
.4f1b	d0 01		bne $4f1e			bne 	_IFAFail
.4f1d					_IFAOkay:
.4f1d	60		rts				rts
.4f1e					_IFAFail:
.4f1e	38		sec				sec
.4f1f	68		pla				pla 								; get address - 2
.4f20	e9 02		sbc #$02			sbc 	#2
.4f22	aa		tax				tax
.4f23	68		pla				pla
.4f24	e9 00		sbc #$00			sbc 	#0
.4f26	a8		tay				tay
.4f27	a9 aa		lda #$aa			lda 	#$AA 						; sign assert
.4f29					_IFAStop:
>4f29	db						.byte 	$DB 						; display an error AA ADR ADR
.4f2a	80 fd		bra $4f29			bra 	_IFAStop

;******  Return to file: basic.asm

.4f2c					NotImplemented:
.4f2c	a9 ff		lda #$ff			lda 	#$FF
.4f2e	80 04		bra $4f34			bra 	EnterDbg
.4f30					ErrorHandler:
.4f30	fa		plx				plx
.4f31	7a		ply				ply
.4f32	a9 ee		lda #$ee			lda 	#$EE
.4f34					EnterDbg:
>4f34	db						.byte 	$DB
.4f35	4c 34 4f	jmp $4f34			jmp 	EnterDbg

;******  End of listing
