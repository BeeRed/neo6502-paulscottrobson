
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -q -Wall -c -C -b -L build/code.lst -l build/code.lbl -D "BASICLOAD=\$1000" -D "BASICCODE=\$3800" -D "ENDMEMORY=\$C000" -D STACKPAGES=2 -o build/basic.bin basic.asm
; Wed Jul  5 17:14:48 2023

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=$1000					BASICLOAD=$1000
=$3800					BASICCODE=$3800
=$c000					ENDMEMORY=$C000
=2					STACKPAGES=2

;******  Processing input file: basic.asm


;******  Processing file: build/ramdata.inc

=$08					ZeroPageBase = $08 							; zero page usage
=$200					StorageBase = $200 							; ROM usage
.0008					IFR0:
>0008							.fill 	4
.000c					IFR1:
>000c							.fill 	4
.0010					IFR2:
>0010							.fill 	4
.0014					IFRTemp:
>0014							.fill 	4
.0018					codePtr:
>0018							.fill 	4
.001c					rTemp0:
>001c							.fill 	2
.001e					rTemp1:
>001e							.fill 	2
.0020					iTemp0:
>0020							.fill 	2
.0200					OSNewLineFlag:
>0200							.fill 	32
.0220					OSXPos:
>0220							.fill 	1
.0221					OSYPos:
>0221							.fill 	1
.0222					OSXSize:
>0222							.fill 	1
.0223					OSYSize:
>0223							.fill 	1
.0224					OSXPosSave:
>0224							.fill 	1
.0225					OSYPosSave:
>0225							.fill 	1
.0226					OSYFrameTop:
>0226							.fill 	1
.0227					OSYFrameBottom:
>0227							.fill 	1
=16					OSKeyboardQueueMaxSize = 16					; keyboard queue max size.
.0228					OSKeyStatus:
>0228							.fill 	32
.0248					OSKeyboardQueue:
>0248							.fill 	OSKeyboardQueueMaxSize
.0258					OSKeyboardQueueSize:
>0258							.fill 	1
.0259					OSIsKeyUp:
>0259							.fill 	1
.025a					OSIsKeyShift:
>025a							.fill 	1
.025b					OSEscapePressed:
>025b							.fill 	1
.025c					OSRKOriginal:
>025c							.fill 	1
.025d					OSXEdit:
>025d							.fill 	1
.025e					OSYEdit:
>025e							.fill 	1
.025f					OSEditPos:
>025f							.fill 	1
.0260					OSEditScroll:
>0260							.fill 	1
=192					OSTextBufferSize = 192
.0261					OSEditWidth:
>0261							.fill 	1
.0262					OSEditLength:
>0262							.fill 	1
.0263					OSEditBuffer:
>0263							.fill 	OSTextBufferSize+1
>0324							.fill 	32
.0022					fsBlock:
>0022							.fill 	2
.0344					sectorSize:
>0344							.fill 	2
.0346					sectorCount:
>0346							.fill 	2
.0348					currentSector:
>0348							.fill 	2
.034a					successFlag:
>034a							.fill 	1
.034b					sectorHeader:
.034b					shFirstNext:
>034b							.fill 	1
.034c					shContinue:
>034c							.fill 	1
.034d					shDataSize:
>034d							.fill 	2
.034f					shFileSize:
>034f							.fill 	2
>0351							.fill 	10
.035b					shNameLength:
>035b							.fill 	1
.035c					shNameText:
>035c							.fill 	15
.036b					shFileSizeCopy:
>036b							.fill 	2
.036d					notFirstSector:
>036d							.fill 	1
.036e					sectorCapacity:
>036e							.fill 	2
.0370					fileRemainingSize:
>0370							.fill 	2
.0372					bytesToWrite:
>0372							.fill 	2
>0374							.align 	256

;******  Return to file: basic.asm


;******  Processing file: build/osvectors.inc

=$ffca					OSReadDirectory          = $ffca ; Read file directory.
=$ffcd					OSDeleteFile             = $ffcd ; Delete file
=$ffd0					OSReadFile               = $ffd0 ; Read file into memory
=$ffd3					OSWriteFile              = $ffd3 ; Write file from memory
=$ffd6					OSFormatFlash            = $ffd6 ; Format drive
=$ffd9					OSGetScreenPosition      = $ffd9 ; Screen position to XY
=$ffdc					OSGetScreenSize          = $ffdc ; Get size of screen to XY
=$ffdf					OSWriteString            = $ffdf ; Write length prefixed string YX to screen
=$ffe2					OSEnterLine              = $ffe2 ; Edit line, return line in YX length prefixed, backspace only editing.
=$ffe5					OSScreenLine             = $ffe5 ; Edit line, return line in YX length prefixed, full screen editing.
=$ffe8					OSKeyboardDataProcess    = $ffe8 ; Keyboard update process.
=$ffeb					OSCheckBreak             = $ffeb ; NZ if ESC pressed.
=$ffee					OSIsKeyAvailable         = $ffee ; Check if key available (CS if so)
=$fff1					OSReadKeystroke          = $fff1 ; Read A from keyboard, display cursor, wait for key.
=$fff4					OSReadKeyboard           = $fff4 ; Read A from keyboard, CC = success, CS = no key
=$fff7					OSWriteScreen            = $fff7 ; Write A to screen, CC = success

;******  Return to file: basic.asm

=0					runEdit = 0 								; setting to 1 builds with the program/testing stuff in.
=0					autoRun = 0 								; setting to 1 autoruns program in memory space.
=2					STACK_PAGES = 2 							; number of stack pages.
.1000					boot:
.1000	a2 38		ldx #$38			ldx 	#BASICCODE >> 8 			; common setup, tells BASIC where its memory area is.
.1002	a0 c0		ldy #$c0			ldy 	#ENDMEMORY >> 8
.1004	20 5a 21	jsr $215a			jsr 	PGMSetBaseAddress
.1007	20 01 2e	jsr $2e01			jsr 	IFInitialise 				; setup math library
.100a	4c 68 14	jmp $1468			jmp 	Command_NEW 				; most just start with this

;******  Processing file: include.files


;******  Processing file: src/assembler/assembler.inc

=$80					AM_ZPAGE 		= $80 						; bit 7 set for ZP/8 bit operands only
="I"					AM_IMPLIED 		= 'I'						; none
=$a3					AM_IMMEDIATE 	= ('#'|AM_ZPAGE)			; immediate
="A"					AM_ABSOLUTE 	= 'A' 			 			; lda nnnn
="X"					AM_ABSOLUTEX 	= 'X' 						; lda nnnn,x
="Y"					AM_ABSOLUTEY 	= 'Y' 						; lda nnnn.y
="I"					AM_ABSOLUTEIX	= 'I' 						; jmp (nnnn,x) [only instance !]
=$c1					AM_ZERO 	= ('A'|AM_ZPAGE) 				; lda nn
=$d8					AM_ZEROX 	= ('X'|AM_ZPAGE)				; lda nn,x
=$d9					AM_ZEROY 	= ('Y'|AM_ZPAGE)				; lda nn,y
=$d0					AM_IND 		= ('P'|AM_ZPAGE) 				; lda (nn)
=$d1					AM_INDX		= ('Q'|AM_ZPAGE) 				; lda (nn,x)
=$d2					AM_INDY		= ('R'|AM_ZPAGE) 				; lda (nn,y)

;******  Return to file: include.files


;******  Processing file: src/data.inc

.0024					zTemp0:
>0024							.fill 	2
.0026					zTemp1:
>0026							.fill 	2
.0028					zTemp2:
>0028							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/generated/token_const.inc

=$80					PR_STRUCTURE_FIRST = $80
=$80					PR_REPEAT = $80
=$81					PR_UNTIL = $81
=$82					PR_WHILE = $82
=$83					PR_WEND = $83
=$84					PR_IF = $84
=$85					PR_ENDIF = $85
=$86					PR_DO = $86
=$87					PR_LOOP = $87
=$88					PR_PROC = $88
=$89					PR_ENDPROC = $89
=$8a					PR_FOR = $8a
=$8b					PR_STRUCTURE_LAST = $8b
=$8b					PR_NEXT = $8b
=$8c					PR_STANDARD_FIRST = $8c
=$8c					PR_LSQLSQENDRSQRSQ = $8c
=$8d					PR_LSQLSQSHIFTRSQRSQ = $8d
=$8e					PR_ELSE = $8e
=$8f					PR_THEN = $8f
=$90					PR_TO = $90
=$91					PR_STEP = $91
=$92					PR_LET = $92
=$93					PR_PRINT = $93
=$94					PR_INPUT = $94
=$95					PR_CALL = $95
=$96					PR_SYS = $96
=$97					PR_REM = $97
=$98					PR_EXIT = $98
=$99					PR_COMMA = $99
=$9a					PR_SEMICOLON = $9a
=$9b					PR_COLON = $9b
=$9c					PR_SQUOTE = $9c
=$9d					PR_RPAREN = $9d
=$9e					PR_POKE = $9e
=$9f					PR_DOKE = $9f
=$a0					PR_READ = $a0
=$a1					PR_DATA = $a1
=$a2					PR_LSQ = $a2
=$a3					PR_RSQ = $a3
=$a4					PR_HASH = $a4
=$a5					PR_STANDARD_LAST = $a5
=$a5					PR_PERIOD = $a5
=$d5					PR_UNARY_FIRST = $d5
=$d5					PR_DEEKLPAREN = $d5
=$d6					PR_PEEKLPAREN = $d6
=$d7					PR_RIGHTDOLLARLPAREN = $d7
=$d8					PR_LEFTDOLLARLPAREN = $d8
=$d9					PR_MIDDOLLARLPAREN = $d9
=$da					PR_STRDOLLARLPAREN = $da
=$db					PR_VALLPAREN = $db
=$dc					PR_SGNLPAREN = $dc
=$dd					PR_ABSLPAREN = $dd
=$de					PR_LENLPAREN = $de
=$df					PR_SQRLPAREN = $df
=$e0					PR_CHRDOLLARLPAREN = $e0
=$e1					PR_ASCLPAREN = $e1
=$e2					PR_INKEYDOLLARLPAREN = $e2
=$e3					PR_EVENTLPAREN = $e3
=$e4					PR_TIME = $e4
=$e5					PR_INTLPAREN = $e5
=$e6					PR_FRACLPAREN = $e6
=$e7					PR_DECLPAREN = $e7
=$e8					PR_HEXDOLLARLPAREN = $e8
=$e9					PR_RNDLPAREN = $e9
=$ea					PR_RANDLPAREN = $ea
=$eb					PR_LPAREN = $eb
=$ec					PR_AMPERSAND = $ec
=$ed					PR_LSQLSQDECIMALRSQRSQ = $ed
=$ee					PR_UNARY_LAST = $ee
=$ee					PR_LSQLSQSTRINGRSQRSQ = $ee
=$ef					PR_BINARY_FIRST = $ef
=$ef					PR_EQUAL = $ef
=$f0					PR_LESSGREATER = $f0
=$f1					PR_LESSEQUAL = $f1
=$f2					PR_LESS = $f2
=$f3					PR_GREATEREQUAL = $f3
=$f4					PR_GREATER = $f4
=$f5					PR_XOR = $f5
=$f6					PR_OR = $f6
=$f7					PR_AND = $f7
=$f8					PR_DIV = $f8
=$f9					PR_MOD = $f9
=$fa					PR_LESSLESS = $fa
=$fb					PR_GREATERGREATER = $fb
=$fc					PR_SLASH = $fc
=$fd					PR_ASTERISK = $fd
=$fe					PR_MINUS = $fe
=$ff					PR_BINARY_LAST = $ff
=$ff					PR_PLUS = $ff
=$8d80					PR_CLEAR = $8d80
=$8d81					PR_NEW = $8d81
=$8d82					PR_RUN = $8d82
=$8d83					PR_STOP = $8d83
=$8d84					PR_END = $8d84
=$8d85					PR_ASSERT = $8d85
=$8d86					PR_LIST = $8d86
=$8d87					PR_SAVE = $8d87
=$8d88					PR_LOAD = $8d88
=$8d89					PR_GOSUB = $8d89
=$8d8a					PR_GOTO = $8d8a
=$8d8b					PR_RETURN = $8d8b
=$8d8c					PR_RESTORE = $8d8c
=$8d8d					PR_DIM = $8d8d
=$8d8e					PR_DIR = $8d8e
=$8d8f					PR_ERASE = $8d8f
=$8d90					PR_RENUMBER = $8d90

;******  Return to file: include.files


;******  Processing file: src/program/data.inc

.0400					TOKLineSize:
>0400							.fill 	1
.0401					TOKLineNumber:
>0401							.fill 	2
.0403					TOKBuffer:
>0403							.fill 	256

;******  Return to file: include.files


;******  Processing file: src/support/errors/generated/errors.inc


;******  Return to file: include.files


;******  Processing file: src/support/stack/stack.inc

=$02					STK_REPEAT = $02
=$12					STK_WHILE = $12
=$22					STK_DO = $22
=$37					STK_FOR = $37
=$42					STK_CALL = $42
=$52					STK_GOSUB = $52

;******  Return to file: include.files


;******  Processing file: src/assembler/entry.asm

.100d					Command_AssemblerStart:
.100d					_CALoop:
.100d	b1 18		lda ($18),y			lda 	(codePtr),y 				; what's next.
.100f	c8		iny				iny 								; consume it.
.1010	c9 a5		cmp #$a5			cmp 	#PR_PERIOD 					; .label
.1012	f0 15		beq $1029			beq 	_CALabel
.1014	c9 a3		cmp #$a3			cmp 	#PR_RSQ  					; ] exit
.1016	f0 30		beq $1048			beq 	_CAExit
.1018	c9 9b		cmp #$9b			cmp 	#PR_COLON 					; : loop back round again.
.101a	f0 f1		beq $100d			beq 	_CALoop
.101c	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; end of line.
.101e	f0 14		beq $1034			beq 	_CAEnd
.1020	29 c0		and #$c0			and 	#$C0 						; is it an identifier (which we will make an opcode)
.1022	c9 40		cmp #$40			cmp 	#$40
.1024	f0 08		beq $102e			beq 	_CAOpcode
.1026	4c 9e 27	jmp $279e		jmp	ErrorV_syntax
.1029					_CALabel:
.1029	20 49 10	jsr $1049			jsr 	ASLabel 					; handle a label
.102c	80 df		bra $100d			bra 	_CALoop
.102e					_CAOpcode:
.102e	88		dey				dey 								; get it back
.102f	20 6c 10	jsr $106c			jsr 	ASOpcode 					; assemble that opcode.
.1032	80 d9		bra $100d			bra 	_CALoop
.1034	18		clc		_CAEnd:	clc 								; next line
.1035	a0 03		ldy #$03			ldy 	#3 							; tokenised code position.
.1037	b2 18		lda ($18)			lda 	(codePtr)
.1039	65 18		adc $18				adc 	codePtr
.103b	85 18		sta $18				sta 	codePtr
.103d	90 02		bcc $1041			bcc 	_CANoCarry
.103f	e6 19		inc $19				inc 	codePtr+1
.1041					_CANoCarry:
.1041	b2 18		lda ($18)			lda 	(codePtr) 					; code present
.1043	d0 c8		bne $100d			bne 	_CALoop 					; go round again
.1045	4c d4 15	jmp $15d4			jmp 	Command_END 				; do END.
.1048					_CAExit:
.1048	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/assembler/label.asm

.1049					ASLabel:
.1049	20 37 18	jsr $1837			jsr 	EXPTermR0 					; get term
.104c	90 1b		bcc $1069			bcc 	_ALError 					; must be a reference term.
.104e	24 0b		bit $0b				bit 	IFR0+IExp	 				; string reference ?
.1050	30 17		bmi $1069			bmi 	_ALError
.1052	5a		phy				phy
.1053	ad b0 06	lda $06b0			lda 	('P'-'A')*4 + FastVariables	; copy P to variable
.1056	92 08		sta ($08)			sta 	(IFR0+IM0)
.1058	a0 01		ldy #$01			ldy 	#1
.105a	ad b1 06	lda $06b1			lda 	('P'-'A')*4 + FastVariables+1
.105d	91 08		sta ($08),y			sta 	(IFR0+IM0),y
.105f	a9 00		lda #$00			lda 	#0 							; clear upper bytes
.1061	c8		iny				iny
.1062	91 08		sta ($08),y			sta 	(IFR0+IM0),y
.1064	c8		iny				iny
.1065	91 08		sta ($08),y			sta 	(IFR0+IM0),y
.1067	7a		ply				ply
.1068	60		rts				rts
.1069					_ALError:
.1069	4c 9e 27	jmp $279e		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/assembler/opcode/opcode.asm

.106c					ASOpcode:
>106c	db						.byte 	$DB

;******  Return to file: include.files


;******  Processing file: src/commands/assert.asm

.106d					Command_ASSERT:
.106d	20 af 17	jsr $17af			jsr 	EXPEvalNumber 				; get a number to assert
.1070	a2 08		ldx #$08			ldx 	#IFR0						; check if it is zero ?
.1072	20 0d 34	jsr $340d			jsr 	IFloatCheckZero
.1075	f0 01		beq $1078			beq 	_CAFail 					; if so, the assert fails.
.1077	60		rts				rts
.1078					_CAFail:
.1078	4c f4 27	jmp $27f4		jmp	ErrorV_assert

;******  Return to file: include.files


;******  Processing file: src/commands/clear.asm

.107b					Command_CLEAR:
.107b	b1 18		lda ($18),y			lda 	(codePtr),y 				; check for CLEAR <something>
.107d	c9 9b		cmp #$9b			cmp 	#PR_COLON
.107f	f0 14		beq $1095			beq 	_CLNoParam
.1081	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ
.1083	f0 10		beq $1095			beq 	_CLNoParam
.1085	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; address for CLEAR
.1088	a5 09		lda $09				lda 	IFR0+IM1 					; high byte
.108a	c9 c0		cmp #$c0			cmp 	#ENDMEMORY >> 8 			; too high
.108c	b0 0b		bcs $1099			bcs 	_CLMemory
.108e	c9 39		cmp #$39			cmp 	#(BASICCODE >> 8)+1 		; too low
.1090	90 07		bcc $1099			bcc 	_CLMemory
.1092	8d 1b 05	sta $051b			sta 	PGMEndMemoryHigh 			; update end of memory, reserving bits.
.1095					_CLNoParam:
.1095	20 9c 10	jsr $109c			jsr 	ClearCode
.1098	60		rts				rts
.1099					_CLMemory:
.1099	4c 8e 28	jmp $288e		jmp	ErrorV_memory
.109c					ClearCode:
.109c	20 6d 21	jsr $216d			jsr 	PGMEndProgram 				; end program => zTemp0
.109f	64 2a		stz $2a				stz 	freeMemory 					; start on next free page
.10a1	a5 25		lda $25				lda 	zTemp0+1 					; for variables.
.10a3	1a		inc a				inc 	a
.10a4	85 2b		sta $2b				sta 	freeMemory+1
.10a6	20 a0 2d	jsr $2da0			jsr 	VARClearHashTables
.10a9	ad 1b 05	lda $051b			lda 	PGMEndMemoryHigh
.10ac	20 e5 29	jsr $29e5			jsr 	StackReset 					; page passed on in A
.10af	20 44 2a	jsr $2a44			jsr 	StringSystemInitialise
.10b2	20 09 27	jsr $2709			jsr 	ScanProcedures
.10b5	20 36 15	jsr $1536			jsr 	Command_RESTORE
.10b8	60		rts				rts
.10b9					AllocateMemory:
.10b9	5a		phy				phy 								; save Y
.10ba	a4 2a		ldy $2a				ldy 	freeMemory 					; save addr.low (of final memory)
.10bc	5a		phy				phy
.10bd	a4 2b		ldy $2b				ldy 	freeMemory+1 				; save addr.high
.10bf	5a		phy				phy
.10c0	a8		tay				tay 								; count is now in XY
.10c1					_AllocateLoop:
.10c1	e0 00		cpx #$00			cpx 	#0 							; allocate count is zero ?
.10c3	d0 04		bne $10c9			bne 	_AllocateOne
.10c5	c0 00		cpy #$00			cpy 	#0
.10c7	f0 15		beq $10de			beq 	_AllocateExit
.10c9					_AllocateOne:
.10c9	a9 00		lda #$00			lda 	#0 							; zero byte
.10cb	92 2a		sta ($2a)			sta 	(freeMemory)
.10cd	e6 2a		inc $2a				inc 	freeMemory 					; bump pointer
.10cf	d0 05		bne $10d6			bne 	_AllocateSkipCarry
.10d1	e6 2b		inc $2b				inc 	freeMemory+1
.10d3	20 e2 10	jsr $10e2			jsr 	ClearCheckMemory 			; check we haven't hit the string space.
.10d6					_AllocateSkipCarry:
.10d6	c0 00		cpy #$00			cpy 	#0 							; do this XY times ; decrement XY
.10d8	d0 01		bne $10db			bne 	_AllocateSkipBorrow
.10da	ca		dex				dex
.10db					_AllocateSkipBorrow:
.10db	88		dey				dey
.10dc	80 e3		bra $10c1			bra 	_AllocateLoop
.10de					_AllocateExit:
.10de	fa		plx				plx 								; restore address
.10df	68		pla				pla
.10e0	7a		ply				ply 								; restore Y
.10e1	60		rts				rts
.10e2					ClearCheckMemory:
.10e2	a5 2b		lda $2b				lda 	freeMemory+1 				; allocatable memory
.10e4	1a		inc a				inc 	a 							; spacing 2 pages
.10e5	1a		inc a				inc 	a
.10e6	cd 23 06	cmp $0623			cmp 	stringMemory+1 				; problems if hit string memory
.10e9	b0 01		bcs $10ec			bcs  	_CCMError
.10eb	60		rts				rts
.10ec					_CCMError:
.10ec	4c 8e 28	jmp $288e		jmp	ErrorV_memory
.002a					freeMemory:
>002a							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/commands/dim.asm

.10ef					CommandDIM:
.10ef	b1 18		lda ($18),y			lda 	(codePtr),y 				; check identifier follows.
.10f1	29 c0		and #$c0			and 	#$C0
.10f3	c9 40		cmp #$40			cmp 	#$40
.10f5	d0 39		bne $1130			bne 	_CDSyntax
.10f7	20 57 2d	jsr $2d57			jsr 	VARGetInfo 					; get information
.10fa	ad 31 06	lda $0631			lda 	VARType 					; check array.
.10fd	29 02		and #$02			and 	#2
.10ff	f0 2f		beq $1130			beq 	_CDSyntax
.1101	20 09 2d	jsr $2d09			jsr 	VARFind 					; does it already exist
.1104	b0 2d		bcs $1133			bcs 	_CDExists
.1106	20 b5 2c	jsr $2cb5			jsr 	VARCreate 					; create it - returns data ptr in XA
.1109	da		phx				phx 								; save target address
.110a	48		pha				pha
.110b	ad 31 06	lda $0631			lda 	VARType 					; type ID.
.110e	29 01		and #$01			and 	#1 							; 0 = Number, 1 = String.
.1110	20 36 11	jsr $1136			jsr 	CreateArray 				; create array to XA
.1113	84 26		sty $26				sty 	zTemp1 						; save Y
.1115	7a		ply				ply 								; restore target to zTemp0
.1116	84 24		sty $24				sty 	zTemp0
.1118	7a		ply				ply
.1119	84 25		sty $25				sty 	zTemp0+1
.111b	92 24		sta ($24)			sta 	(zTemp0) 					; save new array
.111d	a0 01		ldy #$01			ldy 	#1
.111f	8a		txa				txa
.1120	91 24		sta ($24),y			sta 	(zTemp0),y
.1122	a4 26		ldy $26				ldy 	zTemp1 						; restore zTemp1
.1124	20 77 29	jsr $2977			jsr 	ERRCheckRParen 				; check )
.1127	b1 18		lda ($18),y			lda 	(codePtr),y 				; if a comma, consume and go round again.
.1129	c8		iny				iny
.112a	c9 99		cmp #$99			cmp 	#PR_COMMA
.112c	f0 c1		beq $10ef			beq 	CommandDIM
.112e	88		dey				dey
.112f	60		rts				rts
.1130					_CDSyntax:
.1130	4c 9e 27	jmp $279e		jmp	ErrorV_syntax
.1133					_CDExists:
.1133	4c 66 28	jmp $2866		jmp	ErrorV_redefine
.1136					CreateArray:
.1136	8d 03 05	sta $0503			sta 	CAType						; save type
.1139	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; get array dimension to R0
.113c	b1 18		lda ($18),y			lda 	(codePtr),y 				; does a comma follow, if so, 2 dimensions
.113e	c9 99		cmp #$99			cmp 	#PR_COMMA
.1140	f0 04		beq $1146			beq 	_CATwoDimensions
.1142	20 92 11	jsr $1192			jsr 	CreateSingleArray 			; create a lowest level array (e.g. data)
.1145	60		rts				rts
.1146					_CATwoDimensions:
.1146	a5 09		lda $09				lda 	IFR0+IM1 					; copy outer dimension to CADim1
.1148	8d 05 05	sta $0505			sta 	CADim1+1
.114b	a5 08		lda $08				lda 	IFR0+IM0
.114d	8d 04 05	sta $0504			sta 	CADim1+0
.1150	20 7f 29	jsr $297f			jsr 	ERRCheckComma 				; check comma
.1153	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; calculate size of 2nd dimension.
.1156	5a		phy				phy 								; save Y position
.1157	18		clc				clc 								; allocate the outer array of pointers.
.1158	ae 05 05	ldx $0505			ldx 	CADim1+1
.115b	ad 04 05	lda $0504			lda 	CADim1
.115e	20 d1 11	jsr $11d1			jsr 	CSAAllocate 				; allocate the outer array
.1161	da		phx				phx									; save this address on the stack
.1162	48		pha				pha
.1163	86 29		stx $29				stx 	zTemp2+1					; and in zTemp2
.1165	85 28		sta $28				sta 	zTemp2
.1167					_CACreateSubLoop:
.1167	38		sec				sec
.1168	20 92 11	jsr $1192			jsr 	CreateSingleArray 			; create data array of required size.
.116b	a0 02		ldy #$02			ldy 	#2 							; save two on missing the two byte header.
.116d	91 28		sta ($28),y			sta 	(zTemp2),y
.116f	8a		txa				txa
.1170	c8		iny				iny
.1171	91 28		sta ($28),y			sta 	(zTemp2),y
.1173	18		clc				clc  								; next slot.
.1174	a5 28		lda $28				lda 	zTemp2
.1176	69 02		adc #$02			adc 	#2
.1178	85 28		sta $28				sta 	zTemp2
.117a	90 02		bcc $117e			bcc 	_CACNoCarry
.117c	e6 29		inc $29				inc 	zTemp2+1
.117e					_CACNoCarry:
.117e	ad 04 05	lda $0504			lda 	CADim1 						; use DIM1 as a counter
.1181	d0 03		bne $1186			bne 	_CACNoBorrow
.1183	ce 05 05	dec $0505			dec 	CADim1+1
.1186					_CACNoBorrow:
.1186	ce 04 05	dec $0504			dec 	CADim1
.1189	ad 05 05	lda $0505			lda 	CADim1+1 					; but do one more.
.118c	10 d9		bpl $1167			bpl 	_CACreateSubLoop
.118e	68		pla				pla
.118f	fa		plx				plx
.1190	7a		ply				ply
.1191	60		rts				rts
.1192					CreateSingleArray:
.1192	5a		phy				phy
.1193	38		sec				sec 								; allocate memory block all zeros.
.1194	a5 08		lda $08				lda 	IFR0+IM0
.1196	a6 09		ldx $09				ldx 	IFR0+IM1
.1198	20 d1 11	jsr $11d1			jsr 	CSAAllocate
.119b	ac 03 05	ldy $0503			ldy 	CAType 						; if numbers, we don't need to initialise.
.119e	f0 2f		beq $11cf			beq 	_CSANoInit
.11a0	da		phx				phx 								; save address of new array
.11a1	48		pha				pha
.11a2	85 24		sta $24				sta 	zTemp0 						; address in zTemp0
.11a4	86 25		stx $25				stx 	zTemp0+1
.11a6	a0 01		ldy #$01			ldy 	#1 							; count in YX - cannot be zero.
.11a8	b1 24		lda ($24),y			lda 	(zTemp0),y
.11aa	a8		tay				tay
.11ab	b2 24		lda ($24)			lda 	(zTemp0)
.11ad	aa		tax				tax
.11ae					_CSAEraseString:
.11ae	5a		phy				phy
.11af	a0 05		ldy #$05			ldy 	#5 							; 2 initial + 3 on
.11b1	a9 80		lda #$80			lda 	#$80
.11b3	91 24		sta ($24),y			sta 	(zTemp0),y
.11b5	7a		ply				ply
.11b6	18		clc				clc 								; add 4 to next slot.
.11b7	a5 24		lda $24				lda 	zTemp0
.11b9	69 04		adc #$04			adc 	#4
.11bb	85 24		sta $24				sta 	zTemp0
.11bd	90 02		bcc $11c1			bcc 	_CSAENoCarry
.11bf	e6 25		inc $25				inc 	zTemp0+1
.11c1					_CSAENoCarry:
.11c1	e0 00		cpx #$00			cpx 	#0
.11c3	d0 01		bne $11c6			bne 	_CSANoBorrow
.11c5	88		dey				dey
.11c6					_CSANoBorrow:
.11c6	ca		dex				dex
.11c7	d0 e5		bne $11ae			bne 	_CSAEraseString
.11c9	c0 00		cpy #$00			cpy 	#0
.11cb	d0 e1		bne $11ae			bne 	_CSAEraseString
.11cd	68		pla				pla
.11ce	fa		plx				plx
.11cf					_CSANoInit:
.11cf	7a		ply				ply
.11d0	60		rts				rts
.11d1					CSAAllocate:
.11d1	08		php				php 								; save type flag.
.11d2	1a		inc a				inc 	a 							; add 1 because we store the size of the array block
.11d3	d0 01		bne $11d6			bne 	_CSAANoCarry 				; for A(10) this is 11 elements.
.11d5	e8		inx				inx
.11d6					_CSAANoCarry:
.11d6	e0 20		cpx #$20			cpx 	#$20 						; basic range check
.11d8	b0 2e		bcs $1208			bcs 	_CSARange
.11da	28		plp				plp 								; restore type flag
.11db	08		php				php 								; save it back again.
.11dc	da		phx				phx 								; save size.
.11dd	48		pha				pha
.11de	86 25		stx $25				stx  	zTemp0+1 					; now in ztemp0+1:X
.11e0	90 03		bcc $11e5			bcc 	_CSAATimes2 				; if flag on entry clear multiply by 2, otherwise by 4.
.11e2	0a		asl a				asl 	a
.11e3	26 25		rol $25				rol 	zTemp0+1
.11e5					_CSAATimes2:
.11e5	0a		asl a				asl 	a
.11e6	26 25		rol $25				rol 	zTemp0+1
.11e8	18		clc				clc
.11e9	69 02		adc #$02			adc 	#2 							; add 2 bytes for size.
.11eb	90 02		bcc $11ef			bcc 	_CSAANoCarry2
.11ed	e6 25		inc $25				inc 	zTemp0+1
.11ef					_CSAANoCarry2:
.11ef	a6 25		ldx $25				ldx 	zTemp0+1 					; XA is the bytes required.
.11f1	20 b9 10	jsr $10b9			jsr 	AllocateMemory 				; allocate memory to XA
.11f4	86 25		stx $25				stx 	zTemp0+1 					; save pointers
.11f6	85 24		sta $24				sta 	zTemp0
.11f8	68		pla				pla  								; write element count to first 2 bytes
.11f9	92 24		sta ($24)			sta 	(zTemp0)
.11fb	68		pla				pla 								; msb of element count
.11fc	28		plp				plp 								; CC if pointer array
.11fd	b0 02		bcs $1201			bcs 	_CSAAIsData
.11ff	09 80		ora #$80			ora 	#$80 						; set bit 7 of MSB indicating has sub arrays.
.1201					_CSAAIsData:
.1201	a0 01		ldy #$01			ldy 	#1
.1203	91 24		sta ($24),y			sta 	(zTemp0),y
.1205	a5 24		lda $24				lda 	zTemp0 						; fix XA back up again
.1207	60		rts				rts
.1208					_CSARange:
.1208	4c af 27	jmp $27af		jmp	ErrorV_range
.0503					CAType:
>0503							.fill 	1
.0504					CADim1:
>0504							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/commands/dokepoke.asm

.120b					Command_Doke:
.120b	38		sec				sec
.120c	80 01		bra $120f			bra 	DPCommon
.120e					Command_Poke:
.120e	18		clc				clc
.120f					DPCommon:
.120f	08		php				php 								; CS if DOKE
.1210	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; address
.1213	a5 08		lda $08				lda 	IFR0+IM0 					; push on stack
.1215	48		pha				pha
.1216	a5 09		lda $09				lda 	IFR0+IM1
.1218	48		pha				pha
.1219	20 7f 29	jsr $297f			jsr 	ERRCheckComma 				; [dp]oke address,data
.121c	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16
.121f	68		pla				pla 								; get address back
.1220	85 25		sta $25				sta 	zTemp0+1
.1222	68		pla				pla
.1223	85 24		sta $24				sta 	zTemp0
.1225	a5 08		lda $08				lda 	IFR0+IM0 					; write out LSB (e.g. POKE)
.1227	92 24		sta ($24)			sta 	(zTemp0)
.1229	28		plp				plp 								; done if CC
.122a	90 08		bcc $1234			bcc 	_DPExit
.122c	5a		phy				phy 								; else write out MSB (e.g. DOKE)
.122d	a5 09		lda $09				lda 	IFR0+IM1
.122f	a0 01		ldy #$01			ldy 	#1
.1231	91 24		sta ($24),y			sta 	(zTemp0),y
.1233	7a		ply				ply
.1234					_DPExit:
.1234	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/goto.asm

.1235					Command_GOTO:
.1235	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; get line number
.1238					GotoR0:
.1238	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; back to the program start
.123b	85 19		sta $19				sta 	codePtr+1
.123d	64 18		stz $18				stz 	codePtr
.123f					_GOSearch:
.123f	b2 18		lda ($18)			lda 	(codePtr) 					; end of program.
.1241	f0 1f		beq $1262			beq 	_GOError
.1243	a0 01		ldy #$01			ldy 	#1 							; found line #
.1245	b1 18		lda ($18),y			lda 	(codePtr),y
.1247	c5 08		cmp $08				cmp 	IFR0+IM0
.1249	d0 0a		bne $1255			bne 	_GONext
.124b	c8		iny				iny
.124c	b1 18		lda ($18),y			lda 	(codePtr),y
.124e	c5 09		cmp $09				cmp 	IFR0+IM1
.1250	d0 03		bne $1255			bne 	_GONext
.1252	4c 7b 15	jmp $157b			jmp 	RUNNewLine
.1255					_GONext:
.1255	18		clc				clc 								; advance to next line.
.1256	b2 18		lda ($18)			lda 	(codePtr)
.1258	65 18		adc $18				adc 	codePtr
.125a	85 18		sta $18				sta 	codePtr
.125c	90 e1		bcc $123f			bcc 	_GOSearch
.125e	e6 19		inc $19				inc 	codePtr+1
.1260	80 dd		bra $123f			bra 	_GOSearch
.1262					_GOError:
.1262	4c 33 29	jmp $2933		jmp	ErrorV_line

;******  Return to file: include.files


;******  Processing file: src/commands/inputprint.asm

.1265					Command_Input:
.1265	a9 ff		lda #$ff			lda 	#$FF
.1267	8d 06 05	sta $0506			sta 	InputFlag
.126a	80 03		bra $126f			bra 	Command_IP_Main
.126c					Command_Print:
.126c	9c 06 05	stz $0506			stz 	InputFlag
.126f					Command_IP_Main:
.126f	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.1270					_CPLoop:
.1270	08		php				php 								; save last action flag
.1271	b1 18		lda ($18),y			lda 	(codePtr),y 				; get next character
.1273	c9 8c		cmp #$8c			cmp  	#PR_LSQLSQENDRSQRSQ 		; end of line or colon, exit now.
.1275	f0 48		beq $12bf			beq 	_CPExit 					; without consuming
.1277	c9 9b		cmp #$9b			cmp 	#PR_COLON
.1279	f0 44		beq $12bf			beq 	_CPExit
.127b	68		pla				pla 								; throw last action flag
.127c	b1 18		lda ($18),y			lda 	(codePtr),y 				; next character and bump
.127e	c8		iny				iny
.127f	c9 9a		cmp #$9a			cmp 	#PR_SEMICOLON				; is it a semicolon
.1281	f0 39		beq $12bc			beq 	_CPContinueWithSameLine
.1283	c9 99		cmp #$99			cmp 	#PR_COMMA 					; comma
.1285	f0 30		beq $12b7			beq 	_CPTab
.1287	88		dey				dey 								; undo the get.
.1288	2c 06 05	bit $0506			bit 	InputFlag 					; check for Input
.128b	10 0b		bpl $1298			bpl	 	_CPNotInput
.128d	29 c0		and #$c0			and 	#$C0 						; check 40-7F e.g. an identifier.
.128f	c9 40		cmp #$40			cmp 	#$40
.1291	d0 05		bne $1298			bne 	_CPNotInput
.1293	20 c8 12	jsr $12c8			jsr 	_CPInputCode 				; input code
.1296	80 d7		bra $126f			bra 	Command_IP_Main 			; and go round again.
.1298					_CPNotInput:
.1298	20 6f 17	jsr $176f			jsr 	EXPEvaluateExpression 		; evaluate expression.
.129b	24 0b		bit $0b				bit 	IFR0+IExp 					; is it a number ?
.129d	10 0e		bpl $12ad			bpl 	_CPNumber
.129f	5a		phy				phy
.12a0	18		clc				clc 								; string address to YX
.12a1	a5 08		lda $08				lda 	IFR0+IM0
.12a3	aa		tax				tax
.12a4	a5 09		lda $09				lda 	IFR0+IM1
.12a6	a8		tay				tay
.12a7	20 fc 12	jsr $12fc			jsr 	CPPrintYX 					; print YX
.12aa	7a		ply				ply
.12ab	80 c2		bra $126f			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.12ad					_CPNumber:
.12ad	5a		phy				phy
.12ae	20 11 32	jsr $3211			jsr 	IFloatFloatToStringR0 		; convert to string at YX
.12b1	20 fc 12	jsr $12fc			jsr 	CPPrintYX 					; print string at YX
.12b4	7a		ply				ply
.12b5	80 b8		bra $126f			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.12b7					_CPTab:
.12b7	a9 09		lda #$09			lda 	#9 							; print TAB
.12b9	20 14 13	jsr $1314			jsr 	CPPrintA
.12bc					_CPContinueWithSameLine:
.12bc	38		sec				sec 								; loop round with carry set, which
.12bd	80 b1		bra $1270			bra 	_CPLoop 					; will inhibit final CR
.12bf					_CPExit:
.12bf	28		plp				plp 								; get last action flag
.12c0	b0 05		bcs $12c7			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.12c2	a9 0d		lda #$0d			lda 	#13 						; print new line
.12c4	20 14 13	jsr $1314			jsr 	CPPrintA
.12c7					_CPExit2:
.12c7	60		rts				rts
.12c8					_CPInputCode:
.12c8	20 37 18	jsr $1837			jsr 	EXPTermR0 					; get the term.
.12cb	5a		phy				phy 								; save position
.12cc	20 11 13	jsr $1311			jsr 	CPInputA					; input a line to YX
.12cf	a5 0b		lda $0b				lda 	IFR0+IExp 					; string ?
.12d1	30 18		bmi $12eb			bmi 	_CPInputString
.12d3	a5 08		lda $08				lda 	IFR0+IM0 					; push target address on stack
.12d5	48		pha				pha
.12d6	a5 09		lda $09				lda 	IFR0+IM1
.12d8	48		pha				pha
.12d9	86 24		stx $24				stx 	zTemp0 						; use VAL Code to convert.
.12db	84 25		sty $25				sty 	zTemp0+1
.12dd	20 21 1b	jsr $1b21			jsr 	VALConversionZTemp0
.12e0	68		pla				pla 								; do the assign.
.12e1	85 25		sta $25				sta 	zTemp0+1
.12e3	68		pla				pla
.12e4	85 24		sta $24				sta 	zTemp0
.12e6	20 3c 13	jsr $133c			jsr 	AssignNumber
.12e9	7a		ply				ply
.12ea	60		rts				rts
.12eb					_CPInputString:
.12eb	a5 08		lda $08				lda 	IFR0+IM0 					; copy target address to zTemp0
.12ed	85 24		sta $24				sta 	zTemp0
.12ef	a5 09		lda $09				lda 	IFR0+IM1
.12f1	85 25		sta $25				sta 	zTemp0+1
.12f3	86 08		stx $08				stx 	IFR0+IM0 					; string YX in result register
.12f5	84 09		sty $09				sty 	IFR0+IM1
.12f7	20 53 13	jsr $1353			jsr 	AssignString 				; assign the string
.12fa	7a		ply				ply 								; exit
.12fb	60		rts				rts
.12fc					CPPrintYX:
.12fc	86 24		stx $24				stx 	zTemp0
.12fe	84 25		sty $25				sty 	zTemp0+1
.1300	b2 24		lda ($24)			lda 	(zTemp0)
.1302	aa		tax				tax
.1303	f0 0b		beq $1310			beq 	_CPPrintExit
.1305	a0 01		ldy #$01			ldy 	#1
.1307					_CPPrintAYXLoop:
.1307	b1 24		lda ($24),y			lda 	(zTemp0),y
.1309	20 14 13	jsr $1314			jsr 	CPPrintA
.130c	c8		iny				iny
.130d	ca		dex				dex
.130e	d0 f7		bne $1307			bne 	_CPPrintAYXLoop
.1310					_CPPrintExit:
.1310	60		rts				rts
.1311					CPInputA:
.1311	4c e2 ff	jmp $ffe2			jmp 	OSEnterLine
.1314					CPPrintA:
.1314	4c f7 ff	jmp $fff7			jmp 	OSWriteScreen
.0506					InputFlag:
>0506							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/commands/let.asm

.1317					CommandLET:
.1317	20 37 18	jsr $1837			jsr 	EXPTermR0 					; get term
.131a	90 6f		bcc $138b			bcc 	CLError 					; must be a reference term.
.131c	a5 08		lda $08				lda 	IFR0+IM0 					; push address and type onto stack
.131e	48		pha				pha
.131f	a5 09		lda $09				lda 	IFR0+IM1
.1321	48		pha				pha
.1322	a5 0b		lda $0b				lda 	IFR0+IExp
.1324	48		pha				pha
.1325	a9 ef		lda #$ef			lda 	#PR_EQUAL 					; equals for syntax
.1327	20 87 29	jsr $2987			jsr 	ERRCheckA
.132a	20 6f 17	jsr $176f			jsr 	EXPEvaluateExpression 		; right hand side.
.132d	68		pla				pla 								; type of l-expr
.132e	45 0b		eor $0b				eor 	IFR0+IExp 					; check types match
.1330	30 5c		bmi $138e			bmi 	CLType
.1332	fa		plx				plx 	 							; pop target address to zTemp0
.1333	86 25		stx $25				stx 	zTemp0+1
.1335	fa		plx				plx
.1336	86 24		stx $24				stx 	zTemp0
.1338					AssignData:
.1338	a5 0b		lda $0b				lda 	IFR0+IExp 					; string assignment
.133a	30 17		bmi $1353			bmi 	AssignString
.133c					AssignNumber:
.133c	5a		phy				phy
.133d	a0 03		ldy #$03			ldy 	#3
.133f	a5 0b		lda $0b				lda 	IFR0+IExp
.1341	91 24		sta ($24),y			sta 	(zTemp0),y
.1343	88		dey				dey
.1344	a5 0a		lda $0a				lda 	IFR0+IM2
.1346	91 24		sta ($24),y			sta 	(zTemp0),y
.1348	88		dey				dey
.1349	a5 09		lda $09				lda 	IFR0+IM1
.134b	91 24		sta ($24),y			sta 	(zTemp0),y
.134d	a5 08		lda $08				lda 	IFR0+IM0
.134f	92 24		sta ($24)			sta 	(zTemp0)
.1351	7a		ply				ply
.1352	60		rts				rts
.1353					AssignString:
.1353	5a		phy				phy
.1354	a0 01		ldy #$01			ldy 	#1 							; check if any concreted string.
.1356	b1 24		lda ($24),y			lda 	(zTemp0),y
.1358	12 24		ora ($24)			ora 	(zTemp0)
.135a	f0 23		beq $137f			beq 	_CLConcreteString
.135c	b2 24		lda ($24)			lda 	(zTemp0) 					; copy address of string to zTemp1
.135e	85 26		sta $26				sta 	zTemp1
.1360	b1 24		lda ($24),y			lda 	(zTemp0),y
.1362	85 27		sta $27				sta 	zTemp1+1
.1364	b2 26		lda ($26)			lda 	(zTemp1) 					; bytes available in the new slot
.1366	38		sec				sec 								; we want 3 for slot size, status, string size.
.1367	e9 03		sbc #$03			sbc 	#3
.1369	d2 08		cmp ($08)			cmp 	(IFR0) 						; compare against string size.
.136b	90 12		bcc $137f			bcc 	_CLConcreteString 			; if so, concrete the string again.
.136d	b2 08		lda ($08)			lda 	(IFR0) 						; copy size + 1 bytes (for the length byte.)
.136f	1a		inc a				inc 	a
.1370	aa		tax				tax
.1371	a0 00		ldy #$00			ldy 	#0 							; offset in replacement string.
.1373					_CLReplaceString:
.1373	b1 08		lda ($08),y			lda 	(IFR0),y 					; copy new string into previous space.
.1375	c8		iny				iny
.1376	c8		iny				iny
.1377	91 26		sta ($26),y			sta 	(zTemp1),y
.1379	88		dey				dey
.137a	ca		dex				dex
.137b	d0 f6		bne $1373			bne 	_CLReplaceString
.137d	80 0a		bra $1389			bra 	_CLExit
.137f					_CLConcreteString:
.137f	20 f9 29	jsr $29f9			jsr 	StringConcrete  			; concreted string in XA.
.1382	a0 01		ldy #$01			ldy 	#1 							; store the address
.1384	92 24		sta ($24)			sta 	(zTemp0)
.1386	8a		txa				txa
.1387	91 24		sta ($24),y			sta 	(zTemp0),y
.1389					_CLExit:
.1389	7a		ply				ply
.138a	60		rts				rts
.138b					CLError:
.138b	4c d1 28	jmp $28d1		jmp	ErrorV_variable
.138e					CLType:
.138e	4c ce 27	jmp $27ce		jmp	ErrorV_type

;******  Return to file: include.files


;******  Processing file: src/commands/list.asm

.1391					Command_LIST:
.1391	9c 07 05	stz $0507			stz 	CLFrom 						; default from
.1394	9c 08 05	stz $0508			stz 	CLFrom+1
.1397	b1 18		lda ($18),y			lda 	(codePtr),y 				; is there a to line (e.g. LIST ,xxx)
.1399	c9 99		cmp #$99			cmp 	#PR_COMMA
.139b	f0 1d		beq $13ba			beq 	_CLToLine
.139d	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; EOL, default TO
.139f	f0 37		beq $13d8			beq 	_CLDefaultTo
.13a1	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; from value *and* to value now.
.13a4	a5 08		lda $08				lda 	IFR0+IM0
.13a6	8d 07 05	sta $0507			sta 	CLFrom
.13a9	8d 09 05	sta $0509			sta 	CLTo
.13ac	a5 09		lda $09				lda 	IFR0+IM1
.13ae	8d 08 05	sta $0508			sta 	CLFrom+1
.13b1	8d 0a 05	sta $050a			sta 	CLTo+1
.13b4	b1 18		lda ($18),y			lda 	(codePtr),y
.13b6	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; that's the lot ?
.13b8	f0 26		beq $13e0			beq 	_CLList
.13ba					_CLToLine:
.13ba	b1 18		lda ($18),y			lda 	(codePtr),y 				; what follows.
.13bc	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; EOL, default TO
.13be	f0 18		beq $13d8			beq 	_CLDefaultTo
.13c0	20 7f 29	jsr $297f			jsr 	ERRCheckComma 				; sep comma
.13c3	b1 18		lda ($18),y			lda 	(codePtr),y 				; if it is just LIST , then default TO
.13c5	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ
.13c7	f0 0f		beq $13d8			beq 	_CLDefaultTo
.13c9	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; there's a To value.
.13cc	a5 08		lda $08				lda 	IFR0+IM0
.13ce	8d 09 05	sta $0509			sta 	CLTo
.13d1	a5 09		lda $09				lda 	IFR0+IM1
.13d3	8d 0a 05	sta $050a			sta 	CLTo+1
.13d6	80 08		bra $13e0			bra 	_CLList
.13d8					_CLDefaultTo:
.13d8	a9 ff		lda #$ff			lda 	#$FF
.13da	8d 09 05	sta $0509			sta 	CLTo
.13dd	8d 0a 05	sta $050a			sta 	CLTo+1
.13e0					_CLList:
.13e0	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; back to the program start
.13e3	85 19		sta $19				sta 	codePtr+1
.13e5	64 18		stz $18				stz 	codePtr
.13e7	a2 f7		ldx #$f7			ldx 	#OSWriteScreen & $FF 		; tokenise output to screen.
.13e9	a0 ff		ldy #$ff			ldy 	#OSWriteScreen >> 8
.13eb	20 b3 1f	jsr $1fb3			jsr 	TOKSetDetokeniseOutput
.13ee					_CLLoop:
.13ee	b2 18		lda ($18)			lda 	(codePtr) 					; finished
.13f0	f0 51		beq $1443			beq 	_CLExit
.13f2	20 e8 ff	jsr $ffe8			jsr 	OSKeyboardDataProcess
.13f5	20 eb ff	jsr $ffeb			jsr 	OSCheckBreak 				; check escape.
.13f8	d0 4c		bne $1446			bne 	_CLBreak
.13fa	a2 00		ldx #$00			ldx 	#CLFrom-CLFrom 				; compare line number vs from
.13fc	20 49 14	jsr $1449			jsr 	_CLCompareLine
.13ff	c9 ff		cmp #$ff			cmp 	#255 						; < from then skip
.1401	f0 33		beq $1436			beq 	_CLNext
.1403	a2 02		ldx #$02			ldx 	#CLTo-CLFrom   				; compare line number vs IFR0
.1405	20 49 14	jsr $1449			jsr 	_CLCompareLine
.1408	c9 01		cmp #$01			cmp 	#1 							; > to then skip
.140a	f0 2a		beq $1436			beq 	_CLNext
.140c	a0 02		ldy #$02			ldy 	#2 							; print line #
.140e	b1 18		lda ($18),y			lda 	(codePtr),y
.1410	aa		tax				tax
.1411	88		dey				dey
.1412	b1 18		lda ($18),y			lda 	(codePtr),y
.1414	20 ce 2b	jsr $2bce			jsr 	WriteIntXA
.1417					_CLSpacing:
.1417	a9 20		lda #$20			lda 	#32
.1419	20 f7 ff	jsr $fff7			jsr 	OSWriteScreen
.141c	20 d9 ff	jsr $ffd9			jsr 	OSGetScreenPosition
.141f	e0 06		cpx #$06			cpx 	#6
.1421	d0 f4		bne $1417			bne 	_CLSpacing
.1423	a4 19		ldy $19				ldy 	codePtr+1 					; point YX to tokenised code/
.1425	a5 18		lda $18				lda 	codePtr
.1427	18		clc				clc
.1428	69 03		adc #$03			adc 	#3
.142a	aa		tax				tax
.142b	90 01		bcc $142e			bcc 	_CLNoCarry2
.142d	c8		iny				iny
.142e					_CLNoCarry2:
.142e	20 58 1f	jsr $1f58			jsr 	TOKDetokenise
.1431	a9 0d		lda #$0d			lda 	#13	 						; next line
.1433	20 f7 ff	jsr $fff7			jsr 	OSWriteScreen
.1436					_CLNext:
.1436	18		clc				clc 								; advance to next line.
.1437	b2 18		lda ($18)			lda 	(codePtr)
.1439	65 18		adc $18				adc 	codePtr
.143b	85 18		sta $18				sta 	codePtr
.143d	90 02		bcc $1441			bcc 	_CLNoCarry
.143f	e6 19		inc $19				inc 	codePtr+1
.1441					_CLNoCarry:
.1441	80 ab		bra $13ee			bra 	_CLLoop
.1443					_CLExit:
.1443	4c ed 2b	jmp $2bed			jmp 	WarmStart
.1446					_CLBreak:
.1446	4c 29 29	jmp $2929		jmp	ErrorV_break
.1449					_CLCompareLine:
.1449	a0 01		ldy #$01			ldy 	#1
.144b	38		sec				sec
.144c	b1 18		lda ($18),y			lda 	(codePtr),y
.144e	fd 07 05	sbc $0507,x			sbc 	CLFrom,x
.1451	85 24		sta $24				sta 	zTemp0
.1453	c8		iny				iny
.1454	b1 18		lda ($18),y			lda 	(codePtr),y
.1456	fd 08 05	sbc $0508,x			sbc 	CLFrom+1,x
.1459	90 0a		bcc $1465			bcc 	_CLIsNegative
.145b	d0 05		bne $1462			bne 	_CLIsPositive
.145d	a5 24		lda $24				lda 	zTemp0
.145f	d0 01		bne $1462			bne 	_CLIsPositive
.1461	60		rts				rts
.1462					_CLIsPositive:
.1462	a9 01		lda #$01			lda 	#1
.1464	60		rts				rts
.1465					_CLIsNegative:
.1465	a9 ff		lda #$ff			lda 	#255
.1467	60		rts				rts
.0507					CLFrom:
>0507							.fill 	2
.0509					CLTo:
>0509							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/commands/new.asm

.1468					Command_NEW:
.1468	20 61 21	jsr $2161			jsr 	PGMNewProgram 				; Reset current program
.146b	20 9c 10	jsr $109c			jsr 	ClearCode 					; Run CLR
.146e	4c d4 15	jmp $15d4			jmp 	Command_END 				; Run END

;******  Return to file: include.files


;******  Processing file: src/commands/readdata.asm

.1471					Command_READ:
.1471	20 37 18	jsr $1837			jsr 	EXPTermR0 					; get term to R0
.1474	90 35		bcc $14ab			bcc 	_CRSyntax 					; fail if not a reference.
.1476	a5 08		lda $08				lda 	IFR0+IM0 					; push address on the stack
.1478	48		pha				pha
.1479	a5 09		lda $09				lda 	IFR0+IM1
.147b	48		pha				pha
.147c	a5 0b		lda $0b				lda 	IFR0+IExp 					; push type on the stack
.147e	48		pha				pha
.147f	20 48 15	jsr $1548			jsr 	SwapCodeDataPointers 		; swap code and data pointers over
.1482	ad 0f 05	lda $050f			lda 	dataInStatement 			; if in a data statement, we don't need to search
.1485	d0 27		bne $14ae			bne 	_CRHaveData  				; forward for the next one.
.1487					_CRNextLine:
.1487	b2 18		lda ($18)			lda 	(codePtr)					; check end of program, e.g. nothing more to READ.
.1489	f0 1a		beq $14a5			beq 	_CRNoData
.148b					_CRKeepSearching:
.148b	a9 a1		lda #$a1			lda 	#PR_DATA 					; scan for instruction DATA or EOL.
.148d	a2 8c		ldx #$8c			ldx 	#PR_LSQLSQENDRSQRSQ
.148f	20 ae 26	jsr $26ae			jsr 	ScanForward
.1492	c9 a1		cmp #$a1			cmp 	#PR_DATA 					; found data ?
.1494	f0 18		beq $14ae			beq 	_CRHaveData 				; found it
.1496	a0 03		ldy #$03			ldy 	#3 							; position in next line.
.1498	18		clc				clc 								; try the next line, keep going.
.1499	b2 18		lda ($18)			lda 	(codePtr)
.149b	65 18		adc $18				adc 	codePtr
.149d	85 18		sta $18				sta 	codePtr
.149f	90 e6		bcc $1487			bcc 	_CRNextLine
.14a1	e6 19		inc $19				inc 	codePtr+1
.14a3	80 e2		bra $1487			bra 	_CRNextLine
.14a5					_CRNoData:
.14a5	4c 56 28	jmp $2856		jmp	ErrorV_data
.14a8					_CLType:
.14a8	4c ce 27	jmp $27ce		jmp	ErrorV_type
.14ab					_CRSyntax:
.14ab	4c 9e 27	jmp $279e		jmp	ErrorV_syntax
.14ae					_CRHaveData:
.14ae	20 6f 17	jsr $176f			jsr 	EXPEvaluateExpression 		; some sort of value here -> R0
.14b1	68		pla				pla 								; type of l-expr
.14b2	45 0b		eor $0b				eor 	IFR0+IExp 					; check types match
.14b4	30 f2		bmi $14a8			bmi 	_CLType
.14b6	68		pla				pla 								; restore address
.14b7	85 25		sta $25				sta 	zTemp0+1
.14b9	68		pla				pla
.14ba	85 24		sta $24				sta 	zTemp0
.14bc	20 38 13	jsr $1338			jsr 	AssignData 					; write R0 there.
.14bf	9c 0f 05	stz $050f			stz 	dataInStatement 			; clear in data flag
.14c2	b1 18		lda ($18),y			lda 	(codePtr),y 				; data followed by a comma,e.g. more data follows
.14c4	c9 99		cmp #$99			cmp 	#PR_COMMA 					; if not, end of data statement and exit
.14c6	d0 04		bne $14cc			bne 	_CRSwapBack
.14c8	c8		iny				iny 								; consume comma
.14c9	ee 0f 05	inc $050f			inc 	dataInStatement 			; set in data statement flag.
.14cc					_CRSwapBack:
.14cc	20 48 15	jsr $1548			jsr 	SwapCodeDataPointers		; swap them back.
.14cf	b1 18		lda ($18),y			lda 	(codePtr),y 				; l-expr was followed by a comma
.14d1	c8		iny				iny
.14d2	c9 99		cmp #$99			cmp 	#PR_COMMA
.14d4	f0 9b		beq $1471			beq 	Command_READ 				; if so go round again.
.14d6	88		dey				dey 								; unpick get.
.14d7	60		rts				rts
.14d8					Command_DATA:
.14d8	a9 9b		lda #$9b			lda 	#PR_COLON 					; scan forward to : or EOL
.14da	a2 8c		ldx #$8c			ldx 	#PR_LSQLSQENDRSQRSQ
.14dc	20 ae 26	jsr $26ae			jsr 	ScanForward
.14df	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; unconsume the EOL
.14e1	d0 01		bne $14e4			bne 	_CDNotEOL
.14e3	88		dey				dey
.14e4					_CDNotEOL:
.14e4	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/rem.asm

.14e5					Command_REM:
.14e5					Command_REM2:
.14e5	b1 18		lda ($18),y			lda 	(codePtr),y 				; optional string parameter
.14e7	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ
.14e9	d0 06		bne $14f1			bne 	_CRExit
.14eb	c8		iny				iny 								; skip over it, it's a comment.
.14ec	98		tya				tya
.14ed	38		sec				sec
.14ee	71 18		adc ($18),y			adc 	(codePtr),y
.14f0	a8		tay				tay
.14f1					_CRExit:
.14f1	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/renumber.asm

.14f2					Command_RENUMBER:
.14f2	a9 e8		lda #$e8			lda 	#1000 & $FF 				; default REN star
.14f4	85 08		sta $08				sta 	IM0+IFR0
.14f6	a9 03		lda #$03			lda 	#1000 >> 8
.14f8	85 09		sta $09				sta 	IM1+IFR0
.14fa	b1 18		lda ($18),y			lda 	(codePtr),y 				; what follows.
.14fc	c9 9b		cmp #$9b			cmp 	#PR_COLON
.14fe	f0 07		beq $1507			beq 	_CRIsDefault
.1500	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ
.1502	f0 03		beq $1507			beq 	_CRIsDefault
.1504	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; get other start
.1507					_CRIsDefault:
.1507	5a		phy				phy
.1508	64 24		stz $24				stz 	zTemp0						; copy base address to zTemp0
.150a	ad 1a 05	lda $051a			lda 	PGMBaseHigh
.150d	85 25		sta $25				sta 	zTemp0+1
.150f					_CRRenumberLoop:
.150f	b2 24		lda ($24)			lda 	(zTemp0)					; check end
.1511	f0 21		beq $1534			beq 	_CRExit
.1513	18		clc				clc
.1514	a0 01		ldy #$01			ldy 	#1 							; copy line # in bumping as you go.
.1516	a5 08		lda $08				lda 	IFR0+IM0
.1518	91 24		sta ($24),y			sta 	(zTemp0),y
.151a	69 0a		adc #$0a			adc 	#10
.151c	85 08		sta $08				sta 	IFR0+IM0
.151e	c8		iny				iny
.151f	a5 09		lda $09				lda 	IFR0+IM1
.1521	91 24		sta ($24),y			sta 	(zTemp0),y
.1523	69 00		adc #$00			adc 	#0
.1525	85 09		sta $09				sta 	IFR0+IM1
.1527	18		clc				clc 								; next line.
.1528	b2 24		lda ($24)			lda 	(zTemp0)
.152a	65 24		adc $24				adc 	zTemp0
.152c	85 24		sta $24				sta 	zTemp0
.152e	90 df		bcc $150f			bcc 	_CRRenumberLoop
.1530	e6 25		inc $25				inc 	zTemp0+1
.1532	80 db		bra $150f			bra 	_CRRenumberLoop
.1534					_CRExit:
.1534	7a		ply				ply
.1535	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/restore.asm

.1536					S
.1536					Command_RESTORE:
.1536	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; back to the program start
.1539	8d 0c 05	sta $050c			sta 	dataPtr+1
.153c	9c 0b 05	stz $050b			stz 	dataPtr
.153f	a9 03		lda #$03			lda 	#3 							; position start of line
.1541	8d 0d 05	sta $050d			sta 	dataPos
.1544	9c 0f 05	stz $050f			stz 	dataInStatement 			; not in statement
.1547	60		rts				rts
.1548					SwapCodeDataPointers:
.1548	ad 0b 05	lda $050b			lda 	dataPtr 					; swap LSB of code/data
.154b	a6 18		ldx $18				ldx 	codePtr
.154d	85 18		sta $18				sta 	codePtr
.154f	8e 0b 05	stx $050b			stx 	dataPtr
.1552	ad 0c 05	lda $050c			lda 	dataPtr+1 					; swap MSB of code/data
.1555	a6 19		ldx $19				ldx 	codePtr+1
.1557	85 19		sta $19				sta 	codePtr+1
.1559	8e 0c 05	stx $050c			stx 	dataPtr+1
.155c	ad 0d 05	lda $050d			lda 	dataPos 					; swap dataPos and Y
.155f	8c 0d 05	sty $050d			sty 	dataPos
.1562	a8		tay				tay
.1563	60		rts				rts
.050b					dataPtr:
>050b							.fill 	2
.050d					dataPos:
>050d							.fill 	2
.050f					dataInStatement:
>050f							.fill 	1		 					; (should be pointing at , : or EOL)

;******  Return to file: include.files


;******  Processing file: src/commands/run.asm

.1564					Command_RUN:
.1564	20 9c 10	jsr $109c			jsr 	ClearCode					; clear everything out.
.1567	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; back to the program start
.156a	85 19		sta $19				sta 	codePtr+1
.156c	64 18		stz $18				stz 	codePtr
.156e	80 0b		bra $157b			bra 	RUNNewLine
.1570					RUNEndOfLine:
.1570	18		clc				clc 								; advance to next line.
.1571	b2 18		lda ($18)			lda 	(codePtr)
.1573	65 18		adc $18				adc 	codePtr
.1575	85 18		sta $18				sta 	codePtr
.1577	90 02		bcc $157b			bcc 	_RELNoCarry
.1579	e6 19		inc $19				inc 	codePtr+1
.157b					_RELNoCarry:
.157b					RUNNewLine:
.157b	a2 ff		ldx #$ff			ldx 	#$FF 						; 6502 stack reset.
.157d	9a		txs				txs
.157e	b2 18		lda ($18)			lda 	(codePtr) 					; check off end of program
.1580	f0 52		beq $15d4			beq 	Command_END
.1582	a0 01		ldy #$01			ldy 	#1 							; copy error line#
.1584	b1 18		lda ($18),y			lda 	(codePtr),y
.1586	8d 2c 06	sta $062c			sta 	ERRLine
.1589	c8		iny				iny
.158a	b1 18		lda ($18),y			lda 	(codePtr),y
.158c	8d 2d 06	sta $062d			sta 	ERRLine+1
.158f	c8		iny				iny 								; offset into codePtr for start of line.
.1590					RUNNewCommand:
.1590	9c 21 06	stz $0621			stz 	stringInitialised 			; reset string system.
.1593	ce 10 05	dec $0510			dec 	checkCounter
.1596	d0 0a		bne $15a2			bne 	_RNCNoCheck
.1598	5a		phy				phy 								; keyboard check.
.1599	20 e8 ff	jsr $ffe8			jsr 	OSKeyboardDataProcess
.159c	7a		ply				ply
.159d	20 eb ff	jsr $ffeb			jsr 	OSCheckBreak 				; check escape.
.15a0	d0 1e		bne $15c0			bne 	_RUNBreak
.15a2					_RNCNoCheck:
.15a2	b1 18		lda ($18),y			lda 	(codePtr),y 				; get next token
.15a4	10 1d		bpl $15c3			bpl		_RUNNotToken 				; probably an identifier
.15a6	c8		iny				iny 								; consume token
.15a7	c9 9b		cmp #$9b			cmp 	#PR_COLON 					; fast skip colon
.15a9	f0 e5		beq $1590			beq 	RUNNewCommand
.15ab	c9 a6		cmp #$a6			cmp 	#PR_STANDARD_LAST+1 		; check unary function
.15ad	b0 0e		bcs $15bd			bcs 	_RUNSyntax
.15af	c9 80		cmp #$80			cmp 	#PR_STRUCTURE_FIRST 		; adjust for binaries at start.
.15b1	90 0a		bcc $15bd			bcc 	_RUNSyntax
.15b3	0a		asl a				asl 	a 							; double into X.
.15b4	aa		tax				tax
.15b5	20 ba 15	jsr $15ba			jsr 	_RUNDispatchMain			; call the main dispatcher
.15b8	80 d6		bra $1590			bra 	RUNNewCommand
.15ba					_RUNDispatchMain:
.15ba	7c 36 1e	jmp ($1e36,x)			jmp 	(VectorTable,x)
.15bd					_RUNSyntax:
.15bd	4c 9e 27	jmp $279e		jmp	ErrorV_syntax
.15c0					_RUNBreak:
.15c0	4c 29 29	jmp $2929		jmp	ErrorV_break
.15c3					_RUNNotToken:
.15c3	c9 40		cmp #$40			cmp 	#$40 						; 00-3F is a syntax error
.15c5	90 f6		bcc $15bd			bcc 	_RUNSyntax
.15c7	20 17 13	jsr $1317			jsr 	CommandLET 					; assignment
.15ca	80 c4		bra $1590			bra 	RUNNewCommand 				; loop round.
.15cc					Command_Shift_Handler:
.15cc	b1 18		lda ($18),y			lda 	(codePtr),y 				; get token shifted
.15ce	c8		iny				iny
.15cf	0a		asl a				asl 	a 							; double into X
.15d0	aa		tax				tax
.15d1	7c 36 1f	jmp ($1f36,x)			jmp 	(AlternateVectorTable,x) 	; and go there.
.15d4					Command_END:
.15d4	4c ed 2b	jmp $2bed			jmp 	WarmStart
.0510					checkCounter:
>0510							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/commands/stop.asm

.15d7					Command_STOP:
.15d7	4c 42 28	jmp $2842		jmp	ErrorV_stop

;******  Return to file: include.files


;******  Processing file: src/commands/sys.asm

.15da					Command_Sys:
.15da	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; execution address
.15dd	5a		phy				phy
.15de	ad 74 06	lda $0674			lda 	('A'-'A')*4 + FastVariables ; load AXY
.15e1	ae d0 06	ldx $06d0			ldx 	('X'-'A')*4 + FastVariables
.15e4	ac d4 06	ldy $06d4			ldy 	('Y'-'A')*4 + FastVariables
.15e7	20 ec 15	jsr $15ec			jsr 	_CSCallIFR0 				; call the code
.15ea	7a		ply				ply
.15eb	60		rts				rts
.15ec					_CSCallIFR0:
.15ec	6c 08 00	jmp ($0008)			jmp 	(IFR0+IM0)

;******  Return to file: include.files


;******  Processing file: src/commands/unused.asm

.15ef					NoExec01:
.15ef					NoExec02:
.15ef					NoExec03:
.15ef					NoExec04:
.15ef					NoExec05:
.15ef					NoExec06:
.15ef					NoExec07:
.15ef					NoExec08:
.15ef	4c 9e 27	jmp $279e		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/binary/basic.asm

.15f2					EXPBinAdd:
.15f2	24 0b		bit $0b				bit 	IFR0+IExp 					; check if both are strings (already checked same type).
.15f4	30 6f		bmi $1665			bmi 	EXPConcatenate
.15f6	a2 0c		ldx #$0c			ldx 	#IFR1
.15f8	4c 0c 2e	jmp $2e0c			jmp 	IFloatAdd
.15fb					EXPBinSub:
.15fb	24 0b		bit $0b				bit 	IFR0+IExp 					; check if string, error if so
.15fd	30 3f		bmi $163e			bmi 	EXPTypeError
.15ff	a2 0c		ldx #$0c			ldx 	#IFR1
.1601	4c 05 2e	jmp $2e05			jmp 	IFloatSubtract
.1604					EXPBinMul:
.1604	24 0b		bit $0b				bit 	IFR0+IExp					; check if string, error if so
.1606	30 36		bmi $163e			bmi 	EXPTypeError
.1608	a2 0c		ldx #$0c			ldx 	#IFR1
.160a	4c b6 2e	jmp $2eb6			jmp 	IFloatMultiply
.160d					EXPBinFDiv:
.160d	24 0b		bit $0b				bit 	IFR0+IExp 					; check if string, error if so
.160f	30 2d		bmi $163e			bmi 	EXPTypeError
.1611	a2 0c		ldx #$0c			ldx 	#IFR1
.1613	20 38 31	jsr $3138			jsr 	IFloatDivideFloat
.1616	b0 0f		bcs $1627			bcs 	EXPDZero
.1618	60		rts				rts
.1619					EXPBinIDiv:
.1619	24 0b		bit $0b				bit 	IFR0+IExp 					; check if string, error if so
.161b	30 21		bmi $163e			bmi 	EXPTypeError
.161d	a2 0c		ldx #$0c			ldx 	#IFR1
.161f	20 38 31	jsr $3138			jsr 	IFloatDivideFloat
.1622	b0 03		bcs $1627			bcs 	EXPDZero
.1624	4c 15 31	jmp $3115			jmp 	IFloatIntegerR0
.1627					EXPDZero:
.1627	4c 17 28	jmp $2817		jmp	ErrorV_divzero
.162a					EXPBinIMod:
.162a	24 0b		bit $0b				bit 	IFR0+IExp 					; check if string, error if so
.162c	30 10		bmi $163e			bmi 	EXPTypeError
.162e	a2 0c		ldx #$0c			ldx 	#IFR1
.1630	5a		phy				phy
.1631	20 4b 30	jsr $304b			jsr 	IFPreProcessBitwise 		; set up everything.
.1634	d0 05		bne $163b			bne 	EXPDRange
.1636	20 84 2f	jsr $2f84			jsr 	IFloatModulusInteger
.1639	7a		ply				ply
.163a	60		rts				rts
.163b					EXPDRange:
.163b	4c af 27	jmp $27af		jmp	ErrorV_range
.163e					EXPTypeError:
.163e	4c ce 27	jmp $27ce		jmp	ErrorV_type
.1641					EXPBinAnd:
.1641	24 0b		bit $0b				bit 	IFR0+IExp
.1643	30 f9		bmi $163e			bmi 	EXPTypeError
.1645	a2 0c		ldx #$0c			ldx 	#IFR1
.1647	20 06 30	jsr $3006			jsr 	IFloatBitwiseAnd
.164a	b0 ef		bcs $163b			bcs 	EXPDRange
.164c	60		rts				rts
.164d					EXPBinOr:
.164d	24 0b		bit $0b				bit 	IFR0+IExp
.164f	30 ed		bmi $163e			bmi 	EXPTypeError
.1651	a2 0c		ldx #$0c			ldx 	#IFR1
.1653	20 1d 30	jsr $301d			jsr 	IFloatBitwiseOr
.1656	b0 e3		bcs $163b			bcs 	EXPDRange
.1658	60		rts				rts
.1659					EXPBinXor:
.1659	24 0b		bit $0b				bit 	IFR0+IExp
.165b	30 e1		bmi $163e			bmi 	EXPTypeError
.165d	a2 0c		ldx #$0c			ldx 	#IFR1
.165f	20 34 30	jsr $3034			jsr 	IFloatBitwiseXor
.1662	b0 d7		bcs $163b			bcs 	EXPDRange
.1664	60		rts				rts
.1665					EXPConcatenate:
.1665	18		clc				clc
.1666	b2 08		lda ($08)			lda 	(IFR0) 	 					; work out total length
.1668	72 0c		adc ($0c)			adc 	(IFR1)
.166a	b0 2d		bcs $1699			bcs 	_EXPCError 					; far too long.
.166c	a6 08		ldx $08				ldx 	IFR0 						; push R0 string on stack.
.166e	da		phx				phx
.166f	a6 09		ldx $09				ldx 	IFR0+1
.1671	da		phx				phx
.1672	20 6c 2a	jsr $2a6c			jsr 	StringTempAllocate 			; allocate string, set up return
.1675	a6 0d		ldx $0d				ldx 	IFR1+1 						; copy first string.
.1677	a5 0c		lda $0c				lda 	IFR1
.1679	20 82 16	jsr $1682			jsr 	_EXPCCopyXA
.167c	fa		plx				plx 								; copy second string
.167d	68		pla				pla
.167e	20 82 16	jsr $1682			jsr 	_EXPCCopyXA
.1681	60		rts				rts
.1682					_EXPCCopyXA:
.1682	86 25		stx $25				stx 	zTemp0+1 					; save address to zTemp0
.1684	85 24		sta $24				sta 	zTemp0
.1686	b2 24		lda ($24)			lda 	(zTemp0)					; length of string
.1688	f0 0e		beq $1698			beq 	_EXPCCExit 					; nothing in string
.168a	aa		tax				tax 								; count
.168b	5a		phy				phy 								; start position
.168c	a0 01		ldy #$01			ldy 	#1
.168e					_EXPCCLoop:
.168e	b1 24		lda ($24),y			lda 	(zTemp0),y 					; write characters one at a time.
.1690	20 a1 2a	jsr $2aa1			jsr 	StringTempWrite
.1693	c8		iny				iny
.1694	ca		dex				dex
.1695	d0 f7		bne $168e			bne 	_EXPCCLoop
.1697	7a		ply				ply
.1698					_EXPCCExit:
.1698	60		rts				rts
.1699					_EXPCError:
.1699	4c bb 28	jmp $28bb		jmp	ErrorV_string

;******  Return to file: include.files


;******  Processing file: src/expression/binary/compare.asm

.169c					EXPReturnTrue:
.169c	a2 08		ldx #$08			ldx 	#IFR0
.169e	a9 01		lda #$01			lda 	#1
.16a0	20 16 34	jsr $3416			jsr 	IFloatSetByte
.16a3	20 1f 34	jsr $341f			jsr 	IFloatNegate
.16a6	60		rts				rts
.16a7					EXPReturnFalse:
.16a7	a2 08		ldx #$08			ldx 	#IFR0
.16a9	4c 14 34	jmp $3414			jmp 	IFloatSetZero
.16ac					EXPCompareEqual:
.16ac	20 e2 16	jsr $16e2			jsr 	EXPCompareBaseCode
.16af	c9 00		cmp #$00			cmp 	#0
.16b1	f0 e9		beq $169c			beq 	EXPReturnTrue
.16b3	80 f2		bra $16a7			bra 	EXPReturnFalse
.16b5					EXPCompareLess:
.16b5	20 e2 16	jsr $16e2			jsr 	EXPCompareBaseCode
.16b8	c9 ff		cmp #$ff			cmp 	#$FF
.16ba	f0 e0		beq $169c			beq 	EXPReturnTrue
.16bc	80 e9		bra $16a7			bra 	EXPReturnFalse
.16be					EXPCompareGreater:
.16be	20 e2 16	jsr $16e2			jsr 	EXPCompareBaseCode
.16c1	c9 01		cmp #$01			cmp 	#1
.16c3	f0 d7		beq $169c			beq 	EXPReturnTrue
.16c5	80 e0		bra $16a7			bra 	EXPReturnFalse
.16c7					EXPCompareNotEqual:
.16c7	20 e2 16	jsr $16e2			jsr 	EXPCompareBaseCode
.16ca	c9 00		cmp #$00			cmp 	#0
.16cc	d0 ce		bne $169c			bne 	EXPReturnTrue
.16ce	80 d7		bra $16a7			bra 	EXPReturnFalse
.16d0					EXPCompareLessEqual:
.16d0	20 e2 16	jsr $16e2			jsr 	EXPCompareBaseCode
.16d3	c9 01		cmp #$01			cmp 	#1
.16d5	d0 c5		bne $169c			bne 	EXPReturnTrue
.16d7	80 ce		bra $16a7			bra 	EXPReturnFalse
.16d9					EXPCompareGreaterEqual:
.16d9	20 e2 16	jsr $16e2			jsr 	EXPCompareBaseCode
.16dc	c9 ff		cmp #$ff			cmp 	#$FF
.16de	d0 bc		bne $169c			bne 	EXPReturnTrue
.16e0	80 c5		bra $16a7			bra 	EXPReturnFalse
.16e2					EXPCompareBaseCode:
.16e2	24 0b		bit $0b				bit 	IFR0+IExp 					; string compare ?
.16e4	30 10		bmi $16f6			bmi 	_EXCBCString
.16e6	a2 0c		ldx #$0c			ldx 	#IFR1						; float compare
.16e8	20 e3 30	jsr $30e3			jsr 	IFloatCompare
.16eb	a5 08		lda $08				lda 	IFR0+IM0
.16ed	f0 06		beq $16f5			beq 	_EXCBCExit 					; return 0 if zero
.16ef	24 0b		bit $0b				bit 	IFR0+IExp 					; return 1 if +ve
.16f1	50 02		bvc $16f5			bvc 	_EXCBCExit
.16f3	a9 ff		lda #$ff			lda 	#255 						; return $FF if -ve
.16f5					_EXCBCExit:
.16f5	60		rts				rts
.16f6					_EXCBCString:
.16f6	5a		phy				phy
.16f7	b2 08		lda ($08)			lda 	(IFR0) 						; length of smaller of the two in X.
.16f9	d2 0c		cmp ($0c)			cmp 	(IFR1) 						; check it matches so far normally.
.16fb	90 02		bcc $16ff			bcc 	_EXCBCSmaller
.16fd	b2 0c		lda ($0c)			lda 	(IFR1)
.16ff					_EXCBCSmaller:
.16ff	aa		tax				tax
.1700	f0 0d		beq $170f			beq 	_EXCBCMatches 				; if zero common length matches
.1702	a0 00		ldy #$00			ldy 	#0 							; match the strings.
.1704					_EXCBCCheckSmallerMatches:
.1704	c8		iny				iny 								; compare directly as far as common length
.1705	38		sec				sec
.1706	b1 0c		lda ($0c),y			lda 	(IFR1),y
.1708	f1 08		sbc ($08),y			sbc 	(IFR0),y
.170a	d0 08		bne $1714			bne 	_EXCBCExit2
.170c	ca		dex				dex
.170d	d0 f5		bne $1704			bne 	_EXCBCCheckSmallerMatches
.170f					_EXCBCMatches:
.170f	38		sec				sec
.1710	b2 0c		lda ($0c)			lda 	(IFR1) 						; common length matches. If same length equal
.1712	f2 08		sbc ($08)			sbc 	(IFR0)						; if len(r1) > len(r0) then r1 is longer
.1714					_EXCBCExit2:
.1714	7a		ply				ply
.1715	c9 00		cmp #$00			cmp 	#0 							; 0 equal.
.1717	f0 04		beq $171d			beq 	_EXCBCReturn
.1719	30 03		bmi $171e			bmi 	_EXCBCFF 					; return $FF if <
.171b	a9 01		lda #$01			lda 	#1 							; return 1 if >
.171d					_EXCBCReturn:
.171d	60		rts				rts
.171e					_EXCBCFF:
.171e	a9 ff		lda #$ff			lda 	#$FF
.1720	60		rts				rts
.1721					_EXCBCRange:
.1721	4c af 27	jmp $27af		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/binary/shift.asm

.1724					EXPBinLeft:
.1724	a9 ff		lda #$ff			lda 	#$FF
.1726	8d 11 05	sta $0511			sta 	EXPShiftLeftFlag
.1729	4c 2f 17	jmp $172f			jmp 	EXPShiftCommon
.172c					EXPBinRight:
.172c	9c 11 05	stz $0511			stz 	EXPShiftLeftFlag
.172f					EXPShiftCommon:
.172f	a5 0b		lda $0b				lda 	IFR0+IExp 					; check both integers
.1731	05 0f		ora $0f				ora 	IFR1+IExp
.1733	29 7f		and #$7f			and 	#$7F
.1735	d0 35		bne $176c			bne 	_EXPSRange
.1737	a5 08		lda $08				lda 	IFR0+IM0					; check shift >= 32
.1739	29 e0		and #$e0			and 	#$E0
.173b	05 09		ora $09				ora 	IFR0+IM1
.173d	05 0a		ora $0a				ora 	IFR0+IM2
.173f	d0 25		bne $1766			bne 	_EXPSShiftZero 				; if so return zero as would be shifted out.
.1741	5a		phy				phy
.1742	a5 08		lda $08				lda 	IFR0+IM0 					; get shift
.1744	29 1f		and #$1f			and 	#$1F
.1746	f0 17		beq $175f			beq 	_EXPSExit 					; exit if zero
.1748	a8		tay				tay
.1749					_EXPSLoop:
.1749	a2 0c		ldx #$0c			ldx 	#IFR1 						; get direction
.174b	2c 11 05	bit $0511			bit 	EXPShiftLeftFlag
.174e	30 05		bmi $1755			bmi 	_EXPSShiftLeft 				; shift left/right accordingly.
.1750	20 43 34	jsr $3443			jsr 	IFloatShiftRight
.1753	80 07		bra $175c			bra 	_EXPSContinue
.1755					_EXPSShiftLeft:
.1755	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.1758	24 0a		bit $0a				bit 	IFR0+IM2 					; too many shifts (24th bit set)
.175a	30 10		bmi $176c			bmi 	_EXPSRange
.175c					_EXPSContinue:
.175c	88		dey				dey 								; do it Y times
.175d	d0 ea		bne $1749			bne 	_EXPSLoop
.175f					_EXPSExit:
.175f	a2 0c		ldx #$0c			ldx 	#IFR1 						; R0 = R1 <shift> R0
.1761	20 a5 33	jsr $33a5			jsr 	IFloatCopyFromRegister
.1764	7a		ply				ply
.1765	60		rts				rts
.1766					_EXPSShiftZero:
.1766	a2 08		ldx #$08			ldx 	#IFR0
.1768	20 14 34	jsr $3414			jsr 	IFloatSetZero
.176b	60		rts				rts
.176c					_EXPSRange:
.176c	4c af 27	jmp $27af		jmp	ErrorV_range
.0511					EXPShiftLeftFlag:
>0511							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/expression/expression.asm

.176f					EXPEvaluateExpression:
.176f	a9 00		lda #$00			lda 	#0 							; current precedence
.1771					EXPEvaluateExpressionPrecedenceA:
.1771	48		pha				pha
.1772	20 ec 17	jsr $17ec			jsr 	EXPTermValueR0				; do first term.
.1775					_EELoop:
.1775	b1 18		lda ($18),y			lda 	(codePtr),y 				; what follows needs to be a binary operator
.1777	c9 ef		cmp #$ef			cmp 	#PR_BINARY_FIRST 			; binary tokens are the last ones up to $FF
.1779	90 31		bcc $17ac			bcc 	_EEExit
.177b	aa		tax				tax 								; access the precedence of the operator.
.177c	68		pla				pla 								; restore precedence.if >= operator precedence then exit
.177d	dd 4a 1b	cmp $1b4a,x			cmp 	BinaryPrecedence-PR_BINARY_FIRST,x
.1780	b0 2b		bcs $17ad			bcs 	_EEExit2
.1782	48		pha				pha 								; save current precedence.
.1783	da		phx				phx 								; save operator
.1784	c8		iny				iny 								; consume operator
.1785	da		phx				phx
.1786	a2 08		ldx #$08			ldx 	#IFR0 						; push R0 on the stack
.1788	20 63 33	jsr $3363			jsr 	IFloatPushRx
.178b	fa		plx				plx
.178c	bd 4a 1b	lda $1b4a,x			lda 	BinaryPrecedence-PR_BINARY_FIRST,x
.178f	20 71 17	jsr $1771			jsr 	EXPEvaluateExpressionPrecedenceA
.1792	a2 0c		ldx #$0c			ldx 	#IFR1 						; pop LHS to R1.
.1794	20 84 33	jsr $3384			jsr 	IFloatPullRx
.1797	fa		plx				plx 								; operator
.1798	a5 0b		lda $0b				lda 	IFR0+IExp 					; if check types match.
.179a	45 0f		eor $0f				eor 	IFR1+IExp
.179c	30 08		bmi $17a6			bmi 	_EEType
.179e					_EETypeOkay:
.179e	8a		txa				txa
.179f	0a		asl a				asl 	a 							; double -> X
.17a0	aa		tax				tax
.17a1	20 a9 17	jsr $17a9			jsr 	_EECallBinary 				; call the operator R0 := R1 <op> R0
.17a4	80 cf		bra $1775			bra 	_EELoop
.17a6					_EEType:
.17a6	4c ce 27	jmp $27ce		jmp	ErrorV_type
.17a9					_EECallBinary:
.17a9	7c 36 1e	jmp ($1e36,x)			jmp 	(VectorTable,x)
.17ac					_EEExit:
.17ac	68		pla				pla 								; throw precedence
.17ad					_EEExit2:
.17ad	18		clc				clc
.17ae	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/exprutils.asm

.17af					EXPEvalNumber:
.17af	20 6f 17	jsr $176f			jsr 	EXPEvaluateExpression 		; get a value
.17b2	24 0b		bit $0b				bit 	IFR0+IExp 					; fail if string
.17b4	30 01		bmi $17b7			bmi 	EVUType
.17b6	60		rts				rts
.17b7					EVUType:
.17b7	4c ce 27	jmp $27ce		jmp	ErrorV_type
.17ba					EXPEvalInteger:
.17ba	20 af 17	jsr $17af			jsr 	EXPEvalNumber 				; get number, coeerce to integer.
.17bd	20 15 31	jsr $3115			jsr 	IFloatIntegerR0
.17c0	60		rts				rts
.17c1					EXPEvalInteger16:
.17c1	20 ba 17	jsr $17ba			jsr 	EXPEvalInteger 				; get integer
.17c4	a5 0a		lda $0a				lda 	IFR0+IM2 					; range 0000-FFFF
.17c6	d0 21		bne $17e9			bne 	EVURange
.17c8	a6 09		ldx $09				ldx 	IFR0+IM1
.17ca	a5 08		lda $08				lda 	IFR0+IM0
.17cc	60		rts				rts
.17cd					EXPEvalInteger8:
.17cd	20 ba 17	jsr $17ba			jsr 	EXPEvalInteger 				; get integer
.17d0	a5 0a		lda $0a				lda 	IFR0+IM2 					; range 00-FF
.17d2	05 09		ora $09				ora 	IFR0+IM1
.17d4	d0 13		bne $17e9			bne 	EVURange
.17d6	a5 08		lda $08				lda 	IFR0+IM0
.17d8	60		rts				rts
.17d9					EXPEvalString:
.17d9	20 6f 17	jsr $176f			jsr 	EXPEvaluateExpression 		; get value
.17dc	24 0b		bit $0b				bit 	IFR0+IExp 					; exit if integer
.17de	10 d7		bpl $17b7			bpl 	EVUType
.17e0	a6 09		ldx $09				ldx 	IFR0+IM1 					; copy address to zTemp0
.17e2	86 25		stx $25				stx 	zTemp0+1
.17e4	a5 08		lda $08				lda 	IFR0+IM0
.17e6	85 24		sta $24				sta 	zTemp0
.17e8	60		rts				rts
.17e9					EVURange:
.17e9	4c af 27	jmp $27af		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/term.asm

.17ec					EXPTermValueR0:
.17ec	20 37 18	jsr $1837			jsr 	EXPTermR0 					; get term
.17ef	90 45		bcc $1836			bcc 	_ETVNotReference 			; exit if value.
.17f1	5a		phy				phy
.17f2	a0 03		ldy #$03			ldy 	#3 							; get type
.17f4	b1 08		lda ($08),y			lda 	(IFR0),y
.17f6	30 14		bmi $180c			bmi 	_ETVDereferenceString
.17f8	85 0b		sta $0b				sta 	IFR0+IExp 					; save byte 3 into R0
.17fa	88		dey				dey 								; get byte 2
.17fb	b1 08		lda ($08),y			lda 	(IFR0),y
.17fd	85 0a		sta $0a				sta 	IFR0+IM2 					; save byte 2
.17ff	88		dey				dey 								; get byte 1
.1800	b1 08		lda ($08),y			lda 	(IFR0),y
.1802	aa		tax				tax 								; save in X so we can overwrite it
.1803	b2 08		lda ($08)			lda 	(IFR0) 						; get byte 0
.1805	86 09		stx $09				stx 	IFR0+IM1  					; save bytes 1 & 0
.1807	85 08		sta $08				sta 	IFR0+IM0
.1809	7a		ply				ply
.180a	18		clc				clc
.180b	60		rts				rts
.180c					_ETVDereferenceString:
.180c	a0 01		ldy #$01			ldy 	#1 							; check if it is as yet unassigned.
.180e	b1 08		lda ($08),y			lda 	(IFR0),y 					; (e.g. the address is zero)
.1810	12 08		ora ($08)			ora 	(IFR0)
.1812	f0 11		beq $1825			beq 	_ETVNull 					; if so, return a fake NULL.
.1814	b1 08		lda ($08),y			lda 	(IFR0),y 					; load address of string to XA
.1816	aa		tax				tax
.1817	b2 08		lda ($08)			lda 	(IFR0)
.1819	18		clc				clc 								; add two so points to actual string.
.181a	69 02		adc #$02			adc 	#2
.181c	90 01		bcc $181f			bcc 	_EVDSNoCarry
.181e	e8		inx				inx
.181f					_EVDSNoCarry:
.181f	86 09		stx $09				stx 	IFR0+IM1 					; save in slots
.1821	85 08		sta $08				sta 	IFR0
.1823	80 08		bra $182d			bra 	_ETVFillExit 				; tidy up and exit.
.1825					_ETVNull:
.1825	a9 35		lda #$35			lda 	#_EVTNString & $FF
.1827	85 08		sta $08				sta 	IFR0+IM0
.1829	a9 18		lda #$18			lda 	#_EVTNString >> 8
.182b	85 09		sta $09				sta 	IFR0+IM1
.182d					_ETVFillExit:
.182d	64 0a		stz $0a				stz 	IFR0+IM2 					; clear byte 2, not strictly required :)
.182f	a9 80		lda #$80			lda 	#$80 						; set type to string.
.1831	85 0b		sta $0b				sta 	IFR0+IExp
.1833	7a		ply				ply
.1834	60		rts				rts
.1835					_EVTNString:
>1835	00						.byte 	0
.1836					_ETVNotReference:
.1836	60		rts				rts
.1837					EXPTermR0:
.1837	b1 18		lda ($18),y			lda 	(codePtr),y 				; get next token/element
.1839	30 10		bmi $184b			bmi 	_ETMIsUnaryOrMinus 			; if it's a token $80-$FF, it's a unary function, maybe ....
.183b	c8		iny				iny 								; consume element
.183c	c9 40		cmp #$40			cmp 	#$40 						; 40-7F are identifiers.
.183e	b0 08		bcs $1848			bcs 	_ETMIdentifier
.1840	20 76 18	jsr $1876			jsr 	EXPExtractTokenisedInteger 	; pull out tokenised integer to R0
.1843	20 a9 18	jsr $18a9			jsr 	EXPCheckDecimalFollows 		; check for decimals.
.1846	18		clc				clc 								; return value ok
.1847	60		rts				rts
.1848					_ETMIdentifier:
.1848	4c ad 2d	jmp $2dad			jmp 	VARCheckSimple 				; check variables, seperate module.
.184b					_ETMIsUnaryOrMinus:
.184b	c8		iny				iny 								; consume element
.184c	c9 fe		cmp #$fe			cmp 	#PR_MINUS 					; handle - seperately as it has two roles.
.184e	d0 0e		bne $185e			bne 	_ETMCheckUnary
.1850	20 ec 17	jsr $17ec			jsr 	EXPTermValueR0 				; get a term to negate
.1853	a2 08		ldx #$08			ldx 	#IFR0 						; and negate it
.1855	20 1f 34	jsr $341f			jsr 	IFloatNegate
.1858	24 0b		bit $0b				bit 	IFR0+IExp 					; is it a string
.185a	30 17		bmi $1873			bmi 	_ETMUnaryType				; if so error.
.185c	18		clc				clc
.185d	60		rts				rts
.185e					_ETMCheckUnary:
.185e	c9 d5		cmp #$d5			cmp 	#PR_UNARY_FIRST 			; check unary function.
.1860	90 0e		bcc $1870			bcc 	_ETMUnarySyntax
.1862	c9 ef		cmp #$ef			cmp 	#PR_UNARY_LAST+1
.1864	b0 0a		bcs $1870			bcs 	_ETMUnarySyntax
.1866	0a		asl a				asl 	a 							; make it into an index => X
.1867	aa		tax				tax
.1868	20 6d 18	jsr $186d			jsr 	_ETMCallUnaryFunction 		; call the function
.186b	18		clc				clc 								; and return it.
.186c	60		rts				rts
.186d					_ETMCallUnaryFunction:
.186d	7c 36 1e	jmp ($1e36,x)			jmp 	(VectorTable,x)
.1870					_ETMUnarySyntax:
.1870	4c 9e 27	jmp $279e		jmp	ErrorV_syntax
.1873					_ETMUnaryType:
.1873	4c ce 27	jmp $27ce		jmp	ErrorV_type
.1876					EXPExtractTokenisedInteger:
.1876	85 08		sta $08				sta 	IFR0+IM0 					; initial value in IM0
.1878	64 0b		stz $0b				stz 	IFR0+IExp	 				; zero the rest.
.187a	64 09		stz $09				stz 	IFR0+IM1
.187c	64 0a		stz $0a				stz 	IFR0+IM2
.187e					_ETMConstant:
.187e	b1 18		lda ($18),y			lda 	(codePtr),y 				; what follows.
.1880	c9 40		cmp #$40			cmp 	#$40 						; continuing constant
.1882	b0 24		bcs $18a8			bcs 	_ETMCExit 					; no, exit.
.1884	a6 0a		ldx $0a				ldx 	IFR0+IM2 					; x 256 into A:M2 M1 M0
.1886	a5 09		lda $09				lda 	IFR0+IM1
.1888	85 0a		sta $0a				sta 	IFR0+IM2
.188a	a5 08		lda $08				lda 	IFR0+IM0
.188c	85 09		sta $09				sta 	IFR0+IM1
.188e	64 08		stz $08				stz 	IFR0+IM0
.1890	8a		txa				txa
.1891	4a		lsr a				lsr 	a 							; shift right twice, e.g. whole thing is x 64
.1892	66 0a		ror $0a				ror 	IFR0+IM2
.1894	66 09		ror $09				ror 	IFR0+IM1
.1896	66 08		ror $08				ror 	IFR0+IM0
.1898	4a		lsr a				lsr 	a
.1899	66 0a		ror $0a				ror 	IFR0+IM2
.189b	66 09		ror $09				ror 	IFR0+IM1
.189d	66 08		ror $08				ror 	IFR0+IM0
.189f	a5 08		lda $08				lda 	IFR0+IM0 					; LSB in.
.18a1	11 18		ora ($18),y			ora 	(codePtr),y
.18a3	85 08		sta $08				sta 	IFR0+IM0
.18a5	c8		iny				iny 								; consume, loop back
.18a6	80 d6		bra $187e			bra 	_ETMConstant
.18a8					_ETMCExit:
.18a8	60		rts				rts
.18a9					EXPCheckDecimalFollows:
.18a9	b1 18		lda ($18),y			lda 	(codePtr),y 				; check for decimal
.18ab	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ
.18ad	d0 19		bne $18c8			bne 	_ETMCDExit
.18af	c8		iny				iny 								; consume token.
.18b0	b1 18		lda ($18),y			lda 	(codePtr),y 				; get count
.18b2	5a		phy				phy									; save current position
.18b3	48		pha				pha 								; save count of chars.
.18b4	38		sec				sec 								; address into YX : y + codePtr+1
.18b5	98		tya				tya
.18b6	65 18		adc $18				adc 	codePtr
.18b8	aa		tax				tax
.18b9	a5 19		lda $19				lda 	codePtr+1
.18bb	69 00		adc #$00			adc 	#0
.18bd	a8		tay				tay
.18be	68		pla				pla 								; get count.
.18bf	20 b8 32	jsr $32b8			jsr 	IFloatAddDecimalToR0 		; add the decimal to R0
.18c2	7a		ply				ply 								; go to next token.
.18c3	98		tya				tya
.18c4	38		sec				sec
.18c5	71 18		adc ($18),y			adc 	(codePtr),y
.18c7	a8		tay				tay
.18c8					_ETMCDExit:
.18c8	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/abs.asm

.18c9					EXPUnaryAbs:
.18c9	20 af 17	jsr $17af			jsr 	EXPEvalNumber 					; number to R0
.18cc	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.18cf	20 57 30	jsr $3057			jsr 	IFloatAbsoluteR0 				; take absolute value of it.
.18d2	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/ampersand.asm

.18d3					EXPUnaryNull:
.18d3	20 ec 17	jsr $17ec			jsr 	EXPTermValueR0
.18d6	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/asc.asm

.18d7					EXPUnaryAsc:
.18d7	20 d9 17	jsr $17d9			jsr 	EXPEvalString 					; string to R0, zTemp0
.18da	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.18dd	b2 24		lda ($24)			lda 	(zTemp0) 						; length 0 ?
.18df	f0 06		beq $18e7			beq 	_EXAZero 						; if so return 0
.18e1	5a		phy				phy 									; otherwise get first character
.18e2	a0 01		ldy #$01			ldy 	#1
.18e4	b1 24		lda ($24),y			lda 	(zTemp0),y
.18e6	7a		ply				ply
.18e7					_EXAZero:
.18e7	a2 08		ldx #$08			ldx 	#IFR0
.18e9	20 16 34	jsr $3416			jsr 	IFloatSetByte
.18ec	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/chr.asm

.18ed					EXPUnaryChr:
.18ed	20 cd 17	jsr $17cd			jsr 	EXPEvalInteger8 				; expr
.18f0	48		pha				pha 									; push on stack
.18f1	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.18f4	a9 01		lda #$01			lda 	#1 								; alloc temp mem for result, 1 byte only.
.18f6	20 6c 2a	jsr $2a6c			jsr 	StringTempAllocate
.18f9	68		pla				pla 									; get value back
.18fa	20 a1 2a	jsr $2aa1			jsr 	StringTempWrite 				; write to string.
.18fd	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/dec.asm

.18fe					EXPUnaryDec:
.18fe	20 d9 17	jsr $17d9			jsr 	EXPEvalString 					; string to R0, zTemp0
.1901	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.1904	5a		phy				phy 									; save position.
.1905	a2 08		ldx #$08			ldx 	#IFR0 							; zero the result
.1907	20 14 34	jsr $3414			jsr 	IFloatSetZero
.190a	b2 24		lda ($24)			lda 	(zTemp0)						; read the length to X
.190c	f0 3b		beq $1949			beq 	_EUDError 						; empty string is not legit.
.190e	aa		tax				tax 									; count in X.
.190f	a0 01		ldy #$01			ldy 	#1 								; start at offset 1
.1911					_EUDLoop:
.1911	b1 24		lda ($24),y			lda 	(zTemp0),y 						; get next from string
.1913	c9 61		cmp #$61			cmp 	#"a" 							; capitalise
.1915	90 02		bcc $1919			bcc 	_EUDNoCase
.1917	e9 20		sbc #$20			sbc 	#$20
.1919					_EUDNoCase:
.1919	c9 30		cmp #$30			cmp 	#'0' 							; check 0..9
.191b	90 2c		bcc $1949			bcc 	_EUDError
.191d	c9 3a		cmp #$3a			cmp 	#'9'+1
.191f	90 0a		bcc $192b			bcc 	_EUDOkay
.1921	c9 41		cmp #$41			cmp 	#'A'							; check A..F
.1923	90 24		bcc $1949			bcc 	_EUDError
.1925	c9 47		cmp #$47			cmp 	#'F'+1
.1927	b0 20		bcs $1949			bcs 	_EUDError
.1929	e9 06		sbc #$06			sbc 	#6 								; hex adjust, make a nibble value.
.192b					_EUDOkay:
.192b	29 0f		and #$0f			and 	#15 							; make constant
.192d	da		phx				phx
.192e	48		pha				pha
.192f	a2 08		ldx #$08			ldx 	#IFR0 							; multiply R0 x 16
.1931	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.1934	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.1937	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.193a	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.193d	68		pla				pla 									; pop constant and OR in
.193e	fa		plx				plx
.193f	05 08		ora $08				ora 	IFR0+IM0
.1941	85 08		sta $08				sta 	IFR0+IM0
.1943	c8		iny				iny 									; next char
.1944	ca		dex				dex 									; done all characters ?
.1945	d0 ca		bne $1911			bne 	_EUDLoop
.1947	7a		ply				ply
.1948	60		rts				rts
.1949					_EUDError:
.1949	4c c0 27	jmp $27c0		jmp	ErrorV_value

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/decimal.asm

.194c					EXPUnaryInlineDec:
.194c	4c 9e 27	jmp $279e		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/deekpeek.asm

.194f					EXPUnaryPeek:
.194f	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 				; number to R0
.1952	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.1955	b2 08		lda ($08)			lda 	(IFR0)
.1957	a2 08		ldx #$08			ldx 	#IFR0
.1959	20 16 34	jsr $3416			jsr 	IFloatSetByte
.195c	60		rts				rts
.195d					EXPUnaryDeek:
.195d	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 				; number to R0
.1960	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.1963	5a		phy				phy
.1964	a0 01		ldy #$01			ldy 	#1
.1966	b1 08		lda ($08),y			lda 	(IFR0),y
.1968	7a		ply				ply
.1969	48		pha				pha
.196a	b2 08		lda ($08)			lda 	(IFR0)
.196c	a2 08		ldx #$08			ldx 	#IFR0
.196e	20 16 34	jsr $3416			jsr 	IFloatSetByte
.1971	68		pla				pla
.1972	85 09		sta $09				sta 	IFR0+IM1
.1974	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/fractional.asm

.1975					EXPUnaryFrac:
.1975	20 af 17	jsr $17af			jsr 	EXPEvalNumber 					; number to R0
.1978	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.197b	20 bf 30	jsr $30bf			jsr 	IFloatFractionalR0 				; get fractional bit.
.197e	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/inkey.asm

.197f					EXPUnaryInkey:
.197f	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.1982	a9 01		lda #$01			lda 	#1 								; alloc temp mem for result
.1984	20 6c 2a	jsr $2a6c			jsr 	StringTempAllocate
.1987	20 ee ff	jsr $ffee			jsr 	OSIsKeyAvailable 				; if no key exit
.198a	b0 06		bcs $1992			bcs 	_EUIExit
.198c	20 f4 ff	jsr $fff4			jsr 	OSReadKeyboard 					; otherwise get it.
.198f	20 a1 2a	jsr $2aa1			jsr 	StringTempWrite
.1992					_EUIExit:
.1992	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/intfn.asm

.1993					EXPUnaryInt:
.1993	20 af 17	jsr $17af			jsr 	EXPEvalNumber 					; number to R0
.1996	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; check for )
.1999	20 15 31	jsr $3115			jsr 	IFloatIntegerR0 				; force to integer.
.199c	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/len.asm

.199d					EXPUnaryLen:
.199d	20 d9 17	jsr $17d9			jsr 	EXPEvalString 					; string to R0, zTemp0
.19a0	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.19a3	b2 24		lda ($24)			lda 	(zTemp0) 						; first byte is the length
.19a5	a2 08		ldx #$08			ldx 	#IFR0 							; write it out.
.19a7	20 16 34	jsr $3416			jsr 	IFloatSetByte
.19aa	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/parenthesis.asm

.19ab					EXPUnaryParenthesis:
.19ab	20 af 17	jsr $17af			jsr 	EXPEvalNumber 					; number to R0
.19ae	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.19b1	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/random.asm

.19b2					EXPUnaryRnd:
.19b2	20 af 17	jsr $17af			jsr 	EXPEvalNumber 				; number to R0
.19b5	20 77 29	jsr $2977			jsr 	ERRCheckRParen 				; )
.19b8	a2 08		ldx #$08			ldx 	#IFR0 						; load random number to R0
.19ba	20 d1 19	jsr $19d1			jsr 	EXPLoadInRandom
.19bd	a9 29		lda #$29			lda 	#64-23 						; hack the exponent to make it in the range 0-1.
.19bf	85 0b		sta $0b				sta 	IFR0+IExp
.19c1	60		rts				rts
.19c2					ExpUnaryRand:
.19c2	20 ba 17	jsr $17ba			jsr 	EXPEvalInteger 				; integer to R0
.19c5	20 77 29	jsr $2977			jsr 	ERRCheckRParen 				; )
.19c8	a2 0c		ldx #$0c			ldx 	#IFR1 						; random to R1
.19ca	20 d1 19	jsr $19d1			jsr 	EXPLoadInRandom
.19cd	20 84 2f	jsr $2f84			jsr 	IFloatModulusInteger 		; calculate mod r1,r0
.19d0	60		rts				rts
.19d1					EXPLoadInRandom:
.19d1	20 14 34	jsr $3414			jsr 	IFloatSetZero 				; zero it
.19d4	20 e6 19	jsr $19e6			jsr 	EXPRandom32 				; do a 23 bit number.
.19d7	95 00		sta $00,x			sta 	IM0,x
.19d9	20 e6 19	jsr $19e6			jsr 	EXPRandom32
.19dc	95 01		sta $01,x			sta 	IM1,x
.19de	20 e6 19	jsr $19e6			jsr 	EXPRandom32
.19e1	29 7f		and #$7f			and 	#$7F
.19e3	95 02		sta $02,x			sta 	IM2,x
.19e5	60		rts				rts
.19e6					EXPRandom32:
.19e6	5a		phy				phy
.19e7	a0 08		ldy #$08			ldy 	#8
.19e9	ad 12 05	lda $0512			lda 	EXPSeed+0
.19ec	0d 13 05	ora $0513			ora 	EXPSeed+1
.19ef	0d 14 05	ora $0514			ora 	EXPSeed+2
.19f2	0d 15 05	ora $0515			ora 	EXPSeed+3
.19f5	d0 08		bne $19ff			bne 	_EXPRNoReset
.19f7	ee 12 05	inc $0512			inc 	EXPSeed+0
.19fa	a0 10		ldy #$10			ldy 	#16
.19fc	8c 15 05	sty $0515			sty 	EXPSeed+3
.19ff					_EXPRNoReset:
.19ff	ad 12 05	lda $0512			lda 	EXPSeed+0
.1a02					_EXPRLoop:
.1a02	0a		asl a				asl		a
.1a03	2e 13 05	rol $0513			rol 	EXPSeed+1
.1a06	2e 14 05	rol $0514			rol 	EXPSeed+2
.1a09	2e 15 05	rol $0515			rol 	EXPSeed+3
.1a0c	90 02		bcc $1a10			bcc 	_EXPRNoEOR
.1a0e	49 c5		eor #$c5			eor 	#$C5
.1a10					_EXPRNoEOR:
.1a10	88		dey				dey
.1a11	d0 ef		bne $1a02			bne 	_EXPRLoop
.1a13	8d 12 05	sta $0512			sta 	EXPSeed+0
.1a16	7a		ply				ply
.1a17	60		rts				rts
.0512					EXPSeed:
>0512							.fill 	4

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sgn.asm

.1a18					EXPUnarySgn:
.1a18	20 af 17	jsr $17af			jsr 	EXPEvalNumber 					; number to R0
.1a1b	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.1a1e	a2 0c		ldx #$0c			ldx 	#IFR1 							; copy to R1
.1a20	20 b6 33	jsr $33b6			jsr 	IFloatCopyToRegister
.1a23	a2 08		ldx #$08			ldx 	#IFR0 							; R0 = 0
.1a25	20 14 34	jsr $3414			jsr 	IFloatSetZero
.1a28	a2 0c		ldx #$0c			ldx 	#IFR1
.1a2a	20 e3 30	jsr $30e3			jsr 	IFloatCompare 					; compare R1 vs 0, this gives -1,0,1.
.1a2d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sqr.asm

.1a2e					EXPUnarySqr:
.1a2e	20 af 17	jsr $17af			jsr 	EXPEvalNumber 					; number to R0
.1a31	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.1a34	20 5f 30	jsr $305f			jsr 	IFloatSquareRootR0 				; square root.
.1a37	b0 01		bcs $1a3a			bcs 	_EUSValue 						; error check.
.1a39	60		rts				rts
.1a3a					_EUSValue:
.1a3a	4c af 27	jmp $27af		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/strhex.asm

.1a3d					EXPUnaryHex:
.1a3d	20 ba 17	jsr $17ba			jsr 	EXPEvalInteger 					; expr
.1a40	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.1a43	5a		phy				phy
.1a44	a9 10		lda #$10			lda 	#16
.1a46	20 b6 31	jsr $31b6			jsr 	IFloatIntegerToStringR0
.1a49	80 0a		bra $1a55			bra 	EUSMain
.1a4b					EXPUnaryStr:
.1a4b	20 af 17	jsr $17af			jsr 	EXPEvalNumber 					; expr
.1a4e	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.1a51	5a		phy				phy
.1a52	20 11 32	jsr $3211			jsr 	IFloatFloatToStringR0 			; convert to string
.1a55					EUSMain:
.1a55	b0 19		bcs $1a70			bcs 	_EUSError
.1a57	86 24		stx $24				stx 	zTemp0 							; save string address
.1a59	84 25		sty $25				sty 	zTemp0+1
.1a5b	a9 20		lda #$20			lda 	#32 							; allocate space for result.
.1a5d	20 6c 2a	jsr $2a6c			jsr 	StringTempAllocate
.1a60	b2 24		lda ($24)			lda 	(zTemp0) 						; get count
.1a62	aa		tax				tax 									; count in X
.1a63	a0 01		ldy #$01			ldy 	#1
.1a65					_EUSCopy:
.1a65	b1 24		lda ($24),y			lda 	(zTemp0),y
.1a67	c8		iny				iny
.1a68	20 a1 2a	jsr $2aa1			jsr 	StringTempWrite
.1a6b	ca		dex				dex
.1a6c	d0 f7		bne $1a65			bne	 	_EUSCopy
.1a6e	7a		ply				ply
.1a6f	60		rts				rts
.1a70					_EUSError:
.1a70	4c af 27	jmp $27af		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/string.asm

.1a73					EXPUnaryInlineString:
.1a73	18		clc				clc 								; physical address -> IM0,1
.1a74	98		tya				tya 								; put the actual address in IM0
.1a75	65 18		adc $18				adc 	codePtr
.1a77	85 08		sta $08				sta 	IFR0+IM0
.1a79	a5 19		lda $19				lda 	codePtr+1
.1a7b	69 00		adc #$00			adc 	#0
.1a7d	85 09		sta $09				sta 	IFR0+IM1
.1a7f	64 0a		stz $0a				stz 	IFR0+IM2 					; fill in the 3rd byte and type.
.1a81	a9 80		lda #$80			lda 	#$80
.1a83	85 0b		sta $0b				sta 	IFR0+IExp
.1a85	98		tya				tya	 								; skip over it.
.1a86	38		sec				sec
.1a87	71 18		adc ($18),y			adc 	(codePtr),y
.1a89	a8		tay				tay
.1a8a	60		rts				rts
.1a8b					_EXPUISRange:
.1a8b	4c af 27	jmp $27af		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/substring.asm

.1a8e					EXPUnaryLeft:
.1a8e	20 d4 1a	jsr $1ad4			jsr 	EXPCommonStart 					; <string>,
.1a91	48		pha				pha 									; save string address on stack
.1a92	da		phx				phx
.1a93	a9 00		lda #$00			lda 	#0 								; start position (zero offset)
.1a95	48		pha				pha
.1a96	20 cd 17	jsr $17cd			jsr 	EXPEvalInteger8 				; characters to do
.1a99	80 44		bra $1adf			bra 	EXPSubstringCommon
.1a9b					EXPUnaryRight:
.1a9b	20 d4 1a	jsr $1ad4			jsr 	EXPCommonStart 					; <string>,
.1a9e	48		pha				pha 									; save string address on stack
.1a9f	da		phx				phx
.1aa0	b2 08		lda ($08)			lda 	(IFR0) 							; the string length => stack.
.1aa2	48		pha				pha
.1aa3	20 cd 17	jsr $17cd			jsr 	EXPEvalInteger8 				; characters to do
.1aa6	85 24		sta $24				sta 	zTemp0 							; calculate length - required, start point.
.1aa8	68		pla				pla
.1aa9	38		sec				sec
.1aaa	e5 24		sbc $24				sbc 	zTemp0
.1aac	b0 02		bcs $1ab0			bcs 	_EUROffLeft
.1aae	a9 00		lda #$00			lda 	#0
.1ab0					_EUROffLeft:
.1ab0	48		pha				pha 									; start pos
.1ab1	a9 ff		lda #$ff			lda 	#255
.1ab3	80 2a		bra $1adf			bra 	EXPSubstringCommon
.1ab5					EXPUnaryMid:
.1ab5	20 d4 1a	jsr $1ad4			jsr 	EXPCommonStart 					; <string>,
.1ab8	48		pha				pha 									; save string address on stack
.1ab9	da		phx				phx
.1aba	20 cd 17	jsr $17cd			jsr 	EXPEvalInteger8 				; characters start
.1abd	f0 12		beq $1ad1			beq 	_EUSError 						; 1 is left
.1abf	3a		dec a				dec 	a 								; zero based.
.1ac0	48		pha				pha
.1ac1	b1 18		lda ($18),y			lda 	(codePtr),y 					; comma follows
.1ac3	c9 99		cmp #$99			cmp 	#PR_COMMA
.1ac5	f0 04		beq $1acb			beq 	_EUMLength 						; if so m is provided
.1ac7	a9 ff		lda #$ff			lda 	#255 							; default m
.1ac9	80 14		bra $1adf			bra 	EXPSubstringCommon
.1acb					_EUMLength:
.1acb	c8		iny				iny 									; consume comma
.1acc	20 cd 17	jsr $17cd			jsr 	EXPEvalInteger8 				; characters to do
.1acf	80 0e		bra $1adf			bra 	EXPSubstringCommon
.1ad1					_EUSError:
.1ad1	4c c0 27	jmp $27c0		jmp	ErrorV_value
.1ad4					EXPCommonStart:
.1ad4	20 d9 17	jsr $17d9			jsr 	EXPEvalString
.1ad7	20 7f 29	jsr $297f			jsr 	ERRCheckComma
.1ada	a5 08		lda $08				lda 	IFR0+IM0
.1adc	a6 09		ldx $09				ldx 	IFR0+IM1
.1ade	60		rts				rts
.1adf					EXPSubstringCommon:
.1adf	85 26		sta $26				sta 	zTemp1 							; count to do in zTemp1.
.1ae1	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; check right bracket.
.1ae4	68		pla				pla 									; start position
.1ae5	85 27		sta $27				sta 	zTemp1+1 						; save in zTemp1+1
.1ae7	fa		plx				plx 									; get string address to zTemp2.
.1ae8	86 29		stx $29				stx 	zTemp2+1
.1aea	68		pla				pla
.1aeb	85 28		sta $28				sta 	zTemp2
.1aed	38		sec				sec 									; length - start is the max count of chars
.1aee	b2 28		lda ($28)			lda 	(zTemp2)
.1af0	e5 27		sbc $27				sbc 	zTemp1+1
.1af2	c5 26		cmp $26				cmp 	zTemp1 							; if available < count
.1af4	b0 02		bcs $1af8			bcs 	_EXPSSNoTrim
.1af6	85 26		sta $26				sta 	zTemp1 							; update count with available
.1af8					_EXPSSNoTrim:
.1af8	a5 26		lda $26				lda 	zTemp1 							; chars required.
.1afa	20 6c 2a	jsr $2a6c			jsr 	StringTempAllocate 				; allocate memory for it.
.1afd	a5 26		lda $26				lda 	zTemp1 							; zero length string
.1aff	f0 15		beq $1b16			beq 	_EXPSSExit
.1b01	a5 27		lda $27				lda 	zTemp1+1 						; if length >= start exit
.1b03	d2 28		cmp ($28)			cmp 	(zTemp2)
.1b05	b0 0f		bcs $1b16			bcs 	_EXPSSExit
.1b07	5a		phy				phy
.1b08	a4 27		ldy $27				ldy 	zTemp1+1 						; start position
.1b0a	c8		iny				iny 									; +1 for the length byte
.1b0b					_EXPSSCopy:
.1b0b	b1 28		lda ($28),y			lda 	(zTemp2),y
.1b0d	20 a1 2a	jsr $2aa1			jsr 	StringTempWrite
.1b10	c8		iny				iny
.1b11	c6 26		dec $26				dec 	zTemp1
.1b13	d0 f6		bne $1b0b			bne 	_EXPSSCopy
.1b15	7a		ply				ply
.1b16					_EXPSSExit:
.1b16	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/val.asm

.1b17					EXPUnaryVal:
.1b17	20 d9 17	jsr $17d9			jsr 	EXPEvalString 					; string to R0, zTemp0
.1b1a	20 77 29	jsr $2977			jsr 	ERRCheckRParen 					; )
.1b1d	20 21 1b	jsr $1b21			jsr 	VALConversionZTemp0
.1b20	60		rts				rts
.1b21					VALConversionZTemp0:
.1b21	5a		phy				phy
.1b22	18		clc				clc
.1b23	a5 24		lda $24				lda		zTemp0 							; point XY to the text
.1b25	69 01		adc #$01			adc 	#1
.1b27	aa		tax				tax
.1b28	a5 25		lda $25				lda 	zTemp0+1
.1b2a	69 00		adc #$00			adc 	#0
.1b2c	a8		tay				tay
.1b2d	b2 24		lda ($24)			lda 	(zTemp0) 						; get length.
.1b2f	20 78 32	jsr $3278			jsr 	IFloatStringToFloatR0 			; do conversion
.1b32	b0 02		bcs $1b36			bcs 	_EUVError
.1b34	7a		ply				ply
.1b35	60		rts				rts
.1b36					_EUVError:
.1b36	4c c0 27	jmp $27c0		jmp	ErrorV_value

;******  Return to file: include.files


;******  Processing file: src/generated/asmhash.asm

.1b39					AssemblerLookup:
>1b39	a3 1e 00 00 4b 1e 7c eb			.byte 163,30,0,0,75,30,124,235,251,30,124,0,75,30,124,74,184,30,30,0,65,30,124,235,185,30,249,0,65,30,124,74,127,106,0,0,122,106,225,235,35,106,225,0,122,106,225,74,151,106,106,0,122,106,225,235,166,106,125,0,122,106,225,74,56,98,0,0,0,98,11,235,236,98,11,0,46,98,11,74,195,98,98,0,0,98,11,235,191,98,4,0,0,98,11,74,66,29,0,0,59,29,231,235,20,29,231,0,46,29,231,74,211,29,29,0,59,29,231,235,172,29,44,0,46,29,231,74,153,34,0,0,58,34,57,245,147,122,84,0,58,34,57,75,69,34,34,0,58,34,57,245,94,34,102,0,59,34,59,75,25,1,24,0,25,1,24,245,198,1,197,0,25,1,24,75,85,1,1,0,25,1,24,245,204,1,97,0,25,1,24,75,247,168,0,0,247,168,125,245,15,168,146,12,247,168,125,75,117,168,168,0,0,168,125,245,186,168,3,49,0,168,125,75,246,72,0,0,246,72,249,245,14,72,221,0,246,72,249,75,143,72,72,0,0,72,249,245,167,72,43,0,0,72,249,75
>1b41	fb 1e 7c 00 4b 1e 7c 4a b8 1e 1e 00 41 1e 7c eb
>1b51	b9 1e f9 00 41 1e 7c 4a 7f 6a 00 00 7a 6a e1 eb
>1b61	23 6a e1 00 7a 6a e1 4a 97 6a 6a 00 7a 6a e1 eb
>1b71	a6 6a 7d 00 7a 6a e1 4a 38 62 00 00 00 62 0b eb
>1b81	ec 62 0b 00 2e 62 0b 4a c3 62 62 00 00 62 0b eb
>1b91	bf 62 04 00 00 62 0b 4a 42 1d 00 00 3b 1d e7 eb
>1ba1	14 1d e7 00 2e 1d e7 4a d3 1d 1d 00 3b 1d e7 eb
>1bb1	ac 1d 2c 00 2e 1d e7 4a 99 22 00 00 3a 22 39 f5
>1bc1	93 7a 54 00 3a 22 39 4b 45 22 22 00 3a 22 39 f5
>1bd1	5e 22 66 00 3b 22 3b 4b 19 01 18 00 19 01 18 f5
>1be1	c6 01 c5 00 19 01 18 4b 55 01 01 00 19 01 18 f5
>1bf1	cc 01 61 00 19 01 18 4b f7 a8 00 00 f7 a8 7d f5
>1c01	0f a8 92 0c f7 a8 7d 4b 75 a8 a8 00 00 a8 7d f5
>1c11	ba a8 03 31 00 a8 7d 4b f6 48 00 00 f6 48 f9 f5
>1c21	0e 48 dd 00 f6 48 f9 4b 8f 48 48 00 00 48 f9 f5
>1c31	a7 48 2b 00 00 48 f9 4b

;******  Return to file: include.files


;******  Processing file: src/generated/precedence_table.asm

.1c39					BinaryPrecedence:
>1c39	02					.byte	 2	; $ef =
>1c3a	02					.byte	 2	; $f0 <>
>1c3b	02					.byte	 2	; $f1 <=
>1c3c	02					.byte	 2	; $f2 <
>1c3d	02					.byte	 2	; $f3 >=
>1c3e	02					.byte	 2	; $f4 >
>1c3f	01					.byte	 1	; $f5 XOR
>1c40	01					.byte	 1	; $f6 OR
>1c41	01					.byte	 1	; $f7 AND
>1c42	04					.byte	 4	; $f8 DIV
>1c43	04					.byte	 4	; $f9 MOD
>1c44	04					.byte	 4	; $fa <<
>1c45	04					.byte	 4	; $fb >>
>1c46	04					.byte	 4	; $fc /
>1c47	04					.byte	 4	; $fd *
>1c48	03					.byte	 3	; $fe -
>1c49	03					.byte	 3	; $ff +

;******  Return to file: include.files


;******  Processing file: src/generated/structure_table.asm

.1c4a					StructureOffsets:
>1c4a	01					.byte	1  	; $80 REPEAT
>1c4b	ff					.byte	255	; $81 UNTIL
>1c4c	01					.byte	1  	; $82 WHILE
>1c4d	ff					.byte	255	; $83 WEND
>1c4e	01					.byte	1  	; $84 IF
>1c4f	ff					.byte	255	; $85 ENDIF
>1c50	01					.byte	1  	; $86 DO
>1c51	ff					.byte	255	; $87 LOOP
>1c52	01					.byte	1  	; $88 PROC
>1c53	ff					.byte	255	; $89 ENDPROC
>1c54	01					.byte	1  	; $8a FOR
>1c55	ff					.byte	255	; $8b NEXT

;******  Return to file: include.files


;******  Processing file: src/generated/token_text.asm

.1c56					StandardTokens:
>1c56	06 52 45 50 45 41 54			.byte	$06,$52,$45,$50,$45,$41,$54             	; $80 repeat
>1c5d	05 55 4e 54 49 4c			.byte	$05,$55,$4e,$54,$49,$4c                 	; $81 until
>1c63	05 57 48 49 4c 45			.byte	$05,$57,$48,$49,$4c,$45                 	; $82 while
>1c69	04 57 45 4e 44				.byte	$04,$57,$45,$4e,$44                     	; $83 wend
>1c6e	02 49 46				.byte	$02,$49,$46                             	; $84 if
>1c71	05 45 4e 44 49 46			.byte	$05,$45,$4e,$44,$49,$46                 	; $85 endif
>1c77	02 44 4f				.byte	$02,$44,$4f                             	; $86 do
>1c7a	04 4c 4f 4f 50				.byte	$04,$4c,$4f,$4f,$50                     	; $87 loop
>1c7f	04 50 52 4f 43				.byte	$04,$50,$52,$4f,$43                     	; $88 proc
>1c84	07 45 4e 44 50 52 4f 43			.byte	$07,$45,$4e,$44,$50,$52,$4f,$43         	; $89 endproc
>1c8c	03 46 4f 52				.byte	$03,$46,$4f,$52                         	; $8a for
>1c90	04 4e 45 58 54				.byte	$04,$4e,$45,$58,$54                     	; $8b next
>1c95	00					.byte	$00                                     	; $8c [[end]]
>1c96	00					.byte	$00                                     	; $8d [[shift]]
>1c97	04 45 4c 53 45				.byte	$04,$45,$4c,$53,$45                     	; $8e else
>1c9c	04 54 48 45 4e				.byte	$04,$54,$48,$45,$4e                     	; $8f then
>1ca1	02 54 4f				.byte	$02,$54,$4f                             	; $90 to
>1ca4	04 53 54 45 50				.byte	$04,$53,$54,$45,$50                     	; $91 step
>1ca9	03 4c 45 54				.byte	$03,$4c,$45,$54                         	; $92 let
>1cad	05 50 52 49 4e 54			.byte	$05,$50,$52,$49,$4e,$54                 	; $93 print
>1cb3	05 49 4e 50 55 54			.byte	$05,$49,$4e,$50,$55,$54                 	; $94 input
>1cb9	04 43 41 4c 4c				.byte	$04,$43,$41,$4c,$4c                     	; $95 call
>1cbe	03 53 59 53				.byte	$03,$53,$59,$53                         	; $96 sys
>1cc2	03 52 45 4d				.byte	$03,$52,$45,$4d                         	; $97 rem
>1cc6	04 45 58 49 54				.byte	$04,$45,$58,$49,$54                     	; $98 exit
>1ccb	01 2c					.byte	$01,$2c                                 	; $99 ,
>1ccd	01 3b					.byte	$01,$3b                                 	; $9a ;
>1ccf	01 3a					.byte	$01,$3a                                 	; $9b :
>1cd1	01 27					.byte	$01,$27                                 	; $9c '
>1cd3	01 29					.byte	$01,$29                                 	; $9d )
>1cd5	04 50 4f 4b 45				.byte	$04,$50,$4f,$4b,$45                     	; $9e poke
>1cda	04 44 4f 4b 45				.byte	$04,$44,$4f,$4b,$45                     	; $9f doke
>1cdf	04 52 45 41 44				.byte	$04,$52,$45,$41,$44                     	; $a0 read
>1ce4	04 44 41 54 41				.byte	$04,$44,$41,$54,$41                     	; $a1 data
>1ce9	01 5b					.byte	$01,$5b                                 	; $a2 [
>1ceb	01 5d					.byte	$01,$5d                                 	; $a3 ]
>1ced	01 23					.byte	$01,$23                                 	; $a4 #
>1cef	01 2e					.byte	$01,$2e                                 	; $a5 .
>1cf1	00					.byte	0											; $a6
>1cf2	00					.byte	0											; $a7
>1cf3	00					.byte	0											; $a8
>1cf4	00					.byte	0											; $a9
>1cf5	00					.byte	0											; $aa
>1cf6	00					.byte	0											; $ab
>1cf7	00					.byte	0											; $ac
>1cf8	00					.byte	0											; $ad
>1cf9	00					.byte	0											; $ae
>1cfa	00					.byte	0											; $af
>1cfb	00					.byte	0											; $b0
>1cfc	00					.byte	0											; $b1
>1cfd	00					.byte	0											; $b2
>1cfe	00					.byte	0											; $b3
>1cff	00					.byte	0											; $b4
>1d00	00					.byte	0											; $b5
>1d01	00					.byte	0											; $b6
>1d02	00					.byte	0											; $b7
>1d03	00					.byte	0											; $b8
>1d04	00					.byte	0											; $b9
>1d05	00					.byte	0											; $ba
>1d06	00					.byte	0											; $bb
>1d07	00					.byte	0											; $bc
>1d08	00					.byte	0											; $bd
>1d09	00					.byte	0											; $be
>1d0a	00					.byte	0											; $bf
>1d0b	00					.byte	0											; $c0
>1d0c	00					.byte	0											; $c1
>1d0d	00					.byte	0											; $c2
>1d0e	00					.byte	0											; $c3
>1d0f	00					.byte	0											; $c4
>1d10	00					.byte	0											; $c5
>1d11	00					.byte	0											; $c6
>1d12	00					.byte	0											; $c7
>1d13	00					.byte	0											; $c8
>1d14	00					.byte	0											; $c9
>1d15	00					.byte	0											; $ca
>1d16	00					.byte	0											; $cb
>1d17	00					.byte	0											; $cc
>1d18	00					.byte	0											; $cd
>1d19	00					.byte	0											; $ce
>1d1a	00					.byte	0											; $cf
>1d1b	00					.byte	0											; $d0
>1d1c	00					.byte	0											; $d1
>1d1d	00					.byte	0											; $d2
>1d1e	00					.byte	0											; $d3
>1d1f	00					.byte	0											; $d4
>1d20	05 44 45 45 4b 28			.byte	$05,$44,$45,$45,$4b,$28                 	; $d5 deek(
>1d26	05 50 45 45 4b 28			.byte	$05,$50,$45,$45,$4b,$28                 	; $d6 peek(
>1d2c	07 52 49 47 48 54 24 28			.byte	$07,$52,$49,$47,$48,$54,$24,$28         	; $d7 right$(
>1d34	06 4c 45 46 54 24 28			.byte	$06,$4c,$45,$46,$54,$24,$28             	; $d8 left$(
>1d3b	05 4d 49 44 24 28			.byte	$05,$4d,$49,$44,$24,$28                 	; $d9 mid$(
>1d41	05 53 54 52 24 28			.byte	$05,$53,$54,$52,$24,$28                 	; $da str$(
>1d47	04 56 41 4c 28				.byte	$04,$56,$41,$4c,$28                     	; $db val(
>1d4c	04 53 47 4e 28				.byte	$04,$53,$47,$4e,$28                     	; $dc sgn(
>1d51	04 41 42 53 28				.byte	$04,$41,$42,$53,$28                     	; $dd abs(
>1d56	04 4c 45 4e 28				.byte	$04,$4c,$45,$4e,$28                     	; $de len(
>1d5b	04 53 51 52 28				.byte	$04,$53,$51,$52,$28                     	; $df sqr(
>1d60	05 43 48 52 24 28			.byte	$05,$43,$48,$52,$24,$28                 	; $e0 chr$(
>1d66	04 41 53 43 28				.byte	$04,$41,$53,$43,$28                     	; $e1 asc(
>1d6b	07 49 4e 4b 45 59 24 28			.byte	$07,$49,$4e,$4b,$45,$59,$24,$28         	; $e2 inkey$(
>1d73	06 45 56 45 4e 54 28			.byte	$06,$45,$56,$45,$4e,$54,$28             	; $e3 event(
>1d7a	04 54 49 4d 45				.byte	$04,$54,$49,$4d,$45                     	; $e4 time
>1d7f	04 49 4e 54 28				.byte	$04,$49,$4e,$54,$28                     	; $e5 int(
>1d84	05 46 52 41 43 28			.byte	$05,$46,$52,$41,$43,$28                 	; $e6 frac(
>1d8a	04 44 45 43 28				.byte	$04,$44,$45,$43,$28                     	; $e7 dec(
>1d8f	05 48 45 58 24 28			.byte	$05,$48,$45,$58,$24,$28                 	; $e8 hex$(
>1d95	04 52 4e 44 28				.byte	$04,$52,$4e,$44,$28                     	; $e9 rnd(
>1d9a	05 52 41 4e 44 28			.byte	$05,$52,$41,$4e,$44,$28                 	; $ea rand(
>1da0	01 28					.byte	$01,$28                                 	; $eb (
>1da2	01 26					.byte	$01,$26                                 	; $ec &
>1da4	00					.byte	$00                                     	; $ed [[decimal]]
>1da5	00					.byte	$00                                     	; $ee [[string]]
>1da6	01 3d					.byte	$01,$3d                                 	; $ef =
>1da8	02 3c 3e				.byte	$02,$3c,$3e                             	; $f0 <>
>1dab	02 3c 3d				.byte	$02,$3c,$3d                             	; $f1 <=
>1dae	01 3c					.byte	$01,$3c                                 	; $f2 <
>1db0	02 3e 3d				.byte	$02,$3e,$3d                             	; $f3 >=
>1db3	01 3e					.byte	$01,$3e                                 	; $f4 >
>1db5	03 58 4f 52				.byte	$03,$58,$4f,$52                         	; $f5 xor
>1db9	02 4f 52				.byte	$02,$4f,$52                             	; $f6 or
>1dbc	03 41 4e 44				.byte	$03,$41,$4e,$44                         	; $f7 and
>1dc0	03 44 49 56				.byte	$03,$44,$49,$56                         	; $f8 div
>1dc4	03 4d 4f 44				.byte	$03,$4d,$4f,$44                         	; $f9 mod
>1dc8	02 3c 3c				.byte	$02,$3c,$3c                             	; $fa <<
>1dcb	02 3e 3e				.byte	$02,$3e,$3e                             	; $fb >>
>1dce	01 2f					.byte	$01,$2f                                 	; $fc /
>1dd0	01 2a					.byte	$01,$2a                                 	; $fd *
>1dd2	01 2d					.byte	$01,$2d                                 	; $fe -
>1dd4	01 2b					.byte	$01,$2b                                 	; $ff +
>1dd6	ff					.byte	$FF
.1dd7					AlternateTokens:
>1dd7	05 43 4c 45 41 52			.byte	$05,$43,$4c,$45,$41,$52                 	; $8d80 clear
>1ddd	03 4e 45 57				.byte	$03,$4e,$45,$57                         	; $8d81 new
>1de1	03 52 55 4e				.byte	$03,$52,$55,$4e                         	; $8d82 run
>1de5	04 53 54 4f 50				.byte	$04,$53,$54,$4f,$50                     	; $8d83 stop
>1dea	03 45 4e 44				.byte	$03,$45,$4e,$44                         	; $8d84 end
>1dee	06 41 53 53 45 52 54			.byte	$06,$41,$53,$53,$45,$52,$54             	; $8d85 assert
>1df5	04 4c 49 53 54				.byte	$04,$4c,$49,$53,$54                     	; $8d86 list
>1dfa	04 53 41 56 45				.byte	$04,$53,$41,$56,$45                     	; $8d87 save
>1dff	04 4c 4f 41 44				.byte	$04,$4c,$4f,$41,$44                     	; $8d88 load
>1e04	05 47 4f 53 55 42			.byte	$05,$47,$4f,$53,$55,$42                 	; $8d89 gosub
>1e0a	04 47 4f 54 4f				.byte	$04,$47,$4f,$54,$4f                     	; $8d8a goto
>1e0f	06 52 45 54 55 52 4e			.byte	$06,$52,$45,$54,$55,$52,$4e             	; $8d8b return
>1e16	07 52 45 53 54 4f 52 45			.byte	$07,$52,$45,$53,$54,$4f,$52,$45         	; $8d8c restore
>1e1e	03 44 49 4d				.byte	$03,$44,$49,$4d                         	; $8d8d dim
>1e22	03 44 49 52				.byte	$03,$44,$49,$52                         	; $8d8e dir
>1e26	05 45 52 41 53 45			.byte	$05,$45,$52,$41,$53,$45                 	; $8d8f erase
>1e2c	08 52 45 4e 55 4d 42 45			.byte	$08,$52,$45,$4e,$55,$4d,$42,$45,$52     	; $8d90 renumber
>1e34	52
>1e35	ff					.byte	$FF

;******  Return to file: include.files


;******  Processing file: src/generated/vector_table.asm

.1e36					VectorTable:
>1e36	8e 26					.word	Command_REPEAT           ; $80 REPEAT
>1e38	97 26					.word	Command_UNTIL            ; $81 UNTIL
>1e3a	71 27					.word	Command_WHILE            ; $82 WHILE
>1e3c	92 27					.word	Command_WEND             ; $83 WEND
>1e3e	64 26					.word	IfCommand                ; $84 IF
>1e40	8d 26					.word	EndIf                    ; $85 ENDIF
>1e42	e6 24					.word	Command_DO               ; $86 DO
>1e44	fe 24					.word	Command_LOOP             ; $87 LOOP
>1e46	ef 15					.word	NoExec08                 ; $88 PROC
>1e48	da 24					.word	Command_ENDPROC          ; $89 ENDPROC
>1e4a	07 25					.word	Command_FOR              ; $8a FOR
>1e4c	94 25					.word	Command_NEXT             ; $8b NEXT
>1e4e	70 15					.word	RUNEndOfLine             ; $8c [[END]]
>1e50	cc 15					.word	Command_Shift_Handler    ; $8d [[SHIFT]]
>1e52	86 26					.word	ElseCode                 ; $8e ELSE
>1e54	ef 15					.word	NoExec01                 ; $8f THEN
>1e56	ef 15					.word	NoExec02                 ; $90 TO
>1e58	ef 15					.word	NoExec03                 ; $91 STEP
>1e5a	17 13					.word	CommandLET               ; $92 LET
>1e5c	6c 12					.word	Command_Print            ; $93 PRINT
>1e5e	65 12					.word	Command_Input            ; $94 INPUT
>1e60	9e 24					.word	Command_CALL             ; $95 CALL
>1e62	da 15					.word	Command_Sys              ; $96 SYS
>1e64	e5 14					.word	Command_REM              ; $97 REM
>1e66	ef 24					.word	Command_EXIT             ; $98 EXIT
>1e68	ef 15					.word	NoExec04                 ; $99 ,
>1e6a	ef 15					.word	NoExec05                 ; $9a ;
>1e6c	ef 15					.word	NoExec06                 ; $9b :
>1e6e	e5 14					.word	Command_REM2             ; $9c '
>1e70	ef 15					.word	NoExec07                 ; $9d )
>1e72	0e 12					.word	Command_Poke             ; $9e POKE
>1e74	0b 12					.word	Command_Doke             ; $9f DOKE
>1e76	71 14					.word	Command_READ             ; $a0 READ
>1e78	d8 14					.word	Command_DATA             ; $a1 DATA
>1e7a	0d 10					.word	Command_AssemblerStart   ; $a2 [
>1e7c	ea 2b					.word	NotImplemented           ; $a3 ]
>1e7e	ea 2b					.word	NotImplemented           ; $a4 #
>1e80	ea 2b					.word	NotImplemented           ; $a5 .
>1e82	ea 2b					.word	NotImplemented           ; $a6
>1e84	ea 2b					.word	NotImplemented           ; $a7
>1e86	ea 2b					.word	NotImplemented           ; $a8
>1e88	ea 2b					.word	NotImplemented           ; $a9
>1e8a	ea 2b					.word	NotImplemented           ; $aa
>1e8c	ea 2b					.word	NotImplemented           ; $ab
>1e8e	ea 2b					.word	NotImplemented           ; $ac
>1e90	ea 2b					.word	NotImplemented           ; $ad
>1e92	ea 2b					.word	NotImplemented           ; $ae
>1e94	ea 2b					.word	NotImplemented           ; $af
>1e96	ea 2b					.word	NotImplemented           ; $b0
>1e98	ea 2b					.word	NotImplemented           ; $b1
>1e9a	ea 2b					.word	NotImplemented           ; $b2
>1e9c	ea 2b					.word	NotImplemented           ; $b3
>1e9e	ea 2b					.word	NotImplemented           ; $b4
>1ea0	ea 2b					.word	NotImplemented           ; $b5
>1ea2	ea 2b					.word	NotImplemented           ; $b6
>1ea4	ea 2b					.word	NotImplemented           ; $b7
>1ea6	ea 2b					.word	NotImplemented           ; $b8
>1ea8	ea 2b					.word	NotImplemented           ; $b9
>1eaa	ea 2b					.word	NotImplemented           ; $ba
>1eac	ea 2b					.word	NotImplemented           ; $bb
>1eae	ea 2b					.word	NotImplemented           ; $bc
>1eb0	ea 2b					.word	NotImplemented           ; $bd
>1eb2	ea 2b					.word	NotImplemented           ; $be
>1eb4	ea 2b					.word	NotImplemented           ; $bf
>1eb6	ea 2b					.word	NotImplemented           ; $c0
>1eb8	ea 2b					.word	NotImplemented           ; $c1
>1eba	ea 2b					.word	NotImplemented           ; $c2
>1ebc	ea 2b					.word	NotImplemented           ; $c3
>1ebe	ea 2b					.word	NotImplemented           ; $c4
>1ec0	ea 2b					.word	NotImplemented           ; $c5
>1ec2	ea 2b					.word	NotImplemented           ; $c6
>1ec4	ea 2b					.word	NotImplemented           ; $c7
>1ec6	ea 2b					.word	NotImplemented           ; $c8
>1ec8	ea 2b					.word	NotImplemented           ; $c9
>1eca	ea 2b					.word	NotImplemented           ; $ca
>1ecc	ea 2b					.word	NotImplemented           ; $cb
>1ece	ea 2b					.word	NotImplemented           ; $cc
>1ed0	ea 2b					.word	NotImplemented           ; $cd
>1ed2	ea 2b					.word	NotImplemented           ; $ce
>1ed4	ea 2b					.word	NotImplemented           ; $cf
>1ed6	ea 2b					.word	NotImplemented           ; $d0
>1ed8	ea 2b					.word	NotImplemented           ; $d1
>1eda	ea 2b					.word	NotImplemented           ; $d2
>1edc	ea 2b					.word	NotImplemented           ; $d3
>1ede	ea 2b					.word	NotImplemented           ; $d4
>1ee0	5d 19					.word	EXPUnaryDeek             ; $d5 DEEK(
>1ee2	4f 19					.word	EXPUnaryPeek             ; $d6 PEEK(
>1ee4	9b 1a					.word	EXPUnaryRight            ; $d7 RIGHT$(
>1ee6	8e 1a					.word	EXPUnaryLeft             ; $d8 LEFT$(
>1ee8	b5 1a					.word	EXPUnaryMid              ; $d9 MID$(
>1eea	4b 1a					.word	EXPUnaryStr              ; $da STR$(
>1eec	17 1b					.word	EXPUnaryVal              ; $db VAL(
>1eee	18 1a					.word	EXPUnarySgn              ; $dc SGN(
>1ef0	c9 18					.word	EXPUnaryAbs              ; $dd ABS(
>1ef2	9d 19					.word	EXPUnaryLen              ; $de LEN(
>1ef4	2e 1a					.word	EXPUnarySqr              ; $df SQR(
>1ef6	ed 18					.word	EXPUnaryChr              ; $e0 CHR$(
>1ef8	d7 18					.word	EXPUnaryAsc              ; $e1 ASC(
>1efa	7f 19					.word	EXPUnaryInkey            ; $e2 INKEY$(
>1efc	ea 2b					.word	NotImplemented           ; $e3 EVENT(
>1efe	ea 2b					.word	NotImplemented           ; $e4 TIME
>1f00	93 19					.word	EXPUnaryInt              ; $e5 INT(
>1f02	75 19					.word	EXPUnaryFrac             ; $e6 FRAC(
>1f04	fe 18					.word	EXPUnaryDec              ; $e7 DEC(
>1f06	3d 1a					.word	EXPUnaryHex              ; $e8 HEX$(
>1f08	b2 19					.word	EXPUnaryRnd              ; $e9 RND(
>1f0a	c2 19					.word	ExpUnaryRand             ; $ea RAND(
>1f0c	ab 19					.word	EXPUnaryParenthesis      ; $eb (
>1f0e	d3 18					.word	EXPUnaryNull             ; $ec &
>1f10	4c 19					.word	EXPUnaryInlineDec        ; $ed [[DECIMAL]]
>1f12	73 1a					.word	EXPUnaryInlineString     ; $ee [[STRING]]
>1f14	ac 16					.word	EXPCompareEqual          ; $ef =
>1f16	c7 16					.word	EXPCompareNotEqual       ; $f0 <>
>1f18	d0 16					.word	EXPCompareLessEqual      ; $f1 <=
>1f1a	b5 16					.word	EXPCompareLess           ; $f2 <
>1f1c	d9 16					.word	EXPCompareGreaterEqual   ; $f3 >=
>1f1e	be 16					.word	EXPCompareGreater        ; $f4 >
>1f20	59 16					.word	EXPBinXor                ; $f5 XOR
>1f22	4d 16					.word	EXPBinOr                 ; $f6 OR
>1f24	41 16					.word	EXPBinAnd                ; $f7 AND
>1f26	19 16					.word	EXPBinIDiv               ; $f8 DIV
>1f28	2a 16					.word	EXPBinIMod               ; $f9 MOD
>1f2a	24 17					.word	EXPBinLeft               ; $fa <<
>1f2c	2c 17					.word	EXPBinRight              ; $fb >>
>1f2e	0d 16					.word	EXPBinFDiv               ; $fc /
>1f30	04 16					.word	EXPBinMul                ; $fd *
>1f32	fb 15					.word	EXPBinSub                ; $fe -
>1f34	f2 15					.word	EXPBinAdd                ; $ff +
.1f36					AlternateVectorTable:
>1f36	7b 10					.word	Command_CLEAR            ; $8d80 CLEAR
>1f38	68 14					.word	Command_NEW              ; $8d81 NEW
>1f3a	64 15					.word	Command_RUN              ; $8d82 RUN
>1f3c	d7 15					.word	Command_STOP             ; $8d83 STOP
>1f3e	d4 15					.word	Command_END              ; $8d84 END
>1f40	6d 10					.word	Command_ASSERT           ; $8d85 ASSERT
>1f42	91 13					.word	Command_LIST             ; $8d86 LIST
>1f44	58 2b					.word	Command_SAVE             ; $8d87 SAVE
>1f46	17 2b					.word	Command_LOAD             ; $8d88 LOAD
>1f48	4a 26					.word	Command_GOSUB            ; $8d89 GOSUB
>1f4a	35 12					.word	Command_GOTO             ; $8d8a GOTO
>1f4c	58 26					.word	Command_RETURN           ; $8d8b RETURN
>1f4e	36 15					.word	Command_RESTORE          ; $8d8c RESTORE
>1f50	ef 10					.word	CommandDIM               ; $8d8d DIM
>1f52	ae 2a					.word	Command_DIR              ; $8d8e DIR
>1f54	eb 2a					.word	Command_ERASE            ; $8d8f ERASE
>1f56	f2 14					.word	Command_RENUMBER         ; $8d90 RENUMBER

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/detokenise.asm

.1f58					TOKDetokenise:
.1f58	86 28		stx $28				stx 	zTemp2 						; save tokenised code in zTemp2
.1f5a	84 29		sty $29				sty 	zTemp2+1
.1f5c	9c 18 05	stz $0518			stz		TOKLastCharacter 			; clear last character
.1f5f					_TOKDLoop:
.1f5f	20 a4 1f	jsr $1fa4			jsr 	TOKDGet 					; get next
.1f62	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ			; end of line
.1f64	f0 3c		beq $1fa2			beq 	_TOKDExit
.1f66	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ		; is it a string/integer with additional data.
.1f68	f0 33		beq $1f9d			beq 	_TOKDDataItem
.1f6a	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ
.1f6c	f0 2f		beq $1f9d			beq 	_TOKDDataItem
.1f6e	c9 ec		cmp #$ec			cmp 	#PR_AMPERSAND 				; & is a special case.
.1f70	f0 19		beq $1f8b			beq 	_TOKAmpersand
.1f72	c9 00		cmp #$00			cmp 	#0 							; is it a token 80-FF
.1f74	10 05		bpl $1f7b			bpl 	_TOKDNotToken
.1f76	20 6a 20	jsr $206a			jsr 	TOKDToken 					; token to text.
.1f79	80 e4		bra $1f5f			bra 	_TOKDLoop
.1f7b					_TOKDNotToken:
.1f7b	c9 40		cmp #$40			cmp 	#$40  						; 40-7F Identifier
.1f7d	90 05		bcc $1f84			bcc 	_TOKDNotIdentifier
.1f7f	20 e1 1f	jsr $1fe1			jsr 	TOKDIdentifier
.1f82	80 db		bra $1f5f			bra 	_TOKDLoop
.1f84					_TOKDNotIdentifier:
.1f84	a0 0a		ldy #$0a			ldy 	#10
.1f86	20 24 20	jsr $2024			jsr 	TOKDInteger
.1f89	80 d4		bra $1f5f			bra 	_TOKDLoop
.1f8b					_TOKAmpersand:
.1f8b	20 ac 20	jsr $20ac			jsr 	TOKDSpaceLastAlpha  		; space if last alpha
.1f8e	a9 26		lda #$26			lda 	#"&" 						; output hex marker
.1f90	20 ad 1f	jsr $1fad			jsr 	TOKDOutput
.1f93	20 a4 1f	jsr $1fa4			jsr 	TOKDGet 					; get first char of integer
.1f96	a0 10		ldy #$10			ldy 	#16 						; expand in base 16
.1f98	20 24 20	jsr $2024			jsr 	TOKDInteger
.1f9b	80 c2		bra $1f5f			bra 	_TOKDLoop
.1f9d					_TOKDDataItem:
.1f9d	20 ba 1f	jsr $1fba			jsr 	TOKDDataItem
.1fa0	80 bd		bra $1f5f			bra 	_TOKDLoop
.1fa2					_TOKDExit:
.1fa2	18		clc				clc
.1fa3	60		rts				rts
.1fa4	b2 28		lda ($28)	TOKDGet:lda 	(zTemp2)
.1fa6	e6 28		inc $28				inc 	zTemp2
.1fa8	d0 02		bne $1fac			bne 	_TKDGExit
.1faa	e6 29		inc $29				inc 	zTemp2+1
.1fac					_TKDGExit:
.1fac	60		rts				rts
.1fad					TOKDOutput:
.1fad	8d 18 05	sta $0518			sta 	TOKLastCharacter
.1fb0	6c 16 05	jmp ($0516)			jmp 	(TOKOutputMethod)
.1fb3					TOKSetDetokeniseOutput:
.1fb3	8e 16 05	stx $0516			stx 	TOKOutputMethod
.1fb6	8c 17 05	sty $0517			sty 	TOKOutputMethod+1
.1fb9	60		rts				rts
.0516					TOKOutputMethod:
>0516							.fill 	2
.0518					TOKLastCharacter:
>0518							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkdataitem.asm

.1fba					TOKDDataItem:
.1fba	a8		tay				tay 								; type in Y
.1fbb	a9 22		lda #$22			lda 	#'"'						; start with " or .
.1fbd	c0 ee		cpy #$ee			cpy 	#PR_LSQLSQSTRINGRSQRSQ
.1fbf	f0 02		beq $1fc3			beq 	_TOKDDIsString
.1fc1	a9 2e		lda #$2e			lda 	#'.'
.1fc3					_TOKDDIsString:
.1fc3	20 ad 1f	jsr $1fad			jsr 	TOKDOutput 					; dump it
.1fc6	20 a4 1f	jsr $1fa4			jsr 	TOKDGet 					; get length into X
.1fc9	aa		tax				tax
.1fca					_TOKDDOutput:
.1fca	ca		dex				dex 								; are we complete
.1fcb	e0 ff		cpx #$ff			cpx 	#255
.1fcd	f0 08		beq $1fd7			beq 	_TOKDDEnd
.1fcf	20 a4 1f	jsr $1fa4			jsr 	TOKDGet 					; get character and output it
.1fd2	20 ad 1f	jsr $1fad			jsr 	TOKDOutput
.1fd5	80 f3		bra $1fca			bra 	_TOKDDOutput
.1fd7					_TOKDDEnd:
.1fd7	c0 ee		cpy #$ee			cpy 	#PR_LSQLSQSTRINGRSQRSQ 		; if string, do closing quote
.1fd9	d0 05		bne $1fe0			bne 	_TOKDDNotString
.1fdb	a9 22		lda #$22			lda 	#'"'
.1fdd	20 ad 1f	jsr $1fad			jsr 	TOKDOutput
.1fe0					_TOKDDNotString:
.1fe0	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkidentifier.asm

.1fe1					TOKDIdentifier:
.1fe1	a0 ff		ldy #$ff			ldy 	#$FF
.1fe3	8c 19 05	sty $0519			sty 	TOKDIFirstChar
.1fe6					_TOKDLoop:
.1fe6	a8		tay				tay 								; token in Y
.1fe7	a9 5f		lda #$5f			lda 	#'_' 						; handle _
.1fe9	c0 64		cpy #$64			cpy 	#$64
.1feb	f0 0b		beq $1ff8			beq 	_TOKDIOutput
.1fed	98		tya				tya 								; handle a-z
.1fee	18		clc				clc
.1fef	69 21		adc #$21			adc	 	#$21
.1ff1	c0 5a		cpy #$5a			cpy 	#$5A
.1ff3	90 03		bcc $1ff8			bcc 	_TOKDIOutput
.1ff5	38		sec				sec 								; handle 0-9
.1ff6	e9 4b		sbc #$4b			sbc 	#$4B
.1ff8					_TOKDIOutput:
.1ff8	2c 19 05	bit $0519			bit 	TOKDIFirstChar
.1ffb	10 08		bpl $2005			bpl 	_TOKDINoSpacing
.1ffd	48		pha				pha
.1ffe	20 a7 20	jsr $20a7			jsr 	TOKDSpacing
.2001	9c 19 05	stz $0519			stz 	TOKDIFirstChar
.2004	68		pla				pla
.2005					_TOKDINoSpacing:
.2005	20 ad 1f	jsr $1fad			jsr 	TOKDOutput
.2008	20 a4 1f	jsr $1fa4			jsr 	TOKDGet 					; get next token
.200b	c9 7c		cmp #$7c			cmp 	#$7C
.200d	90 d7		bcc $1fe6			bcc 	_TOKDLoop
.200f	f0 12		beq $2023			beq 	_TOKDIExit 					; it's a number, no tail.
.2011	4a		lsr a				lsr 	a 							; string ?
.2012	90 07		bcc $201b			bcc 	_TOKDICheckArray
.2014	48		pha				pha
.2015	a9 24		lda #$24			lda 	#"$"
.2017	20 ad 1f	jsr $1fad			jsr 	TOKDOutput
.201a	68		pla				pla
.201b					_TOKDICheckArray:
.201b	4a		lsr a				lsr 	a 							; array ?
.201c	90 05		bcc $2023			bcc 	_TOKDIExit
.201e	a9 28		lda #$28			lda 	#"("
.2020	20 ad 1f	jsr $1fad			jsr 	TOKDOutput
.2023					_TOKDIExit:
.2023	60		rts				rts
.0519					TOKDIFirstChar:
>0519							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkinteger.asm

.2024					TOKDInteger:
.2024	5a		phy				phy 								; save base
.2025	a2 08		ldx #$08			ldx 	#IFR0 						; set into R0
.2027	20 16 34	jsr $3416			jsr 	IFloatSetByte
.202a					_TOKDILoop:
.202a	b2 28		lda ($28)			lda 	(zTemp2) 					; followed by a 00-3F
.202c	c9 40		cmp #$40			cmp 	#$40
.202e	b0 1d		bcs $204d			bcs 	_TOKDIHaveInteger
.2030	a2 08		ldx #$08			ldx 	#IFR0 						; R0 << 6
.2032	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.2035	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.2038	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.203b	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.203e	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.2041	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.2044	20 a4 1f	jsr $1fa4			jsr 	TOKDGet 					; OR byte in.
.2047	05 08		ora $08				ora 	IFR0+IM0
.2049	85 08		sta $08				sta 	IFR0+IM0
.204b	80 dd		bra $202a			bra 	_TOKDILoop
.204d					_TOKDIHaveInteger:
.204d	7a		ply				ply 								; restore base
.204e	98		tya				tya 								; base in A
.204f	20 b6 31	jsr $31b6			jsr 	IFloatIntegerToStringR0
.2052	86 24		stx $24				stx 	zTemp0
.2054	84 25		sty $25				sty 	zTemp0+1
.2056	b2 24		lda ($24)			lda 	(zTemp0)
.2058	a0 01		ldy #$01			ldy 	#1 							; output buffer.
.205a	b1 24		lda ($24),y			lda 	(zTemp0),y
.205c	20 a7 20	jsr $20a7			jsr 	TOKDSpacing 				; check spacing okay.
.205f					_TOKDOutput:
.205f	b1 24		lda ($24),y			lda 	(zTemp0),y
.2061	20 ad 1f	jsr $1fad			jsr 	TOKDOutput
.2064	c8		iny				iny
.2065	b1 24		lda ($24),y			lda 	(zTemp0),y
.2067	d0 f6		bne $205f			bne 	_TOKDOutput
.2069	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtktoken.asm

.206a					TOKDToken:
.206a	a2 56		ldx #$56			ldx 	#StandardTokens & $FF 		; standard table
.206c	a0 1c		ldy #$1c			ldy 	#StandardTokens >> 8
.206e	c9 8d		cmp #$8d			cmp 	#PR_LSQLSQSHIFTRSQRSQ 		; is it the shift token ?
.2070	d0 07		bne $2079			bne 	_TOKDSearch
.2072	20 a4 1f	jsr $1fa4			jsr 	TOKDGet 					; get next
.2075	a2 d7		ldx #$d7			ldx 	#AlternateTokens & $FF 		; alt table
.2077	a0 1d		ldy #$1d			ldy 	#AlternateTokens >> 8
.2079					_TOKDSearch:
.2079	86 24		stx $24				stx 	zTemp0 						; put table in zTemp0
.207b	84 25		sty $25				sty 	zTemp0+1
.207d	aa		tax				tax 								; token ID in X.
.207e					_TOKDFind:
.207e	ca		dex				dex 								; reached the start
.207f	10 0d		bpl $208e			bpl 	_TOKDFound
.2081	38		sec				sec 								; go to next entry
.2082	b2 24		lda ($24)			lda 	(zTemp0)
.2084	65 24		adc $24				adc 	zTemp0
.2086	85 24		sta $24				sta 	zTemp0
.2088	90 f4		bcc $207e			bcc 	_TOKDFind
.208a	e6 25		inc $25				inc 	zTemp0+1
.208c	80 f0		bra $207e			bra 	_TOKDFind
.208e					_TOKDFound:
.208e	b2 24		lda ($24)			lda 	(zTemp0) 					; length to X
.2090	f0 14		beq $20a6			beq 	_TOKDExit
.2092	aa		tax				tax
.2093	a0 01		ldy #$01			ldy 	#1 							; output the token.
.2095	b1 24		lda ($24),y			lda 	(zTemp0),y 					; check spacing first character,
.2097	20 a7 20	jsr $20a7			jsr 	TOKDSpacing
.209a					_TOKDOutput:
.209a	b1 24		lda ($24),y			lda 	(zTemp0),y
.209c	20 5d 24	jsr $245d			jsr 	TOKToLower
.209f	20 ad 1f	jsr $1fad			jsr 	TOKDOutput
.20a2	c8		iny				iny
.20a3	ca		dex				dex
.20a4	d0 f4		bne $209a			bne 	_TOKDOutput
.20a6					_TOKDExit:
.20a6	60		rts				rts
.20a7					TOKDSpacing:
.20a7	20 74 24	jsr $2474			jsr 	TOKIsIdentifierElement		; next character alphanumeric
.20aa	90 0d		bcc $20b9			bcc 	TOKDSExit
.20ac					TOKDSpaceLastAlpha:
.20ac	ad 18 05	lda $0518			lda 	TOKLastCharacter			; and last character also alphanumeric
.20af	20 74 24	jsr $2474			jsr 	TOKIsIdentifierElement
.20b2	90 05		bcc $20b9			bcc 	TOKDSExit
.20b4	a9 20		lda #$20			lda 	#" " 						; we need a space.
.20b6	20 ad 1f	jsr $1fad			jsr 	TOKDOutput
.20b9					TOKDSExit:
.20b9	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/editing/delete.asm

.20ba					PGMDeleteLine:
.20ba	20 6d 21	jsr $216d			jsr 	PGMEndProgram 				; end of program into zTemp0
.20bd	64 26		stz $26				stz 	zTemp1						; copy base address of code to zTemp1
.20bf	ad 1a 05	lda $051a			lda 	PGMBaseHigh
.20c2	85 27		sta $27				sta 	zTemp1+1
.20c4					_PGMDLoop:
.20c4	b2 26		lda ($26)			lda 	(zTemp1) 					; finished, not found ?
.20c6	38		sec				sec
.20c7	f0 3a		beq $2103			beq 	_PGMDExit
.20c9	a0 01		ldy #$01			ldy 	#1 							; found line number ?
.20cb	b1 26		lda ($26),y			lda 	(zTemp1),y
.20cd	cd 01 04	cmp $0401			cmp 	TOKLineNumber
.20d0	d0 08		bne $20da			bne 	_PGMDNext
.20d2	c8		iny				iny
.20d3	b1 26		lda ($26),y			lda 	(zTemp1),y
.20d5	cd 02 04	cmp $0402			cmp 	TOKLineNumber+1
.20d8	f0 0d		beq $20e7			beq 	_PGMDDelete
.20da					_PGMDNext:
.20da	18		clc				clc
.20db	b2 26		lda ($26)			lda 	(zTemp1)
.20dd	65 26		adc $26				adc 	zTemp1
.20df	85 26		sta $26				sta 	zTemp1
.20e1	90 e1		bcc $20c4			bcc 	_PGMDLoop
.20e3	e6 27		inc $27				inc 	zTemp1+1
.20e5	80 dd		bra $20c4			bra 	_PGMDLoop
.20e7					_PGMDDelete:
.20e7	b2 26		lda ($26)			lda 	(zTemp1) 					; offset to next in Y
.20e9	a8		tay				tay
.20ea					_PGMDCopy:
.20ea	b1 26		lda ($26),y			lda 	(zTemp1),y 					; copy down.
.20ec	92 26		sta ($26)			sta 	(zTemp1)
.20ee	a5 26		lda $26				lda 	zTemp1 						; reached the end ?
.20f0	c5 24		cmp $24				cmp 	zTemp0
.20f2	d0 07		bne $20fb			bne 	_PGMDNext2
.20f4	a5 27		lda $27				lda 	zTemp1+1
.20f6	c5 25		cmp $25				cmp 	zTemp0+1
.20f8	18		clc				clc
.20f9	f0 08		beq $2103			beq 	_PGMDExit
.20fb					_PGMDNext2:
.20fb	e6 26		inc $26				inc 	zTemp1 						; advance pointer.
.20fd	d0 eb		bne $20ea			bne 	_PGMDCopy
.20ff	e6 27		inc $27				inc 	zTemp1+1
.2101	80 e7		bra $20ea			bra 	_PGMDCopy
.2103					_PGMDExit:
.2103	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/editing/insert.asm

.2104					PGMInsertLine:
.2104	20 6d 21	jsr $216d			jsr 	PGMEndProgram 				; end of program into zTemp0
.2107	64 26		stz $26				stz 	zTemp1						; copy base address of code to zTemp1
.2109	ad 1a 05	lda $051a			lda 	PGMBaseHigh
.210c	85 27		sta $27				sta 	zTemp1+1
.210e					_PGMILoop:
.210e	b2 26		lda ($26)			lda 	(zTemp1) 					; reached the end, it goes here on the end.
.2110	f0 1c		beq $212e			beq 	_PGMIInsert
.2112	a0 01		ldy #$01			ldy 	#1 							; compare in-program line vs token line.
.2114	b1 26		lda ($26),y			lda 	(zTemp1),y
.2116	cd 01 04	cmp $0401			cmp 	TOKLineNumber
.2119	c8		iny				iny
.211a	b1 26		lda ($26),y			lda 	(zTemp1),y
.211c	ed 02 04	sbc $0402			sbc 	TOKLineNumber+1
.211f	b0 0d		bcs $212e			bcs 	_PGMIInsert 				; insert here.
.2121	18		clc				clc
.2122	b2 26		lda ($26)			lda 	(zTemp1)
.2124	65 26		adc $26				adc 	zTemp1
.2126	85 26		sta $26				sta 	zTemp1
.2128	90 e4		bcc $210e			bcc 	_PGMILoop
.212a	e6 27		inc $27				inc 	zTemp1+1
.212c	80 e0		bra $210e			bra 	_PGMILoop
.212e					_PGMIInsert:
.212e	ac 00 04	ldy $0400			ldy 	TOKLineSize 				; space required
.2131					_PGMIInsertLoop:
.2131	b2 24		lda ($24)			lda 	(zTemp0)
.2133	91 24		sta ($24),y			sta 	(zTemp0),y
.2135	a5 26		lda $26				lda 	zTemp1 						; reached insert point
.2137	c5 24		cmp $24				cmp 	zTemp0
.2139	d0 06		bne $2141			bne 	_PGMINext
.213b	a5 27		lda $27				lda 	zTemp1+1
.213d	c5 25		cmp $25				cmp 	zTemp0+1
.213f	f0 0a		beq $214b			beq 	_PGMIInserted
.2141					_PGMINext:
.2141	a5 24		lda $24				lda 	zTemp0
.2143	d0 02		bne $2147			bne 	_PGMINoBorrow
.2145	c6 25		dec $25				dec 	zTemp0+1
.2147					_PGMINoBorrow:
.2147	c6 24		dec $24				dec 	zTemp0
.2149	80 e6		bra $2131			bra 	_PGMIInsertLoop
.214b					_PGMIInserted:
.214b	a0 00		ldy #$00			ldy 	#0 							; copy tokenbuffer to insert point
.214d					_PGMICopyLoop:
.214d	b9 00 04	lda $0400,y			lda 	TOKLineSize,y
.2150	91 26		sta ($26),y			sta 	(zTemp1),y
.2152	c8		iny				iny
.2153	cc 00 04	cpy $0400			cpy 	TOKLineSize
.2156	d0 f5		bne $214d			bne 	_PGMICopyLoop
.2158	18		clc				clc
.2159	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/setup.asm

.215a					PGMSetBaseAddress:
.215a	8e 1a 05	stx $051a			stx 	PGMBaseHigh 				; use memory from here
.215d	8c 1b 05	sty $051b			sty 	PGMEndMemoryHigh 			; to here.
.2160	60		rts				rts
.2161					PGMNewProgram:
.2161	64 24		stz $24				stz 	zTemp0						; copy base address to zTemp0
.2163	ad 1a 05	lda $051a			lda 	PGMBaseHigh
.2166	85 25		sta $25				sta 	zTemp0+1
.2168	a9 00		lda #$00			lda 	#0 							; overwrite the offset to zero.
.216a	92 24		sta ($24)			sta 	(zTemp0)
.216c	60		rts				rts
.216d					PGMEndProgram:
.216d	64 24		stz $24				stz 	zTemp0 						; copy base address to zTemp0
.216f	ad 1a 05	lda $051a			lda 	PGMBaseHigh
.2172	85 25		sta $25				sta 	zTemp0+1
.2174					_PGMEPLoop:
.2174	b2 24		lda ($24)			lda 	(zTemp0) 					; reached end ?
.2176	f0 0b		beq $2183			beq 	_PGMEPExit
.2178	18		clc				clc 								; no, advance to next
.2179	65 24		adc $24				adc 	zTemp0
.217b	85 24		sta $24				sta 	zTemp0
.217d	90 f5		bcc $2174			bcc 	_PGMEPLoop
.217f	e6 25		inc $25				inc 	zTemp0+1
.2181	80 f1		bra $2174			bra 	_PGMEPLoop
.2183					_PGMEPExit:
.2183	60		rts				rts
.051a					PGMBaseHigh:
>051a							.fill 	1
.051b					PGMEndMemoryHigh:
>051b							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokbuffer.asm

.2184					TOKResetElement:
.2184	9c 1c 05	stz $051c			stz 	TOKElement
.2187	60		rts				rts
.2188					TOKWriteElement:
.2188	da		phx				phx
.2189	ae 1c 05	ldx $051c			ldx 	TOKElement
.218c	9d 1d 05	sta $051d,x			sta 	TOKElementText,x
.218f	9e 1e 05	stz $051e,x			stz 	TOKElementText+1,x
.2192	fa		plx				plx
.2193	ee 1c 05	inc $051c			inc 	TOKElement
.2196	60		rts				rts
.051c					TOKElement:
>051c							.fill 	1
.051d					TOKElementText:
>051d							.fill 	255

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokconstant.asm

.2197					TOKTokeniseConstant:
.2197	a5 08		lda $08				lda 	IFR0+IM0 					; check > 64
.2199	48		pha				pha 								; save on stack
.219a	29 c0		and #$c0			and 	#$C0
.219c	05 09		ora $09				ora 	IFR0+IM1
.219e	05 0a		ora $0a				ora 	IFR0+IM2
.21a0	f0 10		beq $21b2			beq 	_TTCLess
.21a2	da		phx				phx
.21a3	a2 06		ldx #$06			ldx 	#6 							; divide by 64
.21a5					_TTCShiftRight:
.21a5	46 0a		lsr $0a				lsr 	IFR0+IM2
.21a7	66 09		ror $09				ror 	IFR0+IM1
.21a9	66 08		ror $08				ror 	IFR0+IM0
.21ab	ca		dex				dex
.21ac	d0 f7		bne $21a5			bne 	_TTCShiftRight
.21ae	fa		plx				plx
.21af	20 97 21	jsr $2197			jsr 	TOKTokeniseConstant
.21b2					_TTCLess:
.21b2	68		pla				pla
.21b3	29 3f		and #$3f			and 	#$3F 						; lower 6 bits
.21b5	20 55 22	jsr $2255			jsr 	TOKWriteA
.21b8	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokdecimal.asm

.21b9					TOKTokeniseDecimals:
.21b9	20 68 22	jsr $2268			jsr 	TOKGetNext 					; consume the .
.21bc	20 e1 23	jsr $23e1			jsr 	TOKExtractInteger 			; pull an integer out as text.
.21bf	a9 ed		lda #$ed			lda 	#PR_LSQLSQDECIMALRSQRSQ	 	; decimal token
.21c1	20 55 22	jsr $2255			jsr 	TOKWriteA
.21c4	20 c9 21	jsr $21c9			jsr 	TOKOutputElementBuffer 		; then the buffer
.21c7	18		clc				clc
.21c8	60		rts				rts
.21c9					TOKOutputElementBuffer:
.21c9	ad 1c 05	lda $051c			lda 	TOKElement 					; get count and write that
.21cc	20 55 22	jsr $2255			jsr 	TOKWriteA
.21cf	a8		tay				tay 								; put in Y
.21d0	f0 0c		beq $21de			beq 	_TOEExit 					; exit if empty which is okay.
.21d2	a2 01		ldx #$01			ldx 	#1
.21d4					_TOELoop:
.21d4	bd 1c 05	lda $051c,x			lda 	TOKElement,x
.21d7	20 55 22	jsr $2255			jsr 	TOKWriteA
.21da	e8		inx				inx
.21db	88		dey				dey
.21dc	d0 f6		bne $21d4			bne 	_TOELoop
.21de					_TOEExit:
.21de	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokenise.asm

.21df					TOKTokenise:
.21df	8c 1d 06	sty $061d			sty 	TOKDataSource+1 			; save source routine pointer
.21e2	8e 1c 06	stx $061c			stx 	TOKDataSource
.21e5	a9 01		lda #$01			lda 	#1 							; set first element flag.
.21e7	8d 1e 06	sta $061e			sta 	TOKIsFirstElement
.21ea	a9 03		lda #$03			lda 	#3 							; set the line length to three for the
.21ec	8d 00 04	sta $0400			sta 	TOKLineSize 				; line length itself and the line numbers.
.21ef	9c 01 04	stz $0401			stz 	TOKLineNumber
.21f2	9c 02 04	stz $0402			stz 	TOKLineNumber+1
.21f5					_TOKMainLoop:
.21f5	20 64 22	jsr $2264			jsr 	TOKGet 						; what follows.
.21f8	c9 00		cmp #$00			cmp 	#0 							; if zero, we are complete
.21fa	f0 50		beq $224c			beq 	_TOKExit
.21fc	c9 20		cmp #$20			cmp 	#' '						; space, consume and loop back.
.21fe	d0 05		bne $2205			bne 	_TOKElement
.2200	20 68 22	jsr $2268			jsr 	TOKGetNext
.2203	80 f0		bra $21f5			bra 	_TOKMainLoop
.2205					_TOKElement:
.2205	20 68 24	jsr $2468			jsr 	TOKIsDigit 					; is it 0..9
.2208	90 16		bcc $2220			bcc 	_TOKNotDigit
.220a	20 b8 23	jsr $23b8			jsr 	TOKTokeniseInteger 			; get integer
.220d	b0 44		bcs $2253			bcs 	_TOKFail 					; did it fail ?
.220f	9c 1e 06	stz $061e			stz 	TOKIsFirstElement 			; clear first element flag
.2212	20 64 22	jsr $2264			jsr 	TOKGet 						; what follows ?
.2215	c9 2e		cmp #$2e			cmp 	#"."						; is it decimal e.g. .012345 etc.
.2217	d0 dc		bne $21f5			bne 	_TOKMainLoop
.2219	20 b9 21	jsr $21b9			jsr 	TOKTokeniseDecimals
.221c	b0 35		bcs $2253			bcs 	_TOKFail
.221e	80 d5		bra $21f5			bra 	_TOKMainLoop
.2220					_TOKNotDigit:
.2220	9c 1e 06	stz $061e			stz 	TOKIsFirstElement 			; clear first element flag
.2223	c9 26		cmp #$26			cmp 	#"&"						; check for hexadecimal ?
.2225	d0 07		bne $222e			bne 	_TOKNotHex
.2227	20 be 22	jsr $22be			jsr 	TOKTokeniseHexadecimal
.222a	b0 27		bcs $2253			bcs 	_TOKFail
.222c	80 c7		bra $21f5			bra 	_TOKMainLoop
.222e					_TOKNotHex:
.222e	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.2230	d0 07		bne $2239			bne 	_TOKNotString
.2232	20 2f 24	jsr $242f			jsr 	TOKTokeniseString
.2235	b0 1c		bcs $2253			bcs 	_TOKFail
.2237	80 bc		bra $21f5			bra 	_TOKMainLoop
.2239					_TOKNotString:
.2239	20 81 24	jsr $2481			jsr 	TOKIsAlpha 					; identifier ?
.223c	b0 07		bcs $2245			bcs 	_TOKIdentifier
.223e	20 f5 23	jsr $23f5			jsr 	TOKTokenisePunctuation 		; punctuation
.2241	b0 10		bcs $2253			bcs 	_TOKFail
.2243	80 b0		bra $21f5			bra 	_TOKMainLoop
.2245					_TOKIdentifier:
.2245	20 fb 22	jsr $22fb			jsr 	TOKTokeniseIdentifier 		; identifier/token.
.2248	b0 09		bcs $2253			bcs 	_TOKFail
.224a	80 a9		bra $21f5			bra 	_TOKMainLoop
.224c					_TOKExit:
.224c	a9 8c		lda #$8c			lda 	#PR_LSQLSQENDRSQRSQ 		; write EOL
.224e	20 55 22	jsr $2255			jsr 	TOKWriteA
.2251	18		clc				clc									; return with carry set.
.2252	60		rts				rts
.2253					_TOKFail:
.2253	38		sec				sec
.2254	60		rts				rts
.2255					TOKWriteA:
.2255	da		phx				phx
.2256	ae 00 04	ldx $0400			ldx 	TOKLineSize
.2259	9d 00 04	sta $0400,x			sta 	TOKLineSize,x
.225c	9e 01 04	stz $0401,x			stz 	TOKLineSize+1,x 			; makes it look like a line on its own for RUN.
.225f	fa		plx				plx
.2260	ee 00 04	inc $0400			inc 	TOKLineSize
.2263	60		rts				rts
.2264					TOKGet:
.2264	18		clc				clc
.2265	6c 1c 06	jmp ($061c)			jmp 	(TOKDataSource)
.2268					TOKGetNext:
.2268	38		sec				sec
.2269	6c 1c 06	jmp ($061c)			jmp 	(TOKDataSource)
.061c					TOKDataSource:
>061c							.fill 	2
.061e					TOKIsFirstElement:
>061e							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokfind.asm

.226c					TOKFindToken:
.226c	a2 56		ldx #$56			ldx 	#StandardTokens & $FF 		; do this table
.226e	a0 1c		ldy #$1c			ldy 	#StandardTokens >> 8
.2270	20 88 22	jsr $2288			jsr 	TOKFindTokenXY 				; find it, or not
.2273	b0 0d		bcs $2282			bcs 	_TOKFound1
.2275	a2 d7		ldx #$d7			ldx 	#AlternateTokens & $FF 		; do the alternate table
.2277	a0 1d		ldy #$1d			ldy 	#AlternateTokens >> 8
.2279	20 88 22	jsr $2288			jsr 	TOKFindTokenXY 				; find it, or not
.227c	90 08		bcc $2286			bcc 	_TOKFTFail 					; not ....
.227e	a2 8d		ldx #$8d			ldx 	#PR_LSQLSQSHIFTRSQRSQ 		; shifted token
.2280	38		sec				sec
.2281	60		rts				rts
.2282					_TOKFound1:
.2282	a2 00		ldx #$00			ldx 	#0
.2284	38		sec				sec
.2285	60		rts				rts
.2286					_TOKFTFail
.2286	18		clc				clc
.2287	60		rts				rts
.2288					TOKFindTokenXY:
.2288	86 24		stx $24				stx 	zTemp0 						; save token table address
.228a	84 25		sty $25				sty 	zTemp0+1
.228c	a9 80		lda #$80			lda 	#$80 						; table starts at $80
.228e	8d 1f 06	sta $061f			sta 	TOKCurrent
.2291					_TOKFindLoop:
.2291	b2 24		lda ($24)			lda 	(zTemp0) 					; get token length from table
.2293	18		clc				clc 		 						; clear carry in case of fail
.2294	30 17		bmi $22ad			bmi 	_TOKExit 					; end of table, fail, so return CC.
.2296	cd 1c 05	cmp $051c			cmp 	TOKElement 					; compare against the element length
.2299	d0 13		bne $22ae			bne 	_TOKNext 					; different, try next.
.229b	aa		tax				tax 								; number of chars to compare.
.229c	a0 01		ldy #$01			ldy 	#1 							; offset to actual text.
.229e					_TOKCompare:
.229e	b1 24		lda ($24),y			lda 	(zTemp0),y 					; compare the characters
.22a0	d9 1c 05	cmp $051c,y			cmp 	TOKElementText-1,y
.22a3	d0 09		bne $22ae			bne 	_TOKNext 					; different ? try next
.22a5	c8		iny				iny 								; compare next two
.22a6	ca		dex				dex
.22a7	d0 f5		bne $229e			bne 	_TOKCompare 				; until done X characters.
.22a9	38		sec				sec
.22aa	ad 1f 06	lda $061f			lda 	TOKCurrent 					; return current ID.
.22ad					_TOKExit:
.22ad	60		rts				rts
.22ae					_TOKNext:
.22ae	ee 1f 06	inc $061f			inc 	TOKCurrent 					; increment token #
.22b1	38		sec				sec 								; add length+1 to ptr
.22b2	b2 24		lda ($24)			lda 	(zTemp0)
.22b4	65 24		adc $24				adc 	zTemp0
.22b6	85 24		sta $24				sta 	zTemp0
.22b8	90 d7		bcc $2291			bcc 	_TOKFindLoop
.22ba	e6 25		inc $25				inc 	zTemp0+1
.22bc	80 d3		bra $2291			bra 	_TOKFindLoop
.061f					TOKCurrent:
>061f							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokhexadecimal.asm

.22be					TOKTokeniseHexadecimal:
.22be	20 68 22	jsr $2268			jsr 	TOKGetNext 					; consume the $
.22c1	a2 08		ldx #$08			ldx 	#IFR0
.22c3	20 14 34	jsr $3414			jsr 	IFloatSetZero 				; set R0 = 0
.22c6					_TTHLoop:
.22c6	20 64 22	jsr $2264			jsr 	TOKGet 						; keep getting and copying while numeric.
.22c9	20 8e 24	jsr $248e			jsr 	TOKIsHexadecimal
.22cc	90 23		bcc $22f1			bcc 	_TTHDone
.22ce	a2 08		ldx #$08			ldx 	#IFR0 						; shift R0 right 4
.22d0	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.22d3	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.22d6	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.22d9	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.22dc	20 68 22	jsr $2268			jsr 	TOKGetNext
.22df	20 52 24	jsr $2452			jsr 	TOKToUpper 					; make U/C
.22e2	38		sec				sec 								; convert to decimal.
.22e3	e9 30		sbc #$30			sbc 	#48
.22e5	c9 0a		cmp #$0a			cmp 	#10
.22e7	90 02		bcc $22eb			bcc 	_TTHNotAlpha
.22e9	e9 07		sbc #$07			sbc 	#7
.22eb					_TTHNotAlpha:
.22eb	05 08		ora $08				ora 	IFR0+IM0 					; OR in
.22ed	85 08		sta $08				sta 	IFR0+IM0
.22ef	80 d5		bra $22c6			bra 	_TTHLoop
.22f1					_TTHDone:
.22f1	a9 ec		lda #$ec			lda 	#PR_AMPERSAND 				; write & function out
.22f3	20 55 22	jsr $2255			jsr 	TOKWriteA
.22f6	20 97 21	jsr $2197			jsr 	TOKTokeniseConstant 		; write integer out.
.22f9	18		clc				clc
.22fa	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokidentifier.asm

.22fb					TOKTokeniseIdentifier:
.22fb	20 84 21	jsr $2184			jsr 	TOKResetElement 			; extract an identifier
.22fe					_TOKGetIdentifier:
.22fe	20 64 22	jsr $2264			jsr 	TOKGet
.2301	20 52 24	jsr $2452			jsr 	TOKToUpper
.2304	20 74 24	jsr $2474			jsr 	TOKIsIdentifierElement
.2307	90 08		bcc $2311			bcc 	_TOKEndIdent
.2309	20 88 21	jsr $2188			jsr		TOKWriteElement
.230c	20 68 22	jsr $2268			jsr 	TOKGetNext
.230f	80 ed		bra $22fe			bra 	_TOKGetIdentifier
.2311					_TOKEndIdent:
.2311	c9 24		cmp #$24			cmp 	#"$" 						; last one $
.2313	d0 06		bne $231b			bne 	_TOKNotString
.2315	20 88 21	jsr $2188			jsr 	TOKWriteElement 			; add it
.2318	20 68 22	jsr $2268			jsr 	TOKGetNext 					; consume it
.231b					_TOKNotString:
.231b	20 64 22	jsr $2264			jsr 	TOKGet 						; finally check for (
.231e	c9 28		cmp #$28			cmp 	#"("
.2320	d0 06		bne $2328			bne 	_TOKNoArray
.2322	20 88 21	jsr $2188			jsr 	TOKWriteElement 			; add it
.2325	20 68 22	jsr $2268			jsr 	TOKGetNext 					; consume it
.2328					_TOKNoArray:
.2328	20 6c 22	jsr $226c			jsr 	TOKFindToken 				; find it
.232b	90 18		bcc $2345			bcc		_TOKIsVariable 				; it must be a variable or proc name if not found
.232d	c9 97		cmp #$97			cmp 	#PR_REM 					; is it REM ?
.232f	f0 0f		beq $2340			beq 	_TOKComment 				; yes, do comment code.
.2331	e0 8d		cpx #$8d			cpx 	#PR_LSQLSQSHIFTRSQRSQ 		; shifted token
.2333	d0 06		bne $233b			bne 	_TOKNoShift
.2335	48		pha				pha 								; write the shift.
.2336	8a		txa				txa
.2337	20 55 22	jsr $2255			jsr 	TOKWriteA
.233a	68		pla				pla
.233b					_TOKNoShift:
.233b	20 55 22	jsr $2255			jsr 	TOKWriteA 					; write the main token.
.233e	18		clc				clc
.233f	60		rts				rts
.2340					_TOKComment:
.2340	20 85 23	jsr $2385			jsr 	TOKDoComment
.2343	18		clc				clc
.2344	60		rts				rts
.2345					_TOKIsVariable:
.2345	a2 00		ldx #$00			ldx 	#0 							; output element buffer
.2347					_TOKOutputBuffer:
.2347	bd 1d 05	lda $051d,x			lda 	TOKElementText,x 			; output it translated.
.234a	20 73 23	jsr $2373			jsr 	TOKTranslateIdentifier
.234d	20 55 22	jsr $2255			jsr 	TOKWriteA
.2350	e8		inx				inx
.2351	bd 1d 05	lda $051d,x			lda 	TOKElementText,x
.2354	20 74 24	jsr $2474			jsr 	TOKIsIdentifierElement
.2357	b0 ee		bcs $2347			bcs 	_TOKOutputBuffer
.2359	a8		tay				tay 								; last char in Y
.235a	a9 7c		lda #$7c			lda 	#$7C 						; token is $7C
.235c	c0 00		cpy #$00			cpy 	#0 							; if no modifier use this
.235e	f0 0e		beq $236e			beq 	_TOKIVExit
.2360	c0 24		cpy #$24			cpy 	#'$'						; array mod ?
.2362	d0 04		bne $2368			bne 	_TOKIVCheckArray 			; no, check for (
.2364	1a		inc a				inc 	a 							; token is $7D
.2365	bc 1e 05	ldy $051e,x			ldy 	TOKElementText+1,x 			; get next one.
.2368					_TOKIVCheckArray:
.2368	c0 28		cpy #$28			cpy 	#'('						; is it ( ?
.236a	d0 02		bne $236e			bne 	_TOKIVExit 					; yes, then add 2 more, so 7C->7E and 7D->7F
.236c	1a		inc a				inc 	a
.236d	1a		inc a				inc 	a
.236e					_TOKIVExit:
.236e	20 55 22	jsr $2255			jsr 	TOKWriteA 					; ending token
.2371	18		clc				clc
.2372	60		rts				rts
.2373					TOKTranslateIdentifier:
.2373	c9 5f		cmp #$5f			cmp 	#"_" 						; _ is 0x64
.2375	f0 0b		beq $2382			beq 	_TTI64
.2377	38		sec				sec
.2378	e9 41		sbc #$41			sbc 	#"A" 						; map A-Z onto 0-25
.237a	10 03		bpl $237f			bpl 	_TTIExit
.237c	18		clc				clc 								; map 09 onto 26-35
.237d	69 2b		adc #$2b			adc 	#"A"-"0"+26
.237f					_TTIExit:
.237f	09 40		ora #$40			ora 	#$40 						; correct range.
.2381	60		rts				rts
.2382	a9 64		lda #$64	_TTI64:	lda 	#$64
.2384	60		rts				rts
.2385					TOKDoComment:
.2385	20 55 22	jsr $2255			jsr 	TOKWriteA					; output the token.
.2388					_TOKSkipSpaces:
.2388	20 64 22	jsr $2264			jsr 	TOKGet 						; skip over spaces
.238b	c9 20		cmp #$20			cmp 	#' '
.238d	d0 05		bne $2394			bne 	_TOKEndSpaces
.238f	20 68 22	jsr $2268			jsr 	TOKGetNext
.2392	80 f4		bra $2388			bra 	_TOKSkipSpaces
.2394					_TOKEndSpaces:
.2394	48		pha				pha 								; save it
.2395	68		pla				pla
.2396	f0 04		beq $239c			beq 	_TOKDCExit 					; end of line.
.2398	c9 22		cmp #$22			cmp 	#'"'						; does it have a speech mark ?
.239a	d0 01		bne $239d			bne 	_TOKDCDoLine 				; otherwise the comment is the whole line.
.239c					_TOKDCExit:
.239c	60		rts				rts
.239d					_TOKDCDoLine:
.239d	20 84 21	jsr $2184			jsr 	TOKResetElement 			; start getting the string
.23a0					_TOKDCLoop:
.23a0	20 64 22	jsr $2264			jsr 	TOKGet 						; check EOL
.23a3	c9 00		cmp #$00			cmp 	#0
.23a5	f0 08		beq $23af			beq 	_TOKDCEndComment
.23a7	20 68 22	jsr $2268			jsr 	TOKGetNext 					; get and consume
.23aa	20 88 21	jsr $2188			jsr 	TOKWriteElement
.23ad	80 f1		bra $23a0			bra 	_TOKDCLoop
.23af					_TOKDCEndComment:
.23af	a9 ee		lda #$ee			lda 	#PR_LSQLSQSTRINGRSQRSQ
.23b1	20 55 22	jsr $2255			jsr 	TOKWriteA
.23b4	20 c9 21	jsr $21c9			jsr 	TOKOutputElementBuffer
.23b7	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokinteger.asm

.23b8					TOKTokeniseInteger:
.23b8	20 e1 23	jsr $23e1			jsr 	TOKExtractInteger 			; pull an integer out as text.
.23bb	a2 1d		ldx #$1d			ldx 	#TOKElementText & $FF
.23bd	a0 05		ldy #$05			ldy 	#TOKElementText >> 8
.23bf	ad 1c 05	lda $051c			lda		TOKElement
.23c2	20 78 32	jsr $3278			jsr 	IFloatStringToFloatR0 		; convert to R0 integer
.23c5	ad 1e 06	lda $061e			lda 	TOKIsFirstElement 			; first element ?
.23c8	f0 12		beq $23dc			beq 	_TOKNotLineNumber
.23ca	a5 0a		lda $0a				lda 	IFR0+IM2 					; check it's a 2 digit number
.23cc	d0 0c		bne $23da			bne 	_TOKBadLineNumeber
.23ce	a5 08		lda $08				lda 	IFR0+IM0 					; copy it to the line number section.
.23d0	8d 01 04	sta $0401			sta 	TOKLineNumber
.23d3	a5 09		lda $09				lda 	IFR0+IM1
.23d5	8d 02 04	sta $0402			sta 	TOKLineNumber+1
.23d8	18		clc				clc
.23d9	60		rts				rts
.23da					_TOKBadLineNumeber:
.23da	38		sec				sec
.23db	60		rts				rts
.23dc					_TOKNotLineNumber:
.23dc	20 97 21	jsr $2197			jsr 	TOKTokeniseConstant 		; tokenise the constant in R0
.23df	18		clc				clc
.23e0	60		rts				rts
.23e1					TOKExtractInteger:
.23e1	20 84 21	jsr $2184			jsr 	TOKResetElement 			; restart
.23e4					_TTILoop:
.23e4	20 64 22	jsr $2264			jsr 	TOKGet 						; keep getting and copying while numeric.
.23e7	20 68 24	jsr $2468			jsr 	TOKIsDigit
.23ea	90 08		bcc $23f4			bcc 	_TOKEIExit
.23ec	20 88 21	jsr $2188			jsr 	TOKWriteElement
.23ef	20 68 22	jsr $2268			jsr 	TOKGetNext
.23f2	80 f0		bra $23e4			bra 	_TTILoop
.23f4					_TOKEIExit:
.23f4	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokpunctuation.asm

.23f5					TOKTokenisePunctuation:
.23f5	20 84 21	jsr $2184			jsr 	TOKResetElement 			; copy first punctuation character into element.
.23f8	20 68 22	jsr $2268			jsr 	TOKGetNext
.23fb	20 88 21	jsr $2188			jsr 	TOKWriteElement
.23fe	20 64 22	jsr $2264			jsr 	TOKGet 						; what follows ?
.2401	c9 20		cmp #$20			cmp 	#' '						; space, not 2 character
.2403	f0 10		beq $2415			beq 	_TTPOne
.2405	20 78 24	jsr $2478			jsr 	TOKIsAlphaNumeric 			; if alphanumeric don't bother doing 2 character
.2408	b0 0b		bcs $2415			bcs 	_TTPOne 					; these speed things up a bit.
.240a	20 88 21	jsr $2188			jsr 	TOKWriteElement 			; this is what we will search for.
.240d	20 6c 22	jsr $226c			jsr 	TOKFindToken
.2410	b0 0a		bcs $241c			bcs 	_TTPConsumeExit 			; it was found, consume, generate, exit.
.2412	ce 1c 05	dec $051c			dec 	TOKElement 					; make it a single character
.2415					_TTPOne:
.2415	20 6c 22	jsr $226c			jsr 	TOKFindToken 				; look for one character punctuation
.2418	b0 07		bcs $2421			bcs 	_TTPOutputExit 				; we found it
.241a	38		sec				sec 								; not recognised.
.241b	60		rts				rts
.241c					_TTPConsumeExit:
.241c	48		pha				pha
.241d	20 68 22	jsr $2268			jsr 	TOKGetNext 					; get the 2nd char out.
.2420	68		pla				pla
.2421					_TTPOutputExit:
.2421	c9 9c		cmp #$9c			cmp 	#PR_SQUOTE 					; single quote
.2423	f0 05		beq $242a			beq 	_TTPComment
.2425	20 55 22	jsr $2255			jsr  	TOKWriteA 					; write token out
.2428	18		clc				clc
.2429	60		rts				rts
.242a					_TTPComment:
.242a	20 85 23	jsr $2385			jsr 	TOKDoComment
.242d	18		clc				clc
.242e	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokstring.asm

.242f					TOKTokeniseString:
.242f	20 68 22	jsr $2268			jsr 	TOKGetNext 					; consume the "
.2432	20 84 21	jsr $2184			jsr 	TOKResetElement 			; start getting the string
.2435					_TOKTSLoop:
.2435	20 64 22	jsr $2264			jsr 	TOKGet 						; check EOL
.2438	c9 00		cmp #$00			cmp 	#0
.243a	f0 0c		beq $2448			beq 	_TOKTSExit
.243c	20 68 22	jsr $2268			jsr 	TOKGetNext 					; get and consume
.243f	c9 22		cmp #$22			cmp 	#'"' 						; exit if " consumed
.2441	f0 05		beq $2448			beq 	_TOKTSExit
.2443	20 88 21	jsr $2188			jsr 	TOKWriteElement
.2446	80 ed		bra $2435			bra 	_TOKTSLoop
.2448					_TOKTSExit:
.2448	a9 ee		lda #$ee			lda 	#PR_LSQLSQSTRINGRSQRSQ
.244a	20 55 22	jsr $2255			jsr 	TOKWriteA
.244d	20 c9 21	jsr $21c9			jsr 	TOKOutputElementBuffer
.2450	18		clc				clc
.2451	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/toktypes.asm

.2452					TOKToUpper:
.2452	c9 61		cmp #$61			cmp 	#"a"
.2454	90 06		bcc $245c			bcc 	_TTUNotLower
.2456	c9 7b		cmp #$7b			cmp 	#"z"+1
.2458	b0 02		bcs $245c			bcs 	_TTUNotLower
.245a	49 20		eor #$20			eor 	#$20
.245c					_TTUNotLower:
.245c	60		rts				rts
.245d					TOKToLower:
.245d	c9 41		cmp #$41			cmp 	#"A"
.245f	90 06		bcc $2467			bcc 	_TTUNotUpper
.2461	c9 5b		cmp #$5b			cmp 	#"Z"+1
.2463	b0 02		bcs $2467			bcs 	_TTUNotUpper
.2465	49 20		eor #$20			eor 	#$20
.2467					_TTUNotUpper:
.2467	60		rts				rts
.2468					TOKIsDigit:
.2468	c9 30		cmp #$30			cmp 	#"0"
.246a	90 06		bcc $2472			bcc 	TOKFail
.246c	c9 3a		cmp #$3a			cmp 	#"9"+1
.246e	b0 02		bcs $2472			bcs 	TOKFail
.2470					TOKSucceed:
.2470	38		sec				sec
.2471	60		rts				rts
.2472					TOKFail:
.2472	18		clc				clc
.2473	60		rts				rts
.2474					TOKIsIdentifierElement:
.2474	c9 5f		cmp #$5f			cmp 	#"_"
.2476	f0 f8		beq $2470			beq 	TOKSucceed 					; else fall through to alphanumeric
.2478					TOKIsAlphaNumeric:
.2478	20 81 24	jsr $2481			jsr 	TOKIsAlpha
.247b	b0 f3		bcs $2470			bcs 	TOKSucceed
.247d	20 68 24	jsr $2468			jsr 	TOKIsDigit
.2480	60		rts				rts
.2481					TOKIsAlpha:
.2481	20 52 24	jsr $2452			jsr 	TOKToUpper
.2484	c9 41		cmp #$41			cmp 	#"A"
.2486	90 ea		bcc $2472			bcc 	TOKFail
.2488	c9 5b		cmp #$5b			cmp 	#"Z"+1
.248a	b0 e6		bcs $2472			bcs 	TOKFail
.248c	80 e2		bra $2470			bra 	TOKSucceed
.248e					TOKIsHexadecimal:
.248e	20 68 24	jsr $2468			jsr		TOKIsDigit
.2491	b0 dd		bcs $2470			bcs 	TOKSucceed
.2493	20 81 24	jsr $2481			jsr 	TOKIsAlpha
.2496	90 da		bcc $2472			bcc 	TOKFail
.2498	c9 47		cmp #$47			cmp 	#"F"+1
.249a	b0 d6		bcs $2472			bcs 	TOKFail
.249c	80 d2		bra $2470			bra 	TOKSucceed

;******  Return to file: include.files


;******  Processing file: src/structures/call.asm

.249e					Command_CALL:
.249e	a9 42		lda #$42			lda 	#STK_CALL
.24a0	20 90 29	jsr $2990			jsr 	StackOpen
.24a3	b1 18		lda ($18),y			lda 	(codePtr),y 				; check identifier follows.
.24a5	29 c0		and #$c0			and 	#$C0
.24a7	c9 40		cmp #$40			cmp 	#$40
.24a9	d0 29		bne $24d4			bne 	_CCSyntax
.24ab	20 57 2d	jsr $2d57			jsr 	VARGetInfo 					; get the information
.24ae	20 77 29	jsr $2977			jsr 	ERRCheckRParen 				; check right bracket follows.
.24b1	20 09 2d	jsr $2d09			jsr 	VARFind 					; exists ?
.24b4	90 21		bcc $24d7			bcc 	_CCUnknown
.24b6	86 25		stx $25				stx 	zTemp0+1 					; save target in XA
.24b8	85 24		sta $24				sta 	zTemp0
.24ba	20 c3 29	jsr $29c3			jsr 	STKSaveCodePosition 		; save return address on stack.
.24bd	a0 03		ldy #$03			ldy 	#3 							; check $FF marker
.24bf	b1 24		lda ($24),y			lda 	(zTemp0),y
.24c1	c9 ff		cmp #$ff			cmp 	#$FF
.24c3	d0 12		bne $24d7			bne 	_CCUnknown
.24c5	88		dey				dey 								; get Y offset to stack
.24c6	b1 24		lda ($24),y			lda 	(zTemp0),y
.24c8	48		pha				pha
.24c9	88		dey				dey 								; get address
.24ca	b1 24		lda ($24),y			lda 	(zTemp0),y
.24cc	85 19		sta $19				sta 	codePtr+1
.24ce	b2 24		lda ($24)			lda 	(zTemp0)
.24d0	85 18		sta $18				sta 	codePtr
.24d2	7a		ply				ply 								; restore Y
.24d3	60		rts				rts
.24d4					_CCSyntax:
.24d4	4c 9e 27	jmp $279e		jmp	ErrorV_syntax
.24d7					_CCUnknown:
.24d7	4c 13 29	jmp $2913		jmp	ErrorV_unknown
.24da					Command_ENDPROC:
.24da	a9 42		lda #$42			lda 	#STK_CALL
.24dc	20 bb 29	jsr $29bb			jsr 	StackCheckFrame
.24df	20 d5 29	jsr $29d5			jsr 	STKLoadCodePosition 		; return
.24e2	20 ad 29	jsr $29ad			jsr 	StackClose
.24e5	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/do.asm

.24e6					Command_DO:
.24e6	a9 22		lda #$22			lda 	#STK_DO
.24e8	20 90 29	jsr $2990			jsr 	StackOpen
.24eb	20 c3 29	jsr $29c3			jsr 	STKSaveCodePosition 		; save loop position
.24ee	60		rts				rts
.24ef					Command_EXIT:
.24ef	a9 22		lda #$22			lda 	#STK_DO 					; check in LOOP
.24f1	20 bb 29	jsr $29bb			jsr 	StackCheckFrame
.24f4	20 ad 29	jsr $29ad			jsr 	StackClose 					; close it
.24f7	a9 87		lda #$87			lda 	#PR_LOOP 					; forward to LOOP
.24f9	aa		tax				tax
.24fa	20 ae 26	jsr $26ae			jsr 	ScanForward
.24fd	60		rts				rts
.24fe					Command_LOOP:
.24fe	a9 22		lda #$22			lda 	#STK_DO
.2500	20 bb 29	jsr $29bb			jsr 	StackCheckFrame
.2503	20 d5 29	jsr $29d5			jsr 	STKLoadCodePosition 		; loop back
.2506	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/for.asm

.2507					Command_FOR:
.2507	a9 37		lda #$37			lda 	#STK_FOR 					; create frame
.2509	20 90 29	jsr $2990			jsr 	StackOpen
.250c	20 17 13	jsr $1317			jsr 	CommandLET 					; do "I = 1" bit
.250f	5a		phy				phy 								; save variable address to +4,+5
.2510	a0 04		ldy #$04			ldy 	#4
.2512	a5 24		lda $24				lda 	zTemp0
.2514	91 2c		sta ($2c),y			sta 	(basicStack),y
.2516	c8		iny				iny
.2517	a5 25		lda $25				lda 	zTemp0+1
.2519	91 2c		sta ($2c),y			sta 	(basicStack),y
.251b	7a		ply				ply
.251c	a9 90		lda #$90			lda 	#PR_TO 						; TO symbol required.
.251e	20 87 29	jsr $2987			jsr 	ERRCheckA
.2521	20 af 17	jsr $17af			jsr 	EXPEvalNumber 				; evaluate the terminal value.
.2524	a9 0a		lda #$0a			lda 	#10 						; save in slots 10-13
.2526	a2 08		ldx #$08			ldx 	#IFR0
.2528	20 7d 25	jsr $257d			jsr 	CFSaveR0X
.252b	b1 18		lda ($18),y			lda 	(codePtr),y 				; STEP here ?
.252d	c9 91		cmp #$91			cmp 	#PR_STEP
.252f	d0 06		bne $2537			bne 	_CFStep1
.2531	c8		iny				iny 								; consume step
.2532	20 af 17	jsr $17af			jsr 	EXPEvalNumber 				; evaluate STEP
.2535	80 24		bra $255b			bra 	_CFWriteStep
.2537					_CFStep1:
.2537	a2 08		ldx #$08			ldx 	#IFR0 						; default R0, 1
.2539	a9 01		lda #$01			lda 	#1
.253b	20 16 34	jsr $3416			jsr 	IFloatSetByte
.253e	5a		phy				phy 								; check for fast loop,step 1, integer start/end.
.253f	a0 04		ldy #$04			ldy 	#4 							; get variable address
.2541	b1 2c		lda ($2c),y			lda 	(basicStack),y
.2543	85 24		sta $24				sta 	zTemp0
.2545	c8		iny				iny
.2546	b1 2c		lda ($2c),y			lda 	(basicStack),y
.2548	85 25		sta $25				sta 	zTemp0+1
.254a	a0 03		ldy #$03			ldy 	#IExp 						; check that's an integer
.254c	b1 24		lda ($24),y			lda 	(zTemp0),y
.254e	d0 0a		bne $255a			bne 	_CFNotOptimised
.2550	a0 0d		ldy #$0d			ldy 	#13 						; check terminal value is integer.
.2552	b1 2c		lda ($2c),y			lda 	(basicStack),y
.2554	d0 04		bne $255a			bne 	_CFNotOptimised
.2556	a9 80		lda #$80			lda 	#$80 						; set the step so it's a string/
.2558	85 0b		sta $0b				sta 	IFR0+IExp
.255a					_CFNotOptimised:
.255a	7a		ply				ply
.255b					_CFWriteStep:
.255b	a2 08		ldx #$08			ldx 	#IFR0 						; Write to additive.
.255d	a9 06		lda #$06			lda 	#6
.255f	20 7d 25	jsr $257d			jsr 	CFSaveR0X
.2562	20 c3 29	jsr $29c3			jsr 	STKSaveCodePosition 		; save loop position
.2565	60		rts				rts
.2566					CFLoadR0X:
.2566	5a		phy				phy
.2567	a8		tay				tay
.2568	b1 2c		lda ($2c),y			lda 	(basicStack),y
.256a	95 00		sta $00,x			sta 	IM0,x
.256c	c8		iny				iny
.256d	b1 2c		lda ($2c),y			lda 	(basicStack),y
.256f	95 01		sta $01,x			sta 	IM1,x
.2571	c8		iny				iny
.2572	b1 2c		lda ($2c),y			lda 	(basicStack),y
.2574	95 02		sta $02,x			sta 	IM2,x
.2576	c8		iny				iny
.2577	b1 2c		lda ($2c),y			lda 	(basicStack),y
.2579	95 03		sta $03,x			sta 	IExp,x
.257b	7a		ply				ply
.257c	60		rts				rts
.257d					CFSaveR0X:
.257d	5a		phy				phy
.257e	a8		tay				tay
.257f	b5 00		lda $00,x			lda 	IM0,x
.2581	91 2c		sta ($2c),y			sta 	(basicStack),y
.2583	c8		iny				iny
.2584	b5 01		lda $01,x			lda 	IM1,x
.2586	91 2c		sta ($2c),y			sta 	(basicStack),y
.2588	c8		iny				iny
.2589	b5 02		lda $02,x			lda 	IM2,x
.258b	91 2c		sta ($2c),y			sta 	(basicStack),y
.258d	c8		iny				iny
.258e	b5 03		lda $03,x			lda 	IExp,x
.2590	91 2c		sta ($2c),y			sta 	(basicStack),y
.2592	7a		ply				ply
.2593	60		rts				rts
.2594					Command_NEXT:
.2594	a9 37		lda #$37			lda 	#STK_FOR
.2596	20 bb 29	jsr $29bb			jsr 	StackCheckFrame
.2599	5a		phy				phy 								; check optimised loop
.259a	a0 09		ldy #$09			ldy 	#9
.259c	b1 2c		lda ($2c),y			lda 	(basicStack),y
.259e	7a		ply				ply
.259f	0a		asl a				asl 	a
.25a0	b0 35		bcs $25d7			bcs 	_CNOptimised
.25a2	20 0f 26	jsr $260f			jsr 	_CNLoadValue 				; load index value to R0.
.25a5	a2 0c		ldx #$0c			ldx 	#IFR1 						; load adding value to R1.
.25a7	a9 06		lda #$06			lda 	#6
.25a9	20 66 25	jsr $2566			jsr 	CFLoadR0X
.25ac	20 0c 2e	jsr $2e0c			jsr 	IFloatAdd 					; add them together and write back.
.25af	20 32 26	jsr $2632			jsr 	_CNSaveValue
.25b2	a9 0a		lda #$0a			lda 	#10 						; terminal value in R1
.25b4	a2 0c		ldx #$0c			ldx 	#IFR1
.25b6	20 66 25	jsr $2566			jsr 	CFLoadR0X
.25b9	20 e3 30	jsr $30e3			jsr 	IFloatCompare 				; compare terminal vs current
.25bc	a2 08		ldx #$08			ldx 	#IFR0 						; if zero, e.g. equal, loop back.
.25be	20 0d 34	jsr $340d			jsr 	IFloatCheckZero
.25c1	f0 10		beq $25d3			beq 	_CNLoopBack
.25c3	a5 0b		lda $0b				lda 	IFR0+IExp 					; if sign compare and sign add match, loop back.
.25c5	5a		phy				phy
.25c6	a0 09		ldy #$09			ldy 	#6+IExp
.25c8	51 2c		eor ($2c),y			eor 	(basicStack),y
.25ca	7a		ply				ply
.25cb	29 40		and #$40			and 	#IFSign
.25cd	f0 04		beq $25d3			beq 	_CNLoopBack
.25cf					_CNExitLoop:
.25cf	20 ad 29	jsr $29ad			jsr 	StackClose		 			; return
.25d2	60		rts				rts
.25d3					_CNLoopBack:
.25d3	20 d5 29	jsr $29d5			jsr 	STKLoadCodePosition 		; loop back
.25d6	60		rts				rts
.25d7					_CNOptimised:
.25d7	5a		phy				phy
.25d8	a0 04		ldy #$04			ldy 	#4 							; copy address of index variable to zTemp2
.25da	b1 2c		lda ($2c),y			lda 	(basicStack),y
.25dc	85 28		sta $28				sta 	zTemp2
.25de	c8		iny				iny
.25df	b1 2c		lda ($2c),y			lda 	(basicStack),y
.25e1	85 29		sta $29				sta 	zTemp2+1
.25e3	a0 ff		ldy #$ff			ldy 	#$FF 						; increment that value. this won't go round
.25e5					_CNIncrement:
.25e5	c8		iny				iny
.25e6	b1 28		lda ($28),y			lda 	(zTemp2),y
.25e8	1a		inc a				inc 	a
.25e9	91 28		sta ($28),y			sta 	(zTemp2),y
.25eb	f0 f8		beq $25e5			beq 	_CNIncrement
.25ed	18		clc				clc 								; point zTemp0 to terminal value
.25ee	a5 2c		lda $2c				lda 	basicStack
.25f0	69 0a		adc #$0a			adc 	#10
.25f2	85 24		sta $24				sta 	zTemp0
.25f4	a5 2d		lda $2d				lda 	basicStack+1
.25f6	69 00		adc #$00			adc 	#0
.25f8	85 25		sta $25				sta 	zTemp0+1
.25fa	a0 01		ldy #$01			ldy 	#1 							; compare value to terminal.
.25fc	18		clc				clc 								; borrow 1, we want > not >=
.25fd	b2 28		lda ($28)			lda 	(zTemp2)
.25ff	f2 24		sbc ($24)			sbc 	(zTemp0)
.2601	b1 28		lda ($28),y			lda 	(zTemp2),y
.2603	f1 24		sbc ($24),y			sbc 	(zTemp0),y
.2605	c8		iny				iny
.2606	b1 28		lda ($28),y			lda 	(zTemp2),y
.2608	f1 24		sbc ($24),y			sbc 	(zTemp0),y
.260a	7a		ply				ply
.260b	b0 c2		bcs $25cf			bcs 	_CNExitLoop
.260d	80 c4		bra $25d3			bra 	_CNLoopBack
.260f					_CNLoadValue:
.260f	5a		phy				phy
.2610	a0 04		ldy #$04			ldy 	#4 							; copy address to zTemp2
.2612	b1 2c		lda ($2c),y			lda 	(basicStack),y
.2614	85 28		sta $28				sta 	zTemp2
.2616	c8		iny				iny
.2617	b1 2c		lda ($2c),y			lda 	(basicStack),y
.2619	85 29		sta $29				sta 	zTemp2+1
.261b	a0 00		ldy #$00			ldy 	#0 							; copy dword at zTemp2 to IFR0
.261d	b1 28		lda ($28),y			lda 	(zTemp2),y
.261f	85 08		sta $08				sta 	IFR0+IM0
.2621	c8		iny				iny
.2622	b1 28		lda ($28),y			lda 	(zTemp2),y
.2624	85 09		sta $09				sta 	IFR0+IM1
.2626	c8		iny				iny
.2627	b1 28		lda ($28),y			lda 	(zTemp2),y
.2629	85 0a		sta $0a				sta 	IFR0+IM2
.262b	c8		iny				iny
.262c	b1 28		lda ($28),y			lda 	(zTemp2),y
.262e	85 0b		sta $0b				sta 	IFR0+IExp
.2630	7a		ply				ply
.2631	60		rts				rts
.2632					_CNSaveValue:
.2632	5a		phy				phy
.2633	a0 00		ldy #$00			ldy 	#0
.2635	a5 08		lda $08				lda 	IFR0+IM0
.2637	91 28		sta ($28),y			sta 	(zTemp2),y
.2639	c8		iny				iny
.263a	a5 09		lda $09				lda 	IFR0+IM1
.263c	91 28		sta ($28),y			sta 	(zTemp2),y
.263e	c8		iny				iny
.263f	a5 0a		lda $0a				lda 	IFR0+IM2
.2641	91 28		sta ($28),y			sta 	(zTemp2),y
.2643	c8		iny				iny
.2644	a5 0b		lda $0b				lda 	IFR0+IExp
.2646	91 28		sta ($28),y			sta 	(zTemp2),y
.2648	7a		ply				ply
.2649	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/gosub.asm

.264a					Command_GOSUB:
.264a	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; get line number
.264d	a9 52		lda #$52			lda 	#STK_GOSUB
.264f	20 90 29	jsr $2990			jsr 	StackOpen
.2652	20 c3 29	jsr $29c3			jsr 	STKSaveCodePosition 		; save return address on stack.
.2655	4c 38 12	jmp $1238			jmp 	GotoR0
.2658					Command_RETURN:
.2658	a9 52		lda #$52			lda 	#STK_GOSUB
.265a	20 bb 29	jsr $29bb			jsr 	StackCheckFrame
.265d	20 d5 29	jsr $29d5			jsr 	STKLoadCodePosition 		; return
.2660	20 ad 29	jsr $29ad			jsr 	StackClose
.2663	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/if.asm

.2664					IfCommand:
.2664	20 af 17	jsr $17af			jsr 	EXPEvalNumber 				; Get the if test.
.2667	b1 18		lda ($18),y			lda 	(codePtr),y					; what follows ?
.2669	c9 8f		cmp #$8f			cmp 	#PR_THEN  					; could be THEN <stuff>
.266b	d0 0c		bne $2679			bne 	_IfStructured 				; we still support it.
.266d	c8		iny				iny 								; consume THEN
.266e	a2 08		ldx #$08			ldx 	#IFR0
.2670	20 0d 34	jsr $340d			jsr 	IFloatCheckZero 			; is it zero
.2673	f0 01		beq $2676			beq 	_IfFail 					; if fail, go to next line
.2675	60		rts				rts 								; if THEN just continue
.2676					_IfFail:
.2676	4c 70 15	jmp $1570			jmp 	RUNEndOfLine
.2679					_IfStructured:
.2679	20 0d 34	jsr $340d			jsr 	IFloatCheckZero 			; is it zero
.267c	d0 07		bne $2685			bne 	_IfExit 					; if not, then continue normally.
.267e	a9 8e		lda #$8e			lda 	#PR_ELSE 					; look for else/endif
.2680	a2 85		ldx #$85			ldx 	#PR_ENDIF
.2682	20 ae 26	jsr $26ae			jsr 	ScanForward 				; and run from there
.2685					_IfExit:
.2685	60		rts				rts
.2686					ElseCode:
.2686	a9 85		lda #$85			lda 	#PR_ENDIF 					; else is only run after the if clause succeeds
.2688	aa		tax				tax 								; so just go to the structure exit
.2689	20 ae 26	jsr $26ae			jsr 	ScanForward
.268c	60		rts				rts
.268d					EndIf:
.268d	60		rts				rts 								; endif code does nothing

;******  Return to file: include.files


;******  Processing file: src/structures/repeat.asm

.268e					Command_REPEAT:
.268e	a9 02		lda #$02			lda 	#STK_REPEAT
.2690	20 90 29	jsr $2990			jsr 	StackOpen
.2693	20 c3 29	jsr $29c3			jsr 	STKSaveCodePosition 		; save loop position
.2696	60		rts				rts
.2697					Command_UNTIL:
.2697	a9 02		lda #$02			lda 	#STK_REPEAT
.2699	20 bb 29	jsr $29bb			jsr 	StackCheckFrame
.269c	20 af 17	jsr $17af			jsr 	EXPEvalNumber 				; work out the test
.269f	a2 08		ldx #$08			ldx 	#IFR0
.26a1	20 0d 34	jsr $340d			jsr 	IFloatCheckZero 			; check if zero
.26a4	f0 04		beq $26aa			beq 	_CULoopBack 				; if so keep looping
.26a6	20 ad 29	jsr $29ad			jsr 	StackClose		 			; return
.26a9	60		rts				rts
.26aa					_CULoopBack:
.26aa	20 d5 29	jsr $29d5			jsr 	STKLoadCodePosition 		; loop back
.26ad	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/scanforward.asm

.26ae					ScanForward:
.26ae	85 24		sta $24				sta 	zTemp0 						; save scan options in zTemp0
.26b0	86 25		stx $25				stx 	zTemp0+1
.26b2	64 26		stz $26				stz 	zTemp1 						; clear structure count.
.26b4					_ScanForwardLoop:
.26b4	a5 26		lda $26				lda 	zTemp1 						; if structure count non zero, don't check for end.
.26b6	d0 0a		bne $26c2			bne 	_ScanNoCheck
.26b8	b1 18		lda ($18),y			lda 	(codePtr),y 				; reached either target token.
.26ba	c5 24		cmp $24				cmp 	zTemp0
.26bc	f0 49		beq $2707			beq 	_ScanExit
.26be	c5 25		cmp $25				cmp 	zTemp0+1
.26c0	f0 45		beq $2707			beq 	_ScanExit
.26c2					_ScanNoCheck:
.26c2	b1 18		lda ($18),y			lda 	(codePtr),y 				; get the token and consume it.
.26c4	c8		iny				iny
.26c5	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ 	; check for special multi-byte elements
.26c7	f0 37		beq $2700			beq		_ScanDataItem
.26c9	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ
.26cb	f0 33		beq $2700			beq 	_ScanDataItem
.26cd	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; handle end of line.
.26cf	f0 1b		beq $26ec			beq 	_ScanNextLine
.26d1	c9 8d		cmp #$8d			cmp 	#PR_LSQLSQSHIFTRSQRSQ 		; if shift, skip one.
.26d3	d0 01		bne $26d6			bne 	_ScanNoShift
.26d5	c8		iny				iny
.26d6					_ScanNoShift:
.26d6	c9 8c		cmp #$8c			cmp 	#PR_STRUCTURE_LAST+1 		; nested structures
.26d8	b0 da		bcs $26b4			bcs 	_ScanForwardLoop
.26da	c9 80		cmp #$80			cmp 	#PR_STRUCTURE_FIRST
.26dc	90 d6		bcc $26b4			bcc 	_ScanForwardLoop
.26de	aa		tax				tax 								; access the table to get the adjustment.
.26df	18		clc				clc
.26e0	a5 26		lda $26				lda 	zTemp1 						; add it to structure count.
.26e2	7d ca 1b	adc $1bca,x			adc 	StructureOffsets-PR_STRUCTURE_FIRST,x
.26e5	85 26		sta $26				sta 	zTemp1
.26e7	10 cb		bpl $26b4			bpl		_ScanForwardLoop 			; error if -ve ?
.26e9	4c 2a 28	jmp $282a		jmp	ErrorV_structure
.26ec					_ScanNextLine:
.26ec	18		clc				clc	 								; forward to next line.
.26ed	b2 18		lda ($18)			lda 	(codePtr)
.26ef	65 18		adc $18				adc 	codePtr
.26f1	85 18		sta $18				sta 	codePtr
.26f3	90 02		bcc $26f7			bcc 	_ScanNoCarry
.26f5	e6 19		inc $19				inc 	codePtr+1
.26f7					_ScanNoCarry:
.26f7	a0 03		ldy #$03			ldy 	#3
.26f9	b2 18		lda ($18)			lda 	(codePtr) 					; off end of program ?
.26fb	d0 b7		bne $26b4			bne 	_ScanForwardLoop
.26fd	4c 2a 28	jmp $282a		jmp	ErrorV_structure
.2700					_ScanDataItem:
.2700	98		tya				tya
.2701	38		sec				sec
.2702	71 18		adc ($18),y			adc 	(codePtr),y
.2704	a8		tay				tay
.2705	80 ad		bra $26b4			bra 	_ScanForwardLoop
.2707					_ScanExit:
.2707	c8		iny				iny 								; consume final token.
.2708	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/scanproc.asm

.2709					ScanProcedures:
.2709	a5 18		lda $18				lda 	codePtr 					; push codePtr on the stack
.270b	48		pha				pha
.270c	a5 19		lda $19				lda 	codePtr+1
.270e	48		pha				pha
.270f	5a		phy				phy
.2710	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; back to the program start
.2713	85 19		sta $19				sta 	codePtr+1
.2715	64 18		stz $18				stz 	codePtr
.2717					_SPLoop:
.2717	b2 18		lda ($18)			lda 	(codePtr) 					; end of program
.2719	f0 18		beq $2733			beq 	_SPExit
.271b	a0 03		ldy #$03			ldy 	#3 							; first token PROC
.271d	b1 18		lda ($18),y			lda 	(codePtr),y
.271f	c9 88		cmp #$88			cmp 	#PR_PROC
.2721	d0 03		bne $2726			bne 	_SPNext
.2723	20 3b 27	jsr $273b			jsr 	_SPSetupRecord
.2726					_SPNext:
.2726	18		clc				clc 								; forward to next
.2727	b2 18		lda ($18)			lda 	(codePtr)
.2729	65 18		adc $18				adc 	codePtr
.272b	85 18		sta $18				sta 	codePtr
.272d	90 e8		bcc $2717			bcc 	_SPLoop
.272f	e6 19		inc $19				inc 	codePtr+1
.2731	80 e4		bra $2717			bra 	_SPLoop
.2733					_SPExit:
.2733	7a		ply				ply
.2734	68		pla				pla
.2735	85 19		sta $19				sta 	codePtr+1
.2737	68		pla				pla
.2738	85 18		sta $18				sta 	codePtr
.273a	60		rts				rts
.273b					_SPSetupRecord:
.273b	c8		iny				iny 								; check identifier follows
.273c	b1 18		lda ($18),y			lda 	(codePtr),y
.273e	29 c0		and #$c0			and 	#$C0
.2740	c9 40		cmp #$40			cmp 	#$40
.2742	d0 27		bne $276b			bne 	_SPSyntax
.2744	20 57 2d	jsr $2d57			jsr 	VARGetInfo 					; get the information
.2747	20 77 29	jsr $2977			jsr 	ERRCheckRParen 				; check right bracket follows.
.274a	20 09 2d	jsr $2d09			jsr 	VARFind 					; already exists ?
.274d	b0 1f		bcs $276e			bcs 	_SPUsed 					; error !
.274f	20 b5 2c	jsr $2cb5			jsr 	VARCreate 					; create, XA points to the data.
.2752	85 24		sta $24				sta 	zTemp0
.2754	86 25		stx $25				stx 	zTemp0+1
.2756	5a		phy				phy 								; save Y pos on stack
.2757	a0 01		ldy #$01			ldy 	#1
.2759	a5 18		lda $18				lda 	codePtr 					; save codePtr/Y
.275b	92 24		sta ($24)			sta 	(zTemp0)
.275d	a5 19		lda $19				lda 	codePtr+1
.275f	91 24		sta ($24),y			sta 	(zTemp0),y
.2761	c8		iny				iny
.2762	68		pla				pla
.2763	91 24		sta ($24),y			sta 	(zTemp0),y
.2765	c8		iny				iny
.2766	a9 ff		lda #$ff			lda 	#$FF 						; fill rest with $FF
.2768	91 24		sta ($24),y			sta 	(zTemp0),y
.276a	60		rts				rts
.276b					_SPSyntax:
.276b	4c 9e 27	jmp $279e		jmp	ErrorV_syntax
.276e					_SPUsed:
.276e	4c f5 28	jmp $28f5		jmp	ErrorV_dupproc

;******  Return to file: include.files


;******  Processing file: src/structures/while.asm

.2771					Command_WHILE:
.2771	5a		phy				phy 								; save position of the test
.2772	20 af 17	jsr $17af			jsr 	EXPEvalNumber 				; work out the while test.
.2775	a2 08		ldx #$08			ldx 	#IFR0
.2777	20 0d 34	jsr $340d			jsr 	IFloatCheckZero 			; check if zero
.277a	f0 0e		beq $278a			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.277c	98		tya				tya 								; position *after* test.
.277d	7a		ply				ply 								; restore position before test, at WHILE
.277e	88		dey				dey 								; so we execute the WHILE command again.
.277f	48		pha				pha 								; push after test on the stack
.2780	a9 12		lda #$12			lda 	#STK_WHILE 					; open while frame
.2782	20 90 29	jsr $2990			jsr 	StackOpen
.2785	20 c3 29	jsr $29c3			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.2788	7a		ply				ply 								; restore the position *after* the test
.2789	60		rts				rts
.278a					_WHExitLoop:
.278a	68		pla				pla 								; throw post loop position
.278b	a9 83		lda #$83			lda 	#PR_WEND 					; scan forward past WEND
.278d	aa		tax				tax
.278e	20 ae 26	jsr $26ae			jsr 	ScanForward
.2791	60		rts				rts
.2792					Command_WEND:
.2792	a9 12		lda #$12			lda 	#STK_WHILE 					; check WHILE is TOS e.g. in a while loop :)
.2794	20 bb 29	jsr $29bb			jsr 	StackCheckFrame
.2797	20 d5 29	jsr $29d5			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.279a	20 ad 29	jsr $29ad			jsr 	StackClose		 			; erase the frame
.279d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/support/errors/generated/errors.asm

.279e					ErrorV_syntax:
.279e	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>27a1	0c 53 79 6e 74 61 78 20			.text	12,"Syntax Error",0
>27a9	45 72 72 6f 72 00
.27af					ErrorV_range:
.27af	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>27b2	0c 4f 75 74 20 4f 66 20			.text	12,"Out Of Range",0
>27ba	52 61 6e 67 65 00
.27c0					ErrorV_value:
.27c0	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>27c3	09 42 61 64 20 56 61 6c			.text	9,"Bad Value",0
>27cb	75 65 00
.27ce					ErrorV_type:
.27ce	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>27d1	0d 54 79 70 65 20 4d 69			.text	13,"Type Mismatch",0
>27d9	73 6d 61 74 63 68 00
.27e0					ErrorV_unimplemented:
.27e0	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>27e3	0f 4e 6f 74 20 49 6d 70			.text	15,"Not Implemented",0
>27eb	6c 65 6d 65 6e 74 65 64 00
.27f4					ErrorV_assert:
.27f4	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>27f7	0b 41 73 73 65 72 74 20			.text	11,"Assert Fail",0
>27ff	46 61 69 6c 00
.2804					ErrorV_internal:
.2804	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>2807	0e 49 6e 74 65 72 6e 61			.text	14,"Internal Error",0
>280f	6c 20 45 72 72 6f 72 00
.2817					ErrorV_divzero:
.2817	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>281a	0e 44 69 76 69 64 65 20			.text	14,"Divide By Zero",0
>2822	42 79 20 5a 65 72 6f 00
.282a					ErrorV_structure:
.282a	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>282d	13 53 74 72 75 63 74 75			.text	19,"Structure Imbalance",0
>2835	72 65 20 49 6d 62 61 6c 61 6e 63 65 00
.2842					ErrorV_stop:
.2842	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>2845	0f 50 72 6f 67 72 61 6d			.text	15,"Program Stopped",0
>284d	20 53 74 6f 70 70 65 64 00
.2856					ErrorV_data:
.2856	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>2859	0b 4f 75 74 20 4f 66 20			.text	11,"Out Of Data",0
>2861	44 61 74 61 00
.2866					ErrorV_redefine:
.2866	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>2869	0f 41 72 72 61 79 20 52			.text	15,"Array Redefined",0
>2871	65 64 65 66 69 6e 65 64 00
.287a					ErrorV_index:
.287a	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>287d	0f 42 61 64 20 41 72 72			.text	15,"Bad Array Index",0
>2885	61 79 20 49 6e 64 65 78 00
.288e					ErrorV_memory:
.288e	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>2891	0d 4f 75 74 20 4f 66 20			.text	13,"Out Of Memory",0
>2899	4d 65 6d 6f 72 79 00
.28a0					ErrorV_uninitialised:
.28a0	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>28a3	16 56 61 72 69 61 62 6c			.text	22,"Variable Uninitialised",0
>28ab	65 20 55 6e 69 6e 69 74 69 61 6c 69 73 65 64 00
.28bb					ErrorV_string:
.28bb	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>28be	11 42 61 64 20 53 74 72			.text	17,"Bad String Length",0
>28c6	69 6e 67 20 4c 65 6e 67 74 68 00
.28d1					ErrorV_variable:
.28d1	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>28d4	10 56 61 72 69 61 62 6c			.text	16,"Variable Missing",0
>28dc	65 20 4d 69 73 73 69 6e 67 00
.28e6					ErrorV_stack:
.28e6	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>28e9	0a 53 74 61 63 6b 20 46			.text	10,"Stack Full",0
>28f1	75 6c 6c 00
.28f5					ErrorV_dupproc:
.28f5	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>28f8	19 50 72 6f 63 65 64 75			.text	25,"Procedure Identifier Used",0
>2900	72 65 20 49 64 65 6e 74 69 66 69 65 72 20 55 73
>2910	65 64 00
.2913					ErrorV_unknown:
.2913	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>2916	11 55 6e 6b 6e 6f 77 6e			.text	17,"Unknown Procedure",0
>291e	20 50 72 6f 63 65 64 75 72 65 00
.2929					ErrorV_break:
.2929	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>292c	05 42 72 65 61 6b 00			.text	5,"Break",0
.2933					ErrorV_line:
.2933	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>2936	13 55 6e 6b 6e 6f 77 6e			.text	19,"Unknown Line Number",0
>293e	20 4c 69 6e 65 20 4e 75 6d 62 65 72 00
.294b					ErrorV_fnf:
.294b	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>294e	0e 46 69 6c 65 20 4e 6f			.text	14,"File Not Found",0
>2956	74 20 46 6f 75 6e 64 00
.295e					ErrorV_full:
.295e	20 a5 2b	jsr $2ba5		jsr	ErrorHandler
>2961	0c 53 74 6f 72 61 67 65			.text	12,"Storage Full",0
>2969	20 46 75 6c 6c 00

;******  Return to file: include.files


;******  Processing file: src/support/errors/syntax.asm

.296f					ERRCheckLParen:
.296f	b1 18		lda ($18),y			lda 	(codePtr),y
.2971	c9 eb		cmp #$eb			cmp 	#PR_LPAREN
.2973	d0 18		bne $298d			bne 	ERRSyntaxError
.2975	c8		iny				iny
.2976	60		rts				rts
.2977					ERRCheckRParen:
.2977	b1 18		lda ($18),y			lda 	(codePtr),y
.2979	c9 9d		cmp #$9d			cmp 	#PR_RPAREN
.297b	d0 10		bne $298d			bne 	ERRSyntaxError
.297d	c8		iny				iny
.297e	60		rts				rts
.297f					ERRCheckComma:
.297f	b1 18		lda ($18),y			lda 	(codePtr),y
.2981	c9 99		cmp #$99			cmp 	#PR_COMMA
.2983	d0 08		bne $298d			bne 	ERRSyntaxError
.2985	c8		iny				iny
.2986	60		rts				rts
.2987					ERRCheckA:
.2987	d1 18		cmp ($18),y			cmp 	(codePtr),y
.2989	d0 02		bne $298d			bne 	ERRSyntaxError
.298b	c8		iny				iny
.298c	60		rts				rts
.298d					ERRSyntaxError:
.298d	4c 9e 27	jmp $279e		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/support/stack/frames.asm

.2990					StackOpen:
.2990	48		pha				pha 								; save frame byte
.2991	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.2993	0a		asl a				asl 	a 							; claim twice this for storage
.2994	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.2996	38		sec				sec 								; so basically subtracting from
.2997	65 2c		adc $2c				adc 	basicStack 	 				; basicStack
.2999	85 2c		sta $2c				sta 	basicStack
.299b	b0 09		bcs $29a6			bcs 	_SONoBorrow
.299d	c6 2d		dec $2d				dec 	basicStack+1
.299f	a5 2d		lda $2d				lda 	basicStack+1 				; reached the bottom ?
.29a1	cd 20 06	cmp $0620			cmp 	basicStackEnd
.29a4	f0 04		beq $29aa			beq 	_SOMemory
.29a6					_SONoBorrow:
.29a6	68		pla				pla 								; get marker back and write at TOS
.29a7	92 2c		sta ($2c)			sta 	(basicStack)
.29a9	60		rts				rts
.29aa					_SOMemory:
.29aa	4c e6 28	jmp $28e6		jmp	ErrorV_stack
.29ad					StackClose:
.29ad	b2 2c		lda ($2c)			lda 	(basicStack) 				; get TOS marker
.29af	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.29b1	0a		asl a				asl 	a 							; claim twice this.
.29b2	65 2c		adc $2c				adc 	basicStack 					; add to the stack pointer.
.29b4	85 2c		sta $2c				sta 	basicStack
.29b6	90 02		bcc $29ba			bcc 	_SCExit
.29b8	e6 2d		inc $2d				inc 	basicStack+1
.29ba					_SCExit:
.29ba	60		rts				rts
.29bb					StackCheckFrame:
.29bb	d2 2c		cmp ($2c)			cmp		(basicStack) 				; check  frames match
.29bd	d0 01		bne $29c0			bne 	_SCFError 					; different, we have structures mixed up
.29bf	60		rts				rts
.29c0					_SCFError:
.29c0	4c 2a 28	jmp $282a		jmp	ErrorV_structure

;******  Return to file: include.files


;******  Processing file: src/support/stack/location.asm

.29c3					STKSaveCodePosition:
.29c3	5a		phy				phy
.29c4	98		tya				tya 								; save Y at offset 1.
.29c5	a0 01		ldy #$01			ldy 	#1
.29c7	91 2c		sta ($2c),y			sta 	(basicStack),y
.29c9	a5 18		lda $18				lda 	codePtr 					; save code (low) at 2
.29cb	c8		iny				iny
.29cc	91 2c		sta ($2c),y			sta 	(basicStack),y
.29ce	a5 19		lda $19				lda 	codePtr+1 					; save code (high) at 3
.29d0	c8		iny				iny
.29d1	91 2c		sta ($2c),y			sta 	(basicStack),y
.29d3	7a		ply				ply
.29d4	60		rts				rts
.29d5					STKLoadCodePosition:
.29d5	a0 03		ldy #$03			ldy 	#3 							; load code pointer back
.29d7	b1 2c		lda ($2c),y			lda 	(basicStack),y
.29d9	85 19		sta $19				sta 	codePtr+1
.29db	88		dey				dey
.29dc	b1 2c		lda ($2c),y			lda 	(basicStack),y
.29de	85 18		sta $18				sta 	codePtr
.29e0	88		dey				dey
.29e1	b1 2c		lda ($2c),y			lda 	(basicStack),y 				; line offset to Y
.29e3	a8		tay				tay
.29e4	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/support/stack/setup.asm

.29e5					StackReset:
.29e5	48		pha				pha 								; save top of memory
.29e6	3a		dec a				dec 	a  							; end of stack = previous byte
.29e7	85 2d		sta $2d				sta 	basicStack+1
.29e9	a9 ff		lda #$ff			lda 	#$FF
.29eb	85 2c		sta $2c				sta 	basicStack
.29ed	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.29ef	92 2c		sta ($2c)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.29f1	68		pla				pla 								; allocate pages for stack.
.29f2	38		sec				sec
.29f3	e9 02		sbc #$02			sbc 	#STACKPAGES
.29f5	8d 20 06	sta $0620			sta 	basicStackEnd 				; when stack MSB hits this, it's out of memory.
.29f8	60		rts				rts
.002c					basicStack:
>002c							.fill 	2
.0620					basicStackEnd:
>0620							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/support/strings/concrete.asm

.29f9					StringConcrete:
.29f9	5a		phy				phy 								; save position on stack
.29fa	b2 08		lda ($08)			lda 	(IFR0) 						; get string length
.29fc	c9 fd		cmp #$fd			cmp 	#253 						; string too long - cannot concrete.
.29fe	b0 41		bcs $2a41			bcs 	_SALengthError
.2a00	18		clc				clc 								; length of the new string
.2a01	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.2a03	90 02		bcc $2a07			bcc 	_SAHaveLength
.2a05	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.2a07					_SAHaveLength:
.2a07	48		pha				pha 								; save length to be allocated for concreting.
.2a08	38		sec				sec
.2a09	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.2a0b	6d 22 06	adc $0622			adc 	stringMemory
.2a0e	8d 22 06	sta $0622			sta 	stringMemory
.2a11	85 28		sta $28				sta 	zTemp2 						; update storage address
.2a13	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.2a15	6d 23 06	adc $0623			adc 	stringMemory+1
.2a18	8d 23 06	sta $0623			sta 	stringMemory+1
.2a1b	85 29		sta $29				sta 	zTemp2+1
.2a1d	68		pla				pla 								; save length allocated in +0
.2a1e	92 28		sta ($28)			sta 	(zTemp2)
.2a20	a9 00		lda #$00			lda 	#0 							; clear the status byte in +1
.2a22	a0 01		ldy #$01			ldy 	#1
.2a24	91 28		sta ($28),y			sta 	(zTemp2),y
.2a26					_SACopyNewString:
.2a26	b2 08		lda ($08)			lda 	(IFR0) 						; copy length at +2
.2a28	a0 02		ldy #$02			ldy 	#2
.2a2a	91 28		sta ($28),y			sta 	(zTemp2),y
.2a2c	aa		tax				tax 								; bytes to copy
.2a2d	f0 0c		beq $2a3b			beq 	_SACopyExit
.2a2f	a0 01		ldy #$01			ldy 	#1 							; first character from here
.2a31					_SACopyNSLoop:
.2a31	b1 08		lda ($08),y			lda 	(IFR0),y 					; get character from here
.2a33	c8		iny				iny 								; write two on in string storage
.2a34	c8		iny				iny
.2a35	91 28		sta ($28),y			sta 	(zTemp2),y
.2a37	88		dey				dey
.2a38	ca		dex				dex									; until copied all the string lengths.
.2a39	d0 f6		bne $2a31			bne 	_SACopyNSLoop
.2a3b					_SACopyExit:
.2a3b	a6 29		ldx $29				ldx 	zTemp2+1 					; XA contain the concreted string.
.2a3d	a5 28		lda $28				lda 	zTemp2
.2a3f	7a		ply				ply
.2a40	60		rts				rts
.2a41					_SALengthError:
.2a41	4c bb 28	jmp $28bb		jmp	ErrorV_string

;******  Return to file: include.files


;******  Processing file: src/support/strings/stringalloc.asm

.2a44					StringSystemInitialise:
.2a44	3a		dec a				dec 	a 							; make last byte of previous page.
.2a45	8d 23 06	sta $0623			sta 	stringMemory+1
.2a48	85 25		sta $25				sta 	zTemp0+1
.2a4a	a9 ff		lda #$ff			lda 	#$FF
.2a4c	8d 22 06	sta $0622			sta 	stringMemory
.2a4f	85 24		sta $24				sta 	zTemp0
.2a51	a9 00		lda #$00			lda 	#0 							; put a zero at the end, so know end of string memory.
.2a53	92 24		sta ($24)			sta 	(zTemp0)
.2a55	60		rts				rts
.2a56					StringSpaceInitialise:
.2a56	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.2a58	8d 21 06	sta $0621			sta 	stringInitialised
.2a5b	ad 22 06	lda $0622			lda 	stringMemory 				; allocate 256 bytes for one concreted string
.2a5e	8d 24 06	sta $0624			sta 	stringTempPointer 			; so temporary string space is allocated below that.
.2a61	ad 23 06	lda $0623			lda 	stringMemory+1
.2a64	3a		dec a				dec 	a
.2a65	8d 25 06	sta $0625			sta 	stringTempPointer+1
.2a68	20 e2 10	jsr $10e2			jsr 	ClearCheckMemory
.2a6b	60		rts				rts
.2a6c					StringTempAllocate:
.2a6c	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.2a6e	b0 2e		bcs $2a9e			bcs 	_STALength
.2a70	2c 21 06	bit $0621			bit 	stringInitialised 			; already initialised
.2a73	30 05		bmi $2a7a			bmi 	_STAAllocate
.2a75	48		pha				pha 								; save value to subtract.
.2a76	20 56 2a	jsr $2a56			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.2a79	68		pla				pla 								; restore it
.2a7a					_STAAllocate:
.2a7a	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.2a7c	18		clc				clc  								; deliberate allows one more
.2a7d	6d 24 06	adc $0624			adc 	stringTempPointer 			; subtract from temp pointer
.2a80	8d 24 06	sta $0624			sta 	stringTempPointer
.2a83	85 08		sta $08				sta 	IFR0+IM0 					; address in mantissa too
.2a85	85 2e		sta $2e				sta 	zsTemp 						; and zsTemp
.2a87	ad 25 06	lda $0625			lda 	stringTempPointer+1
.2a8a	69 ff		adc #$ff			adc 	#$FF
.2a8c	8d 25 06	sta $0625			sta 	stringTempPointer+1
.2a8f	85 2f		sta $2f				sta 	zsTemp+1
.2a91	85 09		sta $09				sta 	IFR0+IM1
.2a93	64 0a		stz $0a				stz 	IFR0+IM2 					; set the typing data and the upper address bytes.
.2a95	a9 80		lda #$80			lda 	#$80
.2a97	85 0b		sta $0b				sta 	IFR0+IExp
.2a99	a9 00		lda #$00			lda 	#0 							; clear the target string
.2a9b	92 2e		sta ($2e)			sta 	(zsTemp)
.2a9d	60		rts				rts
.2a9e					_STALength:
.2a9e	4c bb 28	jmp $28bb		jmp	ErrorV_string
.2aa1					StringTempWrite:
.2aa1	5a		phy				phy
.2aa2	48		pha				pha
.2aa3	b2 2e		lda ($2e)			lda 	(zsTemp)
.2aa5	1a		inc a				inc 	a
.2aa6	92 2e		sta ($2e)			sta 	(zsTemp)
.2aa8	a8		tay				tay
.2aa9	68		pla				pla
.2aaa	91 2e		sta ($2e),y			sta 	(zsTemp),y
.2aac	7a		ply				ply
.2aad	60		rts				rts
.002e					zsTemp:
>002e							.fill 	2
.0621					stringInitialised:
>0621							.fill 	1
.0622					stringMemory:
>0622							.fill 	2
.0624					stringTempPointer:
>0624							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/system/files/dir.asm

.2aae					Command_DIR:
.2aae	5a		phy				phy
.2aaf	38		sec				sec 								; reset read
.2ab0	20 ca ff	jsr $ffca			jsr 	OSReadDirectory
.2ab3	18		clc		_CDLoop:clc
.2ab4	20 ca ff	jsr $ffca			jsr 	OSReadDirectory 			; read next
.2ab7	b0 27		bcs $2ae0			bcs 	_CDExit 					; no more
.2ab9	86 24		stx $24				stx 	zTemp0
.2abb	84 25		sty $25				sty 	zTemp0+1
.2abd	20 df ff	jsr $ffdf			jsr	 	OSWriteString				; write name
.2ac0					_CDPad:
.2ac0	a9 20		lda #$20			lda 	#32
.2ac2	20 f7 ff	jsr $fff7			jsr 	OSWriteScreen
.2ac5	20 d9 ff	jsr $ffd9			jsr 	OSGetScreenPosition
.2ac8	e0 10		cpx #$10			cpx 	#16
.2aca	90 f4		bcc $2ac0			bcc 	_CDPad
.2acc	a0 11		ldy #$11			ldy 	#17
.2ace	b1 24		lda ($24),y			lda 	(zTemp0),y
.2ad0	aa		tax				tax
.2ad1	88		dey				dey
.2ad2	b1 24		lda ($24),y			lda 	(zTemp0),y
.2ad4	20 ce 2b	jsr $2bce			jsr 	WriteIntXA
.2ad7	a2 e2		ldx #$e2			ldx 	#_CDTail & $FF
.2ad9	a0 2a		ldy #$2a			ldy 	#_CDTail >> 8
.2adb	20 df ff	jsr $ffdf			jsr 	OSWriteString
.2ade	80 d3		bra $2ab3			bra 	_CDLoop
.2ae0	7a		ply		_CDExit:ply
.2ae1	60		rts				rts
.2ae2					_CDTail:
>2ae2	08						.byte 	_CDTail2-*-1
>2ae3	20 62 79 74 65 73 2e 0d				.text 	" bytes.",13
.2aeb					_CDTail2:

;******  Return to file: include.files


;******  Processing file: src/system/files/erase.asm

.2aeb					Command_ERASE:
.2aeb	20 fd 2a	jsr $2afd			jsr 	FileSetupBlock 				; set up file i/o block with filename.
.2aee	5a		phy				phy
.2aef	a2 26		ldx #$26			ldx 	#FSBBlock & $FF
.2af1	a0 06		ldy #$06			ldy 	#FSBBlock >> 8
.2af3	20 cd ff	jsr $ffcd			jsr 	OSDeleteFile
.2af6	7a		ply				ply
.2af7	b0 01		bcs $2afa			bcs 	_CEFail
.2af9	60		rts				rts
.2afa					_CEFail:
.2afa	4c 4b 29	jmp $294b		jmp	ErrorV_fnf
.2afd					FileSetupBlock:
.2afd	20 d9 17	jsr $17d9			jsr 	EXPEvalString 					; string to R0, zTemp0
.2b00	a5 24		lda $24				lda 	zTemp0 							; address to name
.2b02	8d 26 06	sta $0626			sta 	FSBBlock
.2b05	a5 25		lda $25				lda 	zTemp0+1
.2b07	8d 27 06	sta $0627			sta 	FSBBlock+1 						; zero the rest.
.2b0a	9c 28 06	stz $0628			stz 	FSBBlock+2
.2b0d	9c 29 06	stz $0629			stz 	FSBBlock+3
.2b10	9c 2a 06	stz $062a			stz 	FSBBlock+4
.2b13	9c 2b 06	stz $062b			stz 	FSBBlock+5
.2b16	60		rts				rts
.0626					FSBBlock:
>0626							.fill 	6

;******  Return to file: include.files


;******  Processing file: src/system/files/load.asm

.2b17					Command_LOAD:
.2b17	20 fd 2a	jsr $2afd			jsr 	FileSetupBlock 				; set up file i/o block with filename.
.2b1a	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; set load address
.2b1d	8d 29 06	sta $0629			sta 	FSBBlock+3
.2b20	9c 28 06	stz $0628			stz 	FSBBlock+2
.2b23	b1 18		lda ($18),y			lda 	(codePtr),y 				; what follows ?
.2b25	48		pha				pha
.2b26	20 43 2b	jsr $2b43			jsr	 	FileCheckSecondParam
.2b29	5a		phy				phy
.2b2a	a2 26		ldx #$26			ldx 	#FSBBlock & $FF
.2b2c	a0 06		ldy #$06			ldy 	#FSBBlock >> 8
.2b2e	20 d0 ff	jsr $ffd0			jsr 	OSReadFile
.2b31	7a		ply				ply
.2b32	b0 0c		bcs $2b40			bcs 	_CLFail
.2b34	68		pla				pla 								; load program
.2b35	c9 99		cmp #$99			cmp 	#PR_COMMA
.2b37	f0 06		beq $2b3f			beq 	_CLNoClear
.2b39	20 9c 10	jsr $109c			jsr 	ClearCode 					; run CLEAR code, loaded a new program in.
.2b3c	4c ed 2b	jmp $2bed			jmp 	WarmStart 					; and warm start
.2b3f					_CLNoClear:
.2b3f	60		rts				rts
.2b40					_CLFail:
.2b40	4c 4b 29	jmp $294b		jmp	ErrorV_fnf
.2b43					FileCheckSecondParam:
.2b43	b1 18		lda ($18),y			lda 	(codePtr),y 				; , follows
.2b45	c9 99		cmp #$99			cmp 	#PR_COMMA
.2b47	d0 0e		bne $2b57			bne 	_FCSPExit
.2b49	c8		iny				iny 								; consume
.2b4a	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; get address
.2b4d	a5 08		lda $08				lda 	IFR0+IM0	 				; copy it
.2b4f	8d 28 06	sta $0628			sta 	FSBBlock+2
.2b52	a5 09		lda $09				lda 	IFR0+IM1
.2b54	8d 29 06	sta $0629			sta 	FSBBlock+3
.2b57					_FCSPExit:
.2b57	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/system/files/save.asm

.2b58					Command_SAVE:
.2b58	20 fd 2a	jsr $2afd			jsr 	FileSetupBlock 				; set up file i/o block with filename.
.2b5b	b1 18		lda ($18),y			lda 	(codePtr),y 				; what follows ?
.2b5d	c9 99		cmp #$99			cmp 	#PR_COMMA 					; comma ?
.2b5f	f0 22		beq $2b83			beq 	_CLSaveBlock 				; save "Name",from,size
.2b61	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; set load address
.2b64	8d 29 06	sta $0629			sta 	FSBBlock+3
.2b67	9c 28 06	stz $0628			stz 	FSBBlock+2
.2b6a	20 6d 21	jsr $216d			jsr		PGMEndProgram 				; end of program -> zTemp0
.2b6d	e6 24		inc $24				inc 	zTemp0 						; bump past end NULL
.2b6f	d0 02		bne $2b73			bne 	_CLNoCarry
.2b71	e6 25		inc $25				inc 	zTemp0+1
.2b73					_CLNoCarry:
.2b73	a5 24		lda $24				lda 	zTemp0
.2b75	8d 2a 06	sta $062a			sta 	FSBBlock+4
.2b78	38		sec				sec
.2b79	a5 25		lda $25				lda 	zTemp0+1
.2b7b	ed 29 06	sbc $0629			sbc 	FSBBlock+3
.2b7e	8d 2b 06	sta $062b			sta 	FSBBlock+5
.2b81	80 13		bra $2b96			bra 	_CSSave
.2b83					_CLSaveBlock:
.2b83	20 43 2b	jsr $2b43			jsr 	FileCheckSecondParam 		; the address to save from.
.2b86	20 7f 29	jsr $297f			jsr 	ERRCheckComma
.2b89	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; get size
.2b8c	a5 08		lda $08				lda 	IFR0+IM0	 				; copy it
.2b8e	8d 2a 06	sta $062a			sta 	FSBBlock+4
.2b91	a5 09		lda $09				lda 	IFR0+IM1
.2b93	8d 2b 06	sta $062b			sta 	FSBBlock+5
.2b96					_CSSave:
.2b96	5a		phy				phy
.2b97	a2 26		ldx #$26			ldx 	#FSBBlock & $FF
.2b99	a0 06		ldy #$06			ldy 	#FSBBlock >> 8
.2b9b	20 d3 ff	jsr $ffd3			jsr 	OSWriteFile
.2b9e	7a		ply				ply
.2b9f	b0 01		bcs $2ba2			bcs 	_CSFail
.2ba1	60		rts				rts
.2ba2					_CSFail:
.2ba2	4c 5e 29	jmp $295e		jmp	ErrorV_full

;******  Return to file: include.files


;******  Processing file: src/ui/errorhandler.asm

.2ba5					ErrorHandler:
.2ba5	fa		plx				plx 								; get address of msg
.2ba6	7a		ply				ply
.2ba7	e8		inx				inx 								; bump past RTS
.2ba8	d0 01		bne $2bab			bne 	_EHNoInc
.2baa	c8		iny				iny
.2bab					_EHNoInc:
.2bab	20 df ff	jsr $ffdf			jsr	 	OSWriteString 				; print it.
.2bae	ad 2c 06	lda $062c			lda 	ERRLine 					; direct command ?
.2bb1	0d 2d 06	ora $062d			ora 	ERRLine+1
.2bb4	f0 10		beq $2bc6			beq 	_EHNoNumber
.2bb6	a2 c9		ldx #$c9			ldx 	#_EHAtMsg & $FF
.2bb8	a0 2b		ldy #$2b			ldy 	#_EHAtMsg >> 8
.2bba	20 df ff	jsr $ffdf			jsr 	OSWriteString
.2bbd	ad 2c 06	lda $062c			lda 	ERRLine 					; line number -> XA
.2bc0	ae 2d 06	ldx $062d			ldx 	ERRLine+1
.2bc3	20 ce 2b	jsr $2bce			jsr 	WriteIntXA
.2bc6					_EHNoNumber:
.2bc6	4c f7 2b	jmp $2bf7			jmp 	WarmStartNewLine
.2bc9					_EHAtMsg:
>2bc9	04 20 61 74 20					.text 	_EHAtMsg1-_EHAtMsg-1," at "
.2bce					_EHAtMsg1:
.2bce					WriteIntXA:
.2bce	da		phx				phx
.2bcf	48		pha				pha
.2bd0	a2 08		ldx #$08			ldx 	#IFR0
.2bd2	20 63 33	jsr $3363			jsr 	IFloatPushRx
.2bd5	68		pla				pla
.2bd6	20 16 34	jsr $3416			jsr 	IFloatSetByte
.2bd9	68		pla				pla
.2bda	85 09		sta $09				sta 	IFR0+IM1
.2bdc	a9 0a		lda #$0a			lda 	#10 						; decimal
.2bde	20 b6 31	jsr $31b6			jsr 	IFloatIntegerToStringR0	 	; convert
.2be1	20 df ff	jsr $ffdf			jsr 	OSWriteString 				; print
.2be4	a2 08		ldx #$08			ldx 	#IFR0
.2be6	20 84 33	jsr $3384			jsr 	IFloatPullRx
.2be9	60		rts				rts
.2bea					NotImplemented:
.2bea	4c e0 27	jmp $27e0		jmp	ErrorV_unimplemented
.062c					ERRLine:
>062c							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/ui/warmstart.asm

.2bed					WarmStart:
.2bed	a9 4f		lda #$4f			lda 	#"O" 						; Ready prompt
.2bef	20 f7 ff	jsr $fff7			jsr 	OSWriteScreen
.2bf2	a9 6b		lda #$6b			lda 	#"k"
.2bf4	20 f7 ff	jsr $fff7			jsr 	OSWriteScreen
.2bf7					WarmStartNewLine:
.2bf7	a9 0d		lda #$0d			lda 	#13
.2bf9	20 f7 ff	jsr $fff7			jsr 	OSWriteScreen
.2bfc					WarmStartNoPrompt:
.2bfc	a2 ff		ldx #$ff			ldx 	#$FF 						; 6502 stack reset.
.2bfe	9a		txs				txs
.2bff	20 e5 ff	jsr $ffe5			jsr 	OSScreenLine 				; edit
.2c02	e8		inx				inx 								; skip length byte to make it ASCIIZ
.2c03	d0 01		bne $2c06			bne 	_WSSkip
.2c05	c8		iny				iny
.2c06					_WSSkip:
.2c06	86 28		stx $28				stx 	zTemp2 						; save address
.2c08	84 29		sty $29				sty 	zTemp2+1
.2c0a	b2 28		lda ($28)			lda 	(zTemp2)
.2c0c	f0 ee		beq $2bfc			beq 	WarmStartNoPrompt 			; ignore empty line.
.2c0e	a2 40		ldx #$40			ldx 	#TOKGetCharacter & $FF 		; tokenise it.
.2c10	a0 2c		ldy #$2c			ldy 	#TOKGetCharacter >> 8
.2c12	38		sec				sec
.2c13	20 df 21	jsr $21df			jsr 	TOKTokenise
.2c16	b0 25		bcs $2c3d			bcs 	_WSSyntax
.2c18	ad 01 04	lda $0401			lda 	TOKLineNumber 				; if line number zero
.2c1b	0d 02 04	ora $0402			ora 	TOKLineNumber+1
.2c1e	d0 0b		bne $2c2b			bne 	_WSLineEdit
.2c20	a9 00		lda #$00			lda 	#TOKLineSize & $FF 			; execute code.
.2c22	85 18		sta $18				sta 	codePtr
.2c24	a9 04		lda #$04			lda 	#TOKLineSize >> 8
.2c26	85 19		sta $19				sta 	codePtr+1
.2c28	4c 7b 15	jmp $157b			jmp 	RUNNewLine
.2c2b					_WSLineEdit:
.2c2b	20 ba 20	jsr $20ba			jsr 	PGMDeleteLine 				; delete line, perhaps ?
.2c2e	ad 00 04	lda $0400			lda 	TOKLineSize 				; check line is empty.
.2c31	c9 04		cmp #$04			cmp 	#4
.2c33	f0 03		beq $2c38			beq 	_WSNoInsert
.2c35	20 04 21	jsr $2104			jsr 	PGMInsertLine				; if not, maybe insert
.2c38					_WSNoInsert:
.2c38	20 9c 10	jsr $109c			jsr 	ClearCode 					; clear variables etc.
.2c3b	80 bf		bra $2bfc			bra 	WarmStartNoPrompt
.2c3d					_WSSyntax:
.2c3d	4c 9e 27	jmp $279e		jmp	ErrorV_syntax
.2c40					TOKGetCharacter:
.2c40	b2 28		lda ($28)			lda 	(zTemp2)
.2c42	90 06		bcc $2c4a			bcc 	_GSNoIncrement
.2c44	e6 28		inc $28				inc 	zTemp2
.2c46	d0 02		bne $2c4a			bne 	_GSNoIncrement
.2c48	e6 29		inc $29				inc 	zTemp2+1
.2c4a					_GSNoIncrement:
.2c4a	c9 00		cmp #$00			cmp 	#0
.2c4c	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/variables/array.asm

.2c4d					VARArrayLookup:
.2c4d	85 24		sta $24				sta 	zTemp0 						; save the array address pointer in zTemp0
.2c4f	86 25		stx $25				stx 	zTemp0+1
.2c51	b2 24		lda ($24)			lda 	(zTemp0)
.2c53	48		pha				pha
.2c54	5a		phy				phy
.2c55	a0 01		ldy #$01			ldy 	#1
.2c57	b1 24		lda ($24),y			lda 	(zTemp0),y
.2c59	7a		ply				ply
.2c5a	48		pha				pha
.2c5b	20 c1 17	jsr $17c1			jsr 	EXPEvalInteger16 			; R0 now contains the index
.2c5e	68		pla				pla 								; array address to zTemp0
.2c5f	85 25		sta $25				sta 	zTemp0+1
.2c61	68		pla				pla
.2c62	85 24		sta $24				sta 	zTemp0
.2c64	5a		phy				phy 								; save codePtr position.
.2c65	a0 01		ldy #$01			ldy 	#1 							; get 14-8 of size.
.2c67	b1 24		lda ($24),y			lda 	(zTemp0),y
.2c69	48		pha				pha 								; save bit 15 on stack.
.2c6a	29 7f		and #$7f			and 	#$7F
.2c6c	85 26		sta $26				sta 	zTemp1
.2c6e	a5 08		lda $08				lda 	IFR0+IM0 					; check range of index
.2c70	d2 24		cmp ($24)			cmp 	(zTemp0)
.2c72	a5 09		lda $09				lda 	IFR0+IM1
.2c74	e5 26		sbc $26				sbc 	zTemp1
.2c76	b0 3a		bcs $2cb2			bcs 	_VALIndex
.2c78	a5 09		lda $09				lda 	IFR0+IM1  					; sanity check
.2c7a	c9 40		cmp #$40			cmp 	#$40
.2c7c	b0 34		bcs $2cb2			bcs 	_VALIndex
.2c7e	06 08		asl $08				asl 	IFR0+IM0 					; index x 2 (has sub arrays) x 4 (is data)
.2c80	26 09		rol $09				rol 	IFR0+IM1
.2c82	fa		plx				plx 								; get msb of size -> X
.2c83	30 04		bmi $2c89			bmi 	_VARNotX4 					; if bit 15 set its an array of pointers so x 2
.2c85	06 08		asl $08				asl 	IFR0+IM0
.2c87	26 09		rol $09				rol 	IFR0+IM1
.2c89					_VARNotX4:
.2c89	18		clc				clc 								; add the two for the size bytes
.2c8a	a5 08		lda $08				lda 	IFR0+IM0
.2c8c	69 02		adc #$02			adc 	#2
.2c8e	85 08		sta $08				sta 	IFR0+IM0
.2c90	90 02		bcc $2c94			bcc 	_VARNoCarry1
.2c92	e6 09		inc $09				inc 	IFR0+IM1
.2c94					_VARNoCarry1:
.2c94	18		clc				clc 								; calculate the element address and push to stack.
.2c95	a5 08		lda $08				lda 	IFR0+IM0
.2c97	65 24		adc $24				adc 	zTemp0
.2c99	48		pha				pha
.2c9a	a5 09		lda $09				lda 	IFR0+IM1
.2c9c	65 25		adc $25				adc 	zTemp0+1
.2c9e	e0 00		cpx #$00			cpx 	#0 							; do we have a sub level ?
.2ca0	30 04		bmi $2ca6			bmi 	_VARHasSubLevel
.2ca2	aa		tax				tax 								; address in XA
.2ca3	68		pla				pla
.2ca4	7a		ply				ply 								; restore Y and exit
.2ca5	60		rts				rts
.2ca6					_VARHasSubLevel:
.2ca6	aa		tax				tax 								; get link address in XA
.2ca7	68		pla				pla
.2ca8	7a		ply				ply 								; restore code position.
.2ca9	48		pha				pha
.2caa	20 7f 29	jsr $297f			jsr 	ERRCheckComma 				; comma required.
.2cad	68		pla				pla
.2cae	20 4d 2c	jsr $2c4d			jsr 	VARArrayLookup 				; call it recursively
.2cb1	60		rts				rts
.2cb2					_VALIndex:
.2cb2	4c 7a 28	jmp $287a		jmp	ErrorV_index

;******  Return to file: include.files


;******  Processing file: src/variables/create.asm

.2cb5					VARCreate:
.2cb5	5a		phy				phy
.2cb6	a9 09		lda #$09			lda 	#9 							; create 9 bytes of space
.2cb8	a2 00		ldx #$00			ldx 	#0
.2cba	20 b9 10	jsr $10b9			jsr 	AllocateMemory
.2cbd	85 26		sta $26				sta 	zTemp1 						; save new address in zTemp1
.2cbf	86 27		stx $27				stx 	zTemp1+1
.2cc1	a0 02		ldy #$02			ldy 	#2 							; put hash into +2
.2cc3	ad 30 06	lda $0630			lda 	VARHash
.2cc6	91 26		sta ($26),y			sta 	(zTemp1),y
.2cc8	c8		iny				iny 								; put address of name into +3,+4
.2cc9	ad 2e 06	lda $062e			lda 	VARNameAddress
.2ccc	91 26		sta ($26),y			sta 	(zTemp1),y
.2cce	c8		iny				iny
.2ccf	ad 2f 06	lda $062f			lda 	VARNameAddress+1
.2cd2	91 26		sta ($26),y			sta 	(zTemp1),y
.2cd4	ad 31 06	lda $0631			lda 	VARType
.2cd7	29 01		and #$01			and 	#1
.2cd9	f0 06		beq $2ce1			beq 	_CVNotString
.2cdb	a0 08		ldy #$08			ldy 	#5+3
.2cdd	a9 80		lda #$80			lda 	#$80
.2cdf	91 26		sta ($26),y			sta 	(zTemp1),y
.2ce1					_CVNotString:
.2ce1	ad 52 06	lda $0652			lda 	VARHashEntry 				; hash table ptr -> zTemp0
.2ce4	85 24		sta $24				sta 	zTemp0
.2ce6	ad 53 06	lda $0653			lda 	VARHashEntry+1
.2ce9	85 25		sta $25				sta 	zTemp0+1
.2ceb	a0 01		ldy #$01			ldy 	#1 							; put current head into link.
.2ced	b2 24		lda ($24)			lda 	(zTemp0)
.2cef	92 26		sta ($26)			sta 	(zTemp1)
.2cf1	b1 24		lda ($24),y			lda 	(zTemp0),y
.2cf3	91 26		sta ($26),y			sta 	(zTemp1),y
.2cf5	a5 26		lda $26				lda 	zTemp1 						; address of the new record into head
.2cf7	92 24		sta ($24)			sta 	(zTemp0)
.2cf9	a5 27		lda $27				lda 	zTemp1+1
.2cfb	91 24		sta ($24),y			sta 	(zTemp0),y
.2cfd	a5 26		lda $26				lda 	zTemp1 						; new record to XA
.2cff	a6 27		ldx $27				ldx 	zTemp1+1
.2d01	18		clc				clc 								; add 5 to point to the data.
.2d02	69 05		adc #$05			adc 	#5
.2d04	90 01		bcc $2d07			bcc 	_VCNoCarry
.2d06	e8		inx				inx
.2d07					_VCNoCarry:
.2d07	7a		ply				ply
.2d08	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/variables/find.asm

.2d09					VARFind:
.2d09	5a		phy				phy
.2d0a	a0 01		ldy #$01			ldy 	#1 							; get first link -> zTemp1
.2d0c	b1 24		lda ($24),y			lda 	(zTemp0),y
.2d0e	85 27		sta $27				sta 	zTemp1+1
.2d10	f0 1c		beq $2d2e			beq 	_VFExitFail 				; first link is 00xx, so nothing in that list.
.2d12	b2 24		lda ($24)			lda 	(zTemp0)
.2d14	85 26		sta $26				sta 	zTemp1
.2d16					_VFLoop:
.2d16	a0 02		ldy #$02			ldy 	#2 							; check hashes match
.2d18	b1 26		lda ($26),y			lda 	(zTemp1),y
.2d1a	cd 30 06	cmp $0630			cmp 	VARHash
.2d1d	f0 12		beq $2d31			beq 	_VFHashesMatch 				; if so, check the name.
.2d1f					_VFNext:
.2d1f	b2 26		lda ($26)			lda 	(zTemp1) 					; next link to AX
.2d21	aa		tax				tax
.2d22	a0 01		ldy #$01			ldy 	#1
.2d24	b1 26		lda ($26),y			lda 	(zTemp1),y
.2d26	85 27		sta $27				sta 	zTemp1+1
.2d28	86 26		stx $26				stx 	zTemp1
.2d2a	c9 00		cmp #$00			cmp 	#0 							; if msb non zero, try again
.2d2c	d0 e8		bne $2d16			bne 	_VFLoop
.2d2e					_VFExitFail:
.2d2e	7a		ply				ply
.2d2f	18		clc				clc
.2d30	60		rts				rts
.2d31					_VFHashesMatch:
.2d31	a0 03		ldy #$03			ldy 	#3 							; get address of name -> zTemp2
.2d33	b1 26		lda ($26),y			lda 	(zTemp1),y
.2d35	85 28		sta $28				sta 	zTemp2
.2d37	c8		iny				iny
.2d38	b1 26		lda ($26),y			lda 	(zTemp1),y
.2d3a	85 29		sta $29				sta 	zTemp2+1
.2d3c	a0 ff		ldy #$ff			ldy 	#$FF 						; now compare
.2d3e					_VFNameCompLoop:
.2d3e	c8		iny				iny 								; char at a time
.2d3f	b9 32 06	lda $0632,y			lda 	VARBuffer,y
.2d42	d1 28		cmp ($28),y			cmp 	(zTemp2),y
.2d44	d0 d9		bne $2d1f			bne 	_VFNext						; next entry if different.
.2d46	c9 7c		cmp #$7c			cmp 	#$7C
.2d48	90 f4		bcc $2d3e			bcc 	_VFNameCompLoop 			; until done the whole lot.
.2d4a	18		clc				clc
.2d4b	a5 26		lda $26				lda 	zTemp1
.2d4d	a6 27		ldx $27				ldx 	zTemp1+1
.2d4f	69 05		adc #$05			adc 	#5
.2d51	90 01		bcc $2d54			bcc 	_VFNNoCarry
.2d53	e8		inx				inx
.2d54					_VFNNoCarry:
.2d54	7a		ply				ply
.2d55	38		sec				sec
.2d56	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/variables/info.asm

.2d57					VARGetInfo:
.2d57	98		tya				tya 								; calculate the address of the identifier start.
.2d58	18		clc				clc
.2d59	65 18		adc $18				adc 	codePtr
.2d5b	8d 2e 06	sta $062e			sta 	VARNameAddress
.2d5e	a5 19		lda $19				lda 	codePtr+1
.2d60	69 00		adc #$00			adc 	#0
.2d62	8d 2f 06	sta $062f			sta 	VARNameAddress+1
.2d65	9c 30 06	stz $0630			stz 	VARHash
.2d68	a2 00		ldx #$00			ldx 	#0
.2d6a					_VARCopyName:
.2d6a	18		clc				clc 								; update the sum hash.
.2d6b	ad 30 06	lda $0630			lda 	VARHash
.2d6e	71 18		adc ($18),y			adc 	(codePtr),y
.2d70	8d 30 06	sta $0630			sta 	VARHash
.2d73	b1 18		lda ($18),y			lda 	(codePtr),y 				; get character and save it in buffer
.2d75	c8		iny				iny
.2d76	9d 32 06	sta $0632,x			sta 	VARBuffer,x
.2d79	e8		inx				inx
.2d7a	c9 7c		cmp #$7c			cmp 	#$7C 						; until copied the type byte
.2d7c	90 ec		bcc $2d6a			bcc 	_VARCopyName
.2d7e	8d 31 06	sta $0631			sta 	VARType 					; save type byte
.2d81	29 03		and #$03			and 	#3 							; type is 0-3
.2d83	0a		asl a				asl 	a
.2d84	0a		asl a				asl 	a
.2d85	85 24		sta $24				sta 	zTemp0
.2d87	ad 30 06	lda $0630			lda 	VARHash 					; force into range of hash entries per type.
.2d8a	29 03		and #$03			and		#(VARHashEntriesPerType-1)
.2d8c	65 24		adc $24				adc 	zTemp0 						; index of hash table
.2d8e	0a		asl a				asl 	a 							; offset as 2 bytes / word.
.2d8f	69 54		adc #$54			adc 	#VARHashTables & $FF 		; address of hash table start to zTemp0 & VARHashEntry
.2d91	85 24		sta $24				sta 	zTemp0
.2d93	8d 52 06	sta $0652			sta 	VARHashEntry
.2d96	a9 06		lda #$06			lda 	#VARHashTables >> 8
.2d98	69 00		adc #$00			adc 	#0
.2d9a	85 25		sta $25				sta 	zTemp0+1
.2d9c	8d 53 06	sta $0653			sta 	VARHashEntry+1
.2d9f	60		rts				rts
.2da0					VARClearHashTables:
.2da0	a2 00		ldx #$00			ldx 	#0
.2da2					_VCHRLoop:
.2da2	a9 00		lda #$00			lda 	#0
.2da4	9d 54 06	sta $0654,x			sta 	VARHashTables,x
.2da7	e8		inx				inx
.2da8	e0 20		cpx #$20			cpx 	#VARHashEntriesPerType*4*2
.2daa	d0 f6		bne $2da2			bne 	_VCHRLoop
.2dac	60		rts				rts
.062e					VARNameAddress:
>062e							.fill 	2
.0630					VARHash:
>0630							.fill 	1
.0631					VARType:
>0631							.fill 	1
.0632					VARBuffer:
>0632							.fill 	32
.0652					VARHashEntry:
>0652							.fill 	2
=4					VARHashEntriesPerType = 4 					; hash entries for each of the 4 types.
.0654					VARHashTables:
>0654							.fill 	VARHashEntriesPerType*4*2

;******  Return to file: include.files


;******  Processing file: src/variables/variables.asm

.2dad					VARCheckSimple:
.2dad	aa		tax				tax 								; save in X
.2dae	b1 18		lda ($18),y			lda 	(codePtr),y
.2db0	c9 7c		cmp #$7c			cmp 	#$7C
.2db2	d0 15		bne $2dc9			bne 	_VCSComplex
.2db4	c8		iny				iny 								; consume the second byte, the type.
.2db5	8a		txa				txa  								; character (40-7F) x 4
.2db6	0a		asl a				asl 	a
.2db7	0a		asl a				asl  	a
.2db8	18		clc				clc
.2db9	69 74		adc #$74			adc 	#FastVariables & $FF
.2dbb	85 08		sta $08				sta 	IFR0+IM0
.2dbd	a9 06		lda #$06			lda 	#FastVariables >> 8
.2dbf	69 00		adc #$00			adc 	#0
.2dc1	85 09		sta $09				sta 	IFR0+IM1
.2dc3	64 0a		stz $0a				stz 	IFR0+IM2
.2dc5	64 0b		stz $0b				stz 	IFR0+IExp
.2dc7	38		sec				sec 								; it's a reference
.2dc8	60		rts				rts
.2dc9					_VCSComplex:
.2dc9	88		dey				dey	 								; extract information.
.2dca	20 57 2d	jsr $2d57			jsr 	VARGetInfo
.2dcd	20 09 2d	jsr $2d09			jsr 	VARFind 					; search for variable
.2dd0	b0 0a		bcs $2ddc			bcs 	_VCSHaveVariable
.2dd2	ad 31 06	lda $0631			lda 	VARType 					; error if arrays, cannot autocreate
.2dd5	29 02		and #$02			and 	#2
.2dd7	d0 25		bne $2dfe			bne 	_VCNoCreate
.2dd9	20 b5 2c	jsr $2cb5			jsr 	VARCreate 					; create variable
.2ddc					_VCSHaveVariable:
.2ddc	48		pha				pha 								; save LSB on the stack
.2ddd	ad 31 06	lda $0631			lda 	VARType 					; get var type, and shift bit 1 into carry
.2de0	6a		ror a				ror 	a
.2de1	6a		ror a				ror 	a
.2de2	68		pla				pla 								; restore LSB
.2de3	90 08		bcc $2ded			bcc 	_VCSNotArray 				; skip if not an array
.2de5	20 4d 2c	jsr $2c4d			jsr 	VARArrayLookup 				; look for subscripts.
.2de8	48		pha				pha 								; check )
.2de9	20 77 29	jsr $2977			jsr 	ERRCheckRParen
.2dec	68		pla				pla
.2ded					_VCSNotArray:
.2ded	86 09		stx $09				stx 	IFR0+IM1 					; save address
.2def	85 08		sta $08				sta 	IFR0+IM0
.2df1	64 0a		stz $0a				stz 	IFR0+IM2 					; clear the unused byte.
.2df3	ad 31 06	lda $0631			lda 	VARType 					; number/string bit into carry
.2df6	6a		ror a				ror 	a
.2df7	a9 00		lda #$00			lda 	#0
.2df9	6a		ror a				ror 	a 							; now $00 or $80
.2dfa	85 0b		sta $0b				sta 	IFR0+IExp
.2dfc	38		sec				sec 								; it's a reference
.2dfd	60		rts				rts
.2dfe					_VCNoCreate:
.2dfe	4c a0 28	jmp $28a0		jmp	ErrorV_uninitialised
.0674					FastVariables:
>0674							.fill	26*4

;******  Return to file: include.files


;******  Return to file: basic.asm


;******  Processing file: build/libmathslib.asmlib

=0					IM0 = 0 									; offsets in 4 byte records
=1					IM1 = 1
=2					IM2 = 2
=3					IExp = 3
=$3f					IFXMask = $3F 								; mask out the exponent
=$40					IFSign = $40 								; sign bit.
.2e01					IFInitialise:
.2e01	9c e4 06	stz $06e4			stz 	IFStackIndex 				; reset the internal stack.
.2e04	60		rts				rts
.2e05					IFloatSubtract:
.2e05	da		phx				phx
.2e06	a2 08		ldx #$08			ldx 	#IFR0
.2e08	20 1f 34	jsr $341f			jsr 	IFloatNegate 				; negate R0 and fall through to add.
.2e0b	fa		plx				plx
.2e0c					IFloatAdd:
.2e0c	b5 03		lda $03,x			lda 	IExp,x 						; check if both exponents are zero.
.2e0e	05 0b		ora $0b				ora 	IFR0+IExp
.2e10	29 3f		and #$3f			and 	#IFXMask 					; if not, then we have to do the
.2e12	d0 4e		bne $2e62			bne 	_IFloatAddDecimals 			; floating point version.
.2e14					_IFAddSubMantissa:
.2e14	b5 03		lda $03,x			lda 	IExp,x 						; are the signs different ?
.2e16	45 0b		eor $0b				eor 	IFR0+IExp
.2e18	29 40		and #$40			and 	#IFSign
.2e1a	d0 21		bne $2e3d			bne 	_IFloatSubMantissa			; if so, we do a subtract
.2e1c	18		clc				clc 								; do the actual addition
.2e1d	a5 08		lda $08				lda 	IFR0+IM0
.2e1f	75 00		adc $00,x			adc 		IM0,x
.2e21	85 08		sta $08				sta 	IFR0+IM0
.2e23	a5 09		lda $09				lda 	IFR0+IM1
.2e25	75 01		adc $01,x			adc 		IM1,x
.2e27	85 09		sta $09				sta 	IFR0+IM1
.2e29	a5 0a		lda $0a				lda 	IFR0+IM2
.2e2b	75 02		adc $02,x			adc 		IM2,x
.2e2d	85 0a		sta $0a				sta 	IFR0+IM2
.2e2f	10 29		bpl $2e5a			bpl 	_IFloatAddExit 				; if no carry through to bit 23, then exit.
.2e31	a2 08		ldx #$08			ldx 	#IFR0						; shift R0 right, divide by 2
.2e33	20 43 34	jsr $3443			jsr 	IFloatShiftRight 			; we are now in decimals mode.
.2e36	20 6d 34	jsr $346d			jsr 	IFloatIncExponent
.2e39	d0 1f		bne $2e5a			bne 	_IFloatAddExit
.2e3b	38		sec				sec 								; overflowed numerically.
.2e3c	60		rts				rts
.2e3d					_IFloatSubMantissa:
.2e3d	38		sec				sec 								; do the subtraction R0-Rx
.2e3e	a5 08		lda $08				lda 	IFR0+IM0
.2e40	f5 00		sbc $00,x			sbc 		IM0,x
.2e42	85 08		sta $08				sta 	IFR0+IM0
.2e44	a5 09		lda $09				lda 	IFR0+IM1
.2e46	f5 01		sbc $01,x			sbc 		IM1,x
.2e48	85 09		sta $09				sta 	IFR0+IM1
.2e4a	a5 0a		lda $0a				lda 	IFR0+IM2
.2e4c	f5 02		sbc $02,x			sbc 		IM2,x
.2e4e	85 0a		sta $0a				sta 	IFR0+IM2
.2e50	b0 08		bcs $2e5a			bcs 	_IFloatAddExit 				; no borrow so we are done.
.2e52	a2 08		ldx #$08			ldx 	#IFR0
.2e54	20 27 34	jsr $3427			jsr 	IFloatMantissaNegate 		; 2's complement negate the mantissa
.2e57	20 1f 34	jsr $341f			jsr 	IFloatNegate 				; negate the result using sign bit.
.2e5a					_IFloatAddExit:
.2e5a	18		clc				clc
.2e5b	60		rts				rts
.2e5c					_IFloatZeroAdd:
.2e5c	fa		plx				plx 								; return this value in R0
.2e5d	20 a5 33	jsr $33a5			jsr 	IFloatCopyFromRegister
.2e60	18		clc				clc
.2e61	60		rts				rts
.2e62					_IFloatAddDecimals:
.2e62	20 0d 34	jsr $340d			jsr		IFloatCheckZero 			; if RX = 0 then exit with R0
.2e65	f0 f3		beq $2e5a			beq 	_IFloatAddExit
.2e67	20 4b 34	jsr $344b			jsr 	IFloatNormalise 			; normalise RX
.2e6a	da		phx				phx 								; normalise R0
.2e6b	a2 08		ldx #$08			ldx 	#IFR0
.2e6d	20 0d 34	jsr $340d			jsr 	IFloatCheckZero
.2e70	f0 ea		beq $2e5c			beq 	_IFloatZeroAdd 				; normalised R0 is zero, return RX.
.2e72	20 4b 34	jsr $344b			jsr 	IFloatNormalise
.2e75	fa		plx				plx
.2e76	a5 0b		lda $0b				lda 	IFR0+IExp 					; get the exponent of R0
.2e78	29 3f		and #$3f			and 	#IFXMask
.2e7a	38		sec				sec
.2e7b	e9 20		sbc #$20			sbc 	#$20 						; map 20..3F..00..1F to 00..0F..E0..FF e.g. scaled unsigned
.2e7d	85 20		sta $20				sta 	iTemp0
.2e7f	b5 03		lda $03,x			lda 	IExp,x 						; repeat for exponent of Rx
.2e81	29 3f		and #$3f			and 	#IFXMask
.2e83	38		sec				sec
.2e84	e9 20		sbc #$20			sbc 	#$20
.2e86	c5 20		cmp $20				cmp 	iTemp0 						; get the larger adjusted
.2e88	b0 02		bcs $2e8c			bcs 	_IFloatHaveLarger
.2e8a	a5 20		lda $20				lda 	iTemp0
.2e8c					_IFloatHaveLarger:
.2e8c	18		clc				clc 								; get the actual one back.
.2e8d	69 20		adc #$20			adc 	#$20 						; shift both to that.
.2e8f	20 9c 2e	jsr $2e9c			jsr 	_IFShiftXToA
.2e92	da		phx				phx
.2e93	a2 08		ldx #$08			ldx 	#IFR0
.2e95	20 9c 2e	jsr $2e9c			jsr 	_IFShiftXToA
.2e98	fa		plx				plx
.2e99	4c 14 2e	jmp $2e14			jmp 	_IFAddSubMantissa 			; do the adding bit.
.2e9c					_IFShiftXToA:
.2e9c	8d dc 06	sta $06dc			sta 	IFTarget
.2e9f	20 0d 34	jsr $340d			jsr 	IFloatCheckZero 			; check adding zero ?
.2ea2	f0 11		beq $2eb5			beq 	_IFSXExit
.2ea4					_IFSXLoop:
.2ea4	b5 03		lda $03,x			lda 	IExp,x 	 					; shifted to the right level yet ?
.2ea6	29 3f		and #$3f			and 	#IFXMask
.2ea8	cd dc 06	cmp $06dc			cmp 	IFTarget
.2eab	f0 08		beq $2eb5			beq 	_IFSXExit
.2ead	20 43 34	jsr $3443			jsr 	IFloatShiftRight
.2eb0	20 6d 34	jsr $346d			jsr 	IFloatIncExponent
.2eb3	80 ef		bra $2ea4			bra 	_IFSXLoop
.2eb5					_IFSXExit:
.2eb5	60		rts				rts
.06dc					IFTarget:
>06dc							.fill 	1
.2eb6					IFloatMultiply:
.2eb6	8e dc 06	stx $06dc			stx 	IFTarget 					; save the multiplier (RX) which is "adder"
.2eb9	20 6e 2f	jsr $2f6e			jsr 	IFCalculateNewSign
.2ebc	b5 03		lda $03,x			lda 	IExp,x 						; check two positive 8 bit integers
.2ebe	05 0b		ora $0b				ora 	IFR0+IExp
.2ec0	29 3f		and #$3f			and 	#IFXMask
.2ec2	15 01		ora $01,x			ora 	IM1,x
.2ec4	05 09		ora $09				ora 	IFR0+IM1
.2ec6	15 02		ora $02,x			ora 	IM2,x
.2ec8	05 0a		ora $0a				ora 	IFR0+IM2
.2eca	d0 0a		bne $2ed6			bne 	_IFMStandard
.2ecc	20 f0 33	jsr $33f0			jsr 	IFloatMultiply8BitRx 		; we have a special routine for this.
.2ecf	ad de 06	lda $06de			lda 	IFNewSign
.2ed2	85 0b		sta $0b				sta 	IFR0+IExp
.2ed4	18		clc				clc
.2ed5	60		rts				rts
.2ed6					_IFMStandard:
.2ed6	b5 03		lda $03,x			lda 	IExp,x 						; add the two exponents sign extended
.2ed8	20 65 2f	jsr $2f65			jsr 	IFMSignExtend
.2edb	8d dd 06	sta $06dd			sta 	IFNewExponent
.2ede	a5 0b		lda $0b				lda 	IFR0+IExp
.2ee0	20 65 2f	jsr $2f65			jsr 	IFMSignExtend
.2ee3	18		clc				clc
.2ee4	6d dd 06	adc $06dd			adc 	IFNewExponent
.2ee7	8d dd 06	sta $06dd			sta 	IFNewExponent
.2eea	a2 14		ldx #$14			ldx 	#IFRTemp 					; copy R0 to RTemp which is "shifter"
.2eec	20 b6 33	jsr $33b6			jsr 	IFloatCopyToRegister
.2eef	a2 08		ldx #$08			ldx 	#IFR0 						; zero R0 (the result)
.2ef1	20 14 34	jsr $3414			jsr 	IFloatSetZero
.2ef4					_IFMLoop:
.2ef4	a2 14		ldx #$14			ldx 	#IFRTemp
.2ef6	20 0d 34	jsr $340d			jsr 	IFloatCheckZero
.2ef9	f0 3a		beq $2f35			beq 	_IFMExit
.2efb	ae dc 06	ldx $06dc			ldx 	IFTarget 					; look at adder MSB
.2efe	b5 02		lda $02,x			lda 	IM2,x 						; if it is set we need to shift everything
.2f00	10 03		bpl $2f05			bpl	 	_IFMTargetOkay
.2f02	20 56 2f	jsr $2f56			jsr 	_IFMShiftAll
.2f05					_IFMTargetOkay:
.2f05	a5 14		lda $14				lda 	IFRTemp+0 					; is bit 0 of the shifter (RTemp) set
.2f07	29 01		and #$01			and 	#1
.2f09	f0 16		beq $2f21			beq 	_IFMNoAdd
.2f0b	ae dc 06	ldx $06dc			ldx 	IFTarget 					; add adder
.2f0e	18		clc				clc
.2f0f	a5 08		lda $08				lda 	IFR0+IM0
.2f11	75 00		adc $00,x			adc 		IM0,x
.2f13	85 08		sta $08				sta 	IFR0+IM0
.2f15	a5 09		lda $09				lda 	IFR0+IM1
.2f17	75 01		adc $01,x			adc 		IM1,x
.2f19	85 09		sta $09				sta 	IFR0+IM1
.2f1b	a5 0a		lda $0a				lda 	IFR0+IM2
.2f1d	75 02		adc $02,x			adc 		IM2,x
.2f1f	85 0a		sta $0a				sta 	IFR0+IM2
.2f21					_IFMNoAdd:
.2f21	a5 0a		lda $0a				lda 	IFR0+IM2
.2f23	10 03		bpl $2f28			bpl 	_IFMResultOkay
.2f25	20 56 2f	jsr $2f56			jsr 	_IFMShiftAll
.2f28					_IFMResultOkay:
.2f28	a2 14		ldx #$14			ldx 	#IFRTemp
.2f2a	20 43 34	jsr $3443			jsr 	IFloatShiftRight
.2f2d	ae dc 06	ldx $06dc			ldx 	IFTarget
.2f30	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.2f33	80 bf		bra $2ef4			bra 	_IFMLoop
.2f35					_IFMExit:
.2f35	ad dd 06	lda $06dd			lda 	IFNewExponent 				; validate new exponent.
.2f38	c9 20		cmp #$20			cmp 	#$20 						; valid exponent 00-1F E0-FF
.2f3a	90 0f		bcc $2f4b			bcc 	_IFMOkay
.2f3c	c9 e0		cmp #$e0			cmp 	#$E0
.2f3e	b0 0b		bcs $2f4b			bcs 	_IFMOkay
.2f40	29 80		and #$80			and 	#$80 						; if +ve exponent then error overflow.
.2f42	f0 10		beq $2f54			beq 	_IFMError
.2f44	a2 08		ldx #$08			ldx 	#IFR0 						; return zero underflow
.2f46	20 14 34	jsr $3414			jsr 	IFloatSetZero
.2f49	18		clc				clc
.2f4a	60		rts				rts
.2f4b					_IFMOkay:
.2f4b	29 3f		and #$3f			and 	#IFXMask 					; work out exponent + sign and exit
.2f4d	0d de 06	ora $06de			ora 	IFNewSign
.2f50	85 0b		sta $0b				sta 	IFR0+IExp
.2f52	18		clc				clc
.2f53	60		rts				rts
.2f54					_IFMError:
.2f54	38		sec				sec
.2f55	60		rts				rts
.2f56					_IFMShiftAll:
.2f56	a2 08		ldx #$08			ldx 	#IFR0
.2f58	20 43 34	jsr $3443			jsr 	IFloatShiftRight
.2f5b	ae dc 06	ldx $06dc			ldx 	IFTarget
.2f5e	20 43 34	jsr $3443			jsr 	IFloatShiftRight
.2f61	ee dd 06	inc $06dd			inc 	IFNewExponent
.2f64	60		rts				rts
.2f65					IFMSignExtend:
.2f65	29 3f		and #$3f			and 	#IFXMask
.2f67	c9 1f		cmp #$1f			cmp 	#(IFXMask >> 1)
.2f69	90 02		bcc $2f6d			bcc 	_IFMNoSXX
.2f6b	09 c0		ora #$c0			ora 	#IFXMask ^ $FF
.2f6d					_IFMNoSXX:
.2f6d	60		rts				rts
.2f6e					IFCalculateNewSign:
.2f6e	b5 03		lda $03,x			lda 	IExp,x
.2f70	45 0b		eor $0b				eor 	IFR0+IExp
.2f72	29 40		and #$40			and 	#IFSign
.2f74	8d de 06	sta $06de			sta 	IFNewSign
.2f77	60		rts				rts
.06dd					IFNewExponent:
>06dd							.fill 	1
.06de					IFNewSign:
>06de							.fill 	1
.2f78					IFloatDivideInteger:
.2f78	20 91 2f	jsr $2f91			jsr 	IFloatDivideIntegerCommon 	; do the common code.
.2f7b	b0 06		bcs $2f83			bcs 	_IFDIExit
.2f7d	a2 14		ldx #$14			ldx 	#IFRTemp 					; copy result from register.
.2f7f	20 a5 33	jsr $33a5			jsr 	IFloatCopyFromRegister
.2f82	18		clc				clc
.2f83					_IFDIExit:
.2f83	60		rts				rts
.2f84					IFloatModulusInteger:
.2f84	20 91 2f	jsr $2f91			jsr 	IFloatDivideIntegerCommon
.2f87	b0 07		bcs $2f90			bcs 	_IFMIExit
.2f89	ae dc 06	ldx $06dc			ldx 	IFTarget
.2f8c	20 a5 33	jsr $33a5			jsr 	IFloatCopyFromRegister
.2f8f	18		clc				clc
.2f90					_IFMIExit:
.2f90	60		rts				rts
.2f91					IFloatDivideIntegerCommon:
.2f91	8e dc 06	stx $06dc			stx 	IFTarget  					; this is s1, s0 = R0
.2f94	20 6e 2f	jsr $2f6e			jsr 	IFCalculateNewSign 			; calculate sign of result
.2f97	20 bf 2f	jsr $2fbf			jsr 	IFDCopyRXToRTemp 			; copy S1 to RTemp
.2f9a	a2 08		ldx #$08			ldx 	#IFR0 						; check divide by zero
.2f9c	20 0d 34	jsr $340d			jsr 	IFloatCheckZero
.2f9f	f0 1c		beq $2fbd			beq 	_IFDIDivZero
.2fa1	ae dc 06	ldx $06dc			ldx 	IFTarget 					; zero Rx (S1)
.2fa4	20 14 34	jsr $3414			jsr 	IFloatSetZero
.2fa7	5a		phy				phy
.2fa8	a0 18		ldy #$18			ldy 	#24
.2faa					_IFDILoop:
.2faa	20 d0 2f	jsr $2fd0			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.2fad	20 dc 2f	jsr $2fdc			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.2fb0	88		dey				dey
.2fb1	d0 f7		bne $2faa			bne 	_IFDILoop 					; do it 24 times
.2fb3	7a		ply				ply
.2fb4	ad de 06	lda $06de			lda 	IFNewSign 					; set sign of result.
.2fb7	29 40		and #$40			and 	#IFSign
.2fb9	85 17		sta $17				sta 	IFRTemp+IExp
.2fbb	18		clc				clc 								; is okay.
.2fbc	60		rts				rts
.2fbd					_IFDIDivZero:
.2fbd	38		sec				sec
.2fbe	60		rts				rts
.2fbf					IFDCopyRXToRTemp:
.2fbf	b5 00		lda $00,x			lda 	IM0,x
.2fc1	85 14		sta $14				sta 	IFRTemp+IM0
.2fc3	b5 01		lda $01,x			lda 	IM1,x
.2fc5	85 15		sta $15				sta 	IFRTemp+IM1
.2fc7	b5 02		lda $02,x			lda 	IM2,x
.2fc9	85 16		sta $16				sta 	IFRTemp+IM2
.2fcb	b5 03		lda $03,x			lda 	IExp,x
.2fcd	85 17		sta $17				sta 	IFRTemp+IExp
.2fcf	60		rts				rts
.2fd0					IFDShiftSTempS1Left:
.2fd0	a2 14		ldx #$14			ldx 	#IFRTemp
.2fd2	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft
.2fd5	ae dc 06	ldx $06dc			ldx 	IFTarget
.2fd8	20 3c 34	jsr $343c			jsr 	IFloatRotateLeft
.2fdb	60		rts				rts
.2fdc					IFDTrySubtract:
.2fdc	ae dc 06	ldx $06dc			ldx 	IFTarget 					; s1 = Rx
.2fdf	38		sec				sec 								; subtract, saving the results on the stack.
.2fe0	b5 00		lda $00,x			lda 	IM0,x
.2fe2	e5 08		sbc $08				sbc 	IFR0+IM0
.2fe4	48		pha				pha
.2fe5	b5 01		lda $01,x			lda 	IM1,x
.2fe7	e5 09		sbc $09				sbc 	IFR0+IM1
.2fe9	48		pha				pha
.2fea	b5 02		lda $02,x			lda 	IM2,x
.2fec	e5 0a		sbc $0a				sbc 	IFR0+IM2
.2fee	b0 03		bcs $2ff3			bcs 	_IFDCanSubtract
.2ff0	68		pla				pla 								; cannot subtract, so pop intermediate and exit.
.2ff1	68		pla				pla
.2ff2	60		rts				rts
.2ff3					_IFDCanSubtract:
.2ff3	95 02		sta $02,x			sta 	IM2,x 						; write back to S1.Mantissa
.2ff5	68		pla				pla
.2ff6	95 01		sta $01,x			sta 	IM1,x
.2ff8	68		pla				pla
.2ff9	95 00		sta $00,x			sta 	IM0,x
.2ffb	e6 14		inc $14				inc 	IFRTemp+IM0 				; increment temp
.2ffd	d0 06		bne $3005			bne 	_IFDCSExit
.2fff	e6 15		inc $15				inc 	IFRTemp+IM1
.3001	d0 02		bne $3005			bne 	_IFDCSExit
.3003	e6 16		inc $16				inc 	IFRTemp+IM2
.3005					_IFDCSExit:
.3005	60		rts				rts
.3006					IFloatBitwiseAnd:
.3006	5a		phy				phy
.3007	20 4b 30	jsr $304b			jsr 	IFPreProcessBitwise 		; set up everything.
.300a	d0 0f		bne $301b			bne 	_IFBAExit
.300c					_IFBALoop:
.300c	b9 08 00	lda $0008,y			lda 	IFR0+IM0,y
.300f	35 00		and $00,x			and 	IM0,x
.3011	99 08 00	sta $0008,y			sta 	IFR0+IM0,y
.3014	e8		inx				inx
.3015	c8		iny				iny
.3016	c0 03		cpy #$03			cpy 	#3
.3018	d0 f2		bne $300c			bne 	_IFBALoop
.301a	18		clc				clc
.301b					_IFBAExit:
.301b	7a		ply				ply
.301c	60		rts				rts
.301d					IFloatBitwiseOr:
.301d	5a		phy				phy
.301e	20 4b 30	jsr $304b			jsr 	IFPreProcessBitwise 		; set up everything.
.3021	d0 0f		bne $3032			bne 	_IFBAExit
.3023					_IFBALoop:
.3023	b9 08 00	lda $0008,y			lda 	IFR0+IM0,y
.3026	15 00		ora $00,x			ora 	IM0,x
.3028	99 08 00	sta $0008,y			sta 	IFR0+IM0,y
.302b	e8		inx				inx
.302c	c8		iny				iny
.302d	c0 03		cpy #$03			cpy 	#3
.302f	d0 f2		bne $3023			bne 	_IFBALoop
.3031	18		clc				clc
.3032					_IFBAExit:
.3032	7a		ply				ply
.3033	60		rts				rts
.3034					IFloatBitwiseXor:
.3034	5a		phy				phy
.3035	20 4b 30	jsr $304b			jsr 	IFPreProcessBitwise 		; set up everything.
.3038	d0 0f		bne $3049			bne 	_IFBAExit
.303a					_IFBALoop:
.303a	b9 08 00	lda $0008,y			lda 	IFR0+IM0,y
.303d	55 00		eor $00,x			eor 	IM0,x
.303f	99 08 00	sta $0008,y			sta 	IFR0+IM0,y
.3042	e8		inx				inx
.3043	c8		iny				iny
.3044	c0 03		cpy #$03			cpy 	#3
.3046	d0 f2		bne $303a			bne 	_IFBALoop
.3048	18		clc				clc
.3049					_IFBAExit:
.3049	7a		ply				ply
.304a	60		rts				rts
.304b					IFPreProcessBitwise:
.304b	a0 00		ldy #$00			ldy 	#0 							; set index.
.304d	a5 0b		lda $0b				lda 	IFR0+IExp 					; OR exponents
.304f	15 03		ora $03,x			ora 	IExp,x
.3051	74 03		stz $03,x			stz 	IExp,x 						; zero the result exponent anyway.
.3053	29 3f		and #$3f			and 	#IFXMask 					; NZ if error e.g. not integer
.3055	38		sec				sec 								; carry set just in cases.
.3056	60		rts				rts
.3057					IFloatAbsoluteR0:
.3057	a5 0b		lda $0b				lda 	IFR0+IExp					; reset the sign bit.
.3059	29 bf		and #$bf			and 	#IFSign ^ 255
.305b	85 0b		sta $0b				sta 	IFR0+IExp
.305d	18		clc				clc
.305e	60		rts				rts
.305f					IFloatSquareRootR0:
.305f	a2 08		ldx #$08			ldx 	#IFR0 						; if zero, return zero.
.3061	20 0d 34	jsr $340d			jsr 	IFloatCheckZero
.3064	f0 2e		beq $3094			beq 	_IFSRZero
.3066	a5 0b		lda $0b				lda	 	IFR0+IExp 					; if negative fail.
.3068	29 40		and #$40			and 	#IFSign
.306a	d0 2f		bne $309b			bne 	_IFSRFail
.306c	20 4b 34	jsr $344b			jsr 	IFloatNormalise 			; it will work better !
.306f	a2 0c		ldx #$0c			ldx 	#IFR1 						; R1 contains original throughout
.3071	20 b6 33	jsr $33b6			jsr 	IFloatCopyToRegister
.3074	a5 0b		lda $0b				lda 	IFR0+IExp 					; if exponent is $2A..$3F * 64 otherwise is / 64
.3076	20 65 2f	jsr $2f65			jsr 	IFMSignExtend 				; sign extended version of the exponent
.3079	18		clc				clc
.307a	69 17		adc #$17			adc 	#23 						; this makes it a 0.xxx mantissa
.307c	85 0b		sta $0b				sta 	IFR0+IExp
.307e	4a		lsr a				lsr 	a 							; which we can halve.
.307f	38		sec				sec 								; convert back
.3080	e9 17		sbc #$17			sbc 	#23
.3082	29 3f		and #$3f			and 	#IFXMask 					; make appropriate
.3084	85 0b		sta $0b				sta 	IFR0+IExp 					; to R0
.3086	20 9d 30	jsr $309d			jsr 	_IFSRNewton
.3089	20 9d 30	jsr $309d			jsr 	_IFSRNewton
.308c	20 9d 30	jsr $309d			jsr 	_IFSRNewton
.308f	20 9d 30	jsr $309d			jsr 	_IFSRNewton
.3092	18		clc				clc
.3093	60		rts				rts
.3094					_IFSRZero:
.3094	a2 08		ldx #$08			ldx 	#IFR0
.3096	20 14 34	jsr $3414			jsr 	IFloatSetZero
.3099	18		clc				clc
.309a	60		rts				rts
.309b					_IFSRFail:
.309b	38		sec				sec
.309c	60		rts				rts
.309d					_IFSRNewton:
.309d	a2 0c		ldx #$0c			ldx 	#IFR1 						; push original value (R3) on the stack
.309f	20 63 33	jsr $3363			jsr 	IFloatPushRx
.30a2	a2 08		ldx #$08			ldx 	#IFR0 						; push current guess (R0) on the stack.
.30a4	20 63 33	jsr $3363			jsr 	IFloatPushRx
.30a7	a2 0c		ldx #$0c			ldx 	#IFR1 						; guess = original / guess
.30a9	20 38 31	jsr $3138			jsr 	IFloatDivideFloat
.30ac	a2 0c		ldx #$0c			ldx 	#IFR1 						; restore current guess (was in R0) to R3
.30ae	20 84 33	jsr $3384			jsr 	IFloatPullRx
.30b1	20 0c 2e	jsr $2e0c			jsr 	IFloatAdd 					; now guess + original/guess
.30b4	a2 08		ldx #$08			ldx 	#IFR0 						; divide by 2
.30b6	20 43 34	jsr $3443			jsr 	IFloatShiftRight
.30b9	a2 0c		ldx #$0c			ldx 	#IFR1
.30bb	20 84 33	jsr $3384			jsr 	IFloatPullRx 				; Finally pull the oeifinal
.30be	60		rts				rts
.30bf					IFloatFractionalR0:
.30bf	a5 0b		lda $0b				lda 	IFR0+IExp					; is it integer already ?
.30c1	29 3f		and #$3f			and 	#IFXMask
.30c3	f0 17		beq $30dc			beq 	_FIPZero 					; if so, return with zero as no fractional part.
.30c5	20 57 30	jsr $3057			jsr 	IFloatAbsoluteR0 			; absolute value R0
.30c8	a2 08		ldx #$08			ldx 	#IFR0
.30ca	20 4b 34	jsr $344b			jsr 	IFloatNormalise 			; normalise R0
.30cd	a2 14		ldx #$14			ldx 	#IFRTemp 					; copy to RTemp
.30cf	20 b6 33	jsr $33b6			jsr 	IFloatCopyToRegister
.30d2	20 15 31	jsr $3115			jsr 	IFloatIntegerR0 			; take integer part of R0
.30d5	a2 14		ldx #$14			ldx 	#IFRTemp 					; subtract
.30d7	20 05 2e	jsr $2e05			jsr 	IFloatSubtract
.30da	80 05		bra $30e1			bra 	_FIPExit
.30dc					_FIPZero:
.30dc	a2 08		ldx #$08			ldx 	#IFR0
.30de	20 14 34	jsr $3414			jsr 	IFloatSetZero
.30e1					_FIPExit:
.30e1	18		clc				clc
.30e2	60		rts				rts
.30e3					IFloatCompare:
.30e3	20 05 2e	jsr $2e05			jsr 	IFloatSubtract 				; subtract R0 from RX.
.30e6	b5 03		lda $03,x			lda 	IExp,x 						; check if integer comparison
.30e8	05 0b		ora $0b				ora 	IFR0+IExp
.30ea	a2 08		ldx #$08			ldx 	#IFR0 						; only using R0 from now on.
.30ec	29 3f		and #$3f			and 	#IFXMask
.30ee	d0 19		bne $3109			bne 	_IFCNonInteger
.30f0	20 0d 34	jsr $340d			jsr 	IFloatCheckZero 			; check if zero
.30f3	f0 0f		beq $3104			beq 	_IFCZero
.30f5					_IFCReturnSign:
.30f5	a5 0b		lda $0b				lda 	IFR0+IExp 					; get the sign bit/unused -> stack.
.30f7	29 c0		and #$c0			and 	#(IFXMask ^ $FF)
.30f9	48		pha				pha
.30fa	a9 01		lda #$01			lda 	#1
.30fc	20 16 34	jsr $3416			jsr 	IFloatSetByte 				; return to +1
.30ff	68		pla				pla 								; sign bit back
.3100	85 0b		sta $0b				sta 	IFR0+IExp					; set that sign
.3102	18		clc				clc
.3103	60		rts				rts
.3104					_IFCZero:
.3104	20 14 34	jsr $3414			jsr 	IFloatSetZero
.3107	18		clc				clc
.3108	60		rts				rts
.3109					_IFCNonInteger:
.3109	a5 08		lda $08				lda 	IFR0+IM0 	 				; can adjust what 'zero' means by changing the
.310b	29 00		and #$00			and		#$00 						; mask here to include bits from Mantissa.0
.310d	05 09		ora $09				ora 	IFR0+IM1
.310f	05 0a		ora $0a				ora 	IFR0+IM2
.3111	f0 f1		beq $3104			beq 	_IFCZero 					; near enough !
.3113	80 e0		bra $30f5			bra 	_IFCReturnSign 				; return the sign of the difference.
.3115					IFloatIntegerR0:
.3115	a5 0b		lda $0b				lda 	IFR0+IExp					; is it integer already ?
.3117	29 3f		and #$3f			and 	#IFXMask
.3119	f0 1b		beq $3136			beq 	_FIPExit 					; if so do nothing
.311b	a2 08		ldx #$08			ldx 	#IFR0
.311d	20 4b 34	jsr $344b			jsr 	IFloatNormalise 			; normalise
.3120	20 0d 34	jsr $340d			jsr 	IFloatCheckZero 			; is it zero ?
.3123	f0 0e		beq $3133			beq 	_FIPZero 					; if so return zero.
.3125					_FIPShift:
.3125	a5 0b		lda $0b				lda 	IFR0+IExp 					; if Exponent >= 0 exit.
.3127	29 20		and #$20			and 	#$20 						; still -ve
.3129	f0 0b		beq $3136			beq 	_FIPExit
.312b	20 43 34	jsr $3443			jsr 	IFloatShiftRight 			; shift mantissa right
.312e	20 6d 34	jsr $346d			jsr 	IFloatIncExponent 			; bump exponent
.3131	80 f2		bra $3125			bra 	_FIPShift
.3133					_FIPZero:
.3133	20 14 34	jsr $3414			jsr 	IFloatSetZero
.3136					_FIPExit:
.3136	18		clc				clc
.3137	60		rts				rts
.3138					IFloatDivideFloat:
.3138	8e dc 06	stx $06dc			stx 	IFTarget  					; this is s1, s0 = R0
.313b	20 6e 2f	jsr $2f6e			jsr 	IFCalculateNewSign 			; calculate sign of result
.313e	20 4b 34	jsr $344b			jsr 	IFloatNormalise 			; normalise RX
.3141	a2 08		ldx #$08			ldx 	#IFR0 						; normalise R0
.3143	20 4b 34	jsr $344b			jsr 	IFloatNormalise
.3146	20 0d 34	jsr $340d			jsr 	IFloatCheckZero
.3149	f0 56		beq $31a1			beq 	_IFDFDivZero 				; exit if this normalised to zero.
.314b	a5 0b		lda $0b				lda 	IFR0+IExp 					; calculate s0.exponent
.314d	20 65 2f	jsr $2f65			jsr 	IFMSignExtend
.3150	8d dd 06	sta $06dd			sta 	IFNewExponent
.3153	ae dc 06	ldx $06dc			ldx 	IFTarget 					; calculate s1.exponent
.3156	b5 03		lda $03,x			lda 	IExp,x
.3158	20 65 2f	jsr $2f65			jsr 	IFMSignExtend
.315b	38		sec				sec
.315c	ed dd 06	sbc $06dd			sbc 	IFNewExponent 				; s1.exponent - s0.exponent - 23
.315f	38		sec				sec
.3160	e9 17		sbc #$17			sbc 	#23
.3162	8d dd 06	sta $06dd			sta 	IFNewExponent
.3165	20 a3 31	jsr $31a3			jsr 	IFloatDivideSupport 		; call the support routine (see maths.py)
.3168	a5 16		lda $16				lda 	IFRTemp+IM2 				; result has overflowed ?
.316a	10 08		bpl $3174			bpl 	_IFDFNoShiftResult
.316c	a2 14		ldx #$14			ldx 	#IFRTemp 					; if so, fix it up.
.316e	20 43 34	jsr $3443			jsr 	IFloatShiftRight
.3171	ee dd 06	inc $06dd			inc 	IFNewExponent
.3174					_IFDFNoShiftResult:
.3174	ad dd 06	lda $06dd			lda 	IFNewExponent 				; underflow/overflow check.
.3177	30 06		bmi $317f			bmi 	_IFDFCheckUnderflow
.3179	c9 20		cmp #$20			cmp 	#$20 						; overflow in division
.317b	b0 24		bcs $31a1			bcs 	_IFDFDivZero
.317d	80 11		bra $3190			bra		_IFDFExit
.317f					_IFDFCheckUnderflow:
.317f	ad dd 06	lda $06dd			lda 	IFNewExponent 				; shift into a legal exponent.
.3182	c9 e0		cmp #$e0			cmp 	#$E0 						; if exponent < -32.
.3184	b0 0a		bcs $3190			bcs 	_IFDFExit
.3186	ee dd 06	inc $06dd			inc 	IFNewExponent
.3189	a2 14		ldx #$14			ldx 	#IFRTemp
.318b	20 43 34	jsr $3443			jsr 	IFloatShiftRight
.318e	80 ef		bra $317f			bra 	_IFDFCheckUnderflow
.3190					_IFDFExit:
.3190	ad dd 06	lda $06dd			lda 	IFNewExponent 				; combine exponent and sign.
.3193	29 3f		and #$3f			and 	#IFXMask
.3195	0d de 06	ora $06de			ora 	IFNewSign
.3198	85 17		sta $17				sta 	IFRTemp+IExp
.319a	a2 14		ldx #$14			ldx 	#IFRTemp 					; copy RTemp to R0.
.319c	20 a5 33	jsr $33a5			jsr 	IFloatCopyFromRegister
.319f	18		clc				clc
.31a0	60		rts				rts
.31a1					_IFDFDivZero:
.31a1	38		sec				sec
.31a2	60		rts				rts
.31a3					IFloatDivideSupport:
.31a3	a2 14		ldx #$14			ldx 	#IFRTemp 					; zero RTemp
.31a5	20 14 34	jsr $3414			jsr 	IFloatSetZero
.31a8	5a		phy				phy 								; main division loop x 23
.31a9	a0 17		ldy #$17			ldy 	#23
.31ab					_IFDSLoop:
.31ab	20 dc 2f	jsr $2fdc			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.31ae	20 d0 2f	jsr $2fd0			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.31b1	88		dey				dey
.31b2	d0 f7		bne $31ab			bne 	_IFDSLoop 					; do it 24 times
.31b4	7a		ply				ply
.31b5	60		rts				rts
.31b6					IFloatIntegerToStringR0:
.31b6	8d df 06	sta $06df			sta 	IFBase 						; save base to use.
.31b9	20 95 34	jsr $3495			jsr 	IFloatBufferReset			; empty buffer
.31bc	a5 0b		lda $0b				lda 	IFR0+IExp					; check integer, cant't convert float
.31be	29 3f		and #$3f			and 	#IFXMask
.31c0	d0 1d		bne $31df			bne 	_IFIFail
.31c2	a2 08		ldx #$08			ldx 	#IFR0 						; skip - check if zero.
.31c4	20 0d 34	jsr $340d			jsr 	IFloatCheckZero
.31c7	f0 0e		beq $31d7			beq 	_IFINotNegative
.31c9	a5 0b		lda $0b				lda 	IFR0+IExp 					; is signed ?
.31cb	29 40		and #$40			and 	#IFSign
.31cd	f0 08		beq $31d7			beq 	_IFINotNegative
.31cf	a9 2d		lda #$2d			lda 	#"-"						; output -
.31d1	20 a4 34	jsr $34a4			jsr 	IFloatBufferWrite
.31d4	20 1f 34	jsr $341f			jsr 	IFloatNegate 				; negate the value, e.g. make it +ve.
.31d7					_IFINotNegative:
.31d7	20 e1 31	jsr $31e1			jsr 	_IFIRecursiveConvert 		; start converting
.31da	20 9c 34	jsr $349c			jsr 	IFloatGetBufferAddress 		; get the return address and exit
.31dd	18		clc				clc
.31de	60		rts				rts
.31df					_IFIFail:
.31df	38		sec				sec
.31e0	60		rts				rts
.31e1					_IFIRecursiveConvert:
.31e1	a2 0c		ldx #$0c			ldx 	#IFR1
.31e3	20 b6 33	jsr $33b6			jsr 	IFloatCopyToRegister 		; R0->R1
.31e6	a2 08		ldx #$08			ldx 	#IFR0
.31e8	ad df 06	lda $06df			lda 	IFBase 						; Base -> R0
.31eb	20 16 34	jsr $3416			jsr 	IFloatSetByte
.31ee	a2 0c		ldx #$0c			ldx 	#IFR1 						; R0 = R1 / R0
.31f0	20 78 2f	jsr $2f78			jsr 	IFloatDivideInteger
.31f3	a2 08		ldx #$08			ldx 	#IFR0 						; if result <> 0
.31f5	20 0d 34	jsr $340d			jsr 	IFloatCheckZero
.31f8	f0 09		beq $3203			beq 	_IFIOutDigit
.31fa	a5 0c		lda $0c				lda 	IFR1+IM0 					; save remainder LSB only
.31fc	48		pha				pha
.31fd	20 e1 31	jsr $31e1			jsr 	_IFIRecursiveConvert 		; convert the divide result
.3200	68		pla				pla
.3201	85 0c		sta $0c				sta 	IFR1+IM0 					; restore remainder
.3203					_IFIOutDigit:
.3203	a5 0c		lda $0c				lda 	IFR1+IM0 					; get remainder.
.3205	c9 0a		cmp #$0a			cmp	 	#10 						; convert to hexadecimal.
.3207	90 02		bcc $320b			bcc 	_IFINotHex
.3209	69 06		adc #$06			adc 	#6
.320b					_IFINotHex:
.320b	69 30		adc #$30			adc 	#48
.320d	20 a4 34	jsr $34a4			jsr 	IFloatBufferWrite 			; write character to buffer.
.3210	60		rts				rts
.06df					IFBase:
>06df							.fill 	1
.3211					IFloatFloatToStringR0:
.3211	a2 10		ldx #$10			ldx 	#IFR2 						; copy R2 to stack,value to R2
.3213	20 63 33	jsr $3363			jsr 	IFloatPushRx
.3216	20 b6 33	jsr $33b6			jsr 	IFloatCopyToRegister
.3219	20 15 31	jsr $3115			jsr 	IFloatIntegerR0				; make R0 integer
.321c	a9 0a		lda #$0a			lda 	#10 						; base 10.
.321e	20 b6 31	jsr $31b6			jsr 	IFloatIntegerToStringR0 	; do the integer part.
.3221	9c e0 06	stz $06e0			stz 	IFloatDecimalCount 			; zero the decimal count.
.3224	a5 13		lda $13				lda 	IFR2+IExp 					; if it is integer then exit
.3226	29 3f		and #$3f			and 	#IFXMask
.3228	f0 44		beq $326e			beq 	_IFFSExit
.322a					_IFloatFracLoop:
.322a	a2 10		ldx #$10			ldx 	#IFR2 						; R0 = fractional part of R2
.322c	20 a5 33	jsr $33a5			jsr 	IFloatCopyFromRegister
.322f	20 bf 30	jsr $30bf			jsr 	IFloatFractionalR0
.3232	20 4b 34	jsr $344b			jsr 	IFloatNormalise
.3235	a2 10		ldx #$10			ldx 	#IFR2
.3237	20 b6 33	jsr $33b6			jsr 	IFloatCopyToRegister 		; copy to back R2
.323a	a2 10		ldx #$10			ldx 	#IFR2 						; set R2 to 10
.323c	a9 0a		lda #$0a			lda 	#10
.323e	20 16 34	jsr $3416			jsr 	IFloatSetByte
.3241	a2 10		ldx #$10			ldx 	#IFR2						; R0 = R2 * 10
.3243	20 b6 2e	jsr $2eb6			jsr 	IFloatMultiply
.3246	a2 10		ldx #$10			ldx 	#IFR2 						; copy back, float part next time.
.3248	20 b6 33	jsr $33b6			jsr 	IFloatCopyToRegister
.324b	20 15 31	jsr $3115			jsr 	IFloatIntegerR0 			; get integer part of R0 that's just been x 10.
.324e	ad e0 06	lda $06e0			lda 	IFloatDecimalCount 			; done 3 dp, no more
.3251	c9 03		cmp #$03			cmp 	#3
.3253	f0 16		beq $326b			beq 	_IFFSExitStripZero
.3255	ad e0 06	lda $06e0			lda 	IFloatDecimalCount 			; written the DP yet , e.g. count of digits is not zero.
.3258	d0 05		bne $325f			bne 	_IFloatNotFirst
.325a	a9 2e		lda #$2e			lda 	#"." 						; write decimal point
.325c	20 a4 34	jsr $34a4			jsr 	IFloatBufferWrite
.325f					_IFloatNotFirst:
.325f	ee e0 06	inc $06e0			inc 	IFloatDecimalCount
.3262	a5 08		lda $08				lda 	IFR0+IM0 					; get digit
.3264	09 30		ora #$30			ora 	#"0"						; ASCII
.3266	20 a4 34	jsr $34a4			jsr 	IFloatBufferWrite 			; write to the buffer.
.3269	80 bf		bra $322a			bra 	_IFloatFracLoop
.326b					_IFFSExitStripZero:
.326b	20 b3 34	jsr $34b3			jsr 	IFloatStripTrailingZeros
.326e					_IFFSExit:
.326e	a2 10		ldx #$10			ldx 	#IFR2 						; restore R2
.3270	20 84 33	jsr $3384			jsr 	IFloatPullRx
.3273	20 9c 34	jsr $349c			jsr 	IFloatGetBufferAddress
.3276	18		clc				clc
.3277	60		rts				rts
.06e0					IFloatDecimalCount:
>06e0							.fill 	1
.3278					IFloatStringToFloatR0:
.3278	8d e1 06	sta $06e1			sta 	IFCount 					; save length and positions out.
.327b	86 20		stx $20				stx 	iTemp0
.327d	84 21		sty $21				sty 	iTemp0+1
.327f	a2 08		ldx #$08			ldx 	#IFR0 						; reset the current value.
.3281	20 14 34	jsr $3414			jsr 	IFloatSetZero
.3284	9c e2 06	stz $06e2			stz 	IFSignFlag 					; clear the sign flag
.3287	20 14 33	jsr $3314			jsr 	IFSTFGetNext 				; get first
.328a	f0 1b		beq $32a7			beq 	_IFSTFFail 					; no character, fail.
.328c	90 10		bcc $329e			bcc 	_IFSTFHaveChar 				; legitimate character, go do it.
.328e	c9 2d		cmp #$2d			cmp 	#"-" 						; if not -, fail
.3290	d0 15		bne $32a7			bne 	_IFSTFFail
.3292	a9 40		lda #$40			lda 	#IFSign 					; set sign flag
.3294	8d e2 06	sta $06e2			sta 	IFSignFlag
.3297					_IFSTFLoop:
.3297	20 14 33	jsr $3314			jsr 	IFSTFGetNext 				; get next character
.329a	b0 0b		bcs $32a7			bcs 	_IFSTFFail 					; bad character.
.329c	f0 11		beq $32af			beq 	_IFSTFExit 					; end of data
.329e					_IFSTFHaveChar:
.329e	c9 2e		cmp #$2e			cmp 	#"."						; decimal point ? if so, do the decimal code.
.32a0	f0 08		beq $32aa			beq 	_IFSTFDecimal
.32a2	20 38 33	jsr $3338			jsr 	IFSTFAddR0 					; add number in (R0 = R0 x 10 + A)
.32a5	80 f0		bra $3297			bra 	_IFSTFLoop 					; keep going until . or end.
.32a7					_IFSTFFail:
.32a7	38		sec				sec
.32a8	80 0d		bra $32b7			bra 	_IFSTFReturn
.32aa					_IFSTFDecimal:
.32aa	20 bf 32	jsr $32bf			jsr 	IFSTFDecimal 				; call the decimal places code.
.32ad	b0 08		bcs $32b7			bcs 	_IFSTFReturn 				; error
.32af					_IFSTFExit:
.32af	a5 0b		lda $0b				lda 	IFR0+IExp 					; copy sign flag in.
.32b1	0d e2 06	ora $06e2			ora 	IFSignFlag
.32b4	85 0b		sta $0b				sta 	IFR0+IExp
.32b6	18		clc				clc
.32b7					_IFSTFReturn:
.32b7	60		rts				rts
.32b8					IFloatAddDecimalToR0:
.32b8	8d e1 06	sta $06e1			sta 	IFCount 					; save it out.
.32bb	86 20		stx $20				stx 	iTemp0
.32bd	84 21		sty $21				sty 	iTemp0+1
.32bf					IFSTFDecimal:
.32bf	a2 08		ldx #$08			ldx 	#IFR0 						; push integer part on stack
.32c1	20 63 33	jsr $3363			jsr 	IFloatPushRx
.32c4	a2 08		ldx #$08			ldx 	#IFR0 						; R0 is the decimal digits so far, zero initially
.32c6	20 14 34	jsr $3414			jsr 	IFloatSetZero
.32c9	9c e3 06	stz $06e3			stz 	IFDecimalPlaces 			; zero DP.
.32cc					_IFSTDLoop:
.32cc	20 14 33	jsr $3314			jsr 	IFSTFGetNext 				; get next
.32cf	b0 41		bcs $3312			bcs 	_IFSTFFail2 				; bad character.
.32d1	f0 11		beq $32e4			beq 	_IFSTFComplete 				; end of data, work out the result.
.32d3	c9 2e		cmp #$2e			cmp 	#"."						; only one decimal
.32d5	f0 39		beq $3310			beq 	_IFSTFExit2
.32d7	20 38 33	jsr $3338			jsr 	IFSTFAddR0 					; add number in (e.g. R0=R0*10+A)
.32da	ee e3 06	inc $06e3			inc 	IFDecimalPlaces 			; count decimals
.32dd	ad e3 06	lda $06e3			lda 	IFDecimalPlaces 			; no more than 3 DP used.
.32e0	c9 03		cmp #$03			cmp 	#3
.32e2	90 e8		bcc $32cc			bcc 	_IFSTDLoop
.32e4					_IFSTFComplete:
.32e4	ad e3 06	lda $06e3			lda 	IFDecimalPlaces 			; decimals x 4 as accessing multiplier from a LUT.
.32e7	f0 27		beq $3310			beq 	_IFSTFExit2					; if none, this is syntactically fine, just ignore
.32e9	3a		dec a				dec 	a 							; table indexed from 1.
.32ea	0a		asl a				asl 	a
.32eb	0a		asl a				asl 	a
.32ec	aa		tax				tax
.32ed	bd 4f 33	lda $334f,x			lda 	TableTen,x 					; copy table entry into R0 - these are 0.1,0.01,0.001
.32f0	85 0c		sta $0c				sta  	IFR1+IM0 					; 0.0001 etc, up to 5 decimals.
.32f2	bd 50 33	lda $3350,x			lda 	TableTen+1,x
.32f5	85 0d		sta $0d				sta  	IFR1+IM1
.32f7	bd 51 33	lda $3351,x			lda 	TableTen+2,x
.32fa	85 0e		sta $0e				sta  	IFR1+IM2
.32fc	bd 52 33	lda $3352,x			lda 	TableTen+3,x
.32ff	85 0f		sta $0f				sta  	IFR1+IExp
.3301	a2 0c		ldx #$0c			ldx 	#IFR1 						; multiply into result
.3303	20 b6 2e	jsr $2eb6			jsr 	IFloatMultiply
.3306	a2 0c		ldx #$0c			ldx 	#IFR1  						; pop the integer part to R1
.3308	20 84 33	jsr $3384			jsr 	IFloatPullRx
.330b	a2 0c		ldx #$0c			ldx 	#IFR1 						; add R1 to R0
.330d	20 0c 2e	jsr $2e0c			jsr 	IFloatAdd
.3310					_IFSTFExit2:
.3310	18		clc				clc
.3311	60		rts				rts
.3312					_IFSTFFail2:
.3312	38		sec				sec
.3313	60		rts				rts
.3314					IFSTFGetNext:
.3314	ad e1 06	lda $06e1			lda 	IFCount  					; if count is zero, return with Z set.
.3317	f0 19		beq $3332			beq 	_IFSTFReturnOk
.3319	b2 20		lda ($20)			lda 	(iTemp0) 					; get next character
.331b	e6 20		inc $20				inc 	iTemp0 						; point at next.
.331d	d0 02		bne $3321			bne 	_IFSTFGNNoCarry
.331f	e6 21		inc $21				inc 	iTemp0+1
.3321					_IFSTFGNNoCarry:
.3321	ce e1 06	dec $06e1			dec 	IFCount 					; dec count.
.3324	c9 2e		cmp #$2e			cmp 	#"."	 					; check, dp is allowed.
.3326	f0 08		beq $3330			beq 	_IFSTFGOkay
.3328	c9 30		cmp #$30			cmp 	#"0"						; < 0 fail.
.332a	90 08		bcc $3334			bcc 	_IFSTFGFail
.332c	c9 3a		cmp #$3a			cmp 	#"9"+1 						; > 9 fail.
.332e	b0 04		bcs $3334			bcs 	_IFSTFGFail
.3330					_IFSTFGOkay:
.3330	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.3332					_IFSTFReturnOk:
.3332	18		clc				clc
.3333	60		rts				rts
.3334					_IFSTFGFail:
.3334	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.3336	38		sec				sec
.3337	60		rts				rts
.3338					IFSTFAddR0:
.3338	29 0f		and #$0f			and 	#15 						; to int value
.333a	48		pha				pha 								; save it.
.333b	a9 0a		lda #$0a			lda 	#10
.333d	a2 0c		ldx #$0c			ldx 	#IFR1
.333f	20 16 34	jsr $3416			jsr 	IFloatSetByte
.3342	20 b6 2e	jsr $2eb6			jsr 	IFloatMultiply
.3345	68		pla				pla
.3346	a2 0c		ldx #$0c			ldx 	#IFR1
.3348	20 16 34	jsr $3416			jsr 	IFloatSetByte
.334b	20 0c 2e	jsr $2e0c			jsr 	IFloatAdd
.334e	60		rts				rts
.06e1					IFCount:
>06e1							.fill 	1
.06e2					IFSignFlag:
>06e2							.fill 	1
.06e3					IFDecimalPlaces:
>06e3							.fill 	1
.334f					TableTen:
>334f	9a 19 00 30				.byte	$9a,$19,$00,$30 ; 0.10001
>3353	8f 02 00 30				.byte	$8f,$02,$00,$30 ; 0.00999
>3357	42 00 00 30				.byte	$42,$00,$00,$30 ; 0.00101
>335b	07 00 00 30				.byte	$07,$00,$00,$30 ; 0.00011
>335f	01 00 00 30				.byte	$01,$00,$00,$30 ; 2e-05
.3363					IFloatPushRx:
.3363	5a		phy				phy
.3364	ac e4 06	ldy $06e4			ldy 	IFStackIndex 				; push IM0,1,2,Exp on the stack
.3367	b5 00		lda $00,x			lda 	IM0,x
.3369	99 e5 06	sta $06e5,y			sta 	IFStack,y
.336c	b5 01		lda $01,x			lda 	IM1,x
.336e	99 e6 06	sta $06e6,y			sta 	IFStack+1,y
.3371	b5 02		lda $02,x			lda 	IM2,x
.3373	99 e7 06	sta $06e7,y			sta 	IFStack+2,y
.3376	b5 03		lda $03,x			lda 	IExp,x
.3378	99 e8 06	sta $06e8,y			sta 	IFStack+3,y
.337b	c8		iny				iny
.337c	c8		iny				iny
.337d	c8		iny				iny
.337e	c8		iny				iny
.337f	8c e4 06	sty $06e4			sty 	IFStackIndex 				; update SP
.3382	7a		ply				ply
.3383	60		rts				rts
.3384					IFloatPullRx:
.3384	5a		phy				phy
.3385	ac e4 06	ldy $06e4			ldy 	IFStackIndex	 			; decrement SP
.3388	88		dey				dey
.3389	88		dey				dey
.338a	88		dey				dey
.338b	88		dey				dey
.338c	b9 e5 06	lda $06e5,y			lda 	IFStack,y 					; pop IM0,1,2,Exp off stack
.338f	95 00		sta $00,x			sta 	IM0,x
.3391	b9 e6 06	lda $06e6,y			lda 	IFStack+1,y
.3394	95 01		sta $01,x			sta 	IM1,x
.3396	b9 e7 06	lda $06e7,y			lda 	IFStack+2,y
.3399	95 02		sta $02,x			sta 	IM2,x
.339b	b9 e8 06	lda $06e8,y			lda 	IFStack+3,y
.339e	95 03		sta $03,x			sta 	IExp,x
.33a0	8c e4 06	sty $06e4			sty 	IFStackIndex 				; update SP
.33a3	7a		ply				ply
.33a4	60		rts				rts
.06e4					IFStackIndex:
>06e4							.fill 	1
.06e5					IFStack:
>06e5							.fill 	16*4
.33a5					IFloatCopyFromRegister:
.33a5	b5 00		lda $00,x			lda 	0,x
.33a7	85 08		sta $08				sta 	IFR0
.33a9	b5 01		lda $01,x			lda 	1,x
.33ab	85 09		sta $09				sta 	IFR0+1
.33ad	b5 02		lda $02,x			lda 	2,x
.33af	85 0a		sta $0a				sta 	IFR0+2
.33b1	b5 03		lda $03,x			lda 	3,x
.33b3	85 0b		sta $0b				sta 	IFR0+3
.33b5	60		rts				rts
.33b6					IFloatCopyToRegister:
.33b6	a5 08		lda $08				lda 	IFR0
.33b8	95 00		sta $00,x			sta 	0,x
.33ba	a5 09		lda $09				lda 	IFR0+1
.33bc	95 01		sta $01,x			sta 	1,x
.33be	a5 0a		lda $0a				lda 	IFR0+2
.33c0	95 02		sta $02,x			sta 	2,x
.33c2	a5 0b		lda $0b				lda 	IFR0+3
.33c4	95 03		sta $03,x			sta 	3,x
.33c6	60		rts				rts
.33c7					IFloatLoadInline:
.33c7	68		pla				pla 								; pop address off to iTemp0
.33c8	85 20		sta $20				sta 	iTemp0
.33ca	68		pla				pla
.33cb	85 21		sta $21				sta 	iTemp0+1
.33cd	a0 01		ldy #$01			ldy 	#1
.33cf	b1 20		lda ($20),y			lda 	(iTemp0),y 					; copy byte 0
.33d1	95 00		sta $00,x			sta 	0,x
.33d3	c8		iny				iny
.33d4	b1 20		lda ($20),y			lda 	(iTemp0),y 					; copy byte 1
.33d6	95 01		sta $01,x			sta 	1,x
.33d8	c8		iny				iny
.33d9	b1 20		lda ($20),y			lda 	(iTemp0),y 					; copy byte 2
.33db	95 02		sta $02,x			sta 	2,x
.33dd	c8		iny				iny
.33de	b1 20		lda ($20),y			lda 	(iTemp0),y 					; copy byte 3
.33e0	95 03		sta $03,x			sta 	3,x
.33e2	18		clc				clc 								; inc pointer, 1 for return, 4 for data
.33e3	a5 20		lda $20				lda 	iTemp0
.33e5	69 05		adc #$05			adc 	#5
.33e7	85 20		sta $20				sta 	iTemp0
.33e9	90 02		bcc $33ed			bcc 	_IFLINoCarry
.33eb	e6 21		inc $21				inc 	iTemp0+1
.33ed					_IFLINoCarry:
.33ed	6c 20 00	jmp ($0020)			jmp 	(iTemp0)					; effectively RTS
.33f0					IFloatMultiply8BitRx:
.33f0	5a		phy		        phy
.33f1	b5 00		lda $00,x	        lda     IM0,x                       ; AY are the two values
.33f3	a4 08		ldy $08		        ldy     IFR0+IM0
.33f5	4a		lsr a		        lsr     a                           ; prime the carry bit for the loop
.33f6	85 08		sta $08		        sta     IFR0+IM0
.33f8	84 09		sty $09		        sty     IFR0+IM1
.33fa	a9 00		lda #$00	        lda     #0
.33fc	a0 08		ldy #$08	        ldy     #8
.33fe					_IFMLoop:
.33fe	90 03		bcc $3403	        bcc     _IFMNoAdd
.3400	18		clc		        clc
.3401	65 09		adc $09		        adc     IFR0+IM1
.3403					_IFMNoAdd:
.3403	6a		ror a		        ror     a
.3404	66 08		ror $08		        ror     IFR0+IM0                    ; pull another bit out for the next iteration
.3406	88		dey		        dey
.3407	d0 f5		bne $33fe	        bne     _IFMLoop
.3409	85 09		sta $09		        sta     IFR0+IM1                    ; write MSB out
.340b	7a		ply		        ply
.340c	60		rts		        rts
.340d					IFloatCheckZero:
.340d	b5 00		lda $00,x			lda 	IM0,x 						; or together mantissa bytes.
.340f	15 01		ora $01,x			ora 	IM1,x
.3411	15 02		ora $02,x			ora 	IM2,x
.3413	60		rts				rts
.3414					IFloatSetZero:
.3414	a9 00		lda #$00			lda 	#0
.3416					IFloatSetByte:
.3416	95 00		sta $00,x			sta 	IM0,x 						; set mantissa to 00:A
.3418	74 01		stz $01,x			stz 	IM1,x
.341a	74 02		stz $02,x			stz 	IM2,x
.341c	74 03		stz $03,x			stz 	IExp,x 						; zero the exponent.
.341e	60		rts				rts
.341f					IFloatNegate:
.341f	b5 03		lda $03,x			lda 	IExp,x 						; toggle the sign bit.
.3421	49 40		eor #$40			eor 	#IFSign
.3423	95 03		sta $03,x			sta 	IExp,x
.3425	18		clc				clc
.3426	60		rts				rts
.3427					IFloatMantissaNegate:
.3427	38		sec				sec 								; when you want a real 2's complement negative value.
.3428	a9 00		lda #$00			lda 	#0
.342a	f5 00		sbc $00,x			sbc 	IM0,x
.342c	95 00		sta $00,x			sta 	IM0,x
.342e	a9 00		lda #$00			lda 	#0
.3430	f5 01		sbc $01,x			sbc 	IM1,x
.3432	95 01		sta $01,x			sta 	IM1,x
.3434	a9 00		lda #$00			lda 	#0
.3436	f5 02		sbc $02,x			sbc 	IM2,x
.3438	95 02		sta $02,x			sta 	IM2,x
.343a	60		rts				rts
.343b					IFloatShiftLeft:
.343b	18		clc				clc
.343c					IFloatRotateLeft:
.343c	36 00		rol $00,x			rol 	IM0,x
.343e	36 01		rol $01,x			rol 	IM1,x
.3440	36 02		rol $02,x			rol 	IM2,x
.3442	60		rts				rts
.3443					IFloatShiftRight:
.3443	18		clc				clc
.3444					IFloatRotateRight:
.3444	76 02		ror $02,x			ror 	IM2,x
.3446	76 01		ror $01,x			ror 	IM1,x
.3448	76 00		ror $00,x			ror 	IM0,x
.344a	60		rts				rts
.344b					IFloatNormalise:
.344b	20 0d 34	jsr $340d			jsr 	IFloatCheckZero 			; is it zero
.344e	f0 18		beq $3468			beq 	_IFNExitZero 				; if so exit
.3450					_IFNLoop:
.3450	b5 02		lda $02,x			lda 	IM2,x 						; is it normalised e.g. bits 7/6 are 01
.3452	29 c0		and #$c0			and 	#$C0
.3454	c9 40		cmp #$40			cmp 	#$40
.3456	f0 13		beq $346b			beq 	_IFNExitOkay 				; if so , then we are done.
.3458	b5 03		lda $03,x			lda 	IExp,x 						; check exponent is not -32 already.
.345a	29 3f		and #$3f			and 	#$3F
.345c	c9 20		cmp #$20			cmp 	#$20
.345e	f0 0b		beq $346b			beq 	_IFNExitOkay 				; if so, then we cannot normalise any more.
.3460	20 81 34	jsr $3481			jsr 	IFloatDecExponent
.3463	20 3b 34	jsr $343b			jsr 	IFloatShiftLeft 			; shift mantissa left, e.g. multiply by 2
.3466	80 e8		bra $3450			bra 	_IFNLoop
.3468					_IFNExitZero:
.3468	20 14 34	jsr $3414			jsr 	IFloatSetZero 				; set the result to zero
.346b					_IFNExitOkay:
.346b	18		clc				clc  								; return with CC.
.346c	60		rts				rts
.346d					IFloatIncExponent:
.346d	b5 03		lda $03,x			lda 	IExp,x
.346f	48		pha				pha
.3470	29 c0		and #$c0			and 	#$C0
.3472	8d 25 07	sta $0725			sta 	IFXTemp
.3475	68		pla				pla
.3476	1a		inc a				inc 	a
.3477	29 3f		and #$3f			and 	#$3F
.3479	48		pha				pha
.347a	0d 25 07	ora $0725			ora 	IFXTemp
.347d	95 03		sta $03,x			sta 	IExp,x
.347f	68		pla				pla
.3480	60		rts				rts
.3481					IFloatDecExponent:
.3481	b5 03		lda $03,x			lda 	IExp,x
.3483	48		pha				pha
.3484	29 c0		and #$c0			and 	#$C0
.3486	8d 25 07	sta $0725			sta 	IFXTemp
.3489	68		pla				pla
.348a	3a		dec a				dec 	a
.348b	29 3f		and #$3f			and 	#$3F
.348d	48		pha				pha
.348e	0d 25 07	ora $0725			ora 	IFXTemp
.3491	95 03		sta $03,x			sta 	IExp,x
.3493	68		pla				pla
.3494	60		rts				rts
.0725					IFXTemp:
>0725							.fill 	1
.3495					IFloatBufferReset:
.3495	9c 26 07	stz $0726			stz 	IFBufferCount
.3498	9c 27 07	stz $0727			stz 	IFBuffer
.349b	60		rts				rts
.349c					IFloatGetBufferAddress:
.349c	a0 07		ldy #$07			ldy 	#(IFBufferCount >> 8)
.349e	a2 26		ldx #$26			ldx 	#(IFBufferCount & $FF)
.34a0	ad 26 07	lda $0726			lda 	IFBufferCount
.34a3	60		rts				rts
.34a4					IFloatBufferWrite:
.34a4	da		phx				phx
.34a5	ae 26 07	ldx $0726			ldx 	IFBufferCount
.34a8	9d 27 07	sta $0727,x			sta 	IFBuffer,x
.34ab	9e 28 07	stz $0728,x			stz 	IFBuffer+1,x
.34ae	ee 26 07	inc $0726			inc 	IFBufferCount
.34b1	fa		plx				plx
.34b2	60		rts				rts
.34b3					IFloatStripTrailingZeros:
.34b3	ae 26 07	ldx $0726			ldx 	IFBufferCount
.34b6	bd 26 07	lda $0726,x			lda 	IFBuffer-1,x
.34b9	c9 30		cmp #$30			cmp		#"0"
.34bb	d0 0f		bne $34cc			bne 	_IFSTExit
.34bd	bd 25 07	lda $0725,x			lda 	IFBuffer-2,x
.34c0	c9 2e		cmp #$2e			cmp 	#"."
.34c2	f0 08		beq $34cc			beq 	_IFSTExit
.34c4	ce 26 07	dec $0726			dec 	IFBufferCount
.34c7	9e 26 07	stz $0726,x			stz 	IFBuffer-1,x
.34ca	80 e7		bra $34b3			bra 	IFloatStripTrailingZeros
.34cc					_IFSTExit:
.34cc	60		rts				rts
.0726					IFBufferCount:
>0726							.fill 	1
.0727					IFBuffer:
>0727							.fill 	25
.34cd					IFloatCheckRange:
.34cd	a5 0b		lda $0b				lda 	IFR0+IExp					; force it negative e.g. -|R0|
.34cf	09 40		ora #$40			ora 	#IFSign
.34d1	85 0b		sta $0b				sta 	IFR0+IExp
.34d3	a2 0c		ldx #$0c			ldx 	#IFR1 						; add R1.
.34d5	20 0c 2e	jsr $2e0c			jsr 	IFloatAdd 					; add allowed to error.
.34d8	a2 08		ldx #$08			ldx 	#IFR0
.34da	20 0d 34	jsr $340d			jsr 	IFloatCheckZero 			; error if < 0
.34dd	f0 06		beq $34e5			beq 	_IFAOkay
.34df	a5 0b		lda $0b				lda 	IFR0+IExp
.34e1	29 40		and #$40			and 	#IFSign
.34e3	d0 01		bne $34e6			bne 	_IFAFail
.34e5					_IFAOkay:
.34e5	60		rts				rts
.34e6					_IFAFail:
.34e6	38		sec				sec
.34e7	68		pla				pla 								; get address - 2
.34e8	e9 02		sbc #$02			sbc 	#2
.34ea	aa		tax				tax
.34eb	68		pla				pla
.34ec	e9 00		sbc #$00			sbc 	#0
.34ee	a8		tay				tay
.34ef	a9 aa		lda #$aa			lda 	#$AA 						; sign assert
.34f1					_IFAStop:
>34f1	db						.byte 	$DB 						; display an error AA ADR ADR
.34f2	80 fd		bra $34f1			bra 	_IFAStop

;******  Return to file: basic.asm


;******  End of listing
