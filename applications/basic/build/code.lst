
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -q -Wall -c -C -b -L build/code.lst -l build/code.lbl -o build/basic.bin basic.asm
; Sun May 28 20:16:19 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: build/ramdata.inc

=$08					ZeroPageBase = $08 							; zero page usage
=$200					StorageBase = $200 							; ROM usage
.0008					rTemp0:
>0008							.fill 	2
.000a					iTemp0:
>000a							.fill 	2
.000c					IFR0:
>000c							.fill 	4
.0010					IFR1:
>0010							.fill 	4
.0014					IFR2:
>0014							.fill 	4
.0018					IFRTemp:
>0018							.fill 	4
.0200					OSXPos:
>0200							.fill 	1
.0201					OSYPos:
>0201							.fill 	1
.0202					OSXSize:
>0202							.fill 	1
.0203					OSYSize:
>0203							.fill 	1
=16					OSKeyboardQueueMaxSize = 16					; keyboard queue max size.
.0204					OSKeyStatus:
>0204							.fill 	32
.0224					OSKeyboardQueue:
>0224							.fill 	OSKeyboardQueueMaxSize
.0234					OSKeyboardQueueSize:
>0234							.fill 	1
.0235					OSIsKeyUp:
>0235							.fill 	1
.0236					OSIsKeyShift:
>0236							.fill 	1

;******  Return to file: basic.asm


;******  Processing file: build/osvectors.inc

=$ffe8					OSGetScreenSize          = $ffe8 ; Get size of screen to XY
=$ffeb					OSReadDevice             = $ffeb ; Read device X to A
=$ffee					OSWriteDevice            = $ffee ; Write A to device X
=$fff1					OSWriteScreen            = $fff1 ; Write A to screen (device 0)
=$fff4					OSReadKeyboard           = $fff4 ; Read A from keyboard (device 1)
=$fff7					OSIsKeyAvailable         = $fff7 ; Check if key available (CS if so)

;******  Return to file: basic.asm

.1000					boot:
.1000	a2 40		ldx #$40			ldx 	#$40
.1002	a0 a0		ldy #$a0			ldy 	#$A0
.1004	20 a8 19	jsr $19a8			jsr 	PGMSetBaseAddress
.1007	20 98 1c	jsr $1c98			jsr 	IFInitialise
.100a	a2 af		ldx #$af			ldx 	#TokTest & $FF
.100c	a0 1a		ldy #$1a			ldy 	#TokTest >> 8
.100e	18		clc				clc
.100f	20 2a 1a	jsr $1a2a			jsr 	TOKTokenise
.1012	4c a5 10	jmp $10a5			jmp 	Command_RUN

;******  Processing file: include.files


;******  Processing file: src/data.inc

.001c					codePtr:
>001c							.fill 	2
.001e					zTemp0:
>001e							.fill 	2
.0020					zTemp1:
>0020							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/errors/generated/errors.inc


;******  Return to file: include.files


;******  Processing file: src/generated/token_const.inc

=$80					PR_STRUCTURE_FIRST = $80
=$80					PR_REPEAT = $80
=$81					PR_UNTIL = $81
=$82					PR_WHILE = $82
=$83					PR_WEND = $83
=$84					PR_IF = $84
=$85					PR_ENDIF = $85
=$86					PR_DO = $86
=$87					PR_LOOP = $87
=$88					PR_PROC = $88
=$89					PR_ENDPROC = $89
=$8a					PR_FOR = $8a
=$8b					PR_NEXT = $8b
=$8b					PR_STRUCTURE_LAST = $8b
=$8c					PR_STANDARD_FIRST = $8c
=$8c					PR_LSQLSQENDRSQRSQ = $8c
=$8d					PR_LSQLSQSHIFTRSQRSQ = $8d
=$8e					PR_ELSE = $8e
=$8f					PR_THEN = $8f
=$90					PR_TO = $90
=$91					PR_STEP = $91
=$92					PR_LET = $92
=$93					PR_PRINT = $93
=$94					PR_INPUT = $94
=$95					PR_CALL = $95
=$96					PR_SYS = $96
=$97					PR_REM = $97
=$98					PR_EXIT = $98
=$99					PR_COMMA = $99
=$9a					PR_SEMICOLON = $9a
=$9b					PR_COLON = $9b
=$9c					PR_SQUOTE = $9c
=$9d					PR_RPAREN = $9d
=$9e					PR_DIM = $9e
=$9f					PR_CLEAR = $9f
=$a0					PR_NEW = $a0
=$a1					PR_RUN = $a1
=$a2					PR_STOP = $a2
=$a3					PR_END = $a3
=$a4					PR_ASSERT = $a4
=$a5					PR_LIST = $a5
=$a6					PR_SAVE = $a6
=$a7					PR_LOAD = $a7
=$a7					PR_STANDARD_LAST = $a7
=$d7					PR_RIGHTDOLLARLPAREN = $d7
=$d7					PR_UNARY_FIRST = $d7
=$d8					PR_LEFTDOLLARLPAREN = $d8
=$d9					PR_MIDDOLLARLPAREN = $d9
=$da					PR_STRDOLLARLPAREN = $da
=$db					PR_VALLPAREN = $db
=$dc					PR_SGNLPAREN = $dc
=$dd					PR_ABSLPAREN = $dd
=$de					PR_LENLPAREN = $de
=$df					PR_SQRLPAREN = $df
=$e0					PR_CHRDOLLARLPAREN = $e0
=$e1					PR_ASCLPAREN = $e1
=$e2					PR_INKEYDOLLARLPAREN = $e2
=$e3					PR_EVENTLPAREN = $e3
=$e4					PR_TIME = $e4
=$e5					PR_INTLPAREN = $e5
=$e6					PR_FRACLPAREN = $e6
=$e7					PR_DECLPAREN = $e7
=$e8					PR_HEXDOLLARLPAREN = $e8
=$e9					PR_RNDLPAREN = $e9
=$ea					PR_RANDLPAREN = $ea
=$eb					PR_LPAREN = $eb
=$ec					PR_DOLLAR = $ec
=$ed					PR_LSQLSQDECIMALRSQRSQ = $ed
=$ee					PR_UNARY_LAST = $ee
=$ee					PR_LSQLSQSTRINGRSQRSQ = $ee
=$ef					PR_EQUAL = $ef
=$ef					PR_BINARY_FIRST = $ef
=$f0					PR_LESSGREATER = $f0
=$f1					PR_LESSEQUAL = $f1
=$f2					PR_LESS = $f2
=$f3					PR_GREATEREQUAL = $f3
=$f4					PR_GREATER = $f4
=$f5					PR_XOR = $f5
=$f6					PR_OR = $f6
=$f7					PR_AND = $f7
=$f8					PR_DIV = $f8
=$f9					PR_MOD = $f9
=$fa					PR_LESSLESS = $fa
=$fb					PR_GREATERGREATER = $fb
=$fc					PR_SLASH = $fc
=$fd					PR_ASTERISK = $fd
=$fe					PR_MINUS = $fe
=$ff					PR_BINARY_LAST = $ff
=$ff					PR_PLUS = $ff

;******  Return to file: include.files


;******  Processing file: src/program/data.inc

.0237					TOKLineSize:
>0237							.fill 	1
.0238					TOKLineNumber:
>0238							.fill 	2
.023a					TOKBuffer:
>023a							.fill 	256
.033a					TOKRequireLineNumber:
>033a							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/commands/assert.asm

.1015					Command_ASSERT:
.1015	20 f3 13	jsr $13f3			jsr 	EXPEvalNumber
.1018	a2 0c		ldx #$0c			ldx 	#IFR0
.101a	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero
.101d	f0 01		beq $1020			beq 	_CAFail
.101f	60		rts				rts
.1020					_CAFail:
.1020	4c 43 11	jmp $1143		jmp	ErrorV_assert

;******  Return to file: include.files


;******  Processing file: src/commands/clear.asm

.1023					Command_CLEAR:
.1023	20 2e 1c	jsr $1c2e			jsr 	StringSystemInitialise
.1026	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/dead.asm

.1027					NoExec01:
.1027					NoExec02:
.1027					NoExec03:
.1027					NoExec04:
.1027					NoExec05:
.1027					NoExec06:
.1027					NoExec07:
.1027	4c f2 10	jmp $10f2		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/commands/inputprint.asm

.102a					Command_Print:
.102a					Command_IP_Main:
.102a	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.102b					_CPLoop:
.102b	08		php				php 								; save last action flag
.102c	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get next character
.102e	c9 8c		cmp #$8c			cmp  	#PR_LSQLSQENDRSQRSQ 		; end of line or colon, exit now.
.1030	f0 3e		beq $1070			beq 	_CPExit 					; without consuming
.1032	c9 9b		cmp #$9b			cmp 	#PR_COLON
.1034	f0 3a		beq $1070			beq 	_CPExit
.1036	68		pla				pla 								; throw last action flag
.1037	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; next character and bump
.1039	c8		iny				iny
.103a	c9 9a		cmp #$9a			cmp 	#PR_SEMICOLON				; is it a semicolon
.103c	f0 2f		beq $106d			beq 	_CPContinueWithSameLine
.103e	c9 99		cmp #$99			cmp 	#PR_COMMA 					; comma
.1040	f0 26		beq $1068			beq 	_CPTab
.1042	88		dey				dey 								; undo the get.
.1043	20 b3 13	jsr $13b3			jsr 	EXPEvaluateExpression 		; evaluate expression.
.1046	24 0f		bit $0f				bit 	IFR0+IExp 					; is it a number ?
.1048	10 14		bpl $105e			bpl 	_CPNumber
.104a	5a		phy				phy
.104b	18		clc				clc 								; string address to YX
.104c	a5 0c		lda $0c				lda 	IFR0+IM0
.104e	aa		tax				tax
.104f	a5 0d		lda $0d				lda 	IFR0+IM1
.1051	a8		tay				tay
.1052	e8		inx				inx 								; point to 1st character
.1053	d0 01		bne $1056			bne 	_CPNoCarry
.1055	c8		iny				iny
.1056					_CPNoCarry:
.1056	b2 0c		lda ($0c)			lda 	(IFR0+IM0)					; length to A
.1058	20 79 10	jsr $1079			jsr 	CPPrintAYX 					; print AYX
.105b	7a		ply				ply
.105c	80 cc		bra $102a			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.105e					_CPNumber:
.105e	5a		phy				phy
.105f	20 aa 20	jsr $20aa			jsr 	IFloatFloatToStringR0 		; convert to string at YX length A
.1062	20 79 10	jsr $1079			jsr 	CPPrintAYX 					; print AYX
.1065	7a		ply				ply
.1066	80 c2		bra $102a			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.1068					_CPTab:
.1068	a9 09		lda #$09			lda 	#9 							; print TAB
.106a	20 8c 10	jsr $108c			jsr 	CPPrintA
.106d					_CPContinueWithSameLine:
.106d	38		sec				sec 								; loop round with carry set, which
.106e	80 bb		bra $102b			bra 	_CPLoop 					; will inhibit final CR
.1070					_CPExit:
.1070	28		plp				plp 								; get last action flag
.1071	b0 05		bcs $1078			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.1073	a9 0d		lda #$0d			lda 	#13 						; print new line
.1075	20 8c 10	jsr $108c			jsr 	CPPrintA
.1078					_CPExit2:
.1078	60		rts				rts
.1079					CPPrintAYX:
.1079	86 1e		stx $1e				stx 	zTemp0
.107b	84 1f		sty $1f				sty 	zTemp0+1
.107d	aa		tax				tax
.107e	f0 0b		beq $108b			beq 	_CPPrintExit
.1080	a0 00		ldy #$00			ldy 	#0
.1082					_CPPrintAYXLoop:
.1082	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.1084	20 8c 10	jsr $108c			jsr 	CPPrintA
.1087	c8		iny				iny
.1088	ca		dex				dex
.1089	d0 f7		bne $1082			bne 	_CPPrintAYXLoop
.108b					_CPPrintExit:
.108b	60		rts				rts
.108c					CPPrintA:
.108c	4c f1 ff	jmp $fff1			jmp 	OSWriteScreen

;******  Return to file: include.files


;******  Processing file: src/commands/new.asm

.108f					Command_NEW:
.108f	20 af 19	jsr $19af			jsr 	PGMNewProgram
.1092	20 23 10	jsr $1023			jsr 	Command_CLEAR
.1095	4c ec 10	jmp $10ec			jmp 	Command_END

;******  Return to file: include.files


;******  Processing file: src/commands/rem.asm

.1098					Command_REM:
.1098					Command_REM2:
.1098	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; optional string parameter
.109a	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ
.109c	d0 06		bne $10a4			bne 	_CRExit
.109e	c8		iny				iny 								; skip over it, it's a comment.
.109f	98		tya				tya
.10a0	38		sec				sec
.10a1	71 1c		adc ($1c),y			adc 	(codePtr),y
.10a3	a8		tay				tay
.10a4					_CRExit:
.10a4	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/run.asm

.10a5					Command_RUN:
.10a5	20 23 10	jsr $1023			jsr 	Command_CLEAR 				; clear everything out.
.10a8	ad 40 03	lda $0340			lda 	PGMBaseHigh 				; back to the program start
.10ab	85 1d		sta $1d				sta 	codePtr+1
.10ad	64 1c		stz $1c				stz 	codePtr
.10af	80 0b		bra $10bc			bra 	RUNNewLine
.10b1					RUNEndOfLine:
.10b1	18		clc				clc 								; advance to next line.
.10b2	b2 1c		lda ($1c)			lda 	(codePtr)
.10b4	65 1c		adc $1c				adc 	codePtr
.10b6	85 1c		sta $1c				sta 	codePtr
.10b8	90 02		bcc $10bc			bcc 	_RELNoCarry
.10ba	e6 1d		inc $1d				inc 	codePtr+1
.10bc					_RELNoCarry:
.10bc					RUNNewLine:
.10bc	a2 ff		ldx #$ff			ldx 	#$FF 						; 6502 stack reset.
.10be	9a		txs				txs
.10bf	b2 1c		lda ($1c)			lda 	(codePtr) 					; check off end of program
.10c1	f0 29		beq $10ec			beq 	Command_END
.10c3	a0 03		ldy #$03			ldy 	#3 							; offset into codePtr for start of line.
.10c5					RUNNewCommand:
.10c5	9c 45 04	stz $0445			stz 	stringInitialised 			; reset string system.
.10c8	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get next token
.10ca	10 1a		bpl $10e6			bpl		_RUNNotToken 				; probably an identifier
.10cc	c8		iny				iny 								; consume token
.10cd	c9 9b		cmp #$9b			cmp 	#PR_COLON 					; fast skip colon
.10cf	f0 f4		beq $10c5			beq 	RUNNewCommand
.10d1	c9 a8		cmp #$a8			cmp 	#PR_STANDARD_LAST+1 		; check unary function
.10d3	b0 0e		bcs $10e3			bcs 	_RUNSyntax
.10d5	c9 80		cmp #$80			cmp 	#PR_STRUCTURE_FIRST 		; adjust for binaries at start.
.10d7	90 0a		bcc $10e3			bcc 	_RUNSyntax
.10d9	0a		asl a				asl 	a 							; double into X.
.10da	aa		tax				tax
.10db	20 e0 10	jsr $10e0			jsr 	_RUNDispatchMain			; call the main dispatcher
.10de	80 e5		bra $10c5			bra 	RUNNewCommand
.10e0					_RUNDispatchMain:
.10e0	7c 03 18	jmp ($1803,x)			jmp 	(VectorTable,x)
.10e3					_RUNSyntax:
.10e3	4c f2 10	jmp $10f2		jmp	ErrorV_syntax
.10e6					_RUNNotToken:
.10e6	4c 30 11	jmp $1130		jmp	ErrorV_unimplemented
.10e9					Command_Shift_Handler:
.10e9	4c 30 11	jmp $1130		jmp	ErrorV_unimplemented
.10ec					Command_END:
.10ec	4c ff ff	jmp $ffff			jmp 	$FFFF

;******  Return to file: include.files


;******  Processing file: src/commands/stop.asm

.10ef					Command_STOP:
.10ef	4c 8d 11	jmp $118d		jmp	ErrorV_stop

;******  Return to file: include.files


;******  Processing file: src/errors/generated/errors.asm

.10f2					ErrorV_syntax:
.10f2	20 8f 23	jsr $238f		jsr	ErrorHandler
>10f5	53 79 6e 74 61 78 20 45			.text	"Syntax Error",0
>10fd	72 72 6f 72 00
.1102					ErrorV_range:
.1102	20 8f 23	jsr $238f		jsr	ErrorHandler
>1105	4f 75 74 20 4f 66 20 52			.text	"Out Of Range",0
>110d	61 6e 67 65 00
.1112					ErrorV_value:
.1112	20 8f 23	jsr $238f		jsr	ErrorHandler
>1115	42 61 64 20 56 61 6c 75			.text	"Bad Value",0
>111d	65 00
.111f					ErrorV_type:
.111f	20 8f 23	jsr $238f		jsr	ErrorHandler
>1122	54 79 70 65 20 4d 69 73			.text	"Type Mismatch",0
>112a	6d 61 74 63 68 00
.1130					ErrorV_unimplemented:
.1130	20 8f 23	jsr $238f		jsr	ErrorHandler
>1133	4e 6f 74 20 49 6d 70 6c			.text	"Not Implemented",0
>113b	65 6d 65 6e 74 65 64 00
.1143					ErrorV_assert:
.1143	20 8f 23	jsr $238f		jsr	ErrorHandler
>1146	41 73 73 65 72 74 20 46			.text	"Assert Fail",0
>114e	61 69 6c 00
.1152					ErrorV_internal:
.1152	20 8f 23	jsr $238f		jsr	ErrorHandler
>1155	49 6e 74 65 72 6e 61 6c			.text	"Internal Error",0
>115d	20 45 72 72 6f 72 00
.1164					ErrorV_divzero:
.1164	20 8f 23	jsr $238f		jsr	ErrorHandler
>1167	44 69 76 69 64 65 20 42			.text	"Divide By Zero",0
>116f	79 20 5a 65 72 6f 00
.1176					ErrorV_structure:
.1176	20 8f 23	jsr $238f		jsr	ErrorHandler
>1179	53 74 72 75 63 74 75 72			.text	"Structure Imbalance",0
>1181	65 20 49 6d 62 61 6c 61 6e 63 65 00
.118d					ErrorV_stop:
.118d	20 8f 23	jsr $238f		jsr	ErrorHandler
>1190	50 72 6f 67 72 61 6d 20			.text	"Program Stopped",0
>1198	53 74 6f 70 70 65 64 00
.11a0					ErrorV_data:
.11a0	20 8f 23	jsr $238f		jsr	ErrorHandler
>11a3	4f 75 74 20 4f 66 20 44			.text	"Out Of Data",0
>11ab	61 74 61 00
.11af					ErrorV_redefine:
.11af	20 8f 23	jsr $238f		jsr	ErrorHandler
>11b2	41 72 72 61 79 20 52 65			.text	"Array Redefined",0
>11ba	64 65 66 69 6e 65 64 00
.11c2					ErrorV_index:
.11c2	20 8f 23	jsr $238f		jsr	ErrorHandler
>11c5	42 61 64 20 41 72 72 61			.text	"Bad Array Index",0
>11cd	79 20 49 6e 64 65 78 00
.11d5					ErrorV_memory:
.11d5	20 8f 23	jsr $238f		jsr	ErrorHandler
>11d8	4f 75 74 20 4f 66 20 4d			.text	"Out Of Memory",0
>11e0	65 6d 6f 72 79 00
.11e6					ErrorV_uninitialised:
.11e6	20 8f 23	jsr $238f		jsr	ErrorHandler
>11e9	56 61 72 69 61 62 6c 65			.text	"Variable Uninitialised",0
>11f1	20 55 6e 69 6e 69 74 69 61 6c 69 73 65 64 00
.1200					ErrorV_string:
.1200	20 8f 23	jsr $238f		jsr	ErrorHandler
>1203	42 61 64 20 53 74 72 69			.text	"Bad String Length",0
>120b	6e 67 20 4c 65 6e 67 74 68 00

;******  Return to file: include.files


;******  Processing file: src/errors/syntax.asm

.1215					ERRCheckLParen:
.1215	b1 1c		lda ($1c),y			lda 	(codePtr),y
.1217	c9 eb		cmp #$eb			cmp 	#PR_LPAREN
.1219	d0 18		bne $1233			bne 	ERRSyntaxError
.121b	c8		iny				iny
.121c	60		rts				rts
.121d					ERRCheckRParen:
.121d	b1 1c		lda ($1c),y			lda 	(codePtr),y
.121f	c9 9d		cmp #$9d			cmp 	#PR_RPAREN
.1221	d0 10		bne $1233			bne 	ERRSyntaxError
.1223	c8		iny				iny
.1224	60		rts				rts
.1225					ERRCheckComma:
.1225	b1 1c		lda ($1c),y			lda 	(codePtr),y
.1227	c9 99		cmp #$99			cmp 	#PR_COMMA
.1229	d0 08		bne $1233			bne 	ERRSyntaxError
.122b	c8		iny				iny
.122c	60		rts				rts
.122d					ERRCheckA:
.122d	d1 1c		cmp ($1c),y			cmp 	(codePtr),y
.122f	d0 02		bne $1233			bne 	ERRSyntaxError
.1231	c8		iny				iny
.1232	60		rts				rts
.1233					ERRSyntaxError:
.1233	4c f2 10	jmp $10f2		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/binary/basic.asm

.1236					EXPBinAdd:
.1236	24 0f		bit $0f				bit 	IFR0+IExp
.1238	30 6f		bmi $12a9			bmi 	EXPConcatenate
.123a	a2 10		ldx #$10			ldx 	#IFR1
.123c	4c a3 1c	jmp $1ca3			jmp 	IFloatAdd
.123f					EXPBinSub:
.123f	24 0f		bit $0f				bit 	IFR0+IExp
.1241	30 3f		bmi $1282			bmi 	EXPTypeError
.1243	a2 10		ldx #$10			ldx 	#IFR1
.1245	4c 9c 1c	jmp $1c9c			jmp 	IFloatSubtract
.1248					EXPBinMul:
.1248	24 0f		bit $0f				bit 	IFR0+IExp
.124a	30 36		bmi $1282			bmi 	EXPTypeError
.124c	a2 10		ldx #$10			ldx 	#IFR1
.124e	4c 4d 1d	jmp $1d4d			jmp 	IFloatMultiply
.1251					EXPBinFDiv:
.1251	24 0f		bit $0f				bit 	IFR0+IExp
.1253	30 2d		bmi $1282			bmi 	EXPTypeError
.1255	a2 10		ldx #$10			ldx 	#IFR1
.1257	20 d0 1f	jsr $1fd0			jsr 	IFloatDivideFloat
.125a	b0 0f		bcs $126b			bcs 	EXPDZero
.125c	60		rts				rts
.125d					EXPBinIDiv:
.125d	24 0f		bit $0f				bit 	IFR0+IExp
.125f	30 21		bmi $1282			bmi 	EXPTypeError
.1261	a2 10		ldx #$10			ldx 	#IFR1
.1263	20 d0 1f	jsr $1fd0			jsr 	IFloatDivideFloat
.1266	b0 03		bcs $126b			bcs 	EXPDZero
.1268	4c ad 1f	jmp $1fad			jmp 	IFloatIntegerR0
.126b					EXPDZero:
.126b	4c 64 11	jmp $1164		jmp	ErrorV_divzero
.126e					EXPBinIMod:
.126e	24 0f		bit $0f				bit 	IFR0+IExp
.1270	30 10		bmi $1282			bmi 	EXPTypeError
.1272	a2 10		ldx #$10			ldx 	#IFR1
.1274	5a		phy				phy
.1275	20 e5 1e	jsr $1ee5			jsr 	IFPreProcessBitwise 		; set up everything.
.1278	d0 05		bne $127f			bne 	EXPDRange
.127a	20 1e 1e	jsr $1e1e			jsr 	IFloatModulusInteger
.127d	7a		ply				ply
.127e	60		rts				rts
.127f					EXPDRange:
.127f	4c 02 11	jmp $1102		jmp	ErrorV_range
.1282					EXPTypeError:
.1282	4c 1f 11	jmp $111f		jmp	ErrorV_type
.1285					EXPBinAnd:
.1285	24 0f		bit $0f				bit 	IFR0+IExp
.1287	30 f9		bmi $1282			bmi 	EXPTypeError
.1289	a2 10		ldx #$10			ldx 	#IFR1
.128b	20 a0 1e	jsr $1ea0			jsr 	IFloatBitwiseAnd
.128e	b0 ef		bcs $127f			bcs 	EXPDRange
.1290	60		rts				rts
.1291					EXPBinOr:
.1291	24 0f		bit $0f				bit 	IFR0+IExp
.1293	30 ed		bmi $1282			bmi 	EXPTypeError
.1295	a2 10		ldx #$10			ldx 	#IFR1
.1297	20 b7 1e	jsr $1eb7			jsr 	IFloatBitwiseOr
.129a	b0 e3		bcs $127f			bcs 	EXPDRange
.129c	60		rts				rts
.129d					EXPBinXor:
.129d	24 0f		bit $0f				bit 	IFR0+IExp
.129f	30 e1		bmi $1282			bmi 	EXPTypeError
.12a1	a2 10		ldx #$10			ldx 	#IFR1
.12a3	20 ce 1e	jsr $1ece			jsr 	IFloatBitwiseXor
.12a6	b0 d7		bcs $127f			bcs 	EXPDRange
.12a8	60		rts				rts
.12a9					EXPConcatenate:
.12a9	18		clc				clc
.12aa	b2 0c		lda ($0c)			lda 	(IFR0) 	 					; work out total length
.12ac	72 10		adc ($10)			adc 	(IFR1)
.12ae	b0 2d		bcs $12dd			bcs 	_EXPCError
.12b0	a6 0c		ldx $0c				ldx 	IFR0 						; push R0 string on stack.
.12b2	da		phx				phx
.12b3	a6 0d		ldx $0d				ldx 	IFR0+1
.12b5	da		phx				phx
.12b6	20 56 1c	jsr $1c56			jsr 	StringTempAllocate 			; allocate string, set up return
.12b9	a6 11		ldx $11				ldx 	IFR1+1 						; copy first string.
.12bb	a5 10		lda $10				lda 	IFR1
.12bd	20 c6 12	jsr $12c6			jsr 	_EXPCCopyXA
.12c0	fa		plx				plx 								; copy second string
.12c1	68		pla				pla
.12c2	20 c6 12	jsr $12c6			jsr 	_EXPCCopyXA
.12c5	60		rts				rts
.12c6					_EXPCCopyXA:
.12c6	86 1f		stx $1f				stx 	zTemp0+1 					; save address to zTemp0
.12c8	85 1e		sta $1e				sta 	zTemp0
.12ca	b2 1e		lda ($1e)			lda 	(zTemp0)					; length
.12cc	f0 0e		beq $12dc			beq 	_EXPCCExit 					; nothing.
.12ce	aa		tax				tax 								; count
.12cf	5a		phy				phy 								; start positioin
.12d0	a0 01		ldy #$01			ldy 	#1
.12d2					_EXPCCLoop:
.12d2	b1 1e		lda ($1e),y			lda 	(zTemp0),y 					; write characters one at a time.
.12d4	20 8b 1c	jsr $1c8b			jsr 	StringTempWrite
.12d7	c8		iny				iny
.12d8	ca		dex				dex
.12d9	d0 f7		bne $12d2			bne 	_EXPCCLoop
.12db	7a		ply				ply
.12dc					_EXPCCExit:
.12dc	60		rts				rts
.12dd					_EXPCError:
.12dd	4c 00 12	jmp $1200		jmp	ErrorV_string

;******  Return to file: include.files


;******  Processing file: src/expression/binary/compare.asm

.12e0					EXPReturnTrue:
.12e0	a2 0c		ldx #$0c			ldx 	#IFR0
.12e2	a9 01		lda #$01			lda 	#1
.12e4	20 af 22	jsr $22af			jsr 	IFloatSetByte
.12e7	20 b8 22	jsr $22b8			jsr 	IFloatNegate
.12ea	60		rts				rts
.12eb					EXPReturnFalse:
.12eb	a2 0c		ldx #$0c			ldx 	#IFR0
.12ed	4c ad 22	jmp $22ad			jmp 	IFloatSetZero
.12f0					EXPCompareEqual:
.12f0	20 26 13	jsr $1326			jsr 	EXPCompareBaseCode
.12f3	c9 00		cmp #$00			cmp 	#0
.12f5	f0 e9		beq $12e0			beq 	EXPReturnTrue
.12f7	80 f2		bra $12eb			bra 	EXPReturnFalse
.12f9					EXPCompareLess:
.12f9	20 26 13	jsr $1326			jsr 	EXPCompareBaseCode
.12fc	c9 ff		cmp #$ff			cmp 	#$FF
.12fe	f0 e0		beq $12e0			beq 	EXPReturnTrue
.1300	80 e9		bra $12eb			bra 	EXPReturnFalse
.1302					EXPCompareGreater:
.1302	20 26 13	jsr $1326			jsr 	EXPCompareBaseCode
.1305	c9 01		cmp #$01			cmp 	#1
.1307	f0 d7		beq $12e0			beq 	EXPReturnTrue
.1309	80 e0		bra $12eb			bra 	EXPReturnFalse
.130b					EXPCompareNotEqual:
.130b	20 26 13	jsr $1326			jsr 	EXPCompareBaseCode
.130e	c9 00		cmp #$00			cmp 	#0
.1310	d0 ce		bne $12e0			bne 	EXPReturnTrue
.1312	80 d7		bra $12eb			bra 	EXPReturnFalse
.1314					EXPCompareLessEqual:
.1314	20 26 13	jsr $1326			jsr 	EXPCompareBaseCode
.1317	c9 01		cmp #$01			cmp 	#1
.1319	d0 c5		bne $12e0			bne 	EXPReturnTrue
.131b	80 ce		bra $12eb			bra 	EXPReturnFalse
.131d					EXPCompareGreaterEqual:
.131d	20 26 13	jsr $1326			jsr 	EXPCompareBaseCode
.1320	c9 ff		cmp #$ff			cmp 	#$FF
.1322	d0 bc		bne $12e0			bne 	EXPReturnTrue
.1324	80 c5		bra $12eb			bra 	EXPReturnFalse
.1326					EXPCompareBaseCode:
.1326	24 0f		bit $0f				bit 	IFR0+IExp 					; string compare ?
.1328	30 10		bmi $133a			bmi 	_EXCBCString
.132a	a2 10		ldx #$10			ldx 	#IFR1						; float compare
.132c	20 7b 1f	jsr $1f7b			jsr 	IFloatCompare
.132f	a5 0c		lda $0c				lda 	IFR0+IM0
.1331	f0 06		beq $1339			beq 	_EXCBCExit 					; return 0 if zero
.1333	24 0f		bit $0f				bit 	IFR0+IExp 					; return 1 if +ve
.1335	50 02		bvc $1339			bvc 	_EXCBCExit
.1337	a9 ff		lda #$ff			lda 	#255 						; return $FF if -ve
.1339					_EXCBCExit:
.1339	60		rts				rts
.133a					_EXCBCString:
.133a	5a		phy				phy
.133b	b2 0c		lda ($0c)			lda 	(IFR0) 						; length of smaller of the two in X.
.133d	d2 10		cmp ($10)			cmp 	(IFR1)
.133f	90 02		bcc $1343			bcc 	_EXCBCSmaller
.1341	b2 10		lda ($10)			lda 	(IFR1)
.1343					_EXCBCSmaller:
.1343	aa		tax				tax
.1344	f0 0d		beq $1353			beq 	_EXCBCMatches 				; if zero common length matches
.1346	a0 00		ldy #$00			ldy 	#0 							; match the strings.
.1348					_EXCBCCheckSmallerMatches:
.1348	c8		iny				iny 								; compare directly as far as common length
.1349	38		sec				sec
.134a	b1 10		lda ($10),y			lda 	(IFR1),y
.134c	f1 0c		sbc ($0c),y			sbc 	(IFR0),y
.134e	d0 08		bne $1358			bne 	_EXCBCExit2
.1350	ca		dex				dex
.1351	d0 f5		bne $1348			bne 	_EXCBCCheckSmallerMatches
.1353					_EXCBCMatches:
.1353	38		sec				sec
.1354	b2 10		lda ($10)			lda 	(IFR1) 						; common length matches. If same length equal
.1356	f2 0c		sbc ($0c)			sbc 	(IFR0)						; if len(r1) > len(r0) then r1 is longer
.1358					_EXCBCExit2:
.1358	7a		ply				ply
.1359	c9 00		cmp #$00			cmp 	#0
.135b	f0 04		beq $1361			beq 	_EXCBCReturn
.135d	30 03		bmi $1362			bmi 	_EXCBCFF
.135f	a9 01		lda #$01			lda 	#1
.1361					_EXCBCReturn:
.1361	60		rts				rts
.1362					_EXCBCFF:
.1362	a9 ff		lda #$ff			lda 	#$FF
.1364	60		rts				rts
.1365					_EXCBCRange:
.1365	4c 02 11	jmp $1102		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/binary/shift.asm

.1368					EXPBinLeft:
.1368	a9 ff		lda #$ff			lda 	#$FF
.136a	8d 3b 03	sta $033b			sta 	EXPShiftLeftFlag
.136d	4c 73 13	jmp $1373			jmp 	EXPShiftCommon
.1370					EXPBinRight:
.1370	9c 3b 03	stz $033b			stz 	EXPShiftLeftFlag
.1373					EXPShiftCommon:
.1373	a5 0f		lda $0f				lda 	IFR0+IExp 					; both integers
.1375	05 13		ora $13				ora 	IFR1+IExp
.1377	29 7f		and #$7f			and 	#$7F
.1379	d0 35		bne $13b0			bne 	_EXPSRange
.137b	a5 0c		lda $0c				lda 	IFR0+IM0					; check shift >= 32
.137d	29 e0		and #$e0			and 	#$E0
.137f	05 0d		ora $0d				ora 	IFR0+IM1
.1381	05 0e		ora $0e				ora 	IFR0+IM2
.1383	d0 25		bne $13aa			bne 	_EXPSShiftZero 				; if so return zero
.1385	5a		phy				phy
.1386	a5 0c		lda $0c				lda 	IFR0+IM0 					; get shift
.1388	29 1f		and #$1f			and 	#$1F
.138a	f0 17		beq $13a3			beq 	_EXPSExit 					; exit if zero
.138c	a8		tay				tay
.138d					_EXPSLoop:
.138d	a2 10		ldx #$10			ldx 	#IFR1
.138f	2c 3b 03	bit $033b			bit 	EXPShiftLeftFlag
.1392	30 05		bmi $1399			bmi 	_EXPSShiftLeft
.1394	20 dc 22	jsr $22dc			jsr 	IFloatShiftRight
.1397	80 07		bra $13a0			bra 	_EXPSContinue
.1399					_EXPSShiftLeft:
.1399	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.139c	24 0e		bit $0e				bit 	IFR0+IM2 					; too many shifts
.139e	30 10		bmi $13b0			bmi 	_EXPSRange
.13a0					_EXPSContinue:
.13a0	88		dey				dey
.13a1	d0 ea		bne $138d			bne 	_EXPSLoop
.13a3					_EXPSExit:
.13a3	a2 10		ldx #$10			ldx 	#IFR1
.13a5	20 3e 22	jsr $223e			jsr 	IFloatCopyFromRegister
.13a8	7a		ply				ply
.13a9	60		rts				rts
.13aa					_EXPSShiftZero:
.13aa	a2 0c		ldx #$0c			ldx 	#IFR0
.13ac	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.13af	60		rts				rts
.13b0					_EXPSRange:
.13b0	4c 02 11	jmp $1102		jmp	ErrorV_range
.033b					EXPShiftLeftFlag:
>033b							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/expression/expression.asm

.13b3					EXPEvaluateExpression:
.13b3	a9 00		lda #$00			lda 	#0 							; current precedence
.13b5					EXPEvaluateExpressionPrecedenceA:
.13b5	48		pha				pha
.13b6	20 30 14	jsr $1430			jsr 	EXPTermValueR0				; do first term.
.13b9					_EELoop:
.13b9	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; what follows needs to be a binary operator
.13bb	c9 ef		cmp #$ef			cmp 	#PR_BINARY_FIRST 			; binary tokens are the last ones up to $FF
.13bd	90 31		bcc $13f0			bcc 	_EEExit
.13bf	aa		tax				tax 								; access the precedence of the operator.
.13c0	68		pla				pla 								; restore precedence.if >= operator precedence then exit
.13c1	dd 79 15	cmp $1579,x			cmp 	BinaryPrecedence-PR_BINARY_FIRST,x
.13c4	b0 2b		bcs $13f1			bcs 	_EEExit2
.13c6	48		pha				pha 								; save current precedence.
.13c7	da		phx				phx 								; save operator
.13c8	c8		iny				iny 								; consume operator
.13c9	da		phx				phx
.13ca	a2 0c		ldx #$0c			ldx 	#IFR0 						; push R0 on the stack
.13cc	20 fc 21	jsr $21fc			jsr 	IFloatPushRx
.13cf	fa		plx				plx
.13d0	bd 79 15	lda $1579,x			lda 	BinaryPrecedence-PR_BINARY_FIRST,x
.13d3	20 b5 13	jsr $13b5			jsr 	EXPEvaluateExpressionPrecedenceA
.13d6	a2 10		ldx #$10			ldx 	#IFR1 						; pop LHS to R1.
.13d8	20 1d 22	jsr $221d			jsr 	IFloatPullRx
.13db	fa		plx				plx 								; operator
.13dc	a5 0f		lda $0f				lda 	IFR0+IExp 					; if check types match.
.13de	45 13		eor $13				eor 	IFR1+IExp
.13e0	30 08		bmi $13ea			bmi 	_EEType
.13e2					_EETypeOkay:
.13e2	8a		txa				txa
.13e3	0a		asl a				asl 	a 							; double -> X
.13e4	aa		tax				tax
.13e5	20 ed 13	jsr $13ed			jsr 	_EECallBinary 				; call the operator R0 := R1 <op> R0
.13e8	80 cf		bra $13b9			bra 	_EELoop
.13ea					_EEType:
.13ea	4c 1f 11	jmp $111f		jmp	ErrorV_type
.13ed					_EECallBinary:
.13ed	7c 03 18	jmp ($1803,x)			jmp 	(VectorTable,x)
.13f0					_EEExit:
.13f0	68		pla				pla 								; throw precedence
.13f1					_EEExit2:
.13f1	18		clc				clc
.13f2	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/exprutils.asm

.13f3					EXPEvalNumber:
.13f3	20 b3 13	jsr $13b3			jsr 	EXPEvaluateExpression
.13f6	24 0f		bit $0f				bit 	IFR0+IExp
.13f8	30 01		bmi $13fb			bmi 	EVUType
.13fa	60		rts				rts
.13fb					EVUType:
.13fb	4c 1f 11	jmp $111f		jmp	ErrorV_type
.13fe					EXPEvalInteger:
.13fe	20 f3 13	jsr $13f3			jsr 	EXPEvalNumber 				; get number, coeerce to integer.
.1401	20 ad 1f	jsr $1fad			jsr 	IFloatIntegerR0
.1404	60		rts				rts
.1405					EXPEvalInteger16:
.1405	20 fe 13	jsr $13fe			jsr 	EXPEvalInteger
.1408	a5 0e		lda $0e				lda 	IFR0+IM2
.140a	d0 21		bne $142d			bne 	EVURange
.140c	a6 0d		ldx $0d				ldx 	IFR0+IM1
.140e	a5 0c		lda $0c				lda 	IFR0+IM0
.1410	60		rts				rts
.1411					EXPEvalInteger8:
.1411	20 fe 13	jsr $13fe			jsr 	EXPEvalInteger
.1414	a5 0e		lda $0e				lda 	IFR0+IM2
.1416	05 0d		ora $0d				ora 	IFR0+IM1
.1418	d0 13		bne $142d			bne 	EVURange
.141a	a5 0c		lda $0c				lda 	IFR0+IM0
.141c	60		rts				rts
.141d					EXPEvalString:
.141d	20 b3 13	jsr $13b3			jsr 	EXPEvaluateExpression
.1420	24 0f		bit $0f				bit 	IFR0+IExp
.1422	10 d7		bpl $13fb			bpl 	EVUType
.1424	a6 0d		ldx $0d				ldx 	IFR0+IM1
.1426	86 1f		stx $1f				stx 	zTemp0+1
.1428	a5 0c		lda $0c				lda 	IFR0+IM0
.142a	85 1e		sta $1e				sta 	zTemp0
.142c	60		rts				rts
.142d					EVURange:
.142d	4c 02 11	jmp $1102		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/term.asm

.1430					EXPTermValueR0:
.1430	20 39 14	jsr $1439			jsr 	EXPTermR0
.1433	90 03		bcc $1438			bcc 	_ETVNotReference
.1435	4c 30 11	jmp $1130		jmp	ErrorV_unimplemented
.1438					_ETVNotReference:
.1438	60		rts				rts
.1439					EXPTermR0:
.1439	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get next token/element
.143b	30 3f		bmi $147c			bmi 	_ETMIsUnaryOrMinus 			; if it's a token, it's a unary function, maybe -
.143d	c8		iny				iny 								; consume element
.143e	c9 40		cmp #$40			cmp 	#$40 						; 40-7F are identifiers.
.1440	b0 37		bcs $1479			bcs 	_ETMIdentifier
.1442	85 0c		sta $0c				sta 	IFR0+IM0 					; initial value in IM0
.1444	64 0f		stz $0f				stz 	IFR0+IExp
.1446	64 0d		stz $0d				stz 	IFR0+IM1
.1448	64 0e		stz $0e				stz 	IFR0+IM2
.144a					_ETMConstant:
.144a	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; what follows.
.144c	c9 40		cmp #$40			cmp 	#$40 						; continuing constant
.144e	b0 24		bcs $1474			bcs 	_ETMCExit 					; no.
.1450	a6 0e		ldx $0e				ldx 	IFR0+IM2 					; x 256 into A:M2 M1 M0
.1452	a5 0d		lda $0d				lda 	IFR0+IM1
.1454	85 0e		sta $0e				sta 	IFR0+IM2
.1456	a5 0c		lda $0c				lda 	IFR0+IM0
.1458	85 0d		sta $0d				sta 	IFR0+IM1
.145a	64 0c		stz $0c				stz 	IFR0+IM0
.145c	8a		txa				txa
.145d	4a		lsr a				lsr 	a 							; shift right twice, e.g. whole thing is x 64
.145e	66 0e		ror $0e				ror 	IFR0+IM2
.1460	66 0d		ror $0d				ror 	IFR0+IM1
.1462	66 0c		ror $0c				ror 	IFR0+IM0
.1464	4a		lsr a				lsr 	a
.1465	66 0e		ror $0e				ror 	IFR0+IM2
.1467	66 0d		ror $0d				ror 	IFR0+IM1
.1469	66 0c		ror $0c				ror 	IFR0+IM0
.146b	a5 0c		lda $0c				lda 	IFR0+IM0 					; LSB in.
.146d	11 1c		ora ($1c),y			ora 	(codePtr),y
.146f	85 0c		sta $0c				sta 	IFR0+IM0
.1471	c8		iny				iny 								; consume, loop back
.1472	80 d6		bra $144a			bra 	_ETMConstant
.1474					_ETMCExit:
.1474	20 a0 14	jsr $14a0			jsr 	EXPCheckDecimalFollows 		; check for decimals.
.1477	18		clc				clc 								; return value
.1478	60		rts				rts
.1479					_ETMIdentifier:
.1479	4c 30 11	jmp $1130		jmp	ErrorV_unimplemented
.147c					_ETMIsUnaryOrMinus:
.147c	c8		iny				iny 								; consume element
.147d	c9 fe		cmp #$fe			cmp 	#PR_MINUS 					; handle - seperately as it has two roles.
.147f	d0 0a		bne $148b			bne 	_ETMCheckUnary
.1481	20 30 14	jsr $1430			jsr 	EXPTermValueR0 				; get a term to negate
.1484	a2 0c		ldx #$0c			ldx 	#IFR0 						; and negate it
.1486	20 b8 22	jsr $22b8			jsr 	IFloatNegate
.1489	18		clc				clc
.148a	60		rts				rts
.148b					_ETMCheckUnary:
.148b	c9 d7		cmp #$d7			cmp 	#PR_UNARY_FIRST 			; check unary function.
.148d	90 0e		bcc $149d			bcc 	_ETMUnarySyntax
.148f	c9 ef		cmp #$ef			cmp 	#PR_UNARY_LAST+1
.1491	b0 0a		bcs $149d			bcs 	_ETMUnarySyntax
.1493	0a		asl a				asl 	a
.1494	aa		tax				tax
.1495	20 9a 14	jsr $149a			jsr 	_ETMCallUnaryFunction
.1498	18		clc				clc
.1499	60		rts				rts
.149a					_ETMCallUnaryFunction:
.149a	7c 03 18	jmp ($1803,x)			jmp 	(VectorTable,x)
.149d					_ETMUnarySyntax:
.149d	4c f2 10	jmp $10f2		jmp	ErrorV_syntax
.14a0					EXPCheckDecimalFollows:
.14a0	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; check for decimal
.14a2	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ
.14a4	d0 19		bne $14bf			bne 	_ETMCDExit
.14a6	c8		iny				iny 								; consume token.
.14a7	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get count
.14a9	5a		phy				phy									; save current position
.14aa	48		pha				pha 								; save count of chars.
.14ab	38		sec				sec 								; address into YX : y + codePtr+1
.14ac	98		tya				tya
.14ad	65 1c		adc $1c				adc 	codePtr
.14af	aa		tax				tax
.14b0	a5 1d		lda $1d				lda 	codePtr+1
.14b2	69 00		adc #$00			adc 	#0
.14b4	a8		tay				tay
.14b5	68		pla				pla 								; get count.
.14b6	20 51 21	jsr $2151			jsr 	IFloatAddDecimalToR0 		; add the decimal to R0
.14b9	7a		ply				ply 								; go to next token.
.14ba	98		tya				tya
.14bb	38		sec				sec
.14bc	71 1c		adc ($1c),y			adc 	(codePtr),y
.14be	a8		tay				tay
.14bf					_ETMCDExit:
.14bf	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/abs.asm

.14c0					EXPUnaryAbs:
.14c0	20 f3 13	jsr $13f3			jsr 	EXPEvalNumber 					; number to R0
.14c3	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.14c6	20 f1 1e	jsr $1ef1			jsr 	IFloatAbsoluteR0
.14c9	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/asc.asm

.14ca					EXPUnaryAsc:
.14ca	20 1d 14	jsr $141d			jsr 	EXPEvalString 					; string to R0, zTemp0
.14cd	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.14d0	b2 1e		lda ($1e)			lda 	(zTemp0) 						; length 0 ?
.14d2	f0 06		beq $14da			beq 	_EXAZero 						; if so return 0
.14d4	5a		phy				phy 									; otherwise get first character
.14d5	a0 01		ldy #$01			ldy 	#1
.14d7	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.14d9	7a		ply				ply
.14da					_EXAZero:
.14da	a2 0c		ldx #$0c			ldx 	#IFR0
.14dc	20 af 22	jsr $22af			jsr 	IFloatSetByte
.14df	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/chr.asm

.14e0					EXPUnaryChr:
.14e0	20 11 14	jsr $1411			jsr 	EXPEvalInteger8 				; expr
.14e3	48		pha				pha 									; push on stack
.14e4	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.14e7	a9 01		lda #$01			lda 	#1 								; alloc temp mem for result
.14e9	20 56 1c	jsr $1c56			jsr 	StringTempAllocate
.14ec	68		pla				pla
.14ed	20 8b 1c	jsr $1c8b			jsr 	StringTempWrite
.14f0	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/dec.asm

.14f1					EXPUnaryDec:
.14f1	20 1d 14	jsr $141d			jsr 	EXPEvalString 					; string to R0, zTemp0
.14f4	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.14f7	5a		phy				phy
.14f8	a2 0c		ldx #$0c			ldx 	#IFR0 							; zero the result
.14fa	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.14fd	b2 1e		lda ($1e)			lda 	(zTemp0)						; read the length to X
.14ff	f0 3b		beq $153c			beq 	_EUDError 						; empty string
.1501	aa		tax				tax
.1502	a0 01		ldy #$01			ldy 	#1 								; start at offset 1
.1504					_EUDLoop:
.1504	b1 1e		lda ($1e),y			lda 	(zTemp0),y 						; get next
.1506	c9 61		cmp #$61			cmp 	#"a" 							; l/c -> u/c
.1508	90 02		bcc $150c			bcc 	_EUDNoCase
.150a	e9 20		sbc #$20			sbc 	#$20
.150c					_EUDNoCase:
.150c	c9 30		cmp #$30			cmp 	#'0' 							; check 0..9
.150e	90 2c		bcc $153c			bcc 	_EUDError
.1510	c9 3a		cmp #$3a			cmp 	#'9'+1
.1512	90 0a		bcc $151e			bcc 	_EUDOkay
.1514	c9 41		cmp #$41			cmp 	#'A'							; check A-F
.1516	90 24		bcc $153c			bcc 	_EUDError
.1518	c9 47		cmp #$47			cmp 	#'F'+1
.151a	b0 20		bcs $153c			bcs 	_EUDError
.151c	e9 06		sbc #$06			sbc 	#6 								; hex adjust
.151e					_EUDOkay:
.151e	29 0f		and #$0f			and 	#15 							; make constant
.1520	da		phx				phx
.1521	48		pha				pha
.1522	a2 0c		ldx #$0c			ldx 	#IFR0 							; multiply R0 x 16
.1524	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.1527	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.152a	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.152d	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.1530	68		pla				pla 									; pop constant and OR in
.1531	fa		plx				plx
.1532	05 0c		ora $0c				ora 	IFR0+IM0
.1534	85 0c		sta $0c				sta 	IFR0+IM0
.1536	c8		iny				iny 									; next
.1537	ca		dex				dex
.1538	d0 ca		bne $1504			bne 	_EUDLoop
.153a	7a		ply				ply
.153b	60		rts				rts
.153c					_EUDError:
.153c	4c 12 11	jmp $1112		jmp	ErrorV_value

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/decimal.asm

.153f					EXPUnaryInlineDec:
.153f	4c f2 10	jmp $10f2		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/dollar.asm

.1542					EXPUnaryNull:
.1542	20 30 14	jsr $1430			jsr 	EXPTermValueR0
.1545	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/fractional.asm

.1546					EXPUnaryFrac:
.1546	20 f3 13	jsr $13f3			jsr 	EXPEvalNumber 					; number to R0
.1549	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.154c	20 57 1f	jsr $1f57			jsr 	IFloatFractionalR0
.154f	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/intfn.asm

.1550					EXPUnaryInt:
.1550	20 f3 13	jsr $13f3			jsr 	EXPEvalNumber 					; number to R0
.1553	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.1556	20 ad 1f	jsr $1fad			jsr 	IFloatIntegerR0
.1559	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/len.asm

.155a					EXPUnaryLen:
.155a	20 1d 14	jsr $141d			jsr 	EXPEvalString 					; string to R0, zTemp0
.155d	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.1560	b2 1e		lda ($1e)			lda 	(zTemp0)
.1562	a2 0c		ldx #$0c			ldx 	#IFR0
.1564	20 af 22	jsr $22af			jsr 	IFloatSetByte
.1567	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/parenthesis.asm

.1568					EXPUnaryParenthesis:
.1568	20 f3 13	jsr $13f3			jsr 	EXPEvalNumber 					; number to R0
.156b	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.156e	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/random.asm

.156f					EXPUnaryRnd:
.156f	20 f3 13	jsr $13f3			jsr 	EXPEvalNumber 				; number to R0
.1572	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 				; )
.1575	a2 0c		ldx #$0c			ldx 	#IFR0
.1577	20 8e 15	jsr $158e			jsr 	EXPLoadInRandom
.157a	a9 29		lda #$29			lda 	#64-23 						; hack the exponent to make it work.
.157c	85 0f		sta $0f				sta 	IFR0+IExp
.157e	60		rts				rts
.157f					ExpUnaryRand:
.157f	20 fe 13	jsr $13fe			jsr 	EXPEvalInteger 				; integer to R0
.1582	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 				; )
.1585	a2 10		ldx #$10			ldx 	#IFR1 						; random to R1
.1587	20 8e 15	jsr $158e			jsr 	EXPLoadInRandom
.158a	20 1e 1e	jsr $1e1e			jsr 	IFloatModulusInteger 		; calculate mod r1,r2
.158d	60		rts				rts
.158e					EXPLoadInRandom:
.158e	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.1591	20 a3 15	jsr $15a3			jsr 	EXPRandom32
.1594	95 00		sta $00,x			sta 	IM0,x
.1596	20 a3 15	jsr $15a3			jsr 	EXPRandom32
.1599	95 01		sta $01,x			sta 	IM1,x
.159b	20 a3 15	jsr $15a3			jsr 	EXPRandom32
.159e	29 7f		and #$7f			and 	#$7F
.15a0	95 02		sta $02,x			sta 	IM2,x
.15a2	60		rts				rts
.15a3					EXPRandom32:
.15a3	5a		phy				phy
.15a4	a0 08		ldy #$08			ldy 	#8
.15a6	ad 3c 03	lda $033c			lda 	EXPSeed+0
.15a9	0d 3d 03	ora $033d			ora 	EXPSeed+1
.15ac	0d 3e 03	ora $033e			ora 	EXPSeed+2
.15af	0d 3f 03	ora $033f			ora 	EXPSeed+3
.15b2	d0 08		bne $15bc			bne 	_EXPRNoReset
.15b4	ee 3c 03	inc $033c			inc 	EXPSeed+0
.15b7	a0 10		ldy #$10			ldy 	#16
.15b9	8c 3f 03	sty $033f			sty 	EXPSeed+3
.15bc					_EXPRNoReset:
.15bc	ad 3c 03	lda $033c			lda 	EXPSeed+0
.15bf					_EXPRLoop:
.15bf	0a		asl a				asl		a
.15c0	2e 3d 03	rol $033d			rol 	EXPSeed+1
.15c3	2e 3e 03	rol $033e			rol 	EXPSeed+2
.15c6	2e 3f 03	rol $033f			rol 	EXPSeed+3
.15c9	90 02		bcc $15cd			bcc 	_EXPRNoEOR
.15cb	49 c5		eor #$c5			eor 	#$C5
.15cd					_EXPRNoEOR:
.15cd	88		dey				dey
.15ce	d0 ef		bne $15bf			bne 	_EXPRLoop
.15d0	8d 3c 03	sta $033c			sta 	EXPSeed+0
.15d3	7a		ply				ply
.15d4	60		rts				rts
.033c					EXPSeed:
>033c							.fill 	4

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sgn.asm

.15d5					EXPUnarySgn:
.15d5	20 f3 13	jsr $13f3			jsr 	EXPEvalNumber 					; number to R0
.15d8	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.15db	a2 10		ldx #$10			ldx 	#IFR1 							; copy to R1
.15dd	20 4f 22	jsr $224f			jsr 	IFloatCopyToRegister
.15e0	a2 0c		ldx #$0c			ldx 	#IFR0 							; R0 = 0
.15e2	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.15e5	a2 10		ldx #$10			ldx 	#IFR1
.15e7	20 7b 1f	jsr $1f7b			jsr 	IFloatCompare 					; compare R1 vs 0.
.15ea	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sqr.asm

.15eb					EXPUnarySqr:
.15eb	20 f3 13	jsr $13f3			jsr 	EXPEvalNumber 					; number to R0
.15ee	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.15f1	20 f9 1e	jsr $1ef9			jsr 	IFloatSquareRootR0 				; square root.
.15f4	b0 01		bcs $15f7			bcs 	_EUSValue
.15f6	60		rts				rts
.15f7					_EUSValue:
.15f7	4c 02 11	jmp $1102		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/strhex.asm

.15fa					EXPUnaryHex:
.15fa	20 fe 13	jsr $13fe			jsr 	EXPEvalInteger 					; expr
.15fd	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.1600	5a		phy				phy
.1601	a9 10		lda #$10			lda 	#16
.1603	20 4e 20	jsr $204e			jsr 	IFloatIntegerToStringR0
.1606	80 0a		bra $1612			bra 	EUSMain
.1608					EXPUnaryStr:
.1608	20 f3 13	jsr $13f3			jsr 	EXPEvalNumber 					; expr
.160b	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.160e	5a		phy				phy
.160f	20 aa 20	jsr $20aa			jsr 	IFloatFloatToStringR0 			; convert to string
.1612					EUSMain:
.1612	b0 18		bcs $162c			bcs 	_EUSError
.1614	86 1e		stx $1e				stx 	zTemp0 							; save string address
.1616	84 1f		sty $1f				sty 	zTemp0+1
.1618	48		pha				pha 									; save count
.1619	a9 20		lda #$20			lda 	#32 							; allocate space for result.
.161b	20 56 1c	jsr $1c56			jsr 	StringTempAllocate
.161e	fa		plx				plx 									; count in X
.161f	a0 00		ldy #$00			ldy 	#0
.1621					_EUSCopy:
.1621	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.1623	c8		iny				iny
.1624	20 8b 1c	jsr $1c8b			jsr 	StringTempWrite
.1627	ca		dex				dex
.1628	d0 f7		bne $1621			bne	 	_EUSCopy
.162a	7a		ply				ply
.162b	60		rts				rts
.162c					_EUSError:
.162c	4c 02 11	jmp $1102		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/string.asm

.162f					EXPUnaryInlineString:
.162f	18		clc				clc 								; physical address -> IM0,1
.1630	98		tya				tya
.1631	65 1c		adc $1c				adc 	codePtr
.1633	85 0c		sta $0c				sta 	IFR0+IM0
.1635	a5 1d		lda $1d				lda 	codePtr+1
.1637	69 00		adc #$00			adc 	#0
.1639	85 0d		sta $0d				sta 	IFR0+IM1
.163b	64 0e		stz $0e				stz 	IFR0+IM2 					; fill in rest
.163d	a9 80		lda #$80			lda 	#$80
.163f	85 0f		sta $0f				sta 	IFR0+IExp
.1641	98		tya				tya	 								; skip over it.
.1642	38		sec				sec
.1643	71 1c		adc ($1c),y			adc 	(codePtr),y
.1645	a8		tay				tay
.1646	60		rts				rts
.1647					_EXPUISRange:
.1647	4c 02 11	jmp $1102		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/val.asm

.164a					EXPUnaryVal:
.164a	20 1d 14	jsr $141d			jsr 	EXPEvalString 					; string to R0, zTemp0
.164d	20 1d 12	jsr $121d			jsr 	ERRCheckRParen 					; )
.1650	5a		phy				phy
.1651	18		clc				clc
.1652	a5 1e		lda $1e				lda		zTemp0 							; point XY to the text
.1654	69 01		adc #$01			adc 	#1
.1656	aa		tax				tax
.1657	a5 1f		lda $1f				lda 	zTemp0+1
.1659	69 00		adc #$00			adc 	#0
.165b	a8		tay				tay
.165c	b2 1e		lda ($1e)			lda 	(zTemp0) 						; get length.
.165e	20 11 21	jsr $2111			jsr 	IFloatStringToFloatR0 			; do conversion
.1661	b0 02		bcs $1665			bcs 	_EUVError
.1663	7a		ply				ply
.1664	60		rts				rts
.1665					_EUVError:
.1665	4c 12 11	jmp $1112		jmp	ErrorV_value

;******  Return to file: include.files


;******  Processing file: src/generated/precedence_table.asm

.1668					BinaryPrecedence:
>1668	02					.byte	 2	; $ef =
>1669	02					.byte	 2	; $f0 <>
>166a	02					.byte	 2	; $f1 <=
>166b	02					.byte	 2	; $f2 <
>166c	02					.byte	 2	; $f3 >=
>166d	02					.byte	 2	; $f4 >
>166e	01					.byte	 1	; $f5 XOR
>166f	01					.byte	 1	; $f6 OR
>1670	01					.byte	 1	; $f7 AND
>1671	04					.byte	 4	; $f8 DIV
>1672	04					.byte	 4	; $f9 MOD
>1673	04					.byte	 4	; $fa <<
>1674	04					.byte	 4	; $fb >>
>1675	04					.byte	 4	; $fc /
>1676	04					.byte	 4	; $fd *
>1677	03					.byte	 3	; $fe -
>1678	03					.byte	 3	; $ff +

;******  Return to file: include.files


;******  Processing file: src/generated/token_text.asm

.1679					StandardTokens:
>1679	06 52 45 50 45 41 54			.byte	$06,$52,$45,$50,$45,$41,$54             	; $80 repeat
>1680	05 55 4e 54 49 4c			.byte	$05,$55,$4e,$54,$49,$4c                 	; $81 until
>1686	05 57 48 49 4c 45			.byte	$05,$57,$48,$49,$4c,$45                 	; $82 while
>168c	04 57 45 4e 44				.byte	$04,$57,$45,$4e,$44                     	; $83 wend
>1691	02 49 46				.byte	$02,$49,$46                             	; $84 if
>1694	05 45 4e 44 49 46			.byte	$05,$45,$4e,$44,$49,$46                 	; $85 endif
>169a	02 44 4f				.byte	$02,$44,$4f                             	; $86 do
>169d	04 4c 4f 4f 50				.byte	$04,$4c,$4f,$4f,$50                     	; $87 loop
>16a2	04 50 52 4f 43				.byte	$04,$50,$52,$4f,$43                     	; $88 proc
>16a7	07 45 4e 44 50 52 4f 43			.byte	$07,$45,$4e,$44,$50,$52,$4f,$43         	; $89 endproc
>16af	03 46 4f 52				.byte	$03,$46,$4f,$52                         	; $8a for
>16b3	04 4e 45 58 54				.byte	$04,$4e,$45,$58,$54                     	; $8b next
>16b8	00					.byte	$00                                     	; $8c [[end]]
>16b9	00					.byte	$00                                     	; $8d [[shift]]
>16ba	04 45 4c 53 45				.byte	$04,$45,$4c,$53,$45                     	; $8e else
>16bf	04 54 48 45 4e				.byte	$04,$54,$48,$45,$4e                     	; $8f then
>16c4	02 54 4f				.byte	$02,$54,$4f                             	; $90 to
>16c7	04 53 54 45 50				.byte	$04,$53,$54,$45,$50                     	; $91 step
>16cc	03 4c 45 54				.byte	$03,$4c,$45,$54                         	; $92 let
>16d0	05 50 52 49 4e 54			.byte	$05,$50,$52,$49,$4e,$54                 	; $93 print
>16d6	05 49 4e 50 55 54			.byte	$05,$49,$4e,$50,$55,$54                 	; $94 input
>16dc	04 43 41 4c 4c				.byte	$04,$43,$41,$4c,$4c                     	; $95 call
>16e1	03 53 59 53				.byte	$03,$53,$59,$53                         	; $96 sys
>16e5	03 52 45 4d				.byte	$03,$52,$45,$4d                         	; $97 rem
>16e9	04 45 58 49 54				.byte	$04,$45,$58,$49,$54                     	; $98 exit
>16ee	01 2c					.byte	$01,$2c                                 	; $99 ,
>16f0	01 3b					.byte	$01,$3b                                 	; $9a ;
>16f2	01 3a					.byte	$01,$3a                                 	; $9b :
>16f4	01 27					.byte	$01,$27                                 	; $9c '
>16f6	01 29					.byte	$01,$29                                 	; $9d )
>16f8	03 44 49 4d				.byte	$03,$44,$49,$4d                         	; $9e dim
>16fc	05 43 4c 45 41 52			.byte	$05,$43,$4c,$45,$41,$52                 	; $9f clear
>1702	03 4e 45 57				.byte	$03,$4e,$45,$57                         	; $a0 new
>1706	03 52 55 4e				.byte	$03,$52,$55,$4e                         	; $a1 run
>170a	04 53 54 4f 50				.byte	$04,$53,$54,$4f,$50                     	; $a2 stop
>170f	03 45 4e 44				.byte	$03,$45,$4e,$44                         	; $a3 end
>1713	06 41 53 53 45 52 54			.byte	$06,$41,$53,$53,$45,$52,$54             	; $a4 assert
>171a	04 4c 49 53 54				.byte	$04,$4c,$49,$53,$54                     	; $a5 list
>171f	04 53 41 56 45				.byte	$04,$53,$41,$56,$45                     	; $a6 save
>1724	04 4c 4f 41 44				.byte	$04,$4c,$4f,$41,$44                     	; $a7 load
>1729	00					.byte	0											; $a8
>172a	00					.byte	0											; $a9
>172b	00					.byte	0											; $aa
>172c	00					.byte	0											; $ab
>172d	00					.byte	0											; $ac
>172e	00					.byte	0											; $ad
>172f	00					.byte	0											; $ae
>1730	00					.byte	0											; $af
>1731	00					.byte	0											; $b0
>1732	00					.byte	0											; $b1
>1733	00					.byte	0											; $b2
>1734	00					.byte	0											; $b3
>1735	00					.byte	0											; $b4
>1736	00					.byte	0											; $b5
>1737	00					.byte	0											; $b6
>1738	00					.byte	0											; $b7
>1739	00					.byte	0											; $b8
>173a	00					.byte	0											; $b9
>173b	00					.byte	0											; $ba
>173c	00					.byte	0											; $bb
>173d	00					.byte	0											; $bc
>173e	00					.byte	0											; $bd
>173f	00					.byte	0											; $be
>1740	00					.byte	0											; $bf
>1741	00					.byte	0											; $c0
>1742	00					.byte	0											; $c1
>1743	00					.byte	0											; $c2
>1744	00					.byte	0											; $c3
>1745	00					.byte	0											; $c4
>1746	00					.byte	0											; $c5
>1747	00					.byte	0											; $c6
>1748	00					.byte	0											; $c7
>1749	00					.byte	0											; $c8
>174a	00					.byte	0											; $c9
>174b	00					.byte	0											; $ca
>174c	00					.byte	0											; $cb
>174d	00					.byte	0											; $cc
>174e	00					.byte	0											; $cd
>174f	00					.byte	0											; $ce
>1750	00					.byte	0											; $cf
>1751	00					.byte	0											; $d0
>1752	00					.byte	0											; $d1
>1753	00					.byte	0											; $d2
>1754	00					.byte	0											; $d3
>1755	00					.byte	0											; $d4
>1756	00					.byte	0											; $d5
>1757	00					.byte	0											; $d6
>1758	07 52 49 47 48 54 24 28			.byte	$07,$52,$49,$47,$48,$54,$24,$28         	; $d7 right$(
>1760	06 4c 45 46 54 24 28			.byte	$06,$4c,$45,$46,$54,$24,$28             	; $d8 left$(
>1767	05 4d 49 44 24 28			.byte	$05,$4d,$49,$44,$24,$28                 	; $d9 mid$(
>176d	05 53 54 52 24 28			.byte	$05,$53,$54,$52,$24,$28                 	; $da str$(
>1773	04 56 41 4c 28				.byte	$04,$56,$41,$4c,$28                     	; $db val(
>1778	04 53 47 4e 28				.byte	$04,$53,$47,$4e,$28                     	; $dc sgn(
>177d	04 41 42 53 28				.byte	$04,$41,$42,$53,$28                     	; $dd abs(
>1782	04 4c 45 4e 28				.byte	$04,$4c,$45,$4e,$28                     	; $de len(
>1787	04 53 51 52 28				.byte	$04,$53,$51,$52,$28                     	; $df sqr(
>178c	05 43 48 52 24 28			.byte	$05,$43,$48,$52,$24,$28                 	; $e0 chr$(
>1792	04 41 53 43 28				.byte	$04,$41,$53,$43,$28                     	; $e1 asc(
>1797	07 49 4e 4b 45 59 24 28			.byte	$07,$49,$4e,$4b,$45,$59,$24,$28         	; $e2 inkey$(
>179f	06 45 56 45 4e 54 28			.byte	$06,$45,$56,$45,$4e,$54,$28             	; $e3 event(
>17a6	04 54 49 4d 45				.byte	$04,$54,$49,$4d,$45                     	; $e4 time
>17ab	04 49 4e 54 28				.byte	$04,$49,$4e,$54,$28                     	; $e5 int(
>17b0	05 46 52 41 43 28			.byte	$05,$46,$52,$41,$43,$28                 	; $e6 frac(
>17b6	04 44 45 43 28				.byte	$04,$44,$45,$43,$28                     	; $e7 dec(
>17bb	05 48 45 58 24 28			.byte	$05,$48,$45,$58,$24,$28                 	; $e8 hex$(
>17c1	04 52 4e 44 28				.byte	$04,$52,$4e,$44,$28                     	; $e9 rnd(
>17c6	05 52 41 4e 44 28			.byte	$05,$52,$41,$4e,$44,$28                 	; $ea rand(
>17cc	01 28					.byte	$01,$28                                 	; $eb (
>17ce	01 24					.byte	$01,$24                                 	; $ec $
>17d0	00					.byte	$00                                     	; $ed [[decimal]]
>17d1	00					.byte	$00                                     	; $ee [[string]]
>17d2	01 3d					.byte	$01,$3d                                 	; $ef =
>17d4	02 3c 3e				.byte	$02,$3c,$3e                             	; $f0 <>
>17d7	02 3c 3d				.byte	$02,$3c,$3d                             	; $f1 <=
>17da	01 3c					.byte	$01,$3c                                 	; $f2 <
>17dc	02 3e 3d				.byte	$02,$3e,$3d                             	; $f3 >=
>17df	01 3e					.byte	$01,$3e                                 	; $f4 >
>17e1	03 58 4f 52				.byte	$03,$58,$4f,$52                         	; $f5 xor
>17e5	02 4f 52				.byte	$02,$4f,$52                             	; $f6 or
>17e8	03 41 4e 44				.byte	$03,$41,$4e,$44                         	; $f7 and
>17ec	03 44 49 56				.byte	$03,$44,$49,$56                         	; $f8 div
>17f0	03 4d 4f 44				.byte	$03,$4d,$4f,$44                         	; $f9 mod
>17f4	02 3c 3c				.byte	$02,$3c,$3c                             	; $fa <<
>17f7	02 3e 3e				.byte	$02,$3e,$3e                             	; $fb >>
>17fa	01 2f					.byte	$01,$2f                                 	; $fc /
>17fc	01 2a					.byte	$01,$2a                                 	; $fd *
>17fe	01 2d					.byte	$01,$2d                                 	; $fe -
>1800	01 2b					.byte	$01,$2b                                 	; $ff +
>1802	ff					.byte	$FF

;******  Return to file: include.files


;******  Processing file: src/generated/vector_table.asm

.1803					VectorTable:
>1803	8b 23					.word	NotImplemented           ; $80 REPEAT
>1805	8b 23					.word	NotImplemented           ; $81 UNTIL
>1807	8b 23					.word	NotImplemented           ; $82 WHILE
>1809	8b 23					.word	NotImplemented           ; $83 WEND
>180b	8b 23					.word	NotImplemented           ; $84 IF
>180d	8b 23					.word	NotImplemented           ; $85 ENDIF
>180f	8b 23					.word	NotImplemented           ; $86 DO
>1811	8b 23					.word	NotImplemented           ; $87 LOOP
>1813	8b 23					.word	NotImplemented           ; $88 PROC
>1815	8b 23					.word	NotImplemented           ; $89 ENDPROC
>1817	8b 23					.word	NotImplemented           ; $8a FOR
>1819	8b 23					.word	NotImplemented           ; $8b NEXT
>181b	b1 10					.word	RUNEndOfLine             ; $8c [[END]]
>181d	e9 10					.word	Command_Shift_Handler    ; $8d [[SHIFT]]
>181f	8b 23					.word	NotImplemented           ; $8e ELSE
>1821	27 10					.word	NoExec01                 ; $8f THEN
>1823	27 10					.word	NoExec02                 ; $90 TO
>1825	27 10					.word	NoExec03                 ; $91 STEP
>1827	8b 23					.word	NotImplemented           ; $92 LET
>1829	2a 10					.word	Command_Print            ; $93 PRINT
>182b	8b 23					.word	NotImplemented           ; $94 INPUT
>182d	8b 23					.word	NotImplemented           ; $95 CALL
>182f	8b 23					.word	NotImplemented           ; $96 SYS
>1831	98 10					.word	Command_REM              ; $97 REM
>1833	8b 23					.word	NotImplemented           ; $98 EXIT
>1835	27 10					.word	NoExec04                 ; $99 ,
>1837	27 10					.word	NoExec05                 ; $9a ;
>1839	27 10					.word	NoExec06                 ; $9b :
>183b	98 10					.word	Command_REM2             ; $9c '
>183d	27 10					.word	NoExec07                 ; $9d )
>183f	8b 23					.word	NotImplemented           ; $9e DIM
>1841	23 10					.word	Command_CLEAR            ; $9f CLEAR
>1843	8f 10					.word	Command_NEW              ; $a0 NEW
>1845	a5 10					.word	Command_RUN              ; $a1 RUN
>1847	ef 10					.word	Command_STOP             ; $a2 STOP
>1849	ec 10					.word	Command_END              ; $a3 END
>184b	15 10					.word	Command_ASSERT           ; $a4 ASSERT
>184d	8b 23					.word	NotImplemented           ; $a5 LIST
>184f	8b 23					.word	NotImplemented           ; $a6 SAVE
>1851	8b 23					.word	NotImplemented           ; $a7 LOAD
>1853	8b 23					.word	NotImplemented           ; $a8
>1855	8b 23					.word	NotImplemented           ; $a9
>1857	8b 23					.word	NotImplemented           ; $aa
>1859	8b 23					.word	NotImplemented           ; $ab
>185b	8b 23					.word	NotImplemented           ; $ac
>185d	8b 23					.word	NotImplemented           ; $ad
>185f	8b 23					.word	NotImplemented           ; $ae
>1861	8b 23					.word	NotImplemented           ; $af
>1863	8b 23					.word	NotImplemented           ; $b0
>1865	8b 23					.word	NotImplemented           ; $b1
>1867	8b 23					.word	NotImplemented           ; $b2
>1869	8b 23					.word	NotImplemented           ; $b3
>186b	8b 23					.word	NotImplemented           ; $b4
>186d	8b 23					.word	NotImplemented           ; $b5
>186f	8b 23					.word	NotImplemented           ; $b6
>1871	8b 23					.word	NotImplemented           ; $b7
>1873	8b 23					.word	NotImplemented           ; $b8
>1875	8b 23					.word	NotImplemented           ; $b9
>1877	8b 23					.word	NotImplemented           ; $ba
>1879	8b 23					.word	NotImplemented           ; $bb
>187b	8b 23					.word	NotImplemented           ; $bc
>187d	8b 23					.word	NotImplemented           ; $bd
>187f	8b 23					.word	NotImplemented           ; $be
>1881	8b 23					.word	NotImplemented           ; $bf
>1883	8b 23					.word	NotImplemented           ; $c0
>1885	8b 23					.word	NotImplemented           ; $c1
>1887	8b 23					.word	NotImplemented           ; $c2
>1889	8b 23					.word	NotImplemented           ; $c3
>188b	8b 23					.word	NotImplemented           ; $c4
>188d	8b 23					.word	NotImplemented           ; $c5
>188f	8b 23					.word	NotImplemented           ; $c6
>1891	8b 23					.word	NotImplemented           ; $c7
>1893	8b 23					.word	NotImplemented           ; $c8
>1895	8b 23					.word	NotImplemented           ; $c9
>1897	8b 23					.word	NotImplemented           ; $ca
>1899	8b 23					.word	NotImplemented           ; $cb
>189b	8b 23					.word	NotImplemented           ; $cc
>189d	8b 23					.word	NotImplemented           ; $cd
>189f	8b 23					.word	NotImplemented           ; $ce
>18a1	8b 23					.word	NotImplemented           ; $cf
>18a3	8b 23					.word	NotImplemented           ; $d0
>18a5	8b 23					.word	NotImplemented           ; $d1
>18a7	8b 23					.word	NotImplemented           ; $d2
>18a9	8b 23					.word	NotImplemented           ; $d3
>18ab	8b 23					.word	NotImplemented           ; $d4
>18ad	8b 23					.word	NotImplemented           ; $d5
>18af	8b 23					.word	NotImplemented           ; $d6
>18b1	8b 23					.word	NotImplemented           ; $d7 RIGHT$(
>18b3	8b 23					.word	NotImplemented           ; $d8 LEFT$(
>18b5	8b 23					.word	NotImplemented           ; $d9 MID$(
>18b7	08 16					.word	EXPUnaryStr              ; $da STR$(
>18b9	4a 16					.word	EXPUnaryVal              ; $db VAL(
>18bb	d5 15					.word	EXPUnarySgn              ; $dc SGN(
>18bd	c0 14					.word	EXPUnaryAbs              ; $dd ABS(
>18bf	5a 15					.word	EXPUnaryLen              ; $de LEN(
>18c1	eb 15					.word	EXPUnarySqr              ; $df SQR(
>18c3	e0 14					.word	EXPUnaryChr              ; $e0 CHR$(
>18c5	ca 14					.word	EXPUnaryAsc              ; $e1 ASC(
>18c7	8b 23					.word	NotImplemented           ; $e2 INKEY$(
>18c9	8b 23					.word	NotImplemented           ; $e3 EVENT(
>18cb	8b 23					.word	NotImplemented           ; $e4 TIME
>18cd	50 15					.word	EXPUnaryInt              ; $e5 INT(
>18cf	46 15					.word	EXPUnaryFrac             ; $e6 FRAC(
>18d1	f1 14					.word	EXPUnaryDec              ; $e7 DEC(
>18d3	fa 15					.word	EXPUnaryHex              ; $e8 HEX$(
>18d5	6f 15					.word	EXPUnaryRnd              ; $e9 RND(
>18d7	7f 15					.word	ExpUnaryRand             ; $ea RAND(
>18d9	68 15					.word	EXPUnaryParenthesis      ; $eb (
>18db	42 15					.word	EXPUnaryNull             ; $ec $
>18dd	3f 15					.word	EXPUnaryInlineDec        ; $ed [[DECIMAL]]
>18df	2f 16					.word	EXPUnaryInlineString     ; $ee [[STRING]]
>18e1	f0 12					.word	EXPCompareEqual          ; $ef =
>18e3	0b 13					.word	EXPCompareNotEqual       ; $f0 <>
>18e5	14 13					.word	EXPCompareLessEqual      ; $f1 <=
>18e7	f9 12					.word	EXPCompareLess           ; $f2 <
>18e9	1d 13					.word	EXPCompareGreaterEqual   ; $f3 >=
>18eb	02 13					.word	EXPCompareGreater        ; $f4 >
>18ed	9d 12					.word	EXPBinXor                ; $f5 XOR
>18ef	91 12					.word	EXPBinOr                 ; $f6 OR
>18f1	85 12					.word	EXPBinAnd                ; $f7 AND
>18f3	5d 12					.word	EXPBinIDiv               ; $f8 DIV
>18f5	6e 12					.word	EXPBinIMod               ; $f9 MOD
>18f7	68 13					.word	EXPBinLeft               ; $fa <<
>18f9	70 13					.word	EXPBinRight              ; $fb >>
>18fb	51 12					.word	EXPBinFDiv               ; $fc /
>18fd	48 12					.word	EXPBinMul                ; $fd *
>18ff	3f 12					.word	EXPBinSub                ; $fe -
>1901	36 12					.word	EXPBinAdd                ; $ff +

;******  Return to file: include.files


;******  Processing file: src/program/editing/delete.asm

.1903					PGMDeleteLine:
.1903	20 bb 19	jsr $19bb			jsr 	PGMEndProgram 				; end of program into zTemp0
.1906	64 20		stz $20				stz 	zTemp1						; copy base address of code to zTemp1
.1908	ad 40 03	lda $0340			lda 	PGMBaseHigh
.190b	85 21		sta $21				sta 	zTemp1+1
.190d					_PGMDLoop:
.190d	b2 20		lda ($20)			lda 	(zTemp1) 					; finished, not found ?
.190f	38		sec				sec
.1910	f0 3a		beq $194c			beq 	_PGMDExit
.1912	a0 01		ldy #$01			ldy 	#1 							; found line number ?
.1914	b1 20		lda ($20),y			lda 	(zTemp1),y
.1916	cd 38 02	cmp $0238			cmp 	TOKLineNumber
.1919	d0 08		bne $1923			bne 	_PGMDNext
.191b	c8		iny				iny
.191c	b1 20		lda ($20),y			lda 	(zTemp1),y
.191e	cd 39 02	cmp $0239			cmp 	TOKLineNumber+1
.1921	f0 0d		beq $1930			beq 	_PGMDDelete
.1923					_PGMDNext:
.1923	18		clc				clc
.1924	b2 20		lda ($20)			lda 	(zTemp1)
.1926	65 20		adc $20				adc 	zTemp1
.1928	85 20		sta $20				sta 	zTemp1
.192a	90 e1		bcc $190d			bcc 	_PGMDLoop
.192c	e6 21		inc $21				inc 	zTemp1+1
.192e	80 dd		bra $190d			bra 	_PGMDLoop
.1930					_PGMDDelete:
.1930	b2 20		lda ($20)			lda 	(zTemp1) 					; offset to next in Y
.1932	a8		tay				tay
.1933					_PGMDCopy:
.1933	b1 20		lda ($20),y			lda 	(zTemp1),y 					; copy down.
.1935	92 20		sta ($20)			sta 	(zTemp1)
.1937	a5 20		lda $20				lda 	zTemp1 						; reached the end ?
.1939	c5 1e		cmp $1e				cmp 	zTemp0
.193b	d0 07		bne $1944			bne 	_PGMDNext2
.193d	a5 21		lda $21				lda 	zTemp1+1
.193f	c5 1f		cmp $1f				cmp 	zTemp0+1
.1941	18		clc				clc
.1942	f0 08		beq $194c			beq 	_PGMDExit
.1944					_PGMDNext2:
.1944	e6 20		inc $20				inc 	zTemp1 						; advance pointer.
.1946	d0 eb		bne $1933			bne 	_PGMDCopy
.1948	e6 21		inc $21				inc 	zTemp1+1
.194a	80 e7		bra $1933			bra 	_PGMDCopy
.194c					_PGMDExit:
.194c	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/editing/insert.asm

.194d					PGMInsertLine:
.194d	20 bb 19	jsr $19bb			jsr 	PGMEndProgram 				; end of program into zTemp0
.1950	64 20		stz $20				stz 	zTemp1						; copy base address of code to zTemp1
.1952	ad 40 03	lda $0340			lda 	PGMBaseHigh
.1955	85 21		sta $21				sta 	zTemp1+1
.1957	18		clc				clc
.1958	72 20		adc ($20)			adc 	(zTemp1)
.195a	85 21		sta $21				sta 	zTemp1+1
.195c					_PGMILoop:
.195c	b2 20		lda ($20)			lda 	(zTemp1) 					; reached the end, it goes here on the end.
.195e	f0 1c		beq $197c			beq 	_PGMIInsert
.1960	a0 01		ldy #$01			ldy 	#1 							; compare in-program line vs token line.
.1962	b1 20		lda ($20),y			lda 	(zTemp1),y
.1964	cd 38 02	cmp $0238			cmp 	TOKLineNumber
.1967	c8		iny				iny
.1968	b1 20		lda ($20),y			lda 	(zTemp1),y
.196a	ed 39 02	sbc $0239			sbc 	TOKLineNumber+1
.196d	b0 0d		bcs $197c			bcs 	_PGMIInsert 				; insert here.
.196f	18		clc				clc
.1970	b2 20		lda ($20)			lda 	(zTemp1)
.1972	65 20		adc $20				adc 	zTemp1
.1974	85 20		sta $20				sta 	zTemp1
.1976	90 e4		bcc $195c			bcc 	_PGMILoop
.1978	e6 21		inc $21				inc 	zTemp1+1
.197a	80 e0		bra $195c			bra 	_PGMILoop
.197c					_PGMIInsert:
.197c	ac 37 02	ldy $0237			ldy 	TOKLineSize 				; space required
.197f					_PGMIInsertLoop:
.197f	b2 1e		lda ($1e)			lda 	(zTemp0)
.1981	91 1e		sta ($1e),y			sta 	(zTemp0),y
.1983	a5 20		lda $20				lda 	zTemp1 						; reached insert point
.1985	c5 1e		cmp $1e				cmp 	zTemp0
.1987	d0 06		bne $198f			bne 	_PGMINext
.1989	a5 21		lda $21				lda 	zTemp1+1
.198b	c5 1f		cmp $1f				cmp 	zTemp0+1
.198d	f0 0a		beq $1999			beq 	_PGMIInserted
.198f					_PGMINext:
.198f	a5 1e		lda $1e				lda 	zTemp0
.1991	d0 02		bne $1995			bne 	_PGMINoBorrow
.1993	c6 1f		dec $1f				dec 	zTemp0+1
.1995					_PGMINoBorrow:
.1995	c6 1e		dec $1e				dec 	zTemp0
.1997	80 e6		bra $197f			bra 	_PGMIInsertLoop
.1999					_PGMIInserted:
.1999	a0 00		ldy #$00			ldy 	#0 							; copy tokenbuffer to insert point
.199b					_PGMICopyLoop:
.199b	b9 37 02	lda $0237,y			lda 	TOKLineSize,y
.199e	91 20		sta ($20),y			sta 	(zTemp1),y
.19a0	c8		iny				iny
.19a1	cc 37 02	cpy $0237			cpy 	TOKLineSize
.19a4	d0 f5		bne $199b			bne 	_PGMICopyLoop
.19a6	18		clc				clc
.19a7	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/setup.asm

.19a8					PGMSetBaseAddress:
.19a8	8e 40 03	stx $0340			stx 	PGMBaseHigh
.19ab	8c 41 03	sty $0341			sty 	PGMEndMemoryHigh
.19ae	60		rts				rts
.19af					PGMNewProgram:
.19af	64 1e		stz $1e				stz 	zTemp0						; copy base address to zTemp0
.19b1	ad 40 03	lda $0340			lda 	PGMBaseHigh
.19b4	85 1f		sta $1f				sta 	zTemp0+1
.19b6	a9 00		lda #$00			lda 	#0 							; overwrite the offset
.19b8	92 1e		sta ($1e)			sta 	(zTemp0)
.19ba	60		rts				rts
.19bb					PGMEndProgram:
.19bb	64 1e		stz $1e				stz 	zTemp0 						; copy base address to zTemp0
.19bd	ad 40 03	lda $0340			lda 	PGMBaseHigh
.19c0	85 1f		sta $1f				sta 	zTemp0+1
.19c2					_PGMEPLoop:
.19c2	b2 1e		lda ($1e)			lda 	(zTemp0)
.19c4	f0 0b		beq $19d1			beq 	_PGMEPExit
.19c6	18		clc				clc
.19c7	65 1e		adc $1e				adc 	zTemp0
.19c9	85 1e		sta $1e				sta 	zTemp0
.19cb	90 f5		bcc $19c2			bcc 	_PGMEPLoop
.19cd	e6 1f		inc $1f				inc 	zTemp0+1
.19cf	80 f1		bra $19c2			bra 	_PGMEPLoop
.19d1					_PGMEPExit:
.19d1	60		rts				rts
.0340					PGMBaseHigh:
>0340							.fill 	1
.0341					PGMEndMemoryHigh:
>0341							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokbuffer.asm

.19d2					TOKResetElement:
.19d2	9c 42 03	stz $0342			stz 	TOKElement
.19d5	60		rts				rts
.19d6					TOKWriteElement:
.19d6	da		phx				phx
.19d7	ae 42 03	ldx $0342			ldx 	TOKElement
.19da	9d 43 03	sta $0343,x			sta 	TOKElementText,x
.19dd	fa		plx				plx
.19de	ee 42 03	inc $0342			inc 	TOKElement
.19e1	60		rts				rts
.0342					TOKElement:
>0342							.fill 	1
.0343					TOKElementText:
>0343							.fill 	255

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokconstant.asm

.19e2					TOKTokeniseConstant:
.19e2	a5 0c		lda $0c				lda 	IFR0+IM0 					; check > 64
.19e4	48		pha				pha 								; save on stack
.19e5	29 c0		and #$c0			and 	#$C0
.19e7	05 0d		ora $0d				ora 	IFR0+IM1
.19e9	05 0e		ora $0e				ora 	IFR0+IM2
.19eb	f0 10		beq $19fd			beq 	_TTCLess
.19ed	da		phx				phx
.19ee	a2 06		ldx #$06			ldx 	#6 							; divide by 64
.19f0					_TTCShiftRight:
.19f0	46 0e		lsr $0e				lsr 	IFR0+IM2
.19f2	66 0d		ror $0d				ror 	IFR0+IM1
.19f4	66 0c		ror $0c				ror 	IFR0+IM0
.19f6	ca		dex				dex
.19f7	d0 f7		bne $19f0			bne 	_TTCShiftRight
.19f9	fa		plx				plx
.19fa	20 e2 19	jsr $19e2			jsr 	TOKTokeniseConstant
.19fd					_TTCLess:
.19fd	68		pla				pla
.19fe	29 3f		and #$3f			and 	#$3F 						; lower 6 bits
.1a00	20 9b 1a	jsr $1a9b			jsr 	TOKWriteA
.1a03	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokdecimal.asm

.1a04					TOKTokeniseDecimals:
.1a04	20 ab 1a	jsr $1aab			jsr 	TOKGetNext 					; consume the .
.1a07	20 7e 1b	jsr $1b7e			jsr 	TOKExtractInteger 			; pull an integer out as text.
.1a0a	a9 ed		lda #$ed			lda 	#PR_LSQLSQDECIMALRSQRSQ	 	; decimal token
.1a0c	20 9b 1a	jsr $1a9b			jsr 	TOKWriteA
.1a0f	20 14 1a	jsr $1a14			jsr 	TOKOutputElementBuffer 		; then the buffer
.1a12	18		clc				clc
.1a13	60		rts				rts
.1a14					TOKOutputElementBuffer:
.1a14	ad 42 03	lda $0342			lda 	TOKElement 					; get count and write that
.1a17	20 9b 1a	jsr $1a9b			jsr 	TOKWriteA
.1a1a	a8		tay				tay 								; put in Y
.1a1b	f0 0c		beq $1a29			beq 	_TOEExit 					; exit if empty which is okay.
.1a1d	a2 01		ldx #$01			ldx 	#1
.1a1f					_TOELoop:
.1a1f	bd 42 03	lda $0342,x			lda 	TOKElement,x
.1a22	20 9b 1a	jsr $1a9b			jsr 	TOKWriteA
.1a25	e8		inx				inx
.1a26	88		dey				dey
.1a27	d0 f6		bne $1a1f			bne 	_TOELoop
.1a29					_TOEExit:
.1a29	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokenise.asm

.1a2a					TOKTokenise:
.1a2a	8c 43 04	sty $0443			sty 	TOKDataSource+1 			; save source routine pointer
.1a2d	8e 42 04	stx $0442			stx 	TOKDataSource
.1a30	a9 00		lda #$00			lda 	#0 							; now A = carry = require line #
.1a32	2a		rol a				rol  	a
.1a33	8d 3a 03	sta $033a			sta 	TOKRequireLineNumber 		; store in require line number flag.
.1a36	a9 03		lda #$03			lda 	#3 							; set the line length to three for the
.1a38	8d 37 02	sta $0237			sta 	TOKLineSize 				; line length itself and the line numbers.
.1a3b					_TOKMainLoop:
.1a3b	20 a7 1a	jsr $1aa7			jsr 	TOKGet 						; what follows.
.1a3e	c9 00		cmp #$00			cmp 	#0 							; if zero, we are complete
.1a40	f0 4e		beq $1a90			beq 	_TOKExit
.1a42	c9 20		cmp #$20			cmp 	#' '						; space, consume and loop back.
.1a44	d0 05		bne $1a4b			bne 	_TOKElement
.1a46	20 ab 1a	jsr $1aab			jsr 	TOKGetNext
.1a49	80 f0		bra $1a3b			bra 	_TOKMainLoop
.1a4b					_TOKElement:
.1a4b	20 fc 1b	jsr $1bfc			jsr 	TOKIsDigit 					; is it 0..9
.1a4e	90 0a		bcc $1a5a			bcc 	_TOKNotDigit
.1a50	20 55 1b	jsr $1b55			jsr 	TOKTokeniseInteger 			; get integer
.1a53	b0 43		bcs $1a98			bcs 	_TOKFail 					; did it fail ?
.1a55	9c 3a 03	stz $033a			stz 	TOKRequireLineNumber 		; reset RLN flag.
.1a58	80 e1		bra $1a3b			bra 	_TOKMainLoop
.1a5a					_TOKNotDigit:
.1a5a	ae 3a 03	ldx $033a			ldx 	TOKRequireLineNumber 		; was a line # required
.1a5d	d0 39		bne $1a98			bne 	_TOKFail 					; if so, we've a problem.
.1a5f	c9 24		cmp #$24			cmp 	#"$"						; check for hexadecimal ?
.1a61	d0 07		bne $1a6a			bne 	_TOKNotHex
.1a63	20 1b 1b	jsr $1b1b			jsr 	TOKTokeniseHexadecimal
.1a66	b0 30		bcs $1a98			bcs 	_TOKFail
.1a68	80 d1		bra $1a3b			bra 	_TOKMainLoop
.1a6a					_TOKNotHex:
.1a6a	c9 2e		cmp #$2e			cmp 	#"."						; is it decimal e.g. .012345 etc.
.1a6c	d0 07		bne $1a75			bne 	_TOKNotDecimal
.1a6e	20 04 1a	jsr $1a04			jsr 	TOKTokeniseDecimals
.1a71	b0 25		bcs $1a98			bcs 	_TOKFail
.1a73	80 c6		bra $1a3b			bra 	_TOKMainLoop
.1a75					_TOKNotDecimal:
.1a75	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.1a77	d0 07		bne $1a80			bne 	_TOKNotString
.1a79	20 c3 1b	jsr $1bc3			jsr 	TOKTokeniseString
.1a7c	b0 1a		bcs $1a98			bcs 	_TOKFail
.1a7e	80 bb		bra $1a3b			bra 	_TOKMainLoop
.1a80					_TOKNotString:
.1a80	20 11 1c	jsr $1c11			jsr 	TOKIsAlpha 					; identifier ?
.1a83	b0 07		bcs $1a8c			bcs 	_TOKIdentifier
.1a85	20 92 1b	jsr $1b92			jsr 	TOKTokenisePunctuation 		; punctuation
.1a88	b0 0e		bcs $1a98			bcs 	_TOKFail
.1a8a	80 af		bra $1a3b			bra 	_TOKMainLoop
.1a8c					_TOKIdentifier:
.1a8c	b0 0a		bcs $1a98			bcs 	_TOKFail
.1a8e	80 ab		bra $1a3b			bra 	_TOKMainLoop
.1a90					_TOKExit:
.1a90	a9 8c		lda #$8c			lda 	#PR_LSQLSQENDRSQRSQ 		; write EOL
.1a92	20 9b 1a	jsr $1a9b			jsr 	TOKWriteA
>1a95	db						.byte 	$DB
.1a96	18		clc				clc									; return with carry set.
.1a97	60		rts				rts
.1a98					_TOKFail:
>1a98	db						.byte 	$DB
.1a99	38		sec				sec
.1a9a	60		rts				rts
.1a9b					TOKWriteA:
.1a9b	da		phx				phx
.1a9c	ae 37 02	ldx $0237			ldx 	TOKLineSize
.1a9f	9d 37 02	sta $0237,x			sta 	TOKLineSize,x
.1aa2	fa		plx				plx
.1aa3	ee 37 02	inc $0237			inc 	TOKLineSize
.1aa6	60		rts				rts
.1aa7					TOKGet:
.1aa7	18		clc				clc
.1aa8	6c 42 04	jmp ($0442)			jmp 	(TOKDataSource)
.1aab					TOKGetNext:
.1aab	38		sec				sec
.1aac	6c 42 04	jmp ($0442)			jmp 	(TOKDataSource)
.1aaf	da		phx		TokTest:phx
.1ab0	ae d5 1a	ldx $1ad5			ldx 	TokPos
.1ab3	bd bd 1a	lda $1abd,x			lda 	TokLine,x
.1ab6	90 03		bcc $1abb			bcc 	_TTExit
.1ab8	ee d5 1a	inc $1ad5			inc 	TokPos
.1abb	fa		plx		_TTExit:plx
.1abc	60		rts				rts
>1abd	36 38 2e 31 34 34 20 24		TokLine:.text 	'68.144 $45 "Hello" < <>',0
>1ac5	34 35 20 22 48 65 6c 6c 6f 22 20 3c 20 3c 3e 00
>1ad5	00				TokPos:	.byte 	0
.0442					TOKDataSource:
>0442							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokfind.asm

.1ad6					TOKFindToken:
.1ad6	a2 79		ldx #$79			ldx 	#StandardTokens & $FF 		; do this table
.1ad8	a0 16		ldy #$16			ldy 	#StandardTokens >> 8
.1ada	20 e5 1a	jsr $1ae5			jsr 	TOKFindTokenXY 				; find it, or not
.1add	90 04		bcc $1ae3			bcc 	_TOKFTFail
.1adf	a2 00		ldx #$00			ldx 	#0
.1ae1	38		sec				sec
.1ae2	60		rts				rts
.1ae3					_TOKFTFail
.1ae3	18		clc				clc
.1ae4	60		rts				rts
.1ae5					TOKFindTokenXY:
.1ae5	86 1e		stx $1e				stx 	zTemp0 						; save token table address
.1ae7	84 1f		sty $1f				sty 	zTemp0+1
.1ae9	a9 80		lda #$80			lda 	#$80 						; table starts at $80
.1aeb	8d 44 04	sta $0444			sta 	TOKCurrent
.1aee					_TOKFindLoop:
.1aee	b2 1e		lda ($1e)			lda 	(zTemp0) 					; get token length from table
.1af0	18		clc				clc 		 						; clear carry in case of fail
.1af1	30 17		bmi $1b0a			bmi 	_TOKExit 					; end of table, fail, so return CC.
.1af3	cd 42 03	cmp $0342			cmp 	TOKElement 					; compare against the element length
.1af6	d0 13		bne $1b0b			bne 	_TOKNext 					; different, try next.
.1af8	aa		tax				tax 								; number of chars to compare.
.1af9	a0 01		ldy #$01			ldy 	#1 							; offset to actual text.
.1afb					_TOKCompare:
.1afb	b1 1e		lda ($1e),y			lda 	(zTemp0),y 					; compare the characters
.1afd	d9 42 03	cmp $0342,y			cmp 	TOKElementText-1,y
.1b00	d0 09		bne $1b0b			bne 	_TOKNext 					; different ? try next
.1b02	c8		iny				iny 								; compare next two
.1b03	ca		dex				dex
.1b04	d0 f5		bne $1afb			bne 	_TOKCompare 				; until done X characters.
.1b06	38		sec				sec
.1b07	ad 44 04	lda $0444			lda 	TOKCurrent 					; return current ID.
.1b0a					_TOKExit:
.1b0a	60		rts				rts
.1b0b					_TOKNext:
.1b0b	ee 44 04	inc $0444			inc 	TOKCurrent 					; increment token #
.1b0e	38		sec				sec 								; add length+1 to ptr
.1b0f	b2 1e		lda ($1e)			lda 	(zTemp0)
.1b11	65 1e		adc $1e				adc 	zTemp0
.1b13	85 1e		sta $1e				sta 	zTemp0
.1b15	90 d7		bcc $1aee			bcc 	_TOKFindLoop
.1b17	e6 1f		inc $1f				inc 	zTemp0+1
.1b19	80 d3		bra $1aee			bra 	_TOKFindLoop
.0444					TOKCurrent:
>0444							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokhexadecimal.asm

.1b1b					TOKTokeniseHexadecimal:
.1b1b	20 ab 1a	jsr $1aab			jsr 	TOKGetNext 					; consume the $
.1b1e	a2 0c		ldx #$0c			ldx 	#IFR0
.1b20	20 ad 22	jsr $22ad			jsr 	IFloatSetZero 				; set R0 = 0
.1b23					_TTHLoop:
.1b23	20 a7 1a	jsr $1aa7			jsr 	TOKGet 						; keep getting and copying while numeric.
.1b26	20 1e 1c	jsr $1c1e			jsr 	TOKIsHexadecimal
.1b29	90 20		bcc $1b4b			bcc 	_TTHDone
.1b2b	a2 0c		ldx #$0c			ldx 	#IFR0 						; shift R0 right 4
.1b2d	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.1b30	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.1b33	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.1b36	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.1b39	20 ab 1a	jsr $1aab			jsr 	TOKGetNext
.1b3c	38		sec				sec 								; convert to decimal.
.1b3d	e9 30		sbc #$30			sbc 	#48
.1b3f	c9 0a		cmp #$0a			cmp 	#10
.1b41	90 02		bcc $1b45			bcc 	_TTHNotAlpha
.1b43	e9 07		sbc #$07			sbc 	#7
.1b45					_TTHNotAlpha:
.1b45	05 0c		ora $0c				ora 	IFR0+IM0 					; OR in
.1b47	85 0c		sta $0c				sta 	IFR0+IM0
.1b49	80 d8		bra $1b23			bra 	_TTHLoop
.1b4b					_TTHDone:
.1b4b	a9 ec		lda #$ec			lda 	#PR_DOLLAR 					; write $ function out
.1b4d	20 9b 1a	jsr $1a9b			jsr 	TOKWriteA
.1b50	20 e2 19	jsr $19e2			jsr 	TOKTokeniseConstant 		; write integer out.
.1b53	18		clc				clc
.1b54	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokinteger.asm

.1b55					TOKTokeniseInteger:
.1b55	20 7e 1b	jsr $1b7e			jsr 	TOKExtractInteger 			; pull an integer out as text.
.1b58	a2 43		ldx #$43			ldx 	#TOKElementText & $FF
.1b5a	a0 03		ldy #$03			ldy 	#TOKElementText >> 8
.1b5c	ad 42 03	lda $0342			lda		TOKElement
.1b5f	20 11 21	jsr $2111			jsr 	IFloatStringToFloatR0 		; convert to R0 integer
.1b62	ad 3a 03	lda $033a			lda 	TOKRequireLineNumber 		; do we require a line number.
.1b65	f0 12		beq $1b79			beq 	_TOKNotLineNumber
.1b67	a5 0e		lda $0e				lda 	IFR0+IM2 					; check it's a 2 digit number
.1b69	d0 0c		bne $1b77			bne 	_TOKBadLineNumeber
.1b6b	a5 0c		lda $0c				lda 	IFR0+IM0 					; copy it to the line number section.
.1b6d	8d 38 02	sta $0238			sta 	TOKLineNumber
.1b70	a5 0d		lda $0d				lda 	IFR0+IM1
.1b72	8d 39 02	sta $0239			sta 	TOKLineNumber+1
.1b75	18		clc				clc
.1b76	60		rts				rts
.1b77					_TOKBadLineNumeber:
.1b77	38		sec				sec
.1b78	60		rts				rts
.1b79					_TOKNotLineNumber:
.1b79	20 e2 19	jsr $19e2			jsr 	TOKTokeniseConstant 		; tokenise the constant in R0
.1b7c	18		clc				clc
.1b7d	60		rts				rts
.1b7e					TOKExtractInteger:
.1b7e	20 d2 19	jsr $19d2			jsr 	TOKResetElement 			; restart
.1b81					_TTILoop:
.1b81	20 a7 1a	jsr $1aa7			jsr 	TOKGet 						; keep getting and copying while numeric.
.1b84	20 fc 1b	jsr $1bfc			jsr 	TOKIsDigit
.1b87	90 08		bcc $1b91			bcc 	_TOKEIExit
.1b89	20 d6 19	jsr $19d6			jsr 	TOKWriteElement
.1b8c	20 ab 1a	jsr $1aab			jsr 	TOKGetNext
.1b8f	80 f0		bra $1b81			bra 	_TTILoop
.1b91					_TOKEIExit:
.1b91	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokpunctuation.asm

.1b92					TOKTokenisePunctuation:
.1b92	20 d2 19	jsr $19d2			jsr 	TOKResetElement 			; copy first punctuation character into element.
.1b95	20 ab 1a	jsr $1aab			jsr 	TOKGetNext
.1b98	20 d6 19	jsr $19d6			jsr 	TOKWriteElement
.1b9b	20 a7 1a	jsr $1aa7			jsr 	TOKGet 						; what follows ?
.1b9e	c9 20		cmp #$20			cmp 	#' '						; space, not 2 character
.1ba0	f0 10		beq $1bb2			beq 	_TTPOne
.1ba2	20 08 1c	jsr $1c08			jsr 	TOKIsAlphaNumeric 			; if alphanumeric don't bother doing 2 character
.1ba5	b0 0b		bcs $1bb2			bcs 	_TTPOne 					; these speed things up a bit.
.1ba7	20 d6 19	jsr $19d6			jsr 	TOKWriteElement 			; this is what we will search for.
.1baa	20 d6 1a	jsr $1ad6			jsr 	TOKFindToken
.1bad	b0 0a		bcs $1bb9			bcs 	_TTPConsumeExit 			; it was found, consume, generate, exit.
.1baf	ce 42 03	dec $0342			dec 	TOKElement 					; make it a single character
.1bb2					_TTPOne:
.1bb2	20 d6 1a	jsr $1ad6			jsr 	TOKFindToken 				; look for one character punctuation
.1bb5	b0 07		bcs $1bbe			bcs 	_TTPOutputExit 				; we found it
.1bb7	38		sec				sec 								; not recognised.
.1bb8	60		rts				rts
.1bb9					_TTPConsumeExit:
.1bb9	48		pha				pha
.1bba	20 ab 1a	jsr $1aab			jsr 	TOKGetNext 					; get the 2nd char out.
.1bbd	68		pla				pla
.1bbe					_TTPOutputExit:
.1bbe	20 9b 1a	jsr $1a9b			jsr  	TOKWriteA 					; write token out
.1bc1	18		clc				clc
.1bc2	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokstring.asm

.1bc3					TOKTokeniseString:
.1bc3	20 ab 1a	jsr $1aab			jsr 	TOKGetNext 					; consume the "
.1bc6	20 d2 19	jsr $19d2			jsr 	TOKResetElement 			; start getting the string
.1bc9					_TOKTSLoop:
.1bc9	20 a7 1a	jsr $1aa7			jsr 	TOKGet 						; check EOL
.1bcc	c9 00		cmp #$00			cmp 	#0
.1bce	f0 0c		beq $1bdc			beq 	_TOKTSExit
.1bd0	20 ab 1a	jsr $1aab			jsr 	TOKGetNext 					; get and consume
.1bd3	c9 22		cmp #$22			cmp 	#'"' 						; exit if " consumed
.1bd5	f0 05		beq $1bdc			beq 	_TOKTSExit
.1bd7	20 d6 19	jsr $19d6			jsr 	TOKWriteElement
.1bda	80 ed		bra $1bc9			bra 	_TOKTSLoop
.1bdc					_TOKTSExit:
.1bdc	a9 ee		lda #$ee			lda 	#PR_LSQLSQSTRINGRSQRSQ
.1bde	20 9b 1a	jsr $1a9b			jsr 	TOKWriteA
.1be1	20 14 1a	jsr $1a14			jsr 	TOKOutputElementBuffer
.1be4	18		clc				clc
.1be5	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/toktypes.asm

.1be6					TOKToUpper:
.1be6	c9 61		cmp #$61			cmp 	#"a"
.1be8	90 06		bcc $1bf0			bcc 	_TTUNotLower
.1bea	c9 7b		cmp #$7b			cmp 	#"z"+1
.1bec	b0 02		bcs $1bf0			bcs 	_TTUNotLower
.1bee	49 20		eor #$20			eor 	#$20
.1bf0					_TTUNotLower:
.1bf0	60		rts				rts
.1bf1					TOKToLower:
.1bf1	c9 41		cmp #$41			cmp 	#"A"
.1bf3	90 06		bcc $1bfb			bcc 	_TTUNotUpper
.1bf5	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1bf7	b0 02		bcs $1bfb			bcs 	_TTUNotUpper
.1bf9	49 20		eor #$20			eor 	#$20
.1bfb					_TTUNotUpper:
.1bfb	60		rts				rts
.1bfc					TOKIsDigit:
.1bfc	c9 30		cmp #$30			cmp 	#"0"
.1bfe	90 06		bcc $1c06			bcc 	TOKFail
.1c00	c9 3a		cmp #$3a			cmp 	#"9"+1
.1c02	b0 02		bcs $1c06			bcs 	TOKFail
.1c04					TOKSucceed:
.1c04	38		sec				sec
.1c05	60		rts				rts
.1c06					TOKFail:
.1c06	18		clc				clc
.1c07	60		rts				rts
.1c08					TOKIsAlphaNumeric:
.1c08	20 11 1c	jsr $1c11			jsr 	TOKIsAlpha
.1c0b	b0 f7		bcs $1c04			bcs 	TOKSucceed
.1c0d	20 fc 1b	jsr $1bfc			jsr 	TOKIsDigit
.1c10	60		rts				rts
.1c11					TOKIsAlpha:
.1c11	20 e6 1b	jsr $1be6			jsr 	TOKToUpper
.1c14	c9 41		cmp #$41			cmp 	#"A"
.1c16	90 ee		bcc $1c06			bcc 	TOKFail
.1c18	c9 5b		cmp #$5b			cmp 	#"Z"+1
.1c1a	b0 ea		bcs $1c06			bcs 	TOKFail
.1c1c	80 e6		bra $1c04			bra 	TOKSucceed
.1c1e					TOKIsHexadecimal:
.1c1e	20 fc 1b	jsr $1bfc			jsr		TOKIsDigit
.1c21	b0 e1		bcs $1c04			bcs 	TOKSucceed
.1c23	20 11 1c	jsr $1c11			jsr 	TOKIsAlpha
.1c26	90 de		bcc $1c06			bcc 	TOKFail
.1c28	c9 47		cmp #$47			cmp 	#"F"+1
.1c2a	b0 da		bcs $1c06			bcs 	TOKFail
.1c2c	80 d6		bra $1c04			bra 	TOKSucceed

;******  Return to file: include.files


;******  Processing file: src/support/strings/stringalloc.asm

.1c2e					StringSystemInitialise:
.1c2e	ad 41 03	lda $0341			lda 	PGMEndMemoryHigh 			; last byte of memory
.1c31	3a		dec a				dec 	a
.1c32	8d 47 04	sta $0447			sta 	stringMemory+1
.1c35	85 1f		sta $1f				sta 	zTemp0+1
.1c37	a9 ff		lda #$ff			lda 	#$FF
.1c39	8d 46 04	sta $0446			sta 	stringMemory
.1c3c	85 1e		sta $1e				sta 	zTemp0
.1c3e	a9 00		lda #$00			lda 	#0 							; put a zero at the end, so know end of string memory.
.1c40	92 1e		sta ($1e)			sta 	(zTemp0)
.1c42	60		rts				rts
.1c43					StringSpaceInitialise:
.1c43	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.1c45	8d 45 04	sta $0445			sta 	stringInitialised
.1c48	ad 46 04	lda $0446			lda 	stringMemory 				; allocate 256 bytes for one concreted string
.1c4b	8d 48 04	sta $0448			sta 	stringTempPointer 			; so temporary string space is allocated below that.
.1c4e	ad 47 04	lda $0447			lda 	stringMemory+1
.1c51	3a		dec a				dec 	a
.1c52	8d 49 04	sta $0449			sta 	stringTempPointer+1
.1c55	60		rts				rts
.1c56					StringTempAllocate:
.1c56	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.1c58	b0 2e		bcs $1c88			bcs 	_STALength
.1c5a	2c 45 04	bit $0445			bit 	stringInitialised 			; already initialised
.1c5d	30 05		bmi $1c64			bmi 	_STAAllocate
.1c5f	48		pha				pha 								; save value to subtract.
.1c60	20 43 1c	jsr $1c43			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.1c63	68		pla				pla 								; restore it
.1c64					_STAAllocate:
.1c64	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.1c66	18		clc				clc  								; deliberate allows one more
.1c67	6d 48 04	adc $0448			adc 	stringTempPointer 			; subtract from temp pointer
.1c6a	8d 48 04	sta $0448			sta 	stringTempPointer
.1c6d	85 0c		sta $0c				sta 	IFR0+IM0 					; address in mantissa too
.1c6f	85 22		sta $22				sta 	zsTemp 						; and zsTemp
.1c71	ad 49 04	lda $0449			lda 	stringTempPointer+1
.1c74	69 ff		adc #$ff			adc 	#$FF
.1c76	8d 49 04	sta $0449			sta 	stringTempPointer+1
.1c79	85 23		sta $23				sta 	zsTemp+1
.1c7b	85 0d		sta $0d				sta 	IFR0+IM1
.1c7d	64 0e		stz $0e				stz 	IFR0+IM2 					; set the typing data and the upper address bytes.
.1c7f	a9 80		lda #$80			lda 	#$80
.1c81	85 0f		sta $0f				sta 	IFR0+IExp
.1c83	a9 00		lda #$00			lda 	#0 							; clear the target string
.1c85	92 22		sta ($22)			sta 	(zsTemp)
.1c87	60		rts				rts
.1c88					_STALength:
.1c88	4c 00 12	jmp $1200		jmp	ErrorV_string
.1c8b					StringTempWrite:
.1c8b	5a		phy				phy
.1c8c	48		pha				pha
.1c8d	b2 22		lda ($22)			lda 	(zsTemp)
.1c8f	1a		inc a				inc 	a
.1c90	92 22		sta ($22)			sta 	(zsTemp)
.1c92	a8		tay				tay
.1c93	68		pla				pla
.1c94	91 22		sta ($22),y			sta 	(zsTemp),y
.1c96	7a		ply				ply
.1c97	60		rts				rts
.0022					zsTemp:
>0022							.fill 	2
.0445					stringInitialised:
>0445							.fill 	1
.0446					stringMemory:
>0446							.fill 	2
.0448					stringTempPointer:
>0448							.fill 	2

;******  Return to file: include.files


;******  Return to file: basic.asm


;******  Processing file: build/libmathslib.asmlib

=0					IM0 = 0
=1					IM1 = 1
=2					IM2 = 2
=3					IExp = 3
=$3f					IFXMask = $3F
=$40					IFSign = $40
.1c98					IFInitialise:
.1c98	9c 52 04	stz $0452			stz 	IFStackIndex
.1c9b	60		rts				rts
.1c9c					IFloatSubtract:
.1c9c	da		phx				phx
.1c9d	a2 0c		ldx #$0c			ldx 	#IFR0
.1c9f	20 b8 22	jsr $22b8			jsr 	IFloatNegate 				; negate R0 and fall through to add.
.1ca2	fa		plx				plx
.1ca3					IFloatAdd:
.1ca3	b5 03		lda $03,x			lda 	IExp,x 						; check if both exponents are zero.
.1ca5	05 0f		ora $0f				ora 	IFR0+IExp
.1ca7	29 3f		and #$3f			and 	#IFXMask 					; if not, then we have to do the
.1ca9	d0 4e		bne $1cf9			bne 	_IFloatAddDecimals 			; decimal version.
.1cab					_IFAddSubMantissa:
.1cab	b5 03		lda $03,x			lda 	IExp,x 						; are the signs different ?
.1cad	45 0f		eor $0f				eor 	IFR0+IExp
.1caf	29 40		and #$40			and 	#IFSign
.1cb1	d0 21		bne $1cd4			bne 	_IFloatSubMantissa
.1cb3	18		clc				clc 								; do the actual addition
.1cb4	a5 0c		lda $0c			lda 	IFR0+IM0
.1cb6	75 00		adc $00,x		adc 		IM0,x
.1cb8	85 0c		sta $0c			sta 	IFR0+IM0
.1cba	a5 0d		lda $0d			lda 	IFR0+IM1
.1cbc	75 01		adc $01,x		adc 		IM1,x
.1cbe	85 0d		sta $0d			sta 	IFR0+IM1
.1cc0	a5 0e		lda $0e			lda 	IFR0+IM2
.1cc2	75 02		adc $02,x		adc 		IM2,x
.1cc4	85 0e		sta $0e			sta 	IFR0+IM2
.1cc6	10 29		bpl $1cf1			bpl 	_IFloatAddExit 				; if no carry through to bit 23, then exit.
.1cc8	a2 0c		ldx #$0c			ldx 	#IFR0						; shift R0 right, divide by 2
.1cca	20 dc 22	jsr $22dc			jsr 	IFloatShiftRight
.1ccd	20 06 23	jsr $2306			jsr 	IFloatIncExponent
.1cd0	d0 1f		bne $1cf1			bne 	_IFloatAddExit
.1cd2	38		sec				sec 								; overflowed numerically.
.1cd3	60		rts				rts
.1cd4					_IFloatSubMantissa:
.1cd4	38		sec				sec 								; do the subtraction R0-Rx
.1cd5	a5 0c		lda $0c			lda 	IFR0+IM0
.1cd7	f5 00		sbc $00,x		sbc 		IM0,x
.1cd9	85 0c		sta $0c			sta 	IFR0+IM0
.1cdb	a5 0d		lda $0d			lda 	IFR0+IM1
.1cdd	f5 01		sbc $01,x		sbc 		IM1,x
.1cdf	85 0d		sta $0d			sta 	IFR0+IM1
.1ce1	a5 0e		lda $0e			lda 	IFR0+IM2
.1ce3	f5 02		sbc $02,x		sbc 		IM2,x
.1ce5	85 0e		sta $0e			sta 	IFR0+IM2
.1ce7	b0 08		bcs $1cf1			bcs 	_IFloatAddExit 				; no borrow so we are done.
.1ce9	a2 0c		ldx #$0c			ldx 	#IFR0
.1ceb	20 c0 22	jsr $22c0			jsr 	IFloatMantissaNegate 		; 2's complement negate the mantissa
.1cee	20 b8 22	jsr $22b8			jsr 	IFloatNegate 				; negate
.1cf1					_IFloatAddExit:
.1cf1	18		clc				clc
.1cf2	60		rts				rts
.1cf3					_IFloatZeroAdd:
.1cf3	fa		plx				plx 								; return this value in R0
.1cf4	20 3e 22	jsr $223e			jsr 	IFloatCopyFromRegister
.1cf7	18		clc				clc
.1cf8	60		rts				rts
.1cf9					_IFloatAddDecimals:
.1cf9	20 a6 22	jsr $22a6			jsr		IFloatCheckZero 			; if RX = 0 then exit with R0
.1cfc	f0 f3		beq $1cf1			beq 	_IFloatAddExit
.1cfe	20 e4 22	jsr $22e4			jsr 	IFloatNormalise 			; normalise RX
.1d01	da		phx				phx 								; normalise R0
.1d02	a2 0c		ldx #$0c			ldx 	#IFR0
.1d04	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero
.1d07	f0 ea		beq $1cf3			beq 	_IFloatZeroAdd
.1d09	20 e4 22	jsr $22e4			jsr 	IFloatNormalise
.1d0c	fa		plx				plx
.1d0d	a5 0f		lda $0f				lda 	IFR0+IExp 					; get the exponent of R0
.1d0f	29 3f		and #$3f			and 	#IFXMask
.1d11	38		sec				sec
.1d12	e9 20		sbc #$20			sbc 	#$20 						; map 20..3F..00..1F to 00..0F..E0..FF e.g. scaled unsigned
.1d14	85 0a		sta $0a				sta 	iTemp0
.1d16	b5 03		lda $03,x			lda 	IExp,x 						; repeat for exponent of Rx
.1d18	29 3f		and #$3f			and 	#IFXMask
.1d1a	38		sec				sec
.1d1b	e9 20		sbc #$20			sbc 	#$20
.1d1d	c5 0a		cmp $0a				cmp 	iTemp0 						; get the larger adjusted
.1d1f	b0 02		bcs $1d23			bcs 	_IFloatHaveLarger
.1d21	a5 0a		lda $0a				lda 	iTemp0
.1d23					_IFloatHaveLarger:
.1d23	18		clc				clc 								; get the actual one back.
.1d24	69 20		adc #$20			adc 	#$20 						; shift both to that.
.1d26	20 33 1d	jsr $1d33			jsr 	_IFShiftXToA
.1d29	da		phx				phx
.1d2a	a2 0c		ldx #$0c			ldx 	#IFR0
.1d2c	20 33 1d	jsr $1d33			jsr 	_IFShiftXToA
.1d2f	fa		plx				plx
.1d30	4c ab 1c	jmp $1cab			jmp 	_IFAddSubMantissa 			; do the adding bit.
.1d33					_IFShiftXToA:
.1d33	8d 4a 04	sta $044a			sta 	IFTarget
.1d36	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero 			; check adding zero ?
.1d39	f0 11		beq $1d4c			beq 	_IFSXExit
.1d3b					_IFSXLoop:
.1d3b	b5 03		lda $03,x			lda 	IExp,x 	 					; shifted to the right level yet ?
.1d3d	29 3f		and #$3f			and 	#IFXMask
.1d3f	cd 4a 04	cmp $044a			cmp 	IFTarget
.1d42	f0 08		beq $1d4c			beq 	_IFSXExit
.1d44	20 dc 22	jsr $22dc			jsr 	IFloatShiftRight
.1d47	20 06 23	jsr $2306			jsr 	IFloatIncExponent
.1d4a	80 ef		bra $1d3b			bra 	_IFSXLoop
.1d4c					_IFSXExit:
.1d4c	60		rts				rts
.044a					IFTarget:
>044a							.fill 	1
.1d4d					IFloatMultiply:
.1d4d	8e 4a 04	stx $044a			stx 	IFTarget 					; save the multiplier (RX) which is "adder"
.1d50	20 08 1e	jsr $1e08			jsr 	IFCalculateNewSign
.1d53	b5 03		lda $03,x			lda 	IExp,x 						; check two positive 8 bit integers
.1d55	05 0f		ora $0f				ora 	IFR0+IExp
.1d57	29 3f		and #$3f			and 	#IFXMask
.1d59	15 01		ora $01,x			ora 	IM1,x
.1d5b	05 0d		ora $0d				ora 	IFR0+IM1
.1d5d	15 02		ora $02,x			ora 	IM2,x
.1d5f	05 0e		ora $0e				ora 	IFR0+IM2
.1d61	d0 0a		bne $1d6d			bne 	_IFMStandard
.1d63	20 89 22	jsr $2289			jsr 	IFloatMultiply8BitRx
.1d66	ad 4c 04	lda $044c			lda 	IFNewSign
.1d69	85 0f		sta $0f				sta 	IFR0+IExp
.1d6b	18		clc				clc
.1d6c	60		rts				rts
.1d6d					_IFMStandard:
.1d6d	b5 03		lda $03,x			lda 	IExp,x 						; add the two exponents sign extended
.1d6f	20 ff 1d	jsr $1dff			jsr 	IFMSignExtend
.1d72	8d 4b 04	sta $044b			sta 	IFNewExponent
.1d75	a5 0f		lda $0f				lda 	IFR0+IExp
.1d77	20 ff 1d	jsr $1dff			jsr 	IFMSignExtend
.1d7a	18		clc				clc
.1d7b	6d 4b 04	adc $044b			adc 	IFNewExponent
.1d7e	8d 4b 04	sta $044b			sta 	IFNewExponent
.1d81	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy R0 to RTemp which is "shifter"
.1d83	20 4f 22	jsr $224f			jsr 	IFloatCopyToRegister
.1d86	a2 0c		ldx #$0c			ldx 	#IFR0 						; zero R0 (the result)
.1d88	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.1d8b					_IFMLoop:
.1d8b	a2 18		ldx #$18			ldx 	#IFRTemp
.1d8d	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero
.1d90	f0 3a		beq $1dcc			beq 	_IFMExit
.1d92	ae 4a 04	ldx $044a			ldx 	IFTarget 					; look at adder MSB
.1d95	b5 02		lda $02,x			lda 	IM2,x 						; if it is set we need to shift everything
.1d97	10 03		bpl $1d9c			bpl	 	_IFMTargetOkay
.1d99	20 f0 1d	jsr $1df0			jsr 	_IFMShiftAll
.1d9c					_IFMTargetOkay:
.1d9c	a5 18		lda $18				lda 	IFRTemp+0 					; is bit 0 of the shifter (RTemp) set
.1d9e	29 01		and #$01			and 	#1
.1da0	f0 16		beq $1db8			beq 	_IFMNoAdd
.1da2	ae 4a 04	ldx $044a			ldx 	IFTarget 					; add adder
.1da5	18		clc				clc
.1da6	a5 0c		lda $0c			lda 	IFR0+IM0
.1da8	75 00		adc $00,x		adc 		IM0,x
.1daa	85 0c		sta $0c			sta 	IFR0+IM0
.1dac	a5 0d		lda $0d			lda 	IFR0+IM1
.1dae	75 01		adc $01,x		adc 		IM1,x
.1db0	85 0d		sta $0d			sta 	IFR0+IM1
.1db2	a5 0e		lda $0e			lda 	IFR0+IM2
.1db4	75 02		adc $02,x		adc 		IM2,x
.1db6	85 0e		sta $0e			sta 	IFR0+IM2
.1db8					_IFMNoAdd:
.1db8	a5 0e		lda $0e				lda 	IFR0+IM2
.1dba	10 03		bpl $1dbf			bpl 	_IFMResultOkay
.1dbc	20 f0 1d	jsr $1df0			jsr 	_IFMShiftAll
.1dbf					_IFMResultOkay:
.1dbf	a2 18		ldx #$18			ldx 	#IFRTemp
.1dc1	20 dc 22	jsr $22dc			jsr 	IFloatShiftRight
.1dc4	ae 4a 04	ldx $044a			ldx 	IFTarget
.1dc7	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.1dca	80 bf		bra $1d8b			bra 	_IFMLoop
.1dcc					_IFMExit:
.1dcc	ad 4b 04	lda $044b			lda 	IFNewExponent 				; validate new exponent.
.1dcf	c9 20		cmp #$20			cmp 	#$20 						; valid exponent 00-1F E0-FF
.1dd1	90 0f		bcc $1de2			bcc 	_IFMOkay
.1dd3	c9 e0		cmp #$e0			cmp 	#$E0
.1dd5	b0 0b		bcs $1de2			bcs 	_IFMOkay
.1dd7	29 80		and #$80			and 	#$80 						; if +ve exponent then error overflow.
.1dd9	f0 13		beq $1dee			beq 	_IFMError
.1ddb	a2 0c		ldx #$0c			ldx 	#IFR0 						; return zero underflow
.1ddd	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.1de0	18		clc				clc
.1de1	60		rts				rts
.1de2					_IFMOkay:
.1de2	29 3f		and #$3f			and 	#IFXMask 					; work out exponent + sign and exit
.1de4	0d 4c 04	ora $044c			ora 	IFNewSign
.1de7	85 0f		sta $0f				sta 	IFR0+IExp
.1de9	18		clc				clc
.1dea	60		rts				rts
.1deb	4c ff ff	jmp $ffff			jmp 	$FFFF
.1dee					_IFMError:
.1dee	38		sec				sec
.1def	60		rts				rts
.1df0					_IFMShiftAll:
.1df0	a2 0c		ldx #$0c			ldx 	#IFR0
.1df2	20 dc 22	jsr $22dc			jsr 	IFloatShiftRight
.1df5	ae 4a 04	ldx $044a			ldx 	IFTarget
.1df8	20 dc 22	jsr $22dc			jsr 	IFloatShiftRight
.1dfb	ee 4b 04	inc $044b			inc 	IFNewExponent
.1dfe	60		rts				rts
.1dff					IFMSignExtend:
.1dff	29 3f		and #$3f			and 	#IFXMask
.1e01	c9 1f		cmp #$1f			cmp 	#(IFXMask >> 1)
.1e03	90 02		bcc $1e07			bcc 	_IFMNoSXX
.1e05	09 c0		ora #$c0			ora 	#IFXMask ^ $FF
.1e07					_IFMNoSXX:
.1e07	60		rts				rts
.1e08					IFCalculateNewSign:
.1e08	b5 03		lda $03,x			lda 	IExp,x
.1e0a	45 0f		eor $0f				eor 	IFR0+IExp
.1e0c	29 40		and #$40			and 	#IFSign
.1e0e	8d 4c 04	sta $044c			sta 	IFNewSign
.1e11	60		rts				rts
.044b					IFNewExponent:
>044b							.fill 	1
.044c					IFNewSign:
>044c							.fill 	1
.1e12					IFloatDivideInteger:
.1e12	20 2b 1e	jsr $1e2b			jsr 	IFloatDivideIntegerCommon 	; do the common code.
.1e15	b0 06		bcs $1e1d			bcs 	_IFDIExit
.1e17	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy result from register.
.1e19	20 3e 22	jsr $223e			jsr 	IFloatCopyFromRegister
.1e1c	18		clc				clc
.1e1d					_IFDIExit:
.1e1d	60		rts				rts
.1e1e					IFloatModulusInteger:
.1e1e	20 2b 1e	jsr $1e2b			jsr 	IFloatDivideIntegerCommon
.1e21	b0 07		bcs $1e2a			bcs 	_IFMIExit
.1e23	ae 4a 04	ldx $044a			ldx 	IFTarget
.1e26	20 3e 22	jsr $223e			jsr 	IFloatCopyFromRegister
.1e29	18		clc				clc
.1e2a					_IFMIExit:
.1e2a	60		rts				rts
.1e2b					IFloatDivideIntegerCommon:
.1e2b	8e 4a 04	stx $044a			stx 	IFTarget  					; this is s1, s0 = R0
.1e2e	20 08 1e	jsr $1e08			jsr 	IFCalculateNewSign 			; calculate sign of result
.1e31	20 59 1e	jsr $1e59			jsr 	IFDCopyRXToRTemp 			; copy S1 to RTemp
.1e34	a2 0c		ldx #$0c			ldx 	#IFR0 						; check divide by zero
.1e36	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero
.1e39	f0 1c		beq $1e57			beq 	_IFDIDivZero
.1e3b	ae 4a 04	ldx $044a			ldx 	IFTarget 					; zero Rx (S1)
.1e3e	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.1e41	5a		phy				phy
.1e42	a0 18		ldy #$18			ldy 	#24
.1e44					_IFDILoop:
.1e44	20 6a 1e	jsr $1e6a			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.1e47	20 76 1e	jsr $1e76			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.1e4a	88		dey				dey
.1e4b	d0 f7		bne $1e44			bne 	_IFDILoop 					; do it 24 times
.1e4d	7a		ply				ply
.1e4e	ad 4c 04	lda $044c			lda 	IFNewSign 					; set sign of result.
.1e51	29 40		and #$40			and 	#IFSign
.1e53	85 1b		sta $1b				sta 	IFRTemp+IExp
.1e55	18		clc				clc 								; is okay.
.1e56	60		rts				rts
.1e57					_IFDIDivZero:
.1e57	38		sec				sec
.1e58	60		rts				rts
.1e59					IFDCopyRXToRTemp:
.1e59	b5 00		lda $00,x			lda 	IM0,x
.1e5b	85 18		sta $18				sta 	IFRTemp+IM0
.1e5d	b5 01		lda $01,x			lda 	IM1,x
.1e5f	85 19		sta $19				sta 	IFRTemp+IM1
.1e61	b5 02		lda $02,x			lda 	IM2,x
.1e63	85 1a		sta $1a				sta 	IFRTemp+IM2
.1e65	b5 03		lda $03,x			lda 	IExp,x
.1e67	85 1b		sta $1b				sta 	IFRTemp+IExp
.1e69	60		rts				rts
.1e6a					IFDShiftSTempS1Left:
.1e6a	a2 18		ldx #$18			ldx 	#IFRTemp
.1e6c	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft
.1e6f	ae 4a 04	ldx $044a			ldx 	IFTarget
.1e72	20 d5 22	jsr $22d5			jsr 	IFloatRotateLeft
.1e75	60		rts				rts
.1e76					IFDTrySubtract:
.1e76	ae 4a 04	ldx $044a			ldx 	IFTarget 					; s1 = Rx
.1e79	38		sec				sec 								; subtract, saving the results on the stack.
.1e7a	b5 00		lda $00,x			lda 	IM0,x
.1e7c	e5 0c		sbc $0c				sbc 	IFR0+IM0
.1e7e	48		pha				pha
.1e7f	b5 01		lda $01,x			lda 	IM1,x
.1e81	e5 0d		sbc $0d				sbc 	IFR0+IM1
.1e83	48		pha				pha
.1e84	b5 02		lda $02,x			lda 	IM2,x
.1e86	e5 0e		sbc $0e				sbc 	IFR0+IM2
.1e88	b0 03		bcs $1e8d			bcs 	_IFDCanSubtract
.1e8a	68		pla				pla 								; cannot subtract, so pop intermediate and exit.
.1e8b	68		pla				pla
.1e8c	60		rts				rts
.1e8d					_IFDCanSubtract:
.1e8d	95 02		sta $02,x			sta 	IM2,x 						; write back to S1.Mantissa
.1e8f	68		pla				pla
.1e90	95 01		sta $01,x			sta 	IM1,x
.1e92	68		pla				pla
.1e93	95 00		sta $00,x			sta 	IM0,x
.1e95	e6 18		inc $18				inc 	IFRTemp+IM0 				; increment temp
.1e97	d0 06		bne $1e9f			bne 	_IFDCSExit
.1e99	e6 19		inc $19				inc 	IFRTemp+IM1
.1e9b	d0 02		bne $1e9f			bne 	_IFDCSExit
.1e9d	e6 1a		inc $1a				inc 	IFRTemp+IM2
.1e9f					_IFDCSExit:
.1e9f	60		rts				rts
.1ea0					IFloatBitwiseAnd:
.1ea0	5a		phy				phy
.1ea1	20 e5 1e	jsr $1ee5			jsr 	IFPreProcessBitwise 		; set up everything.
.1ea4	d0 0f		bne $1eb5			bne 	_IFBAExit
.1ea6					_IFBALoop:
.1ea6	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.1ea9	35 00		and $00,x			and 	IM0,x
.1eab	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.1eae	e8		inx				inx
.1eaf	c8		iny				iny
.1eb0	c0 03		cpy #$03			cpy 	#3
.1eb2	d0 f2		bne $1ea6			bne 	_IFBALoop
.1eb4	18		clc				clc
.1eb5					_IFBAExit:
.1eb5	7a		ply				ply
.1eb6	60		rts				rts
.1eb7					IFloatBitwiseOr:
.1eb7	5a		phy				phy
.1eb8	20 e5 1e	jsr $1ee5			jsr 	IFPreProcessBitwise 		; set up everything.
.1ebb	d0 0f		bne $1ecc			bne 	_IFBAExit
.1ebd					_IFBALoop:
.1ebd	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.1ec0	15 00		ora $00,x			ora 	IM0,x
.1ec2	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.1ec5	e8		inx				inx
.1ec6	c8		iny				iny
.1ec7	c0 03		cpy #$03			cpy 	#3
.1ec9	d0 f2		bne $1ebd			bne 	_IFBALoop
.1ecb	18		clc				clc
.1ecc					_IFBAExit:
.1ecc	7a		ply				ply
.1ecd	60		rts				rts
.1ece					IFloatBitwiseXor:
.1ece	5a		phy				phy
.1ecf	20 e5 1e	jsr $1ee5			jsr 	IFPreProcessBitwise 		; set up everything.
.1ed2	d0 0f		bne $1ee3			bne 	_IFBAExit
.1ed4					_IFBALoop:
.1ed4	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.1ed7	55 00		eor $00,x			eor 	IM0,x
.1ed9	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.1edc	e8		inx				inx
.1edd	c8		iny				iny
.1ede	c0 03		cpy #$03			cpy 	#3
.1ee0	d0 f2		bne $1ed4			bne 	_IFBALoop
.1ee2	18		clc				clc
.1ee3					_IFBAExit:
.1ee3	7a		ply				ply
.1ee4	60		rts				rts
.1ee5					IFPreProcessBitwise:
.1ee5	a0 00		ldy #$00			ldy 	#0 							; set index.
.1ee7	a5 0f		lda $0f				lda 	IFR0+IExp 					; OR exponents
.1ee9	15 03		ora $03,x			ora 	IExp,x
.1eeb	74 03		stz $03,x			stz 	IExp,x 						; zero the result exponent anyway.
.1eed	29 3f		and #$3f			and 	#IFXMask 					; NZ if error e.g. not integer
.1eef	38		sec				sec 								; carry set just in cases.
.1ef0	60		rts				rts
.1ef1					IFloatAbsoluteR0:
.1ef1	a5 0f		lda $0f				lda 	IFR0+IExp					; reset the sign bit.
.1ef3	29 bf		and #$bf			and 	#IFSign ^ 255
.1ef5	85 0f		sta $0f				sta 	IFR0+IExp
.1ef7	18		clc				clc
.1ef8	60		rts				rts
.1ef9					IFloatSquareRootR0:
.1ef9	a2 0c		ldx #$0c			ldx 	#IFR0 						; if zero, return zero.
.1efb	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero
.1efe	a5 0f		lda $0f				lda	 	IFR0+IExp 					; if negative fail.
.1f00	29 40		and #$40			and 	#IFSign
.1f02	d0 2f		bne $1f33			bne 	_IFSRFail
.1f04	20 e4 22	jsr $22e4			jsr 	IFloatNormalise 			; it will work better !
.1f07	a2 10		ldx #$10			ldx 	#IFR1 						; R1 contains original throughout
.1f09	20 4f 22	jsr $224f			jsr 	IFloatCopyToRegister
.1f0c	a5 0f		lda $0f				lda 	IFR0+IExp 					; if exponent is $2A..$3F * 64 otherwise is / 64
.1f0e	20 ff 1d	jsr $1dff			jsr 	IFMSignExtend 				; sign extended version of the exponent
.1f11	18		clc				clc
.1f12	69 17		adc #$17			adc 	#23 						; this makes it a 0.xxx mantissa
.1f14	85 0f		sta $0f				sta 	IFR0+IExp
.1f16	4a		lsr a				lsr 	a 							; which we can halve.
.1f17	38		sec				sec 								; convert back
.1f18	e9 17		sbc #$17			sbc 	#23
.1f1a	29 3f		and #$3f			and 	#IFXMask 					; make appropriate
.1f1c	85 0f		sta $0f				sta 	IFR0+IExp 					; to R0
.1f1e	20 35 1f	jsr $1f35			jsr 	_IFSRNewton
.1f21	20 35 1f	jsr $1f35			jsr 	_IFSRNewton
.1f24	20 35 1f	jsr $1f35			jsr 	_IFSRNewton
.1f27	20 35 1f	jsr $1f35			jsr 	_IFSRNewton
.1f2a	18		clc				clc
.1f2b	60		rts				rts
.1f2c					_IFSRZero:
.1f2c	a2 0c		ldx #$0c			ldx 	#IFR0
.1f2e	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.1f31	18		clc				clc
.1f32	60		rts				rts
.1f33					_IFSRFail:
.1f33	38		sec				sec
.1f34	60		rts				rts
.1f35					_IFSRNewton:
.1f35	a2 10		ldx #$10			ldx 	#IFR1 						; push original value (R3) on the stack
.1f37	20 fc 21	jsr $21fc			jsr 	IFloatPushRx
.1f3a	a2 0c		ldx #$0c			ldx 	#IFR0 						; push current guess (R0) on the stack.
.1f3c	20 fc 21	jsr $21fc			jsr 	IFloatPushRx
.1f3f	a2 10		ldx #$10			ldx 	#IFR1 						; guess = original / guess
.1f41	20 d0 1f	jsr $1fd0			jsr 	IFloatDivideFloat
.1f44	a2 10		ldx #$10			ldx 	#IFR1 						; restore current guess (was in R0) to R3
.1f46	20 1d 22	jsr $221d			jsr 	IFloatPullRx
.1f49	20 a3 1c	jsr $1ca3			jsr 	IFloatAdd 					; now guess + original/guess
.1f4c	a2 0c		ldx #$0c			ldx 	#IFR0 						; divide by 2
.1f4e	20 dc 22	jsr $22dc			jsr 	IFloatShiftRight
.1f51	a2 10		ldx #$10			ldx 	#IFR1
.1f53	20 1d 22	jsr $221d			jsr 	IFloatPullRx 				; Finally pull the oeifinal
.1f56	60		rts				rts
.1f57					IFloatFractionalR0:
.1f57	a5 0f		lda $0f				lda 	IFR0+IExp					; is it integer already ?
.1f59	29 3f		and #$3f			and 	#IFXMask
.1f5b	f0 17		beq $1f74			beq 	_FIPZero 					; if so, return with zero as no fractional part.
.1f5d	20 f1 1e	jsr $1ef1			jsr 	IFloatAbsoluteR0 			; absolute value R9
.1f60	a2 0c		ldx #$0c			ldx 	#IFR0
.1f62	20 e4 22	jsr $22e4			jsr 	IFloatNormalise 			; normalise R0
.1f65	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy to RTemp
.1f67	20 4f 22	jsr $224f			jsr 	IFloatCopyToRegister
.1f6a	20 ad 1f	jsr $1fad			jsr 	IFloatIntegerR0 			; take integer part of R0
.1f6d	a2 18		ldx #$18			ldx 	#IFRTemp 					; subtract
.1f6f	20 9c 1c	jsr $1c9c			jsr 	IFloatSubtract
.1f72	80 05		bra $1f79			bra 	_FIPExit
.1f74					_FIPZero:
.1f74	a2 0c		ldx #$0c			ldx 	#IFR0
.1f76	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.1f79					_FIPExit:
.1f79	18		clc				clc
.1f7a	60		rts				rts
.1f7b					IFloatCompare:
.1f7b	20 9c 1c	jsr $1c9c			jsr 	IFloatSubtract 				; subtract R0 from RX.
.1f7e	b5 03		lda $03,x			lda 	IExp,x 						; check if integer comparison
.1f80	05 0f		ora $0f				ora 	IFR0+IExp
.1f82	a2 0c		ldx #$0c			ldx 	#IFR0 						; only using R0 from now on.
.1f84	29 3f		and #$3f			and 	#IFXMask
.1f86	d0 19		bne $1fa1			bne 	_IFCNonInteger
.1f88	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero 			; check if zero
.1f8b	f0 0f		beq $1f9c			beq 	_IFCZero
.1f8d					_IFCReturnSign:
.1f8d	a5 0f		lda $0f				lda 	IFR0+IExp 					; get the sign bit/unused -> stack.
.1f8f	29 c0		and #$c0			and 	#(IFXMask ^ $FF)
.1f91	48		pha				pha
.1f92	a9 01		lda #$01			lda 	#1
.1f94	20 af 22	jsr $22af			jsr 	IFloatSetByte 				; return to +1
.1f97	68		pla				pla 								; sign bit back
.1f98	85 0f		sta $0f				sta 	IFR0+IExp					; set that sign
.1f9a	18		clc				clc
.1f9b	60		rts				rts
.1f9c					_IFCZero:
.1f9c	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.1f9f	18		clc				clc
.1fa0	60		rts				rts
.1fa1					_IFCNonInteger:
.1fa1	a5 0c		lda $0c				lda 	IFR0+IM0
.1fa3	29 00		and #$00			and		#$00
.1fa5	05 0d		ora $0d				ora 	IFR0+IM1
.1fa7	05 0e		ora $0e				ora 	IFR0+IM2
.1fa9	f0 f1		beq $1f9c			beq 	_IFCZero 					; near enough !
.1fab	80 e0		bra $1f8d			bra 	_IFCReturnSign 				; return the sign of the difference.
.1fad					IFloatIntegerR0:
.1fad	a5 0f		lda $0f				lda 	IFR0+IExp					; is it integer already ?
.1faf	29 3f		and #$3f			and 	#IFXMask
.1fb1	f0 1b		beq $1fce			beq 	_FIPExit 					; if so do nothing
.1fb3	a2 0c		ldx #$0c			ldx 	#IFR0
.1fb5	20 e4 22	jsr $22e4			jsr 	IFloatNormalise 			; normalise
.1fb8	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero 			; is it zero ?
.1fbb	f0 0e		beq $1fcb			beq 	_FIPZero 					; if so return zero.
.1fbd					_FIPShift:
.1fbd	a5 0f		lda $0f				lda 	IFR0+IExp 					; if Exponent >= 0 exit.
.1fbf	29 20		and #$20			and 	#$20 						; still -ve
.1fc1	f0 0b		beq $1fce			beq 	_FIPExit
.1fc3	20 dc 22	jsr $22dc			jsr 	IFloatShiftRight 			; shift mantissa right
.1fc6	20 06 23	jsr $2306			jsr 	IFloatIncExponent 			; bump exponent
.1fc9	80 f2		bra $1fbd			bra 	_FIPShift
.1fcb					_FIPZero:
.1fcb	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.1fce					_FIPExit:
.1fce	18		clc				clc
.1fcf	60		rts				rts
.1fd0					IFloatDivideFloat:
.1fd0	8e 4a 04	stx $044a			stx 	IFTarget  					; this is s1, s0 = R0
.1fd3	20 08 1e	jsr $1e08			jsr 	IFCalculateNewSign 			; calculate sign of result
.1fd6	20 e4 22	jsr $22e4			jsr 	IFloatNormalise 			; normalise RX
.1fd9	a2 0c		ldx #$0c			ldx 	#IFR0 						; normalise R0
.1fdb	20 e4 22	jsr $22e4			jsr 	IFloatNormalise
.1fde	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero
.1fe1	f0 56		beq $2039			beq 	_IFDFDivZero 				; exit if this normalised to zero.
.1fe3	a5 0f		lda $0f				lda 	IFR0+IExp 					; calculate s0.exponent
.1fe5	20 ff 1d	jsr $1dff			jsr 	IFMSignExtend
.1fe8	8d 4b 04	sta $044b			sta 	IFNewExponent
.1feb	ae 4a 04	ldx $044a			ldx 	IFTarget 					; calculate s1.exponent
.1fee	b5 03		lda $03,x			lda 	IExp,x
.1ff0	20 ff 1d	jsr $1dff			jsr 	IFMSignExtend
.1ff3	38		sec				sec
.1ff4	ed 4b 04	sbc $044b			sbc 	IFNewExponent 				; s1.exponent - s0.exponent - 23
.1ff7	38		sec				sec
.1ff8	e9 17		sbc #$17			sbc 	#23
.1ffa	8d 4b 04	sta $044b			sta 	IFNewExponent
.1ffd	20 3b 20	jsr $203b			jsr 	IFloatDivideSupport 		; call the support routine (see maths.py)
.2000	a5 1a		lda $1a				lda 	IFRTemp+IM2 				; result has overflowed ?
.2002	10 08		bpl $200c			bpl 	_IFDFNoShiftResult
.2004	a2 18		ldx #$18			ldx 	#IFRTemp 					; if so, fix it up.
.2006	20 dc 22	jsr $22dc			jsr 	IFloatShiftRight
.2009	ee 4b 04	inc $044b			inc 	IFNewExponent
.200c					_IFDFNoShiftResult:
.200c	ad 4b 04	lda $044b			lda 	IFNewExponent 				; underflow/overflow check.
.200f	30 06		bmi $2017			bmi 	_IFDFCheckUnderflow
.2011	c9 20		cmp #$20			cmp 	#$20 						; overflow in division
.2013	b0 24		bcs $2039			bcs 	_IFDFDivZero
.2015	80 11		bra $2028			bra		_IFDFExit
.2017					_IFDFCheckUnderflow:
.2017	ad 4b 04	lda $044b			lda 	IFNewExponent 				; shift into a legal exponent.
.201a	c9 e0		cmp #$e0			cmp 	#$E0 						; if exponent < -32.
.201c	b0 0a		bcs $2028			bcs 	_IFDFExit
.201e	ee 4b 04	inc $044b			inc 	IFNewExponent
.2021	a2 18		ldx #$18			ldx 	#IFRTemp
.2023	20 dc 22	jsr $22dc			jsr 	IFloatShiftRight
.2026	80 ef		bra $2017			bra 	_IFDFCheckUnderflow
.2028					_IFDFExit:
.2028	ad 4b 04	lda $044b			lda 	IFNewExponent 				; combine exponent and sign.
.202b	29 3f		and #$3f			and 	#IFXMask
.202d	0d 4c 04	ora $044c			ora 	IFNewSign
.2030	85 1b		sta $1b				sta 	IFRTemp+IExp
.2032	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy RTemp to R0.
.2034	20 3e 22	jsr $223e			jsr 	IFloatCopyFromRegister
.2037	18		clc				clc
.2038	60		rts				rts
.2039					_IFDFDivZero:
.2039	38		sec				sec
.203a	60		rts				rts
.203b					IFloatDivideSupport:
.203b	a2 18		ldx #$18			ldx 	#IFRTemp 					; zero RTemp
.203d	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.2040	5a		phy				phy 								; main division loop x 23
.2041	a0 17		ldy #$17			ldy 	#23
.2043					_IFDSLoop:
.2043	20 76 1e	jsr $1e76			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.2046	20 6a 1e	jsr $1e6a			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.2049	88		dey				dey
.204a	d0 f7		bne $2043			bne 	_IFDSLoop 					; do it 24 times
.204c	7a		ply				ply
.204d	60		rts				rts
.204e					IFloatIntegerToStringR0:
.204e	8d 4d 04	sta $044d			sta 	IFBase 						; save base to use.
.2051	20 2e 23	jsr $232e			jsr 	IFloatBufferReset			; empty buffer
.2054	a5 0f		lda $0f				lda 	IFR0+IExp					; check integer
.2056	29 3f		and #$3f			and 	#IFXMask
.2058	d0 1e		bne $2078			bne 	_IFIFail
.205a	a2 0c		ldx #$0c			ldx 	#IFR0 						; skip - check if zero.
.205c	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero
.205f	f0 0e		beq $206f			beq 	_IFINotNegative
.2061	a5 0f		lda $0f				lda 	IFR0+IExp 					; is signed ?
.2063	29 40		and #$40			and 	#IFSign
.2065	f0 08		beq $206f			beq 	_IFINotNegative
.2067	a9 2d		lda #$2d			lda 	#"-"						; output -
.2069	20 3d 23	jsr $233d			jsr 	IFloatBufferWrite
.206c	20 b8 22	jsr $22b8			jsr 	IFloatNegate 				; tidy up !
.206f					_IFINotNegative:
.206f	20 7a 20	jsr $207a			jsr 	_IFIRecursiveConvert 		; start converting
.2072	20 35 23	jsr $2335			jsr 	IFloatGetBufferAddress
.2075	18		clc				clc
.2076	80 01		bra $2079			bra 	_IFIExit
.2078					_IFIFail:
.2078	38		sec				sec
.2079					_IFIExit:
.2079	60		rts				rts
.207a					_IFIRecursiveConvert:
.207a	a2 10		ldx #$10			ldx 	#IFR1
.207c	20 4f 22	jsr $224f			jsr 	IFloatCopyToRegister 		; R0->R1
.207f	a2 0c		ldx #$0c			ldx 	#IFR0
.2081	ad 4d 04	lda $044d			lda 	IFBase 						; Base -> R0
.2084	20 af 22	jsr $22af			jsr 	IFloatSetByte
.2087	a2 10		ldx #$10			ldx 	#IFR1 						; R0 = R1 / R0
.2089	20 12 1e	jsr $1e12			jsr 	IFloatDivideInteger
.208c	a2 0c		ldx #$0c			ldx 	#IFR0 						; if result <> 0
.208e	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero
.2091	f0 09		beq $209c			beq 	_IFIOutDigit
.2093	a5 10		lda $10				lda 	IFR1+IM0 					; save remainder
.2095	48		pha				pha
.2096	20 7a 20	jsr $207a			jsr 	_IFIRecursiveConvert 		; convert the divider
.2099	68		pla				pla
.209a	85 10		sta $10				sta 	IFR1+IM0 					; restore remainder
.209c					_IFIOutDigit:
.209c	a5 10		lda $10				lda 	IFR1+IM0 					; get remainder.
.209e	c9 0a		cmp #$0a			cmp	 	#10
.20a0	90 02		bcc $20a4			bcc 	_IFINotHex
.20a2	69 06		adc #$06			adc 	#6
.20a4					_IFINotHex:
.20a4	69 30		adc #$30			adc 	#48
.20a6	20 3d 23	jsr $233d			jsr 	IFloatBufferWrite
.20a9	60		rts				rts
.044d					IFBase:
>044d							.fill 	1
.20aa					IFloatFloatToStringR0:
.20aa	a2 14		ldx #$14			ldx 	#IFR2 						; copy R2 to stack,value to R2
.20ac	20 fc 21	jsr $21fc			jsr 	IFloatPushRx
.20af	20 4f 22	jsr $224f			jsr 	IFloatCopyToRegister
.20b2	20 ad 1f	jsr $1fad			jsr 	IFloatIntegerR0				; make R0 integer
.20b5	a9 0a		lda #$0a			lda 	#10 						; base 10.
.20b7	20 4e 20	jsr $204e			jsr 	IFloatIntegerToStringR0 	; do the integer part.
.20ba	9c 4e 04	stz $044e			stz 	IFloatDecimalCount 			; zero the decimal count.
.20bd	a5 17		lda $17				lda 	IFR2+IExp 					; is integer.
.20bf	29 3f		and #$3f			and 	#IFXMask
.20c1	f0 44		beq $2107			beq 	_IFFSExit
.20c3					_IFloatFracLoop:
.20c3	a2 14		ldx #$14			ldx 	#IFR2 						; R0 = fractional part of R2
.20c5	20 3e 22	jsr $223e			jsr 	IFloatCopyFromRegister
.20c8	20 57 1f	jsr $1f57			jsr 	IFloatFractionalR0
.20cb	20 e4 22	jsr $22e4			jsr 	IFloatNormalise
.20ce	a2 14		ldx #$14			ldx 	#IFR2
.20d0	20 4f 22	jsr $224f			jsr 	IFloatCopyToRegister 		; copy to R2
.20d3	a2 14		ldx #$14			ldx 	#IFR2 						; set R2 to 10
.20d5	a9 0a		lda #$0a			lda 	#10
.20d7	20 af 22	jsr $22af			jsr 	IFloatSetByte
.20da	a2 14		ldx #$14			ldx 	#IFR2						; R0,R2 = R2 * 10
.20dc	20 4d 1d	jsr $1d4d			jsr 	IFloatMultiply
.20df	a2 14		ldx #$14			ldx 	#IFR2
.20e1	20 4f 22	jsr $224f			jsr 	IFloatCopyToRegister
.20e4	20 ad 1f	jsr $1fad			jsr 	IFloatIntegerR0 			; get integer part of R0
.20e7	ad 4e 04	lda $044e			lda 	IFloatDecimalCount 			; done 5 dp, no more
.20ea	c9 03		cmp #$03			cmp 	#3
.20ec	f0 16		beq $2104			beq 	_IFFSExitStripZero
.20ee	ad 4e 04	lda $044e			lda 	IFloatDecimalCount 			; written the DP yet ?
.20f1	d0 05		bne $20f8			bne 	_IFloatNotFirst
.20f3	a9 2e		lda #$2e			lda 	#"." 						; write decimal point
.20f5	20 3d 23	jsr $233d			jsr 	IFloatBufferWrite
.20f8					_IFloatNotFirst:
.20f8	ee 4e 04	inc $044e			inc 	IFloatDecimalCount
.20fb	a5 0c		lda $0c				lda 	IFR0+IM0 					; get digit
.20fd	09 30		ora #$30			ora 	#"0"						; ASCII
.20ff	20 3d 23	jsr $233d			jsr 	IFloatBufferWrite 			; write to the buffer.
.2102	80 bf		bra $20c3			bra 	_IFloatFracLoop
.2104					_IFFSExitStripZero:
.2104	20 4c 23	jsr $234c			jsr 	IFloatStripTrailingZeros
.2107					_IFFSExit:
.2107	a2 14		ldx #$14			ldx 	#IFR2 						; restore R2
.2109	20 1d 22	jsr $221d			jsr 	IFloatPullRx
.210c	20 35 23	jsr $2335			jsr 	IFloatGetBufferAddress
.210f	18		clc				clc
.2110	60		rts				rts
.044e					IFloatDecimalCount:
>044e							.fill 	1
.2111					IFloatStringToFloatR0:
.2111	8d 4f 04	sta $044f			sta 	IFCount 					; save it out.
.2114	86 0a		stx $0a				stx 	iTemp0
.2116	84 0b		sty $0b				sty 	iTemp0+1
.2118	a2 0c		ldx #$0c			ldx 	#IFR0 						; reset the current value.
.211a	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.211d	9c 50 04	stz $0450			stz 	IFSignFlag 					; clear the sign flag
.2120	20 ad 21	jsr $21ad			jsr 	IFSTFGetNext 				; get first
.2123	f0 1b		beq $2140			beq 	_IFSTFFail 					; no character
.2125	90 10		bcc $2137			bcc 	_IFSTFHaveChar 				; legitimate character, go do it.
.2127	c9 2d		cmp #$2d			cmp 	#"-" 						; if not -, fail
.2129	d0 15		bne $2140			bne 	_IFSTFFail
.212b	a9 40		lda #$40			lda 	#IFSign 					; set sign flag
.212d	8d 50 04	sta $0450			sta 	IFSignFlag
.2130					_IFSTFLoop:
.2130	20 ad 21	jsr $21ad			jsr 	IFSTFGetNext 				; get next
.2133	b0 0b		bcs $2140			bcs 	_IFSTFFail 					; bad character.
.2135	f0 11		beq $2148			beq 	_IFSTFExit 					; end of data
.2137					_IFSTFHaveChar:
.2137	c9 2e		cmp #$2e			cmp 	#"."						; decimal point ?
.2139	f0 08		beq $2143			beq 	_IFSTFDecimal
.213b	20 d1 21	jsr $21d1			jsr 	IFSTFAddR0 					; add number in
.213e	80 f0		bra $2130			bra 	_IFSTFLoop 					; keep going until . or end.
.2140					_IFSTFFail:
.2140	38		sec				sec
.2141	80 0d		bra $2150			bra 	_IFSTFReturn
.2143					_IFSTFDecimal:
.2143	20 58 21	jsr $2158			jsr 	IFSTFDecimal 				; call the decimal places code.
.2146	b0 08		bcs $2150			bcs 	_IFSTFReturn 				; error
.2148					_IFSTFExit:
.2148	a5 0f		lda $0f				lda 	IFR0+IExp 					; copy sign flag in.
.214a	0d 50 04	ora $0450			ora 	IFSignFlag
.214d	85 0f		sta $0f				sta 	IFR0+IExp
.214f	18		clc				clc
.2150					_IFSTFReturn:
.2150	60		rts				rts
.2151					IFloatAddDecimalToR0:
.2151	8d 4f 04	sta $044f			sta 	IFCount 					; save it out.
.2154	86 0a		stx $0a				stx 	iTemp0
.2156	84 0b		sty $0b				sty 	iTemp0+1
.2158					IFSTFDecimal:
.2158	a2 0c		ldx #$0c			ldx 	#IFR0 						; push integer part on stack
.215a	20 fc 21	jsr $21fc			jsr 	IFloatPushRx
.215d	a2 0c		ldx #$0c			ldx 	#IFR0 						; R0 is the decimal digits so far.
.215f	20 ad 22	jsr $22ad			jsr 	IFloatSetZero
.2162	9c 51 04	stz $0451			stz 	IFDecimalPlaces
.2165					_IFSTDLoop:
.2165	20 ad 21	jsr $21ad			jsr 	IFSTFGetNext 				; get next
.2168	b0 41		bcs $21ab			bcs 	_IFSTFFail2 				; bad character.
.216a	f0 11		beq $217d			beq 	_IFSTFComplete 				; end of data, work out the result.
.216c	c9 2e		cmp #$2e			cmp 	#"."						; only one decimal
.216e	f0 39		beq $21a9			beq 	_IFSTFExit2
.2170	20 d1 21	jsr $21d1			jsr 	IFSTFAddR0 					; add number in
.2173	ee 51 04	inc $0451			inc 	IFDecimalPlaces 			; count decimals
.2176	ad 51 04	lda $0451			lda 	IFDecimalPlaces 			; no more than 3 DP used.
.2179	c9 03		cmp #$03			cmp 	#3
.217b	90 e8		bcc $2165			bcc 	_IFSTDLoop
.217d					_IFSTFComplete:
.217d	ad 51 04	lda $0451			lda 	IFDecimalPlaces 			; decimals x 4 as accessing multiplier from a LUT.
.2180	f0 27		beq $21a9			beq 	_IFSTFExit2					; if none, this is syntactically fine, just ignore
.2182	3a		dec a				dec 	a 							; table indexed from 1.
.2183	0a		asl a				asl 	a
.2184	0a		asl a				asl 	a
.2185	aa		tax				tax
.2186	bd e8 21	lda $21e8,x			lda 	TableTen,x 					; copy table entry into R0 - these are 0.1,0.01,0.001
.2189	85 10		sta $10				sta  	IFR1+IM0 					; 0.0001 etc, up to 5 decimals.
.218b	bd e9 21	lda $21e9,x			lda 	TableTen+1,x
.218e	85 11		sta $11				sta  	IFR1+IM1
.2190	bd ea 21	lda $21ea,x			lda 	TableTen+2,x
.2193	85 12		sta $12				sta  	IFR1+IM2
.2195	bd eb 21	lda $21eb,x			lda 	TableTen+3,x
.2198	85 13		sta $13				sta  	IFR1+IExp
.219a	a2 10		ldx #$10			ldx 	#IFR1 						; multiply into result
.219c	20 4d 1d	jsr $1d4d			jsr 	IFloatMultiply
.219f	a2 10		ldx #$10			ldx 	#IFR1  						; pop and add the decimal.
.21a1	20 1d 22	jsr $221d			jsr 	IFloatPullRx
.21a4	a2 10		ldx #$10			ldx 	#IFR1
.21a6	20 a3 1c	jsr $1ca3			jsr 	IFloatAdd
.21a9					_IFSTFExit2:
.21a9	18		clc				clc
.21aa	60		rts				rts
.21ab					_IFSTFFail2:
.21ab	38		sec				sec
.21ac	60		rts				rts
.21ad					IFSTFGetNext:
.21ad	ad 4f 04	lda $044f			lda 	IFCount  					; if count is zero, return with Z set.
.21b0	f0 19		beq $21cb			beq 	_IFSTFReturnOk
.21b2	b2 0a		lda ($0a)			lda 	(iTemp0) 					; get next character
.21b4	e6 0a		inc $0a				inc 	iTemp0 						; point at next.
.21b6	d0 02		bne $21ba			bne 	_IFSTFGNNoCarry
.21b8	e6 0b		inc $0b				inc 	iTemp0+1
.21ba					_IFSTFGNNoCarry:
.21ba	ce 4f 04	dec $044f			dec 	IFCount 					; dec count.
.21bd	c9 2e		cmp #$2e			cmp 	#"."	 					; check, dp is allowed.
.21bf	f0 08		beq $21c9			beq 	_IFSTFGOkay
.21c1	c9 30		cmp #$30			cmp 	#"0"						; < 0 fail.
.21c3	90 08		bcc $21cd			bcc 	_IFSTFGFail
.21c5	c9 3a		cmp #$3a			cmp 	#"9"+1 						; > 9 fail.
.21c7	b0 04		bcs $21cd			bcs 	_IFSTFGFail
.21c9					_IFSTFGOkay:
.21c9	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.21cb					_IFSTFReturnOk:
.21cb	18		clc				clc
.21cc	60		rts				rts
.21cd					_IFSTFGFail:
.21cd	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.21cf	38		sec				sec
.21d0	60		rts				rts
.21d1					IFSTFAddR0:
.21d1	29 0f		and #$0f			and 	#15 						; to int value
.21d3	48		pha				pha 								; save it.
.21d4	a9 0a		lda #$0a			lda 	#10
.21d6	a2 10		ldx #$10			ldx 	#IFR1
.21d8	20 af 22	jsr $22af			jsr 	IFloatSetByte
.21db	20 4d 1d	jsr $1d4d			jsr 	IFloatMultiply
.21de	68		pla				pla
.21df	a2 10		ldx #$10			ldx 	#IFR1
.21e1	20 af 22	jsr $22af			jsr 	IFloatSetByte
.21e4	20 a3 1c	jsr $1ca3			jsr 	IFloatAdd
.21e7	60		rts				rts
.044f					IFCount:
>044f							.fill 	1
.0450					IFSignFlag:
>0450							.fill 	1
.0451					IFDecimalPlaces:
>0451							.fill 	1
.21e8					TableTen:
>21e8	9a 19 00 30				.byte	$9a,$19,$00,$30 ; 0.10001
>21ec	8f 02 00 30				.byte	$8f,$02,$00,$30 ; 0.00999
>21f0	42 00 00 30				.byte	$42,$00,$00,$30 ; 0.00101
>21f4	07 00 00 30				.byte	$07,$00,$00,$30 ; 0.00011
>21f8	01 00 00 30				.byte	$01,$00,$00,$30 ; 2e-05
.21fc					IFloatPushRx:
.21fc	5a		phy				phy
.21fd	ac 52 04	ldy $0452			ldy 	IFStackIndex
.2200	b5 00		lda $00,x			lda 	IM0,x
.2202	99 53 04	sta $0453,y			sta 	IFStack,y
.2205	b5 01		lda $01,x			lda 	IM1,x
.2207	99 54 04	sta $0454,y			sta 	IFStack+1,y
.220a	b5 02		lda $02,x			lda 	IM2,x
.220c	99 55 04	sta $0455,y			sta 	IFStack+2,y
.220f	b5 03		lda $03,x			lda 	IExp,x
.2211	99 56 04	sta $0456,y			sta 	IFStack+3,y
.2214	c8		iny				iny
.2215	c8		iny				iny
.2216	c8		iny				iny
.2217	c8		iny				iny
.2218	8c 52 04	sty $0452			sty 	IFStackIndex
.221b	7a		ply				ply
.221c	60		rts				rts
.221d					IFloatPullRx:
.221d	5a		phy				phy
.221e	ac 52 04	ldy $0452			ldy 	IFStackIndex
.2221	88		dey				dey
.2222	88		dey				dey
.2223	88		dey				dey
.2224	88		dey				dey
.2225	b9 53 04	lda $0453,y			lda 	IFStack,y
.2228	95 00		sta $00,x			sta 	IM0,x
.222a	b9 54 04	lda $0454,y			lda 	IFStack+1,y
.222d	95 01		sta $01,x			sta 	IM1,x
.222f	b9 55 04	lda $0455,y			lda 	IFStack+2,y
.2232	95 02		sta $02,x			sta 	IM2,x
.2234	b9 56 04	lda $0456,y			lda 	IFStack+3,y
.2237	95 03		sta $03,x			sta 	IExp,x
.2239	8c 52 04	sty $0452			sty 	IFStackIndex
.223c	7a		ply				ply
.223d	60		rts				rts
.0452					IFStackIndex:
>0452							.fill 	1
.0453					IFStack:
>0453							.fill 	16*4
.223e					IFloatCopyFromRegister:
.223e	b5 00		lda $00,x			lda 	0,x
.2240	85 0c		sta $0c				sta 	IFR0
.2242	b5 01		lda $01,x			lda 	1,x
.2244	85 0d		sta $0d				sta 	IFR0+1
.2246	b5 02		lda $02,x			lda 	2,x
.2248	85 0e		sta $0e				sta 	IFR0+2
.224a	b5 03		lda $03,x			lda 	3,x
.224c	85 0f		sta $0f				sta 	IFR0+3
.224e	60		rts				rts
.224f					IFloatCopyToRegister:
.224f	a5 0c		lda $0c				lda 	IFR0
.2251	95 00		sta $00,x			sta 	0,x
.2253	a5 0d		lda $0d				lda 	IFR0+1
.2255	95 01		sta $01,x			sta 	1,x
.2257	a5 0e		lda $0e				lda 	IFR0+2
.2259	95 02		sta $02,x			sta 	2,x
.225b	a5 0f		lda $0f				lda 	IFR0+3
.225d	95 03		sta $03,x			sta 	3,x
.225f	60		rts				rts
.2260					IFloatLoadInline:
.2260	68		pla				pla 								; pop address off to iTemp0
.2261	85 0a		sta $0a				sta 	iTemp0
.2263	68		pla				pla
.2264	85 0b		sta $0b				sta 	iTemp0+1
.2266	a0 01		ldy #$01			ldy 	#1
.2268	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 0
.226a	95 00		sta $00,x			sta 	0,x
.226c	c8		iny				iny
.226d	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 1
.226f	95 01		sta $01,x			sta 	1,x
.2271	c8		iny				iny
.2272	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 2
.2274	95 02		sta $02,x			sta 	2,x
.2276	c8		iny				iny
.2277	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 3
.2279	95 03		sta $03,x			sta 	3,x
.227b	18		clc				clc 								; inc pointer, 1 for return, 4 for data
.227c	a5 0a		lda $0a				lda 	iTemp0
.227e	69 05		adc #$05			adc 	#5
.2280	85 0a		sta $0a				sta 	iTemp0
.2282	90 02		bcc $2286			bcc 	_IFLINoCarry
.2284	e6 0b		inc $0b				inc 	iTemp0+1
.2286					_IFLINoCarry:
.2286	6c 0a 00	jmp ($000a)			jmp 	(iTemp0)					; effectively RTS
.2289					IFloatMultiply8BitRx:
.2289	5a		phy		        phy
.228a	b5 00		lda $00,x	        lda     IM0,x                       ; AY are the two values
.228c	a4 0c		ldy $0c		        ldy     IFR0+IM0
.228e	4a		lsr a		        lsr     a                           ; prime the carry bit for the loop
.228f	85 0c		sta $0c		        sta     IFR0+IM0
.2291	84 0d		sty $0d		        sty     IFR0+IM1
.2293	a9 00		lda #$00	        lda     #0
.2295	a0 08		ldy #$08	        ldy     #8
.2297					_IFMLoop:
.2297	90 03		bcc $229c	        bcc     _IFMNoAdd
.2299	18		clc		        clc
.229a	65 0d		adc $0d		        adc     IFR0+IM1
.229c					_IFMNoAdd:
.229c	6a		ror a		        ror     a
.229d	66 0c		ror $0c		        ror     IFR0+IM0                    ; pull another bit out for the next iteration
.229f	88		dey		        dey
.22a0	d0 f5		bne $2297	        bne     _IFMLoop
.22a2	85 0d		sta $0d		        sta     IFR0+IM1                    ; write MSB out
.22a4	7a		ply		        ply
.22a5	60		rts		        rts
.22a6					IFloatCheckZero:
.22a6	b5 00		lda $00,x			lda 	IM0,x
.22a8	15 01		ora $01,x			ora 	IM1,x
.22aa	15 02		ora $02,x			ora 	IM2,x
.22ac	60		rts				rts
.22ad					IFloatSetZero:
.22ad	a9 00		lda #$00			lda 	#0
.22af					IFloatSetByte:
.22af	95 00		sta $00,x			sta 	IM0,x 						; set mantissa to 00A
.22b1	74 01		stz $01,x			stz 	IM1,x
.22b3	74 02		stz $02,x			stz 	IM2,x
.22b5	74 03		stz $03,x			stz 	IExp,x 						; zero the exponent.
.22b7	60		rts				rts
.22b8					IFloatNegate:
.22b8	b5 03		lda $03,x			lda 	IExp,x
.22ba	49 40		eor #$40			eor 	#IFSign
.22bc	95 03		sta $03,x			sta 	IExp,x
.22be	18		clc				clc
.22bf	60		rts				rts
.22c0					IFloatMantissaNegate:
.22c0	38		sec				sec
.22c1	a9 00		lda #$00			lda 	#0
.22c3	f5 00		sbc $00,x			sbc 	IM0,x
.22c5	95 00		sta $00,x			sta 	IM0,x
.22c7	a9 00		lda #$00			lda 	#0
.22c9	f5 01		sbc $01,x			sbc 	IM1,x
.22cb	95 01		sta $01,x			sta 	IM1,x
.22cd	a9 00		lda #$00			lda 	#0
.22cf	f5 02		sbc $02,x			sbc 	IM2,x
.22d1	95 02		sta $02,x			sta 	IM2,x
.22d3	60		rts				rts
.22d4					IFloatShiftLeft:
.22d4	18		clc				clc
.22d5					IFloatRotateLeft:
.22d5	36 00		rol $00,x			rol 	IM0,x
.22d7	36 01		rol $01,x			rol 	IM1,x
.22d9	36 02		rol $02,x			rol 	IM2,x
.22db	60		rts				rts
.22dc					IFloatShiftRight:
.22dc	18		clc				clc
.22dd					IFloatRotateRight:
.22dd	76 02		ror $02,x			ror 	IM2,x
.22df	76 01		ror $01,x			ror 	IM1,x
.22e1	76 00		ror $00,x			ror 	IM0,x
.22e3	60		rts				rts
.22e4					IFloatNormalise:
.22e4	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero 			; is it zero
.22e7	f0 18		beq $2301			beq 	_IFNExitZero 				; if so exit
.22e9					_IFNLoop:
.22e9	b5 02		lda $02,x			lda 	IM2,x 						; is it normalised e.g. bits 7/6 are 01
.22eb	29 c0		and #$c0			and 	#$C0
.22ed	c9 40		cmp #$40			cmp 	#$40
.22ef	f0 13		beq $2304			beq 	_IFNExitOkay 				; if so , then we are done.
.22f1	b5 03		lda $03,x			lda 	IExp,x 						; check exponent is not -32 already.
.22f3	29 3f		and #$3f			and 	#$3F
.22f5	c9 20		cmp #$20			cmp 	#$20
.22f7	f0 0b		beq $2304			beq 	_IFNExitOkay 				; if so, then we cannot normalise any more.
.22f9	20 1a 23	jsr $231a			jsr 	IFloatDecExponent
.22fc	20 d4 22	jsr $22d4			jsr 	IFloatShiftLeft 			; shift mantissa left, e.g. multiply by 2
.22ff	80 e8		bra $22e9			bra 	_IFNLoop
.2301					_IFNExitZero:
.2301	20 ad 22	jsr $22ad			jsr 	IFloatSetZero 				; set the result to zero
.2304					_IFNExitOkay:
.2304	18		clc				clc  								; return with CC.
.2305	60		rts				rts
.2306					IFloatIncExponent:
.2306	b5 03		lda $03,x			lda 	IExp,x
.2308	48		pha				pha
.2309	29 c0		and #$c0			and 	#$C0
.230b	8d 93 04	sta $0493			sta 	IFXTemp
.230e	68		pla				pla
.230f	1a		inc a				inc 	a
.2310	29 3f		and #$3f			and 	#$3F
.2312	48		pha				pha
.2313	0d 93 04	ora $0493			ora 	IFXTemp
.2316	95 03		sta $03,x			sta 	IExp,x
.2318	68		pla				pla
.2319	60		rts				rts
.231a					IFloatDecExponent:
.231a	b5 03		lda $03,x			lda 	IExp,x
.231c	48		pha				pha
.231d	29 c0		and #$c0			and 	#$C0
.231f	8d 93 04	sta $0493			sta 	IFXTemp
.2322	68		pla				pla
.2323	3a		dec a				dec 	a
.2324	29 3f		and #$3f			and 	#$3F
.2326	48		pha				pha
.2327	0d 93 04	ora $0493			ora 	IFXTemp
.232a	95 03		sta $03,x			sta 	IExp,x
.232c	68		pla				pla
.232d	60		rts				rts
.0493					IFXTemp:
>0493							.fill 	1
.232e					IFloatBufferReset:
.232e	9c 94 04	stz $0494			stz 	IFBufferCount
.2331	9c 95 04	stz $0495			stz 	IFBuffer
.2334	60		rts				rts
.2335					IFloatGetBufferAddress:
.2335	a0 04		ldy #$04			ldy 	#(IFBuffer >> 8)
.2337	a2 95		ldx #$95			ldx 	#(IFBuffer & $FF)
.2339	ad 94 04	lda $0494			lda 	IFBufferCount
.233c	60		rts				rts
.233d					IFloatBufferWrite:
.233d	da		phx				phx
.233e	ae 94 04	ldx $0494			ldx 	IFBufferCount
.2341	9d 95 04	sta $0495,x			sta 	IFBuffer,x
.2344	9e 96 04	stz $0496,x			stz 	IFBuffer+1,x
.2347	ee 94 04	inc $0494			inc 	IFBufferCount
.234a	fa		plx				plx
.234b	60		rts				rts
.234c					IFloatStripTrailingZeros:
.234c	ae 94 04	ldx $0494			ldx 	IFBufferCount
.234f	bd 94 04	lda $0494,x			lda 	IFBuffer-1,x
.2352	c9 30		cmp #$30			cmp		#"0"
.2354	d0 0f		bne $2365			bne 	_IFSTExit
.2356	bd 93 04	lda $0493,x			lda 	IFBuffer-2,x
.2359	c9 2e		cmp #$2e			cmp 	#"."
.235b	f0 08		beq $2365			beq 	_IFSTExit
.235d	ce 94 04	dec $0494			dec 	IFBufferCount
.2360	9e 94 04	stz $0494,x			stz 	IFBuffer-1,x
.2363	80 e7		bra $234c			bra 	IFloatStripTrailingZeros
.2365					_IFSTExit:
.2365	60		rts				rts
.0494					IFBufferCount:
>0494							.fill 	1
.0495					IFBuffer:
>0495							.fill 	25
.2366					IFloatCheck:
.2366	a5 0f		lda $0f				lda 	IFR0+IExp					; force it negative
.2368	09 40		ora #$40			ora 	#IFSign
.236a	85 0f		sta $0f				sta 	IFR0+IExp
.236c	20 a3 1c	jsr $1ca3			jsr 	IFloatAdd 					; add allowed to error.
.236f	a2 0c		ldx #$0c			ldx 	#IFR0
.2371	20 a6 22	jsr $22a6			jsr 	IFloatCheckZero 			; error if < 0
.2374	f0 06		beq $237c			beq 	_IFAOkay
.2376	a5 0f		lda $0f				lda 	IFR0+IExp
.2378	29 40		and #$40			and 	#IFSign
.237a	d0 01		bne $237d			bne 	_IFAFail
.237c					_IFAOkay:
.237c	60		rts				rts
.237d					_IFAFail:
.237d	38		sec				sec
.237e	68		pla				pla 								; get address - 2
.237f	e9 02		sbc #$02			sbc 	#2
.2381	aa		tax				tax
.2382	68		pla				pla
.2383	e9 00		sbc #$00			sbc 	#0
.2385	a8		tay				tay
.2386	a9 aa		lda #$aa			lda 	#$AA 						; sign assert
.2388					_IFAStop:
>2388	db						.byte 	$DB 						; display an error AA ADR ADR
.2389	80 fd		bra $2388			bra 	_IFAStop

;******  Return to file: basic.asm

.238b					NotImplemented:
.238b	a9 ff		lda #$ff			lda 	#$FF
.238d	80 04		bra $2393			bra 	EnterDbg
.238f					ErrorHandler:
.238f	fa		plx				plx
.2390	7a		ply				ply
.2391	a9 ee		lda #$ee			lda 	#$EE
.2393					EnterDbg:
>2393	db						.byte 	$DB
.2394	4c 93 23	jmp $2393			jmp 	EnterDbg

;******  End of listing
