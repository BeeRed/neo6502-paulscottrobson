
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -q -Wall -c -C -b -L build/code.lst -l build/code.lbl -D "BASICLOAD=\$1000" -D "BASICCODE=\$6000" -D "ENDMEMORY=\$B000" -D STACKPAGES=2 -D runEdit=1 -o build/basic.bin basic.asm
; Tue Jun  6 03:32:14 2023

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=$1000					BASICLOAD=$1000
=$6000					BASICCODE=$6000
=$b000					ENDMEMORY=$B000
=2					STACKPAGES=2
=1					runEdit=1

;******  Processing input file: basic.asm


;******  Processing file: build/ramdata.inc

=$08					ZeroPageBase = $08 							; zero page usage
=$200					StorageBase = $200 							; ROM usage
.0008					rTemp0:
>0008							.fill 	2
.000a					iTemp0:
>000a							.fill 	2
.000c					IFR0:
>000c							.fill 	4
.0010					IFR1:
>0010							.fill 	4
.0014					IFR2:
>0014							.fill 	4
.0018					IFRTemp:
>0018							.fill 	4
.0200					OSXPos:
>0200							.fill 	1
.0201					OSYPos:
>0201							.fill 	1
.0202					OSXSize:
>0202							.fill 	1
.0203					OSYSize:
>0203							.fill 	1
=16					OSKeyboardQueueMaxSize = 16					; keyboard queue max size.
.0204					OSKeyStatus:
>0204							.fill 	32
.0224					OSKeyboardQueue:
>0224							.fill 	OSKeyboardQueueMaxSize
.0234					OSKeyboardQueueSize:
>0234							.fill 	1
.0235					OSIsKeyUp:
>0235							.fill 	1
.0236					OSIsKeyShift:
>0236							.fill 	1
.0237					OSRKOriginal:
>0237							.fill 	1
=192					OSTextBufferSize = 192
.0238					OSXEdit:
>0238							.fill 	1
.0239					OSYEdit:
>0239							.fill 	1
.023a					OSEditWidth:
>023a							.fill 	1
.023b					OSEditPos:
>023b							.fill 	1
.023c					OSEditScroll:
>023c							.fill 	1
.023d					OSEditLength:
>023d							.fill 	1
.023e					OSEditBuffer:
>023e							.fill 	OSTextBufferSize+1
>02ff							.fill 	32
>031f							.align 	256

;******  Return to file: basic.asm


;******  Processing file: build/osvectors.inc

=$ffe5					OSGetScreenSize          = $ffe5 ; Get size of screen to XY
=$ffe8					OSIsKeyAvailable         = $ffe8 ; Check if key available (CS if so)
=$ffeb					OSReadKeystroke          = $ffeb ; Read A from keyboard, showing cursor while waiting.
=$ffee					OSReadKeyboard           = $ffee ; Read A from keyboard (device 1), CC = success
=$fff1					OSWriteScreen            = $fff1 ; Write A to screen (device 0), CC = success
=$fff4					OSReadDevice             = $fff4 ; Read device X to A, CC = success
=$fff7					OSWriteDevice            = $fff7 ; Write A to device X, CC = success

;******  Return to file: basic.asm

=0					runEdit = 0 								; setting to 1 builds with the program/testing stuff in.
=0					autoRun = 0 								; setting to 1 autoruns program in memory space.
.1000					boot:
.1000	a2 60		ldx #$60			ldx 	#BASICCODE >> 8 			; common setup
.1002	a0 b0		ldy #$b0			ldy 	#ENDMEMORY >> 8
.1004	20 60 39	jsr $3960			jsr 	PGMSetBaseAddress
.1007	20 90 43	jsr $4390			jsr 	IFInitialise 				; setup math library
.100a	4c 0d 10	jmp $100d			jmp 	TestCode

;******  Processing file: src/program/testing/testing.asmx

.100d					TestCode:
.100d	20 67 39	jsr $3967			jsr 	PGMNewProgram
.1010	9c ff ff	stz $ffff			stz 	$FFFF

;******  Processing file: src/program/testing/testrun.incx

.1013	a2 5e		ldx #$5e		ldx #Line0 & $FF
.1015	a0 13		ldy #$13		ldy #Line0 >> 8
.1017	20 70 2c	jsr $2c70		jsr TOKOneLine
.101a	a2 99		ldx #$99		ldx #Line1 & $FF
.101c	a0 13		ldy #$13		ldy #Line1 >> 8
.101e	20 70 2c	jsr $2c70		jsr TOKOneLine
.1021	a2 cb		ldx #$cb		ldx #Line2 & $FF
.1023	a0 13		ldy #$13		ldy #Line2 >> 8
.1025	20 70 2c	jsr $2c70		jsr TOKOneLine
.1028	a2 09		ldx #$09		ldx #Line3 & $FF
.102a	a0 14		ldy #$14		ldy #Line3 >> 8
.102c	20 70 2c	jsr $2c70		jsr TOKOneLine
.102f	a2 28		ldx #$28		ldx #Line4 & $FF
.1031	a0 14		ldy #$14		ldy #Line4 >> 8
.1033	20 70 2c	jsr $2c70		jsr TOKOneLine
.1036	a2 9a		ldx #$9a		ldx #Line5 & $FF
.1038	a0 14		ldy #$14		ldy #Line5 >> 8
.103a	20 70 2c	jsr $2c70		jsr TOKOneLine
.103d	a2 a9		ldx #$a9		ldx #Line6 & $FF
.103f	a0 14		ldy #$14		ldy #Line6 >> 8
.1041	20 70 2c	jsr $2c70		jsr TOKOneLine
.1044	a2 10		ldx #$10		ldx #Line7 & $FF
.1046	a0 15		ldy #$15		ldy #Line7 >> 8
.1048	20 70 2c	jsr $2c70		jsr TOKOneLine
.104b	a2 3c		ldx #$3c		ldx #Line8 & $FF
.104d	a0 15		ldy #$15		ldy #Line8 >> 8
.104f	20 70 2c	jsr $2c70		jsr TOKOneLine
.1052	a2 7a		ldx #$7a		ldx #Line9 & $FF
.1054	a0 15		ldy #$15		ldy #Line9 >> 8
.1056	20 70 2c	jsr $2c70		jsr TOKOneLine
.1059	a2 7e		ldx #$7e		ldx #Line10 & $FF
.105b	a0 15		ldy #$15		ldy #Line10 >> 8
.105d	20 70 2c	jsr $2c70		jsr TOKOneLine
.1060	a2 e8		ldx #$e8		ldx #Line11 & $FF
.1062	a0 15		ldy #$15		ldy #Line11 >> 8
.1064	20 70 2c	jsr $2c70		jsr TOKOneLine
.1067	a2 ec		ldx #$ec		ldx #Line12 & $FF
.1069	a0 15		ldy #$15		ldy #Line12 >> 8
.106b	20 70 2c	jsr $2c70		jsr TOKOneLine
.106e	a2 f0		ldx #$f0		ldx #Line13 & $FF
.1070	a0 15		ldy #$15		ldy #Line13 >> 8
.1072	20 70 2c	jsr $2c70		jsr TOKOneLine
.1075	a2 2e		ldx #$2e		ldx #Line14 & $FF
.1077	a0 16		ldy #$16		ldy #Line14 >> 8
.1079	20 70 2c	jsr $2c70		jsr TOKOneLine
.107c	a2 32		ldx #$32		ldx #Line15 & $FF
.107e	a0 16		ldy #$16		ldy #Line15 >> 8
.1080	20 70 2c	jsr $2c70		jsr TOKOneLine
.1083	a2 36		ldx #$36		ldx #Line16 & $FF
.1085	a0 16		ldy #$16		ldy #Line16 >> 8
.1087	20 70 2c	jsr $2c70		jsr TOKOneLine
.108a	a2 4e		ldx #$4e		ldx #Line17 & $FF
.108c	a0 16		ldy #$16		ldy #Line17 >> 8
.108e	20 70 2c	jsr $2c70		jsr TOKOneLine
.1091	a2 52		ldx #$52		ldx #Line18 & $FF
.1093	a0 16		ldy #$16		ldy #Line18 >> 8
.1095	20 70 2c	jsr $2c70		jsr TOKOneLine
.1098	a2 c8		ldx #$c8		ldx #Line19 & $FF
.109a	a0 16		ldy #$16		ldy #Line19 >> 8
.109c	20 70 2c	jsr $2c70		jsr TOKOneLine
.109f	a2 e1		ldx #$e1		ldx #Line20 & $FF
.10a1	a0 16		ldy #$16		ldy #Line20 >> 8
.10a3	20 70 2c	jsr $2c70		jsr TOKOneLine
.10a6	a2 1c		ldx #$1c		ldx #Line21 & $FF
.10a8	a0 17		ldy #$17		ldy #Line21 >> 8
.10aa	20 70 2c	jsr $2c70		jsr TOKOneLine
.10ad	a2 20		ldx #$20		ldx #Line22 & $FF
.10af	a0 17		ldy #$17		ldy #Line22 >> 8
.10b1	20 70 2c	jsr $2c70		jsr TOKOneLine
.10b4	a2 53		ldx #$53		ldx #Line23 & $FF
.10b6	a0 17		ldy #$17		ldy #Line23 >> 8
.10b8	20 70 2c	jsr $2c70		jsr TOKOneLine
.10bb	a2 cd		ldx #$cd		ldx #Line24 & $FF
.10bd	a0 17		ldy #$17		ldy #Line24 >> 8
.10bf	20 70 2c	jsr $2c70		jsr TOKOneLine
.10c2	a2 49		ldx #$49		ldx #Line25 & $FF
.10c4	a0 18		ldy #$18		ldy #Line25 >> 8
.10c6	20 70 2c	jsr $2c70		jsr TOKOneLine
.10c9	a2 82		ldx #$82		ldx #Line26 & $FF
.10cb	a0 18		ldy #$18		ldy #Line26 >> 8
.10cd	20 70 2c	jsr $2c70		jsr TOKOneLine
.10d0	a2 8f		ldx #$8f		ldx #Line27 & $FF
.10d2	a0 18		ldy #$18		ldy #Line27 >> 8
.10d4	20 70 2c	jsr $2c70		jsr TOKOneLine
.10d7	a2 0a		ldx #$0a		ldx #Line28 & $FF
.10d9	a0 19		ldy #$19		ldy #Line28 >> 8
.10db	20 70 2c	jsr $2c70		jsr TOKOneLine
.10de	a2 6c		ldx #$6c		ldx #Line29 & $FF
.10e0	a0 19		ldy #$19		ldy #Line29 >> 8
.10e2	20 70 2c	jsr $2c70		jsr TOKOneLine
.10e5	a2 bb		ldx #$bb		ldx #Line30 & $FF
.10e7	a0 19		ldy #$19		ldy #Line30 >> 8
.10e9	20 70 2c	jsr $2c70		jsr TOKOneLine
.10ec	a2 34		ldx #$34		ldx #Line31 & $FF
.10ee	a0 1a		ldy #$1a		ldy #Line31 >> 8
.10f0	20 70 2c	jsr $2c70		jsr TOKOneLine
.10f3	a2 71		ldx #$71		ldx #Line32 & $FF
.10f5	a0 1a		ldy #$1a		ldy #Line32 >> 8
.10f7	20 70 2c	jsr $2c70		jsr TOKOneLine
.10fa	a2 a4		ldx #$a4		ldx #Line33 & $FF
.10fc	a0 1a		ldy #$1a		ldy #Line33 >> 8
.10fe	20 70 2c	jsr $2c70		jsr TOKOneLine
.1101	a2 b7		ldx #$b7		ldx #Line34 & $FF
.1103	a0 1a		ldy #$1a		ldy #Line34 >> 8
.1105	20 70 2c	jsr $2c70		jsr TOKOneLine
.1108	a2 19		ldx #$19		ldx #Line35 & $FF
.110a	a0 1b		ldy #$1b		ldy #Line35 >> 8
.110c	20 70 2c	jsr $2c70		jsr TOKOneLine
.110f	a2 55		ldx #$55		ldx #Line36 & $FF
.1111	a0 1b		ldy #$1b		ldy #Line36 >> 8
.1113	20 70 2c	jsr $2c70		jsr TOKOneLine
.1116	a2 a4		ldx #$a4		ldx #Line37 & $FF
.1118	a0 1b		ldy #$1b		ldy #Line37 >> 8
.111a	20 70 2c	jsr $2c70		jsr TOKOneLine
.111d	a2 a8		ldx #$a8		ldx #Line38 & $FF
.111f	a0 1b		ldy #$1b		ldy #Line38 >> 8
.1121	20 70 2c	jsr $2c70		jsr TOKOneLine
.1124	a2 ac		ldx #$ac		ldx #Line39 & $FF
.1126	a0 1b		ldy #$1b		ldy #Line39 >> 8
.1128	20 70 2c	jsr $2c70		jsr TOKOneLine
.112b	a2 14		ldx #$14		ldx #Line40 & $FF
.112d	a0 1c		ldy #$1c		ldy #Line40 >> 8
.112f	20 70 2c	jsr $2c70		jsr TOKOneLine
.1132	a2 59		ldx #$59		ldx #Line41 & $FF
.1134	a0 1c		ldy #$1c		ldy #Line41 >> 8
.1136	20 70 2c	jsr $2c70		jsr TOKOneLine
.1139	a2 64		ldx #$64		ldx #Line42 & $FF
.113b	a0 1c		ldy #$1c		ldy #Line42 >> 8
.113d	20 70 2c	jsr $2c70		jsr TOKOneLine
.1140	a2 ca		ldx #$ca		ldx #Line43 & $FF
.1142	a0 1c		ldy #$1c		ldy #Line43 >> 8
.1144	20 70 2c	jsr $2c70		jsr TOKOneLine
.1147	a2 da		ldx #$da		ldx #Line44 & $FF
.1149	a0 1c		ldy #$1c		ldy #Line44 >> 8
.114b	20 70 2c	jsr $2c70		jsr TOKOneLine
.114e	a2 21		ldx #$21		ldx #Line45 & $FF
.1150	a0 1d		ldy #$1d		ldy #Line45 >> 8
.1152	20 70 2c	jsr $2c70		jsr TOKOneLine
.1155	a2 30		ldx #$30		ldx #Line46 & $FF
.1157	a0 1d		ldy #$1d		ldy #Line46 >> 8
.1159	20 70 2c	jsr $2c70		jsr TOKOneLine
.115c	a2 6b		ldx #$6b		ldx #Line47 & $FF
.115e	a0 1d		ldy #$1d		ldy #Line47 >> 8
.1160	20 70 2c	jsr $2c70		jsr TOKOneLine
.1163	a2 c5		ldx #$c5		ldx #Line48 & $FF
.1165	a0 1d		ldy #$1d		ldy #Line48 >> 8
.1167	20 70 2c	jsr $2c70		jsr TOKOneLine
.116a	a2 1a		ldx #$1a		ldx #Line49 & $FF
.116c	a0 1e		ldy #$1e		ldy #Line49 >> 8
.116e	20 70 2c	jsr $2c70		jsr TOKOneLine
.1171	a2 4e		ldx #$4e		ldx #Line50 & $FF
.1173	a0 1e		ldy #$1e		ldy #Line50 >> 8
.1175	20 70 2c	jsr $2c70		jsr TOKOneLine
.1178	a2 ac		ldx #$ac		ldx #Line51 & $FF
.117a	a0 1e		ldy #$1e		ldy #Line51 >> 8
.117c	20 70 2c	jsr $2c70		jsr TOKOneLine
.117f	a2 b3		ldx #$b3		ldx #Line52 & $FF
.1181	a0 1e		ldy #$1e		ldy #Line52 >> 8
.1183	20 70 2c	jsr $2c70		jsr TOKOneLine
.1186	a2 ea		ldx #$ea		ldx #Line53 & $FF
.1188	a0 1e		ldy #$1e		ldy #Line53 >> 8
.118a	20 70 2c	jsr $2c70		jsr TOKOneLine
.118d	a2 f2		ldx #$f2		ldx #Line54 & $FF
.118f	a0 1e		ldy #$1e		ldy #Line54 >> 8
.1191	20 70 2c	jsr $2c70		jsr TOKOneLine
.1194	a2 64		ldx #$64		ldx #Line55 & $FF
.1196	a0 1f		ldy #$1f		ldy #Line55 >> 8
.1198	20 70 2c	jsr $2c70		jsr TOKOneLine
.119b	a2 ab		ldx #$ab		ldx #Line56 & $FF
.119d	a0 1f		ldy #$1f		ldy #Line56 >> 8
.119f	20 70 2c	jsr $2c70		jsr TOKOneLine
.11a2	a2 17		ldx #$17		ldx #Line57 & $FF
.11a4	a0 20		ldy #$20		ldy #Line57 >> 8
.11a6	20 70 2c	jsr $2c70		jsr TOKOneLine
.11a9	a2 36		ldx #$36		ldx #Line58 & $FF
.11ab	a0 20		ldy #$20		ldy #Line58 >> 8
.11ad	20 70 2c	jsr $2c70		jsr TOKOneLine
.11b0	a2 67		ldx #$67		ldx #Line59 & $FF
.11b2	a0 20		ldy #$20		ldy #Line59 >> 8
.11b4	20 70 2c	jsr $2c70		jsr TOKOneLine
.11b7	a2 6b		ldx #$6b		ldx #Line60 & $FF
.11b9	a0 20		ldy #$20		ldy #Line60 >> 8
.11bb	20 70 2c	jsr $2c70		jsr TOKOneLine
.11be	a2 cb		ldx #$cb		ldx #Line61 & $FF
.11c0	a0 20		ldy #$20		ldy #Line61 >> 8
.11c2	20 70 2c	jsr $2c70		jsr TOKOneLine
.11c5	a2 29		ldx #$29		ldx #Line62 & $FF
.11c7	a0 21		ldy #$21		ldy #Line62 >> 8
.11c9	20 70 2c	jsr $2c70		jsr TOKOneLine
.11cc	a2 64		ldx #$64		ldx #Line63 & $FF
.11ce	a0 21		ldy #$21		ldy #Line63 >> 8
.11d0	20 70 2c	jsr $2c70		jsr TOKOneLine
.11d3	a2 a3		ldx #$a3		ldx #Line64 & $FF
.11d5	a0 21		ldy #$21		ldy #Line64 >> 8
.11d7	20 70 2c	jsr $2c70		jsr TOKOneLine
.11da	a2 a7		ldx #$a7		ldx #Line65 & $FF
.11dc	a0 21		ldy #$21		ldy #Line65 >> 8
.11de	20 70 2c	jsr $2c70		jsr TOKOneLine
.11e1	a2 ab		ldx #$ab		ldx #Line66 & $FF
.11e3	a0 21		ldy #$21		ldy #Line66 >> 8
.11e5	20 70 2c	jsr $2c70		jsr TOKOneLine
.11e8	a2 b3		ldx #$b3		ldx #Line67 & $FF
.11ea	a0 21		ldy #$21		ldy #Line67 >> 8
.11ec	20 70 2c	jsr $2c70		jsr TOKOneLine
.11ef	a2 28		ldx #$28		ldx #Line68 & $FF
.11f1	a0 22		ldy #$22		ldy #Line68 >> 8
.11f3	20 70 2c	jsr $2c70		jsr TOKOneLine
.11f6	a2 4e		ldx #$4e		ldx #Line69 & $FF
.11f8	a0 22		ldy #$22		ldy #Line69 >> 8
.11fa	20 70 2c	jsr $2c70		jsr TOKOneLine
.11fd	a2 52		ldx #$52		ldx #Line70 & $FF
.11ff	a0 22		ldy #$22		ldy #Line70 >> 8
.1201	20 70 2c	jsr $2c70		jsr TOKOneLine
.1204	a2 63		ldx #$63		ldx #Line71 & $FF
.1206	a0 22		ldy #$22		ldy #Line71 >> 8
.1208	20 70 2c	jsr $2c70		jsr TOKOneLine
.120b	a2 76		ldx #$76		ldx #Line72 & $FF
.120d	a0 22		ldy #$22		ldy #Line72 >> 8
.120f	20 70 2c	jsr $2c70		jsr TOKOneLine
.1212	a2 bd		ldx #$bd		ldx #Line73 & $FF
.1214	a0 22		ldy #$22		ldy #Line73 >> 8
.1216	20 70 2c	jsr $2c70		jsr TOKOneLine
.1219	a2 c1		ldx #$c1		ldx #Line74 & $FF
.121b	a0 22		ldy #$22		ldy #Line74 >> 8
.121d	20 70 2c	jsr $2c70		jsr TOKOneLine
.1220	a2 e2		ldx #$e2		ldx #Line75 & $FF
.1222	a0 22		ldy #$22		ldy #Line75 >> 8
.1224	20 70 2c	jsr $2c70		jsr TOKOneLine
.1227	a2 45		ldx #$45		ldx #Line76 & $FF
.1229	a0 23		ldy #$23		ldy #Line76 >> 8
.122b	20 70 2c	jsr $2c70		jsr TOKOneLine
.122e	a2 53		ldx #$53		ldx #Line77 & $FF
.1230	a0 23		ldy #$23		ldy #Line77 >> 8
.1232	20 70 2c	jsr $2c70		jsr TOKOneLine
.1235	a2 e3		ldx #$e3		ldx #Line78 & $FF
.1237	a0 23		ldy #$23		ldy #Line78 >> 8
.1239	20 70 2c	jsr $2c70		jsr TOKOneLine
.123c	a2 23		ldx #$23		ldx #Line79 & $FF
.123e	a0 24		ldy #$24		ldy #Line79 >> 8
.1240	20 70 2c	jsr $2c70		jsr TOKOneLine
.1243	a2 27		ldx #$27		ldx #Line80 & $FF
.1245	a0 24		ldy #$24		ldy #Line80 >> 8
.1247	20 70 2c	jsr $2c70		jsr TOKOneLine
.124a	a2 58		ldx #$58		ldx #Line81 & $FF
.124c	a0 24		ldy #$24		ldy #Line81 >> 8
.124e	20 70 2c	jsr $2c70		jsr TOKOneLine
.1251	a2 74		ldx #$74		ldx #Line82 & $FF
.1253	a0 24		ldy #$24		ldy #Line82 >> 8
.1255	20 70 2c	jsr $2c70		jsr TOKOneLine
.1258	a2 df		ldx #$df		ldx #Line83 & $FF
.125a	a0 24		ldy #$24		ldy #Line83 >> 8
.125c	20 70 2c	jsr $2c70		jsr TOKOneLine
.125f	a2 3f		ldx #$3f		ldx #Line84 & $FF
.1261	a0 25		ldy #$25		ldy #Line84 >> 8
.1263	20 70 2c	jsr $2c70		jsr TOKOneLine
.1266	a2 69		ldx #$69		ldx #Line85 & $FF
.1268	a0 25		ldy #$25		ldy #Line85 >> 8
.126a	20 70 2c	jsr $2c70		jsr TOKOneLine
.126d	a2 98		ldx #$98		ldx #Line86 & $FF
.126f	a0 25		ldy #$25		ldy #Line86 >> 8
.1271	20 70 2c	jsr $2c70		jsr TOKOneLine
.1274	a2 ff		ldx #$ff		ldx #Line87 & $FF
.1276	a0 25		ldy #$25		ldy #Line87 >> 8
.1278	20 70 2c	jsr $2c70		jsr TOKOneLine
.127b	a2 1b		ldx #$1b		ldx #Line88 & $FF
.127d	a0 26		ldy #$26		ldy #Line88 >> 8
.127f	20 70 2c	jsr $2c70		jsr TOKOneLine
.1282	a2 4e		ldx #$4e		ldx #Line89 & $FF
.1284	a0 26		ldy #$26		ldy #Line89 >> 8
.1286	20 70 2c	jsr $2c70		jsr TOKOneLine
.1289	a2 52		ldx #$52		ldx #Line90 & $FF
.128b	a0 26		ldy #$26		ldy #Line90 >> 8
.128d	20 70 2c	jsr $2c70		jsr TOKOneLine
.1290	a2 95		ldx #$95		ldx #Line91 & $FF
.1292	a0 26		ldy #$26		ldy #Line91 >> 8
.1294	20 70 2c	jsr $2c70		jsr TOKOneLine
.1297	a2 0c		ldx #$0c		ldx #Line92 & $FF
.1299	a0 27		ldy #$27		ldy #Line92 >> 8
.129b	20 70 2c	jsr $2c70		jsr TOKOneLine
.129e	a2 30		ldx #$30		ldx #Line93 & $FF
.12a0	a0 27		ldy #$27		ldy #Line93 >> 8
.12a2	20 70 2c	jsr $2c70		jsr TOKOneLine
.12a5	a2 34		ldx #$34		ldx #Line94 & $FF
.12a7	a0 27		ldy #$27		ldy #Line94 >> 8
.12a9	20 70 2c	jsr $2c70		jsr TOKOneLine
.12ac	a2 3c		ldx #$3c		ldx #Line95 & $FF
.12ae	a0 27		ldy #$27		ldy #Line95 >> 8
.12b0	20 70 2c	jsr $2c70		jsr TOKOneLine
.12b3	a2 83		ldx #$83		ldx #Line96 & $FF
.12b5	a0 27		ldy #$27		ldy #Line96 >> 8
.12b7	20 70 2c	jsr $2c70		jsr TOKOneLine
.12ba	a2 da		ldx #$da		ldx #Line97 & $FF
.12bc	a0 27		ldy #$27		ldy #Line97 >> 8
.12be	20 70 2c	jsr $2c70		jsr TOKOneLine
.12c1	a2 19		ldx #$19		ldx #Line98 & $FF
.12c3	a0 28		ldy #$28		ldy #Line98 >> 8
.12c5	20 70 2c	jsr $2c70		jsr TOKOneLine
.12c8	a2 25		ldx #$25		ldx #Line99 & $FF
.12ca	a0 28		ldy #$28		ldy #Line99 >> 8
.12cc	20 70 2c	jsr $2c70		jsr TOKOneLine
.12cf	a2 5d		ldx #$5d		ldx #Line100 & $FF
.12d1	a0 28		ldy #$28		ldy #Line100 >> 8
.12d3	20 70 2c	jsr $2c70		jsr TOKOneLine
.12d6	a2 d0		ldx #$d0		ldx #Line101 & $FF
.12d8	a0 28		ldy #$28		ldy #Line101 >> 8
.12da	20 70 2c	jsr $2c70		jsr TOKOneLine
.12dd	a2 08		ldx #$08		ldx #Line102 & $FF
.12df	a0 29		ldy #$29		ldy #Line102 >> 8
.12e1	20 70 2c	jsr $2c70		jsr TOKOneLine
.12e4	a2 3c		ldx #$3c		ldx #Line103 & $FF
.12e6	a0 29		ldy #$29		ldy #Line103 >> 8
.12e8	20 70 2c	jsr $2c70		jsr TOKOneLine
.12eb	a2 86		ldx #$86		ldx #Line104 & $FF
.12ed	a0 29		ldy #$29		ldy #Line104 >> 8
.12ef	20 70 2c	jsr $2c70		jsr TOKOneLine
.12f2	a2 8a		ldx #$8a		ldx #Line105 & $FF
.12f4	a0 29		ldy #$29		ldy #Line105 >> 8
.12f6	20 70 2c	jsr $2c70		jsr TOKOneLine
.12f9	a2 8e		ldx #$8e		ldx #Line106 & $FF
.12fb	a0 29		ldy #$29		ldy #Line106 >> 8
.12fd	20 70 2c	jsr $2c70		jsr TOKOneLine
.1300	a2 b9		ldx #$b9		ldx #Line107 & $FF
.1302	a0 29		ldy #$29		ldy #Line107 >> 8
.1304	20 70 2c	jsr $2c70		jsr TOKOneLine
.1307	a2 13		ldx #$13		ldx #Line108 & $FF
.1309	a0 2a		ldy #$2a		ldy #Line108 >> 8
.130b	20 70 2c	jsr $2c70		jsr TOKOneLine
.130e	a2 17		ldx #$17		ldx #Line109 & $FF
.1310	a0 2a		ldy #$2a		ldy #Line109 >> 8
.1312	20 70 2c	jsr $2c70		jsr TOKOneLine
.1315	a2 32		ldx #$32		ldx #Line110 & $FF
.1317	a0 2a		ldy #$2a		ldy #Line110 >> 8
.1319	20 70 2c	jsr $2c70		jsr TOKOneLine
.131c	a2 98		ldx #$98		ldx #Line111 & $FF
.131e	a0 2a		ldy #$2a		ldy #Line111 >> 8
.1320	20 70 2c	jsr $2c70		jsr TOKOneLine
.1323	a2 cb		ldx #$cb		ldx #Line112 & $FF
.1325	a0 2a		ldy #$2a		ldy #Line112 >> 8
.1327	20 70 2c	jsr $2c70		jsr TOKOneLine
.132a	a2 1f		ldx #$1f		ldx #Line113 & $FF
.132c	a0 2b		ldy #$2b		ldy #Line113 >> 8
.132e	20 70 2c	jsr $2c70		jsr TOKOneLine
.1331	a2 23		ldx #$23		ldx #Line114 & $FF
.1333	a0 2b		ldy #$2b		ldy #Line114 >> 8
.1335	20 70 2c	jsr $2c70		jsr TOKOneLine
.1338	a2 41		ldx #$41		ldx #Line115 & $FF
.133a	a0 2b		ldy #$2b		ldy #Line115 >> 8
.133c	20 70 2c	jsr $2c70		jsr TOKOneLine
.133f	a2 4c		ldx #$4c		ldx #Line116 & $FF
.1341	a0 2b		ldy #$2b		ldy #Line116 >> 8
.1343	20 70 2c	jsr $2c70		jsr TOKOneLine
.1346	a2 c1		ldx #$c1		ldx #Line117 & $FF
.1348	a0 2b		ldy #$2b		ldy #Line117 >> 8
.134a	20 70 2c	jsr $2c70		jsr TOKOneLine
.134d	a2 00		ldx #$00		ldx #Line118 & $FF
.134f	a0 2c		ldy #$2c		ldy #Line118 >> 8
.1351	20 70 2c	jsr $2c70		jsr TOKOneLine
.1354	a2 28		ldx #$28		ldx #Line119 & $FF
.1356	a0 2c		ldy #$2c		ldy #Line119 >> 8
.1358	20 70 2c	jsr $2c70		jsr TOKOneLine

;******  Return to file: src/program/testing/testing.asmx

.135b	4c ff ff	jmp $ffff			jmp 	$FFFF

;******  Processing file: src/program/testing/testdat.incx

.135e					Line0:
>135e	36 31 36 20 4d 24 20 41			.text '616 M$ A4J WHILE XOR 640 4.17* 832 "RL""SLPDM" -8.83"")168',0
>1366	34 4a 20 57 48 49 4c 45 20 58 4f 52 20 36 34 30
>1376	20 34 2e 31 37 2a 20 38 33 32 20 22 52 4c 22 22
>1386	53 4c 50 44 4d 22 20 2d 38 2e 38 33 22 22 29 31
>1396	36 38 00
.1399					Line1:
>1399	38 38 20 20 32 2e 39 32			.text '88  2.92 <= S1T6D-5.81 INPUT <;768 FOR LOAD 864 >',0
>13a1	20 3c 3d 20 53 31 54 36 44 2d 35 2e 38 31 20 49
>13b1	4e 50 55 54 20 3c 3b 37 36 38 20 46 4f 52 20 4c
>13c1	4f 41 44 20 38 36 34 20 3e 00
.13cb					Line2:
>13cb	33 34 34 20 49 46 3d 4c			.text '344 IF=L5D1Y0 680-3.16"S""W@AQPU"C)F9X0L 120- >4.98(LET L4X4/',0
>13d3	35 44 31 59 30 20 36 38 30 2d 33 2e 31 36 22 53
>13e3	22 22 57 40 41 51 50 55 22 43 29 46 39 58 30 4c
>13f3	20 31 32 30 2d 20 3e 34 2e 39 38 28 4c 45 54 20
>1403	4c 34 58 34 2f 00
.1409					Line3:
>1409	37 32 38 20 20 43 32 45			.text '728  C2E4Z("PMDTGLC"-720 "YNK"',0
>1411	34 5a 28 22 50 4d 44 54 47 4c 43 22 2d 37 32 30
>1421	20 22 59 4e 4b 22 00
.1428					Line4:
>1428	38 38 38 20 2d 37 2e 35			.text '888 -7.56 ,(L6Q("FUYX@I"-3.79 3.4 Z U Z0X( 8.92"GPRCM"< 456 = 9.85 648 1000-7.44 400 -7.95 384 ( D4L1X3-0.12-1.49',0
>1430	36 20 2c 28 4c 36 51 28 22 46 55 59 58 40 49 22
>1440	2d 33 2e 37 39 20 33 2e 34 20 5a 20 55 20 5a 30
>1450	58 28 20 38 2e 39 32 22 47 50 52 43 4d 22 3c 20
>1460	34 35 36 20 3d 20 39 2e 38 35 20 36 34 38 20 31
>1470	30 30 30 2d 37 2e 34 34 20 34 30 30 20 2d 37 2e
>1480	39 35 20 33 38 34 20 28 20 44 34 4c 31 58 33 2d
>1490	30 2e 31 32 2d 31 2e 34 39 00
.149a					Line5:
>149a	34 34 30 20 3c 29 20 2b			.text '440 <) +D5 528',0
>14a2	44 35 20 35 32 38 00
.14a9					Line6:
>14a9	37 32 20 35 35 32 22 40			.text '72 552"@LT"496 POKE MOD 0.45 ("ZKPR"400 T7Q1Q +LOAD N5(-6.34 INPUT<J9Y8E REM OR 576"T@F@Q"-3.44=STR$(*',0
>14b1	4c 54 22 34 39 36 20 50 4f 4b 45 20 4d 4f 44 20
>14c1	30 2e 34 35 20 28 22 5a 4b 50 52 22 34 30 30 20
>14d1	54 37 51 31 51 20 2b 4c 4f 41 44 20 4e 35 28 2d
>14e1	36 2e 33 34 20 49 4e 50 55 54 3c 4a 39 59 38 45
>14f1	20 52 45 4d 20 4f 52 20 35 37 36 22 54 40 46 40
>1501	51 22 2d 33 2e 34 34 3d 53 54 52 24 28 2a 00
.1510					Line7:
>1510	31 39 32 20 20 22 54 51			.text '192  "TQ"3.29 2.44 RND(> 728 Q7W5""776 6.23',0
>1518	22 33 2e 32 39 20 32 2e 34 34 20 52 4e 44 28 3e
>1528	20 37 32 38 20 51 37 57 35 22 22 37 37 36 20 36
>1538	2e 32 33 00
.153c					Line8:
>153c	35 36 38 20 4c 45 54 2d			.text '568 LET- "DRIJXWUT" 536 EVENT(-8.22"MSZFECC"B5F9-1.64"K"W(J0F',0
>1544	20 22 44 52 49 4a 58 57 55 54 22 20 35 33 36 20
>1554	45 56 45 4e 54 28 2d 38 2e 32 32 22 4d 53 5a 46
>1564	45 43 43 22 42 35 46 39 2d 31 2e 36 34 22 4b 22
>1574	57 28 4a 30 46 00
.157a					Line9:
>157a	36 38 30 00				.text '680',0
.157e					Line10:
>157e	38 30 20 20 2d 34 2e 39			.text '80  -4.96-8.36> *272"HE"HEX$(-4.34 LIST - < "I"CLEAR "MPCJUUJO"* (ASC((4.49"NLPPIYK"4.13 FRAC(RUN ) "QUD"',0
>1586	36 2d 38 2e 33 36 3e 20 2a 32 37 32 22 48 45 22
>1596	48 45 58 24 28 2d 34 2e 33 34 20 4c 49 53 54 20
>15a6	2d 20 3c 20 22 49 22 43 4c 45 41 52 20 22 4d 50
>15b6	43 4a 55 55 4a 4f 22 2a 20 28 41 53 43 28 28 34
>15c6	2e 34 39 22 4e 4c 50 50 49 59 4b 22 34 2e 31 33
>15d6	20 46 52 41 43 28 52 55 4e 20 29 20 22 51 55 44
>15e6	22 00
.15e8					Line11:
>15e8	34 34 38 00				.text '448',0
.15ec					Line12:
>15ec	31 31 32 00				.text '112',0
.15f0					Line13:
>15f0	39 35 32 20 36 38 30 20			.text '952 680 464 U0K Q(E3E1S Y WEND-5.67"JKQ"O3W7L1 248 -1.0 G0W2(',0
>15f8	34 36 34 20 55 30 4b 20 51 28 45 33 45 31 53 20
>1608	59 20 57 45 4e 44 2d 35 2e 36 37 22 4a 4b 51 22
>1618	4f 33 57 37 4c 31 20 32 34 38 20 2d 31 2e 30 20
>1628	47 30 57 32 28 00
.162e					Line14:
>162e	37 37 36 00				.text '776',0
.1632					Line15:
>1632	36 31 36 00				.text '616',0
.1636					Line16:
>1636	38 30 30 20 38 34 38 20			.text '800 848 6.42 160 Y Q7W5',0
>163e	36 2e 34 32 20 31 36 30 20 59 20 51 37 57 35 00
.164e					Line17:
>164e	38 39 36 00				.text '896',0
.1652					Line18:
>1652	37 34 34 20 32 36 34 20			.text '744 264 K8P6$ -7.47) *M$ HEX$(> "JVPVLI"616 LET:REPEAT"AKD"<= "AXDR"280 Z5F3L4( LEN(MOD 952 0.69 DEEK( "KVFGWEDI">720',0
>165a	4b 38 50 36 24 20 2d 37 2e 34 37 29 20 2a 4d 24
>166a	20 48 45 58 24 28 3e 20 22 4a 56 50 56 4c 49 22
>167a	36 31 36 20 4c 45 54 3a 52 45 50 45 41 54 22 41
>168a	4b 44 22 3c 3d 20 22 41 58 44 52 22 32 38 30 20
>169a	5a 35 46 33 4c 34 28 20 4c 45 4e 28 4d 4f 44 20
>16aa	39 35 32 20 30 2e 36 39 20 44 45 45 4b 28 20 22
>16ba	4b 56 46 47 57 45 44 49 22 3e 37 32 30 00
.16c8					Line19:
>16c8	32 37 32 20 2a 32 2e 32			.text '272 *2.2 INPUT -0.58 E8U',0
>16d0	20 49 4e 50 55 54 20 2d 30 2e 35 38 20 45 38 55
>16e0	00
.16e1					Line20:
>16e1	34 39 36 20 20 56 31 55			.text '496  V1U+3.15 -4.98 7.2 INT( 8.79 1.57>)<> I3R( "XIBL"-1.3',0
>16e9	2b 33 2e 31 35 20 2d 34 2e 39 38 20 37 2e 32 20
>16f9	49 4e 54 28 20 38 2e 37 39 20 31 2e 35 37 3e 29
>1709	3c 3e 20 49 33 52 28 20 22 58 49 42 4c 22 2d 31
>1719	2e 33 00
.171c					Line21:
>171c	31 39 32 00				.text '192',0
.1720					Line22:
>1720	35 30 34 20 2b 20 53 54			.text '504 + STR$(OR* -0.2 552=488 E3E1S E3E1S"SV@N" - D0',0
>1728	52 24 28 4f 52 2a 20 2d 30 2e 32 20 35 35 32 3d
>1738	34 38 38 20 45 33 45 31 53 20 45 33 45 31 53 22
>1748	53 56 40 4e 22 20 2d 20 44 30 00
.1753					Line23:
>1753	34 38 30 20 20 39 2e 38			.text '480  9.87 V6O2("VX"ELSE L3A8(280;7.23 "YXTAKN"R2J R8P1 LEFT$(-1.76 "I" REPEAT 2.96-7.99 0.08/; 296 568<U8D1(1000 Z6I 1.77',0
>175b	37 20 56 36 4f 32 28 22 56 58 22 45 4c 53 45 20
>176b	4c 33 41 38 28 32 38 30 3b 37 2e 32 33 20 22 59
>177b	58 54 41 4b 4e 22 52 32 4a 20 52 38 50 31 20 4c
>178b	45 46 54 24 28 2d 31 2e 37 36 20 22 49 22 20 52
>179b	45 50 45 41 54 20 32 2e 39 36 2d 37 2e 39 39 20
>17ab	30 2e 30 38 2f 3b 20 32 39 36 20 35 36 38 3c 55
>17bb	38 44 31 28 31 30 30 30 20 5a 36 49 20 31 2e 37
>17cb	37 00
.17cd					Line24:
>17cd	31 38 34 20 43 4c 45 41			.text '184 CLEAR+ IF C"SVNSOXB"RIGHT$(768 "C@") "C" )784 960"WGTWKK"8.29 712 WHILE"GYLHT" R7H6 G7Z2 + "FQUOIZ"608 888 200 "ZNNZ@"/',0
>17d5	52 2b 20 49 46 20 43 22 53 56 4e 53 4f 58 42 22
>17e5	52 49 47 48 54 24 28 37 36 38 20 22 43 40 22 29
>17f5	20 22 43 22 20 29 37 38 34 20 39 36 30 22 57 47
>1805	54 57 4b 4b 22 38 2e 32 39 20 37 31 32 20 57 48
>1815	49 4c 45 22 47 59 4c 48 54 22 20 52 37 48 36 20
>1825	47 37 5a 32 20 2b 20 22 46 51 55 4f 49 5a 22 36
>1835	30 38 20 38 38 38 20 32 30 30 20 22 5a 4e 4e 5a
>1845	40 22 2f 00
.1849					Line25:
>1849	35 33 36 20 20 3c 3e 2a			.text '536  <>*"J"3.66 PEEK("CCTQRM" "JB")888 -7.41= -0.36:2.14',0
>1851	22 4a 22 33 2e 36 36 20 50 45 45 4b 28 22 43 43
>1861	54 51 52 4d 22 20 22 4a 42 22 29 38 38 38 20 2d
>1871	37 2e 34 31 3d 20 2d 30 2e 33 36 3a 32 2e 31 34
>1881	00
.1882					Line26:
>1882	37 32 30 20 22 54 50 42			.text '720 "TPBIFV"',0
>188a	49 46 56 22 00
.188f					Line27:
>188f	34 31 36 20 37 36 30 22			.text '416 760"GNLPBIE"< LEN( VAL(C2E4Z-6.5 (6.73 W9F 176 END CLEAR ELSE"CFFPDO"400 "TT""AKVCT" 688 Q9I6 INT(M3U8 Q3 56 8.47-5.88',0
>1897	47 4e 4c 50 42 49 45 22 3c 20 4c 45 4e 28 20 56
>18a7	41 4c 28 43 32 45 34 5a 2d 36 2e 35 20 28 36 2e
>18b7	37 33 20 57 39 46 20 31 37 36 20 45 4e 44 20 43
>18c7	4c 45 41 52 20 45 4c 53 45 22 43 46 46 50 44 4f
>18d7	22 34 30 30 20 22 54 54 22 22 41 4b 56 43 54 22
>18e7	20 36 38 38 20 51 39 49 36 20 49 4e 54 28 4d 33
>18f7	55 38 20 51 33 20 35 36 20 38 2e 34 37 2d 35 2e
>1907	38 38 00
.190a					Line28:
>190a	36 34 30 20 54 49 4d 45			.text '640 TIME""= 752 544 944 9.9 ASC( 824-8.04 8.99 Q9E3P 56 PRINT 1.53 536"NVWYSQCF"VAL(RND(TO ASSERT',0
>1912	22 22 3d 20 37 35 32 20 35 34 34 20 39 34 34 20
>1922	39 2e 39 20 41 53 43 28 20 38 32 34 2d 38 2e 30
>1932	34 20 38 2e 39 39 20 51 39 45 33 50 20 35 36 20
>1942	50 52 49 4e 54 20 31 2e 35 33 20 35 33 36 22 4e
>1952	56 57 59 53 51 43 46 22 56 41 4c 28 52 4e 44 28
>1962	54 4f 20 41 53 53 45 52 54 00
.196c					Line29:
>196c	39 36 30 20 41 42 53 28			.text '960 ABS(-3.19"YIX"=-3.85 80 SGN(A0Y3W4 ELSE"J"-4.82 "VLXU"1008-4.88 688)""=416',0
>1974	2d 33 2e 31 39 22 59 49 58 22 3d 2d 33 2e 38 35
>1984	20 38 30 20 53 47 4e 28 41 30 59 33 57 34 20 45
>1994	4c 53 45 22 4a 22 2d 34 2e 38 32 20 22 56 4c 58
>19a4	55 22 31 30 30 38 2d 34 2e 38 38 20 36 38 38 29
>19b4	22 22 3d 34 31 36 00
.19bb					Line30:
>19bb	35 39 32 20 20 22 42 52			.text '592  "BRXZJKH"<-7.43 5.0- 88 M6 Q0P1V7 W6 ) 1008 ="G"E8U "QBZYI"ASC(808 M2D8M$-7.19"Q"496-9.62"PYWNJ""GYNKPB" I3X6X$Y L2',0
>19c3	58 5a 4a 4b 48 22 3c 2d 37 2e 34 33 20 35 2e 30
>19d3	2d 20 38 38 20 4d 36 20 51 30 50 31 56 37 20 57
>19e3	36 20 29 20 31 30 30 38 20 3d 22 47 22 45 38 55
>19f3	20 22 51 42 5a 59 49 22 41 53 43 28 38 30 38 20
>1a03	4d 32 44 38 4d 24 2d 37 2e 31 39 22 51 22 34 39
>1a13	36 2d 39 2e 36 32 22 50 59 57 4e 4a 22 22 47 59
>1a23	4e 4b 50 42 22 20 49 33 58 36 58 24 59 20 4c 32
>1a33	00
.1a34					Line31:
>1a34	32 34 38 20 22 55 45 22			.text '248 "UE")"ZVJEH"PEEK( 0.5"" <STR$( U0K "VONUJ"S1V4R0$440 REM',0
>1a3c	29 22 5a 56 4a 45 48 22 50 45 45 4b 28 20 30 2e
>1a4c	35 22 22 20 3c 53 54 52 24 28 20 55 30 4b 20 22
>1a5c	56 4f 4e 55 4a 22 53 31 56 34 52 30 24 34 34 30
>1a6c	20 52 45 4d 00
.1a71					Line32:
>1a71	36 34 30 20 20 29 31 32			.text '640  )120 2.52 "UT"-5.23+T0J:208"GCO" 432 SQR( AND',0
>1a79	30 20 32 2e 35 32 20 22 55 54 22 2d 35 2e 32 33
>1a89	2b 54 30 4a 3a 32 30 38 22 47 43 4f 22 20 34 33
>1a99	32 20 53 51 52 28 20 41 4e 44 00
.1aa4					Line33:
>1aa4	31 34 34 20 47 37 5a 32			.text '144 G7Z2= EXIT-264',0
>1aac	3d 20 45 58 49 54 2d 32 36 34 00
.1ab7					Line34:
>1ab7	39 36 30 20 22 4f 40 41			.text '960 "O@AO@" POKE"SO""D"2.4 PRINT -1.33 1008 I9A0 Z5F3L4( +"WXK@SP" INPUT T0J"VIJREDU"872"RZ" 3.02',0
>1abf	4f 40 22 20 50 4f 4b 45 22 53 4f 22 22 44 22 32
>1acf	2e 34 20 50 52 49 4e 54 20 2d 31 2e 33 33 20 31
>1adf	30 30 38 20 49 39 41 30 20 5a 35 46 33 4c 34 28
>1aef	20 2b 22 57 58 4b 40 53 50 22 20 49 4e 50 55 54
>1aff	20 54 30 4a 22 56 49 4a 52 45 44 55 22 38 37 32
>1b0f	22 52 5a 22 20 33 2e 30 32 00
.1b19					Line35:
>1b19	31 31 32 20 20 2f 20 28			.text '112  / ( RIGHT$(-4.57$ 9.73 L6Q(5.89=224 904*V6O2 L2<>-8.46',0
>1b21	20 52 49 47 48 54 24 28 2d 34 2e 35 37 24 20 39
>1b31	2e 37 33 20 4c 36 51 28 35 2e 38 39 3d 32 32 34
>1b41	20 39 30 34 2a 56 36 4f 32 20 4c 32 3c 3e 2d 38
>1b51	2e 34 36 00
.1b55					Line36:
>1b55	38 37 32 20 38 2e 33 38			.text '872 8.38 DEC("QLTSC""EW@"E2U4( "">"JMBRS""OHYJDV" -8.73 696 SQR("ALIFSHU"DEEK(',0
>1b5d	20 44 45 43 28 22 51 4c 54 53 43 22 22 45 57 40
>1b6d	22 45 32 55 34 28 20 22 22 3e 22 4a 4d 42 52 53
>1b7d	22 22 4f 48 59 4a 44 56 22 20 2d 38 2e 37 33 20
>1b8d	36 39 36 20 53 51 52 28 22 41 4c 49 46 53 48 55
>1b9d	22 44 45 45 4b 28 00
.1ba4					Line37:
>1ba4	34 33 32 00				.text '432',0
.1ba8					Line38:
>1ba8	35 31 32 00				.text '512',0
.1bac					Line39:
>1bac	39 36 30 20 2b 2b 2d 37			.text '960 ++-7.79(>D-9.89"GCRVNJ""OP""QE@E""HI""UPWPVAM"1.67 4.12 ) SAVE "VNO"808"ICSRGGCU"440( *136 320-3.35',0
>1bb4	2e 37 39 28 3e 44 2d 39 2e 38 39 22 47 43 52 56
>1bc4	4e 4a 22 22 4f 50 22 22 51 45 40 45 22 22 48 49
>1bd4	22 22 55 50 57 50 56 41 4d 22 31 2e 36 37 20 34
>1be4	2e 31 32 20 29 20 53 41 56 45 20 22 56 4e 4f 22
>1bf4	38 30 38 22 49 43 53 52 47 47 43 55 22 34 34 30
>1c04	28 20 2a 31 33 36 20 33 32 30 2d 33 2e 33 35 00
.1c14					Line40:
>1c14	34 31 36 20 4d 32 52 20			.text '416 M2R 96"EMNSP"- P <> HEX$(WEND MOD L6Q(O3W7L1 584 STR$(-5.73/ 9.8',0
>1c1c	39 36 22 45 4d 4e 53 50 22 2d 20 50 20 3c 3e 20
>1c2c	48 45 58 24 28 57 45 4e 44 20 4d 4f 44 20 4c 36
>1c3c	51 28 4f 33 57 37 4c 31 20 35 38 34 20 53 54 52
>1c4c	24 28 2d 35 2e 37 33 2f 20 39 2e 38 00
.1c59					Line41:
>1c59	31 36 30 20 20 2d 39 2e			.text '160  -9.86',0
>1c61	38 36 00
.1c64					Line42:
>1c64	35 34 34 20 2a 20 3c 54			.text '544 * <T9I0B SQR(-3.71-7.33)80 9.91 S1T6D"TC@@V" 552 A0F1( STR$( 432- 592 1.49 OR "NKYTO"NEW/"X" 696=',0
>1c6c	39 49 30 42 20 53 51 52 28 2d 33 2e 37 31 2d 37
>1c7c	2e 33 33 29 38 30 20 39 2e 39 31 20 53 31 54 36
>1c8c	44 22 54 43 40 40 56 22 20 35 35 32 20 41 30 46
>1c9c	31 28 20 53 54 52 24 28 20 34 33 32 2d 20 35 39
>1cac	32 20 31 2e 34 39 20 4f 52 20 22 4e 4b 59 54 4f
>1cbc	22 4e 45 57 2f 22 58 22 20 36 39 36 3d 00
.1cca					Line43:
>1cca	33 38 34 20 29 2d 32 2e			.text '384 )-2.71 0.83',0
>1cd2	37 31 20 30 2e 38 33 00
.1cda					Line44:
>1cda	39 34 34 20 44 39 55 2b			.text '944 D9U+ 688 376 456 328-0.54$= /296 "Q" 888 M2R MOD 152 696 "VYHTFTF"',0
>1ce2	20 36 38 38 20 33 37 36 20 34 35 36 20 33 32 38
>1cf2	2d 30 2e 35 34 24 3d 20 2f 32 39 36 20 22 51 22
>1d02	20 38 38 38 20 4d 32 52 20 4d 4f 44 20 31 35 32
>1d12	20 36 39 36 20 22 56 59 48 54 46 54 46 22 00
.1d21					Line45:
>1d21	37 39 32 20 35 34 34 20			.text '792 544 R5K3D9',0
>1d29	52 35 4b 33 44 39 00
.1d30					Line46:
>1d30	33 33 36 20 31 34 34 20			.text '336 144 TO 784 D9U+ XOR 888 232 9.67 464 OR 104 RAND("GD@"',0
>1d38	54 4f 20 37 38 34 20 44 39 55 2b 20 58 4f 52 20
>1d48	38 38 38 20 32 33 32 20 39 2e 36 37 20 34 36 34
>1d58	20 4f 52 20 31 30 34 20 52 41 4e 44 28 22 47 44
>1d68	40 22 00
.1d6b					Line47:
>1d6b	36 36 34 20 39 30 34 20			.text '664 904 )STR$( ""Z8M9( -2.43-0.52 STR$(-9.41 D9U DO IF) -0.18="",=LET C2E4Z-1.47 656 2.62',0
>1d73	29 53 54 52 24 28 20 22 22 5a 38 4d 39 28 20 2d
>1d83	32 2e 34 33 2d 30 2e 35 32 20 53 54 52 24 28 2d
>1d93	39 2e 34 31 20 44 39 55 20 44 4f 20 49 46 29 20
>1da3	2d 30 2e 31 38 3d 22 22 2c 3d 4c 45 54 20 43 32
>1db3	45 34 5a 2d 31 2e 34 37 20 36 35 36 20 32 2e 36
>1dc3	32 00
.1dc5					Line48:
>1dc5	39 35 32 20 20 37 2e 32			.text '952  7.23 S3S7S3$ J0W9 8.17 328 "DLMF"8.06"XT" U8D1(Q( -0.41 1.89 136"ECGYGI""NX"352',0
>1dcd	33 20 53 33 53 37 53 33 24 20 4a 30 57 39 20 38
>1ddd	2e 31 37 20 33 32 38 20 22 44 4c 4d 46 22 38 2e
>1ded	30 36 22 58 54 22 20 55 38 44 31 28 51 28 20 2d
>1dfd	30 2e 34 31 20 31 2e 38 39 20 31 33 36 22 45 43
>1e0d	47 59 47 49 22 22 4e 58 22 33 35 32 00
.1e1a					Line49:
>1e1a	36 30 30 20 53 59 53 20			.text '600 SYS Z5F3L4( F7$ END 136 DIM"EOUWVA" 720 INKEY$(',0
>1e22	5a 35 46 33 4c 34 28 20 46 37 24 20 45 4e 44 20
>1e32	31 33 36 20 44 49 4d 22 45 4f 55 57 56 41 22 20
>1e42	37 32 30 20 49 4e 4b 45 59 24 28 00
.1e4e					Line50:
>1e4e	39 30 34 20 22 50 57 52			.text '904 "PWRI"856"SAWF" "FY"I INPUT 880"V"SYS 536 424* "DWRLDF""UMDXZN"<528 824 -REM 872 2.96 5.9',0
>1e56	49 22 38 35 36 22 53 41 57 46 22 20 22 46 59 22
>1e66	49 20 49 4e 50 55 54 20 38 38 30 22 56 22 53 59
>1e76	53 20 35 33 36 20 34 32 34 2a 20 22 44 57 52 4c
>1e86	44 46 22 22 55 4d 44 58 5a 4e 22 3c 35 32 38 20
>1e96	38 32 34 20 2d 52 45 4d 20 38 37 32 20 32 2e 39
>1ea6	36 20 35 2e 39 00
.1eac					Line51:
>1eac	39 37 36 20 20 29 00			.text '976  )',0
.1eb3					Line52:
>1eb3	39 34 34 20 33 32 38 20			.text '944 328 I3X6X$--7.98-408 T9I0B VAL( "TUKTXSX">*U6P1T1$',0
>1ebb	49 33 58 36 58 24 2d 2d 37 2e 39 38 2d 34 30 38
>1ecb	20 54 39 49 30 42 20 56 41 4c 28 20 22 54 55 4b
>1edb	54 58 53 58 22 3e 2a 55 36 50 31 54 31 24 00
.1eea					Line53:
>1eea	35 36 20 20 37 32 30 00			.text '56  720',0
.1ef2					Line54:
>1ef2	31 39 32 20 33 39 32 20			.text '192 392 >CALL 312>)0.9 240 1000+"FW" -0.42 ( 8.28""=R7H6"QLKUHMP" 696 568 808 J0W9/6.05 2.78 1.9 "NT"AND"CLUNVVC"',0
>1efa	3e 43 41 4c 4c 20 33 31 32 3e 29 30 2e 39 20 32
>1f0a	34 30 20 31 30 30 30 2b 22 46 57 22 20 2d 30 2e
>1f1a	34 32 20 28 20 38 2e 32 38 22 22 3d 52 37 48 36
>1f2a	22 51 4c 4b 55 48 4d 50 22 20 36 39 36 20 35 36
>1f3a	38 20 38 30 38 20 4a 30 57 39 2f 36 2e 30 35 20
>1f4a	32 2e 37 38 20 31 2e 39 20 22 4e 54 22 41 4e 44
>1f5a	22 43 4c 55 4e 56 56 43 22 00
.1f64					Line55:
>1f64	31 31 32 20 3d 22 4e 52			.text '112 ="NRFF"<=P8W5 7.38 3.46 8.1 <<0.75 <512 OR+ >> WEND 528 FRAC(STR$(',0
>1f6c	46 46 22 3c 3d 50 38 57 35 20 37 2e 33 38 20 33
>1f7c	2e 34 36 20 38 2e 31 20 3c 3c 30 2e 37 35 20 3c
>1f8c	35 31 32 20 4f 52 2b 20 3e 3e 20 57 45 4e 44 20
>1f9c	35 32 38 20 46 52 41 43 28 53 54 52 24 28 00
.1fab					Line56:
>1fab	35 35 32 20 44 37 53 38			.text '552 D7S8 LIST 5.26 Z6I 704<"ML" 824 DOKE+VAL(I9A0<<8.76 816-3.06 2.93(L6Q(PEEK(0.47 8.56 FRAC( 4.02 72 Q9I6',0
>1fb3	20 4c 49 53 54 20 35 2e 32 36 20 5a 36 49 20 37
>1fc3	30 34 3c 22 4d 4c 22 20 38 32 34 20 44 4f 4b 45
>1fd3	2b 56 41 4c 28 49 39 41 30 3c 3c 38 2e 37 36 20
>1fe3	38 31 36 2d 33 2e 30 36 20 32 2e 39 33 28 4c 36
>1ff3	51 28 50 45 45 4b 28 30 2e 34 37 20 38 2e 35 36
>2003	20 46 52 41 43 28 20 34 2e 30 32 20 37 32 20 51
>2013	39 49 36 00
.2017					Line57:
>2017	31 38 34 20 36 31 36 20			.text '184 616 7.31 "IGCT"904"E@ZQRN"',0
>201f	37 2e 33 31 20 22 49 47 43 54 22 39 30 34 22 45
>202f	40 5a 51 52 4e 22 00
.2036					Line58:
>2036	39 37 36 20 20 3d 20 3d			.text '976  = =- (736 R3J1T +"LKEPBEJN"-3.66-8.18$"ERX"',0
>203e	2d 20 28 37 33 36 20 52 33 4a 31 54 20 2b 22 4c
>204e	4b 45 50 42 45 4a 4e 22 2d 33 2e 36 36 2d 38 2e
>205e	31 38 24 22 45 52 58 22 00
.2067					Line59:
>2067	31 39 32 00				.text '192',0
.206b					Line60:
>206b	38 38 30 20 3e 41 30 46			.text '880 >A0F1< W( (K8P6$896 "NK" 320"NWYOY@"V1U "MILER"Q3 Z6I"WRSCLEV" 984-5.52 L6Q(RUN-3.42 * )"W"',0
>2073	31 3c 20 57 28 20 28 4b 38 50 36 24 38 39 36 20
>2083	22 4e 4b 22 20 33 32 30 22 4e 57 59 4f 59 40 22
>2093	56 31 55 20 22 4d 49 4c 45 52 22 51 33 20 5a 36
>20a3	49 22 57 52 53 43 4c 45 56 22 20 39 38 34 2d 35
>20b3	2e 35 32 20 4c 36 51 28 52 55 4e 2d 33 2e 34 32
>20c3	20 2a 20 29 22 57 22 00
.20cb					Line61:
>20cb	34 35 36 20 20 22 54 41			.text '456  "TAX" L6Q("FF@"PROC 344 RIGHT$(DOKE )"ZTN" FRAC(G TO "MKOVNB"744 648 -6.5 ENDPROC 264 A1',0
>20d3	58 22 20 4c 36 51 28 22 46 46 40 22 50 52 4f 43
>20e3	20 33 34 34 20 52 49 47 48 54 24 28 44 4f 4b 45
>20f3	20 29 22 5a 54 4e 22 20 46 52 41 43 28 47 20 54
>2103	4f 20 22 4d 4b 4f 56 4e 42 22 37 34 34 20 36 34
>2113	38 20 2d 36 2e 35 20 45 4e 44 50 52 4f 43 20 32
>2123	36 34 20 41 31 00
.2129					Line62:
>2129	38 34 38 20 20 2d 31 2e			.text '848  -1.97-9.3 >C 368 560 REPEAT"FYEGHXD" LEFT$( 760 3.35=',0
>2131	39 37 2d 39 2e 33 20 3e 43 20 33 36 38 20 35 36
>2141	30 20 52 45 50 45 41 54 22 46 59 45 47 48 58 44
>2151	22 20 4c 45 46 54 24 28 20 37 36 30 20 33 2e 33
>2161	35 3d 00
.2164					Line63:
>2164	32 38 30 20 41 30 59 33			.text '280 A0Y3W4 -2.07 272"TEACHJ""OV@QHPF"*0.37"ZEFFMJP"528"MKKGPD"',0
>216c	57 34 20 2d 32 2e 30 37 20 32 37 32 22 54 45 41
>217c	43 48 4a 22 22 4f 56 40 51 48 50 46 22 2a 30 2e
>218c	33 37 22 5a 45 46 46 4d 4a 50 22 35 32 38 22 4d
>219c	4b 4b 47 50 44 22 00
.21a3					Line64:
>21a3	34 38 38 00				.text '488',0
.21a7					Line65:
>21a7	39 32 38 00				.text '928',0
.21ab					Line66:
>21ab	35 34 34 20 20 29 51 00			.text '544  )Q',0
.21b3					Line67:
>21b3	38 36 34 20 31 2e 38 38			.text '864 1.88/ 816-3.71 "EHAVRXJR""UUMZGRUQ" -2.23-6.12 928 472 U8D1( R5K3D9 R2J"BG""QTWD") "URN" 3.79"WPQZAGFH" INT(3.61',0
>21bb	2f 20 38 31 36 2d 33 2e 37 31 20 22 45 48 41 56
>21cb	52 58 4a 52 22 22 55 55 4d 5a 47 52 55 51 22 20
>21db	2d 32 2e 32 33 2d 36 2e 31 32 20 39 32 38 20 34
>21eb	37 32 20 55 38 44 31 28 20 52 35 4b 33 44 39 20
>21fb	52 32 4a 22 42 47 22 22 51 54 57 44 22 29 20 22
>220b	55 52 4e 22 20 33 2e 37 39 22 57 50 51 5a 41 47
>221b	46 48 22 20 49 4e 54 28 33 2e 36 31 00
.2228					Line68:
>2228	34 31 36 20 45 4e 44 50			.text '416 ENDPROC/K0J6U$/ Q9E3P"GON" )>5.39',0
>2230	52 4f 43 2f 4b 30 4a 36 55 24 2f 20 51 39 45 33
>2240	50 22 47 4f 4e 22 20 29 3e 35 2e 33 39 00
.224e					Line69:
>224e	32 36 34 00				.text '264',0
.2252					Line70:
>2252	32 35 36 20 4d 32 44 38			.text '256 M2D8M$=UNTIL',0
>225a	4d 24 3d 55 4e 54 49 4c 00
.2263					Line71:
>2263	36 34 20 2d 33 2e 33 37			.text '64 -3.37 512 /NEXT',0
>226b	20 35 31 32 20 2f 4e 45 58 54 00
.2276					Line72:
>2276	34 30 30 20 33 2e 30 35			.text '400 3.05-Z5F3L4( -6.75"TVM"7.64"RUBOSIL"TIME<>U6P1T1$0.56 480 "ZEYQAO"',0
>227e	2d 5a 35 46 33 4c 34 28 20 2d 36 2e 37 35 22 54
>228e	56 4d 22 37 2e 36 34 22 52 55 42 4f 53 49 4c 22
>229e	54 49 4d 45 3c 3e 55 36 50 31 54 31 24 30 2e 35
>22ae	36 20 34 38 30 20 22 5a 45 59 51 41 4f 22 00
.22bd					Line73:
>22bd	32 39 36 00				.text '296',0
.22c1					Line74:
>22c1	39 31 32 20 22 54 46 50			.text '912 "TFPKTXW"LIST"IXNC"6.66 248)',0
>22c9	4b 54 58 57 22 4c 49 53 54 22 49 58 4e 43 22 36
>22d9	2e 36 36 20 32 34 38 29 00
.22e2					Line75:
>22e2	39 32 30 20 3c 3c 54 48			.text '920 <<THEN 296 AND 400 Q8W 880 88 "M"TO<-0.61 LOAD 888 WEND I9A0 >4.87 / F7$416-9.96<424 720 PEEK(',0
>22ea	45 4e 20 32 39 36 20 41 4e 44 20 34 30 30 20 51
>22fa	38 57 20 38 38 30 20 38 38 20 22 4d 22 54 4f 3c
>230a	2d 30 2e 36 31 20 4c 4f 41 44 20 38 38 38 20 57
>231a	45 4e 44 20 49 39 41 30 20 3e 34 2e 38 37 20 2f
>232a	20 46 37 24 34 31 36 2d 39 2e 39 36 3c 34 32 34
>233a	20 37 32 30 20 50 45 45 4b 28 00
.2345					Line76:
>2345	38 32 34 20 45 4c 53 45			.text '824 ELSE 128-',0
>234d	20 31 32 38 2d 00
.2353					Line77:
>2353	32 34 38 20 37 2e 31 39			.text '248 7.19 272 336"XJXVAYBS" ("XWKZK"W9W*1.32 SAVE LOOP = -5.47 304 800 PROC -9.26 352(8.77 2.78 "BFI" HEX$(192"KHKZXEFQ""""YIDRIBH"J9Y8E LET 520',0
>235b	20 32 37 32 20 33 33 36 22 58 4a 58 56 41 59 42
>236b	53 22 20 28 22 58 57 4b 5a 4b 22 57 39 57 2a 31
>237b	2e 33 32 20 53 41 56 45 20 4c 4f 4f 50 20 3d 20
>238b	2d 35 2e 34 37 20 33 30 34 20 38 30 30 20 50 52
>239b	4f 43 20 2d 39 2e 32 36 20 33 35 32 28 38 2e 37
>23ab	37 20 32 2e 37 38 20 22 42 46 49 22 20 48 45 58
>23bb	24 28 31 39 32 22 4b 48 4b 5a 58 45 46 51 22 22
>23cb	22 22 59 49 44 52 49 42 48 22 4a 39 59 38 45 20
>23db	4c 45 54 20 35 32 30 00
.23e3					Line78:
>23e3	37 30 34 20 3d 20 22 47			.text '704 = "GF" AND R2M3 X8L5H TO<< >+ <-4.03("IV"768 656 6.56 632 <',0
>23eb	46 22 20 41 4e 44 20 52 32 4d 33 20 58 38 4c 35
>23fb	48 20 54 4f 3c 3c 20 3e 2b 20 3c 2d 34 2e 30 33
>240b	28 22 49 56 22 37 36 38 20 36 35 36 20 36 2e 35
>241b	36 20 36 33 32 20 3c 00
.2423					Line79:
>2423	32 39 36 00				.text '296',0
.2427					Line80:
>2427	33 32 38 20 32 2e 30 32			.text '328 2.02/ I9A0 L4X4 REPEAT"@" M3U8 496"VIEGP"256',0
>242f	2f 20 49 39 41 30 20 4c 34 58 34 20 52 45 50 45
>243f	41 54 22 40 22 20 4d 33 55 38 20 34 39 36 22 56
>244f	49 45 47 50 22 32 35 36 00
.2458					Line81:
>2458	32 30 30 20 50 4f 4b 45			.text '200 POKE 424 RAND( "C@WXQA"',0
>2460	20 34 32 34 20 52 41 4e 44 28 20 22 43 40 57 58
>2470	51 41 22 00
.2474					Line82:
>2474	33 36 38 20 20 4e 45 58			.text '368  NEXT "KP@O@""IZ"768 / W T0J"@HVBC"-2.07)OR 928 256 "U"U E8U "CHFH"336 L4X4 6.41 "RA">-2.47 R3J1T-4.15',0
>247c	54 20 22 4b 50 40 4f 40 22 22 49 5a 22 37 36 38
>248c	20 2f 20 57 20 54 30 4a 22 40 48 56 42 43 22 2d
>249c	32 2e 30 37 29 4f 52 20 39 32 38 20 32 35 36 20
>24ac	22 55 22 55 20 45 38 55 20 22 43 48 46 48 22 33
>24bc	33 36 20 4c 34 58 34 20 36 2e 34 31 20 22 52 41
>24cc	22 3e 2d 32 2e 34 37 20 52 33 4a 31 54 2d 34 2e
>24dc	31 35 00
.24df					Line83:
>24df	32 38 30 20 20 29 2d 39			.text '280  )-9.15 U0K 304 L4X4)W6 A0Y3W4 +<I3X6X$"@XZWCO" 968>>584 B5F9 S0L 6.22= /"B"INT(-"DW"""(=96',0
>24e7	2e 31 35 20 55 30 4b 20 33 30 34 20 4c 34 58 34
>24f7	29 57 36 20 41 30 59 33 57 34 20 2b 3c 49 33 58
>2507	36 58 24 22 40 58 5a 57 43 4f 22 20 39 36 38 3e
>2517	3e 35 38 34 20 42 35 46 39 20 53 30 4c 20 36 2e
>2527	32 32 3d 20 2f 22 42 22 49 4e 54 28 2d 22 44 57
>2537	22 22 22 28 3d 39 36 00
.253f					Line84:
>253f	34 30 38 20 22 54 42 4b			.text '408 "TBKPZNJ"888 LIST M$-8.34<968 Z5F3L4(',0
>2547	50 5a 4e 4a 22 38 38 38 20 4c 49 53 54 20 4d 24
>2557	2d 38 2e 33 34 3c 39 36 38 20 5a 35 46 33 4c 34
>2567	28 00
.2569					Line85:
>2569	35 32 30 20 34 2e 35 39			.text '520 4.59 "M"/Q "SONA"W6"GCWXH"ENDIF 232 ELSE>>',0
>2571	20 22 4d 22 2f 51 20 22 53 4f 4e 41 22 57 36 22
>2581	47 43 57 58 48 22 45 4e 44 49 46 20 32 33 32 20
>2591	45 4c 53 45 3e 3e 00
.2598					Line86:
>2598	38 34 38 20 20 51 39 45			.text '848  Q9E3P NEW D4L1X3 S3S7S3$< 944 8.71 X4 C2E4Z "E@FJ" 896"KHZGSYK"A0Y( 2.58 304 912= -0.6 -5.19 2.31',0
>25a0	33 50 20 4e 45 57 20 44 34 4c 31 58 33 20 53 33
>25b0	53 37 53 33 24 3c 20 39 34 34 20 38 2e 37 31 20
>25c0	58 34 20 43 32 45 34 5a 20 22 45 40 46 4a 22 20
>25d0	38 39 36 22 4b 48 5a 47 53 59 4b 22 41 30 59 28
>25e0	20 32 2e 35 38 20 33 30 34 20 39 31 32 3d 20 2d
>25f0	30 2e 36 20 2d 35 2e 31 39 20 32 2e 33 31 00
.25ff					Line87:
>25ff	37 36 38 20 3c 58 38 4c			.text '768 <X8L5H DOKE SGN(D9U/ ""',0
>2607	35 48 20 44 4f 4b 45 20 53 47 4e 28 44 39 55 2f
>2617	20 22 22 00
.261b					Line88:
>261b	33 30 34 20 28 2d 34 2e			.text '304 (-4.32 "D@P""QHNE"-*6.8 D3E0-7.22-0.94 Z0X(984',0
>2623	33 32 20 22 44 40 50 22 22 51 48 4e 45 22 2d 2a
>2633	36 2e 38 20 44 33 45 30 2d 37 2e 32 32 2d 30 2e
>2643	39 34 20 5a 30 58 28 39 38 34 00
.264e					Line89:
>264e	37 36 30 00				.text '760',0
.2652					Line90:
>2652	32 35 36 20 20 22 47 5a			.text '256  "GZQI" -8.97 256 SYS R2J 64 -6.34+ LOOP 2.51 ""A0F1-9.79 R8P1',0
>265a	51 49 22 20 2d 38 2e 39 37 20 32 35 36 20 53 59
>266a	53 20 52 32 4a 20 36 34 20 2d 36 2e 33 34 2b 20
>267a	4c 4f 4f 50 20 32 2e 35 31 20 22 22 41 30 46 31
>268a	2d 39 2e 37 39 20 52 38 50 31 00
.2695					Line91:
>2695	38 36 34 20 20 22 44 44			.text '864  "DDGIGC"V8C6E6 472 448"JKL"> A0F1 2.55 0.5"UBHLURX""SLCVP"200 0.83"HMK" =ELSE Z0X( P8W5 7.51 -HEX$(512=>160 -0.31',0
>269d	47 49 47 43 22 56 38 43 36 45 36 20 34 37 32 20
>26ad	34 34 38 22 4a 4b 4c 22 3e 20 41 30 46 31 20 32
>26bd	2e 35 35 20 30 2e 35 22 55 42 48 4c 55 52 58 22
>26cd	22 53 4c 43 56 50 22 32 30 30 20 30 2e 38 33 22
>26dd	48 4d 4b 22 20 3d 45 4c 53 45 20 5a 30 58 28 20
>26ed	50 38 57 35 20 37 2e 35 31 20 2d 48 45 58 24 28
>26fd	35 31 32 3d 3e 31 36 30 20 2d 30 2e 33 31 00
.270c					Line92:
>270c	38 34 30 20 57 28 20 47			.text '840 W( G7(=INKEY$( -5.85"QH"656 392',0
>2714	37 28 3d 49 4e 4b 45 59 24 28 20 2d 35 2e 38 35
>2724	22 51 48 22 36 35 36 20 33 39 32 00
.2730					Line93:
>2730	34 31 36 00				.text '416',0
.2734					Line94:
>2734	31 35 32 20 20 49 46 00			.text '152  IF',0
.273c					Line95:
>273c	37 37 36 20 20 42 35 46			.text '776  B5F9 I0N4H "YGG@Y"NEW RAND(128 POKE 376> (SYS"WU""VCZDCHCN"L5D1Y0',0
>2744	39 20 49 30 4e 34 48 20 22 59 47 47 40 59 22 4e
>2754	45 57 20 52 41 4e 44 28 31 32 38 20 50 4f 4b 45
>2764	20 33 37 36 3e 20 28 53 59 53 22 57 55 22 22 56
>2774	43 5a 44 43 48 43 4e 22 4c 35 44 31 59 30 00
.2783					Line96:
>2783	32 38 30 20 22 4b 51 52			.text '280 "KQRH"+"SZQ"<("VFVGOL"K8P6$>256"OMFKKB" 6.41 RAND(696 T0J 760-1.09 TIME<<-0.06 K$<',0
>278b	48 22 2b 22 53 5a 51 22 3c 28 22 56 46 56 47 4f
>279b	4c 22 4b 38 50 36 24 3e 32 35 36 22 4f 4d 46 4b
>27ab	4b 42 22 20 36 2e 34 31 20 52 41 4e 44 28 36 39
>27bb	36 20 54 30 4a 20 37 36 30 2d 31 2e 30 39 20 54
>27cb	49 4d 45 3c 3c 2d 30 2e 30 36 20 4b 24 3c 00
.27da					Line97:
>27da	34 30 30 20 2d 33 2e 37			.text '400 -3.77 )PEEK(- M2D8M$864 F7$Y/Y-3.72 "RABAMQPG" /"CJ"WHILE<',0
>27e2	37 20 29 50 45 45 4b 28 2d 20 4d 32 44 38 4d 24
>27f2	38 36 34 20 46 37 24 59 2f 59 2d 33 2e 37 32 20
>2802	22 52 41 42 41 4d 51 50 47 22 20 2f 22 43 4a 22
>2812	57 48 49 4c 45 3c 00
.2819					Line98:
>2819	33 32 30 20 53 47 4e 28			.text '320 SGN(984',0
>2821	39 38 34 00
.2825					Line99:
>2825	33 34 34 20 22 54 43 41			.text '344 "TCAL" 768"WKXXPV"M2R =REM"X"/736 3.16 0.02 296 648',0
>282d	4c 22 20 37 36 38 22 57 4b 58 58 50 56 22 4d 32
>283d	52 20 3d 52 45 4d 22 58 22 2f 37 33 36 20 33 2e
>284d	31 36 20 30 2e 30 32 20 32 39 36 20 36 34 38 00
.285d					Line100:
>285d	38 30 38 20 46 52 41 43			.text '808 FRAC(-5.58 D4L1X3)Q(920"HWPNQDI" M$"XEKYIEOA" >608)U 3.72)616* HEX$(D3E0 J6(O3W7L1 L4X4 7.31 DEEK(- "SBH"> "Z"',0
>2865	28 2d 35 2e 35 38 20 44 34 4c 31 58 33 29 51 28
>2875	39 32 30 22 48 57 50 4e 51 44 49 22 20 4d 24 22
>2885	58 45 4b 59 49 45 4f 41 22 20 3e 36 30 38 29 55
>2895	20 33 2e 37 32 29 36 31 36 2a 20 48 45 58 24 28
>28a5	44 33 45 30 20 4a 36 28 4f 33 57 37 4c 31 20 4c
>28b5	34 58 34 20 37 2e 33 31 20 44 45 45 4b 28 2d 20
>28c5	22 53 42 48 22 3e 20 22 5a 22 00
.28d0					Line101:
>28d0	34 33 32 20 4c 4f 41 44			.text '432 LOAD "PCZK"-"ZYMKAGCC"POKE S0G8J3 632-3.05 U5T$ 744',0
>28d8	20 22 50 43 5a 4b 22 2d 22 5a 59 4d 4b 41 47 43
>28e8	43 22 50 4f 4b 45 20 53 30 47 38 4a 33 20 36 33
>28f8	32 2d 33 2e 30 35 20 55 35 54 24 20 37 34 34 00
.2908					Line102:
>2908	38 38 38 20 20 39 36 2d			.text '888  96-704+-0.04 Q( -6.23"" "")<= */-6.58 /"CEDLF"',0
>2910	37 30 34 2b 2d 30 2e 30 34 20 51 28 20 2d 36 2e
>2920	32 33 22 22 20 22 22 29 3c 3d 20 2a 2f 2d 36 2e
>2930	35 38 20 2f 22 43 45 44 4c 46 22 00
.293c					Line103:
>293c	32 30 30 20 20 4f 52 20			.text '200  OR 896 344 WHILE"SVW" PEEK( -2.4 G 3.21 ( F SYS R2Z3S5 520=THEN >=<>',0
>2944	38 39 36 20 33 34 34 20 57 48 49 4c 45 22 53 56
>2954	57 22 20 50 45 45 4b 28 20 2d 32 2e 34 20 47 20
>2964	33 2e 32 31 20 28 20 46 20 53 59 53 20 52 32 5a
>2974	33 53 35 20 35 32 30 3d 54 48 45 4e 20 3e 3d 3c
>2984	3e 00
.2986					Line104:
>2986	38 39 36 00				.text '896',0
.298a					Line105:
>298a	34 32 34 00				.text '424',0
.298e					Line106:
>298e	34 33 32 20 20 43 4c 45			.text '432  CLEAR"CFN"E4Z4T("ZNQBNCX" "JLUOHM@" $',0
>2996	41 52 22 43 46 4e 22 45 34 5a 34 54 28 22 5a 4e
>29a6	51 42 4e 43 58 22 20 22 4a 4c 55 4f 48 4d 40 22
>29b6	20 24 00
.29b9					Line107:
>29b9	33 36 38 20 20 22 4f 55			.text '368  "OUJ"IF 376 976 END "FRVY"360 D4L1X3 "QRVPF" 112-0.54-*288 UNTIL STOP"" "GICTVTCK" -',0
>29c1	4a 22 49 46 20 33 37 36 20 39 37 36 20 45 4e 44
>29d1	20 22 46 52 56 59 22 33 36 30 20 44 34 4c 31 58
>29e1	33 20 22 51 52 56 50 46 22 20 31 31 32 2d 30 2e
>29f1	35 34 2d 2a 32 38 38 20 55 4e 54 49 4c 20 53 54
>2a01	4f 50 22 22 20 22 47 49 43 54 56 54 43 4b 22 20
>2a11	2d 00
.2a13					Line108:
>2a13	35 38 34 00				.text '584',0
.2a17					Line109:
>2a17	36 34 20 3a 2d 37 2e 31			.text '64 :-7.13 RAND(64 4.06 F5N',0
>2a1f	33 20 52 41 4e 44 28 36 34 20 34 2e 30 36 20 46
>2a2f	35 4e 00
.2a32					Line110:
>2a32	31 30 34 20 22 4b 54 4e			.text '104 "KTNVZ" -6.56 J9Y8E -1.64>"DORP" 600 0.97<<D4L1X3 608 640 "RQMZQT"*< R9P5H DOKE*-0.73 ENDPROC 976',0
>2a3a	56 5a 22 20 2d 36 2e 35 36 20 4a 39 59 38 45 20
>2a4a	2d 31 2e 36 34 3e 22 44 4f 52 50 22 20 36 30 30
>2a5a	20 30 2e 39 37 3c 3c 44 34 4c 31 58 33 20 36 30
>2a6a	38 20 36 34 30 20 22 52 51 4d 5a 51 54 22 2a 3c
>2a7a	20 52 39 50 35 48 20 44 4f 4b 45 2a 2d 30 2e 37
>2a8a	33 20 45 4e 44 50 52 4f 43 20 39 37 36 00
.2a98					Line111:
>2a98	33 38 34 20 22 49 22 20			.text '384 "I" 448 /("UIR"RIGHT$(7.63 0.56 STOP "N"-5.41(',0
>2aa0	34 34 38 20 2f 28 22 55 49 52 22 52 49 47 48 54
>2ab0	24 28 37 2e 36 33 20 30 2e 35 36 20 53 54 4f 50
>2ac0	20 22 4e 22 2d 35 2e 34 31 28 00
.2acb					Line112:
>2acb	38 32 34 20 2d 33 2e 39			.text '824 -3.98 J0W9 "TJM"/ 832-1.68 -1.8 -8.6+END W9F(G7(256 R5K3D9 128 R2M3 *Q4V-3.76""',0
>2ad3	38 20 4a 30 57 39 20 22 54 4a 4d 22 2f 20 38 33
>2ae3	32 2d 31 2e 36 38 20 2d 31 2e 38 20 2d 38 2e 36
>2af3	2b 45 4e 44 20 57 39 46 28 47 37 28 32 35 36 20
>2b03	52 35 4b 33 44 39 20 31 32 38 20 52 32 4d 33 20
>2b13	2a 51 34 56 2d 33 2e 37 36 22 22 00
.2b1f					Line113:
>2b1f	33 39 32 00				.text '392',0
.2b23					Line114:
>2b23	32 38 30 20 20 36 35 36			.text '280  656 + 464 U6P1T1$F5N 728',0
>2b2b	20 2b 20 34 36 34 20 55 36 50 31 54 31 24 46 35
>2b3b	4e 20 37 32 38 00
.2b41					Line115:
>2b41	38 32 34 20 4d 32 44 38			.text '824 M2D8M$',0
>2b49	4d 24 00
.2b4c					Line116:
>2b4c	38 34 38 20 20 22 4d 50			.text '848  "MP" 224 )192 J0F W6 C("" "SCKJ"U4Q$440-0.85= 7.83-4.09 ELSE L5D1Y0 )ENDPROC<Y -7.59 168 2.43- "C" Z LET LEFT$(',0
>2b54	22 20 32 32 34 20 29 31 39 32 20 4a 30 46 20 57
>2b64	36 20 43 28 22 22 20 22 53 43 4b 4a 22 55 34 51
>2b74	24 34 34 30 2d 30 2e 38 35 3d 20 37 2e 38 33 2d
>2b84	34 2e 30 39 20 45 4c 53 45 20 4c 35 44 31 59 30
>2b94	20 29 45 4e 44 50 52 4f 43 3c 59 20 2d 37 2e 35
>2ba4	39 20 31 36 38 20 32 2e 34 33 2d 20 22 43 22 20
>2bb4	5a 20 4c 45 54 20 4c 45 46 54 24 28 00
.2bc1					Line117:
>2bc1	38 33 32 20 49 33 52 28			.text '832 I3R(-4.81 256 "XGS" -9.82 M6"QGGS"4.57 INKEY$( "CA""" RND(',0
>2bc9	2d 34 2e 38 31 20 32 35 36 20 22 58 47 53 22 20
>2bd9	2d 39 2e 38 32 20 4d 36 22 51 47 47 53 22 34 2e
>2be9	35 37 20 49 4e 4b 45 59 24 28 20 22 43 41 22 22
>2bf9	22 20 52 4e 44 28 00
.2c00					Line118:
>2c00	33 36 38 20 20 41 31 49			.text '368  A1I8Q:"AIVADCM"+832 ( 848 DIV L6Q(',0
>2c08	38 51 3a 22 41 49 56 41 44 43 4d 22 2b 38 33 32
>2c18	20 28 20 38 34 38 20 44 49 56 20 4c 36 51 28 00
.2c28					Line119:
>2c28	34 33 32 20 20 32 37 32			.text '432  272 768 XOR"" F9X0L 56 992 P3Y0$DOKE "PMTQGA"/"WQRA"8.07"QDQF"0.48',0
>2c30	20 37 36 38 20 58 4f 52 22 22 20 46 39 58 30 4c
>2c40	20 35 36 20 39 39 32 20 50 33 59 30 24 44 4f 4b
>2c50	45 20 22 50 4d 54 51 47 41 22 2f 22 57 51 52 41
>2c60	22 38 2e 30 37 22 51 44 51 46 22 30 2e 34 38 00

;******  Return to file: src/program/testing/testing.asmx

.2c70					TOKOneLine:
.2c70	86 22		stx $22				stx 	zTemp2
.2c72	84 23		sty $23				sty 	zTemp2+1
.2c74	a2 8a		ldx #$8a			ldx 	#TOKGetSource & $FF
.2c76	a0 2c		ldy #$2c			ldy 	#TOKGetSource >> 8
.2c78	38		sec				sec
.2c79	20 e5 39	jsr $39e5			jsr 	TOKTokenise
.2c7c	20 c0 38	jsr $38c0			jsr 	PGMDeleteLine
.2c7f	ad 01 04	lda $0401			lda 	TOKLineSize
.2c82	c9 04		cmp #$04			cmp 	#4
.2c84	f0 03		beq $2c89			beq 	_TOKNoInsert
.2c86	20 0a 39	jsr $390a			jsr 	PGMInsertLine
.2c89					_TOKNoInsert:
.2c89	60		rts				rts
.2c8a					TOKGetSource:
.2c8a	b2 22		lda ($22)			lda 	(zTemp2)
.2c8c	90 06		bcc $2c94			bcc 	_GSNoIncrement
.2c8e	e6 22		inc $22				inc 	zTemp2
.2c90	d0 02		bne $2c94			bne 	_GSNoIncrement
.2c92	e6 23		inc $23				inc 	zTemp2+1
.2c94					_GSNoIncrement:
.2c94	c9 00		cmp #$00			cmp 	#0
.2c96	60		rts				rts
.0400					SrcPosition:
>0400							.fill 		1

;******  Return to file: basic.asm

>2c97	db						.byte 	$DB
.2c98	4c 1c 2f	jmp $2f1c			jmp 	Command_NEW

;******  Processing file: include.files


;******  Processing file: src/data.inc

.001c					codePtr:
>001c							.fill 	2
.001e					zTemp0:
>001e							.fill 	2
.0020					zTemp1:
>0020							.fill 	2
.0022					zTemp2:
>0022							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/generated/token_const.inc

=$80					PR_STRUCTURE_FIRST = $80
=$80					PR_REPEAT = $80
=$81					PR_UNTIL = $81
=$82					PR_WHILE = $82
=$83					PR_WEND = $83
=$84					PR_IF = $84
=$85					PR_ENDIF = $85
=$86					PR_DO = $86
=$87					PR_LOOP = $87
=$88					PR_PROC = $88
=$89					PR_ENDPROC = $89
=$8a					PR_FOR = $8a
=$8b					PR_NEXT = $8b
=$8b					PR_STRUCTURE_LAST = $8b
=$8c					PR_STANDARD_FIRST = $8c
=$8c					PR_LSQLSQENDRSQRSQ = $8c
=$8d					PR_LSQLSQSHIFTRSQRSQ = $8d
=$8e					PR_ELSE = $8e
=$8f					PR_THEN = $8f
=$90					PR_TO = $90
=$91					PR_STEP = $91
=$92					PR_LET = $92
=$93					PR_PRINT = $93
=$94					PR_INPUT = $94
=$95					PR_CALL = $95
=$96					PR_SYS = $96
=$97					PR_REM = $97
=$98					PR_EXIT = $98
=$99					PR_COMMA = $99
=$9a					PR_SEMICOLON = $9a
=$9b					PR_COLON = $9b
=$9c					PR_SQUOTE = $9c
=$9d					PR_RPAREN = $9d
=$9e					PR_DIM = $9e
=$9f					PR_CLEAR = $9f
=$a0					PR_NEW = $a0
=$a1					PR_RUN = $a1
=$a2					PR_STOP = $a2
=$a3					PR_END = $a3
=$a4					PR_ASSERT = $a4
=$a5					PR_LIST = $a5
=$a6					PR_SAVE = $a6
=$a7					PR_LOAD = $a7
=$a8					PR_POKE = $a8
=$a9					PR_DOKE = $a9
=$a9					PR_STANDARD_LAST = $a9
=$d5					PR_DEEKLPAREN = $d5
=$d5					PR_UNARY_FIRST = $d5
=$d6					PR_PEEKLPAREN = $d6
=$d7					PR_RIGHTDOLLARLPAREN = $d7
=$d8					PR_LEFTDOLLARLPAREN = $d8
=$d9					PR_MIDDOLLARLPAREN = $d9
=$da					PR_STRDOLLARLPAREN = $da
=$db					PR_VALLPAREN = $db
=$dc					PR_SGNLPAREN = $dc
=$dd					PR_ABSLPAREN = $dd
=$de					PR_LENLPAREN = $de
=$df					PR_SQRLPAREN = $df
=$e0					PR_CHRDOLLARLPAREN = $e0
=$e1					PR_ASCLPAREN = $e1
=$e2					PR_INKEYDOLLARLPAREN = $e2
=$e3					PR_EVENTLPAREN = $e3
=$e4					PR_TIME = $e4
=$e5					PR_INTLPAREN = $e5
=$e6					PR_FRACLPAREN = $e6
=$e7					PR_DECLPAREN = $e7
=$e8					PR_HEXDOLLARLPAREN = $e8
=$e9					PR_RNDLPAREN = $e9
=$ea					PR_RANDLPAREN = $ea
=$eb					PR_LPAREN = $eb
=$ec					PR_DOLLAR = $ec
=$ed					PR_LSQLSQDECIMALRSQRSQ = $ed
=$ee					PR_UNARY_LAST = $ee
=$ee					PR_LSQLSQSTRINGRSQRSQ = $ee
=$ef					PR_EQUAL = $ef
=$ef					PR_BINARY_FIRST = $ef
=$f0					PR_LESSGREATER = $f0
=$f1					PR_LESSEQUAL = $f1
=$f2					PR_LESS = $f2
=$f3					PR_GREATEREQUAL = $f3
=$f4					PR_GREATER = $f4
=$f5					PR_XOR = $f5
=$f6					PR_OR = $f6
=$f7					PR_AND = $f7
=$f8					PR_DIV = $f8
=$f9					PR_MOD = $f9
=$fa					PR_LESSLESS = $fa
=$fb					PR_GREATERGREATER = $fb
=$fc					PR_SLASH = $fc
=$fd					PR_ASTERISK = $fd
=$fe					PR_MINUS = $fe
=$ff					PR_BINARY_LAST = $ff
=$ff					PR_PLUS = $ff

;******  Return to file: include.files


;******  Processing file: src/program/data.inc

.0401					TOKLineSize:
>0401							.fill 	1
.0402					TOKLineNumber:
>0402							.fill 	2
.0404					TOKBuffer:
>0404							.fill 	256

;******  Return to file: include.files


;******  Processing file: src/support/errors/generated/errors.inc


;******  Return to file: include.files


;******  Processing file: src/support/stack/stack.inc

=$02					STK_REPEAT = $02
=$12					STK_WHILE = $12
=$22					STK_DO = $22
=$37					STK_FOR = $37
=$42					STK_CALL = $42

;******  Return to file: include.files


;******  Processing file: src/commands/assert.asm

.2c9b					Command_ASSERT:
.2c9b	20 5a 31	jsr $315a			jsr 	EXPEvalNumber
.2c9e	a2 0c		ldx #$0c			ldx 	#IFR0
.2ca0	20 9e 49	jsr $499e			jsr 	IFloatCheckZero
.2ca3	f0 01		beq $2ca6			beq 	_CAFail
.2ca5	60		rts				rts
.2ca6					_CAFail:
.2ca6	4c 76 3f	jmp $3f76		jmp	ErrorV_assert

;******  Return to file: include.files


;******  Processing file: src/commands/clear.asm

.2ca9					Command_CLEAR:
.2ca9	20 73 39	jsr $3973			jsr 	PGMEndProgram 				; end program => zTemp0
.2cac	64 24		stz $24				stz 	freeMemory 					; start on next free page
.2cae	a5 1f		lda $1f				lda 	zTemp0+1
.2cb0	1a		inc a				inc 	a
.2cb1	85 25		sta $25				sta 	freeMemory+1
.2cb3	20 2f 43	jsr $432f			jsr 	VARClearHashTables
.2cb6	ad 11 05	lda $0511			lda 	PGMEndMemoryHigh
.2cb9	20 13 41	jsr $4113			jsr 	StackReset
.2cbc	20 72 41	jsr $4172			jsr 	StringSystemInitialise
.2cbf	20 92 3e	jsr $3e92			jsr 	ScanProcedures
.2cc2	60		rts				rts
.2cc3					AllocateMemory:
.2cc3	5a		phy				phy 								; save Y
.2cc4	a4 24		ldy $24				ldy 	freeMemory 					; save addr.low
.2cc6	5a		phy				phy
.2cc7	a4 25		ldy $25				ldy 	freeMemory+1 				; save addr.high
.2cc9	5a		phy				phy
.2cca	a8		tay				tay 								; count is now in XY
.2ccb					_AllocateLoop:
.2ccb	e0 00		cpx #$00			cpx 	#0 							; allocate count is zero ?
.2ccd	d0 04		bne $2cd3			bne 	_AllocateOne
.2ccf	c0 00		cpy #$00			cpy 	#0
.2cd1	f0 15		beq $2ce8			beq 	_AllocateExit
.2cd3					_AllocateOne:
.2cd3	a9 00		lda #$00			lda 	#0 							; zero byte
.2cd5	92 24		sta ($24)			sta 	(freeMemory)
.2cd7	e6 24		inc $24				inc 	freeMemory 					; bump pointer
.2cd9	d0 05		bne $2ce0			bne 	_AllocateSkipCarry
.2cdb	e6 25		inc $25				inc 	freeMemory+1
.2cdd	20 ec 2c	jsr $2cec			jsr 	ClearCheckMemory
.2ce0					_AllocateSkipCarry:
.2ce0	c0 00		cpy #$00			cpy 	#0 							; decrement XY
.2ce2	d0 01		bne $2ce5			bne 	_AllocateSkipBorrow
.2ce4	ca		dex				dex
.2ce5					_AllocateSkipBorrow:
.2ce5	88		dey				dey
.2ce6	80 e3		bra $2ccb			bra 	_AllocateLoop
.2ce8					_AllocateExit:
.2ce8	fa		plx				plx 								; restore address
.2ce9	68		pla				pla
.2cea	7a		ply				ply 								; restore Y
.2ceb	60		rts				rts
.2cec					ClearCheckMemory:
.2cec	a5 25		lda $25				lda 	freeMemory+1
.2cee	1a		inc a				inc 	a
.2cef	1a		inc a				inc 	a
.2cf0	cd 19 06	cmp $0619			cmp 	stringMemory+1
.2cf3	b0 01		bcs $2cf6			bcs  	_CCMError
.2cf5	60		rts				rts
.2cf6					_CCMError:
.2cf6	4c 08 40	jmp $4008		jmp	ErrorV_memory
.0024					freeMemory:
>0024							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/commands/dim.asm

.2cf9					CommandDIM:
.2cf9	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; check identifier follows.
.2cfb	29 c0		and #$c0			and 	#$C0
.2cfd	c9 40		cmp #$40			cmp 	#$40
.2cff	d0 39		bne $2d3a			bne 	_CDSyntax
.2d01	20 e6 42	jsr $42e6			jsr 	VARGetInfo 					; get information
.2d04	ad 1f 06	lda $061f			lda 	VARType 					; check array.
.2d07	29 02		and #$02			and 	#2
.2d09	f0 2f		beq $2d3a			beq 	_CDSyntax
.2d0b	20 98 42	jsr $4298			jsr 	VARFind 					; does it already exist
.2d0e	b0 2d		bcs $2d3d			bcs 	_CDExists
.2d10	20 44 42	jsr $4244			jsr 	VARCreate 					; create it - returns data ptr in XA
.2d13	da		phx				phx 								; save target address
.2d14	48		pha				pha
.2d15	ad 1f 06	lda $061f			lda 	VARType 					; type ID.
.2d18	29 01		and #$01			and 	#1 							; 0 = Number, 1 = String.
.2d1a	20 40 2d	jsr $2d40			jsr 	CreateArray 				; create array to XA
.2d1d	84 20		sty $20				sty 	zTemp1 						; save Y
.2d1f	7a		ply				ply 								; restore target to zTemp0
.2d20	84 1e		sty $1e				sty 	zTemp0
.2d22	7a		ply				ply
.2d23	84 1f		sty $1f				sty 	zTemp0+1
.2d25	92 1e		sta ($1e)			sta 	(zTemp0) 					; save new array
.2d27	a0 01		ldy #$01			ldy 	#1
.2d29	8a		txa				txa
.2d2a	91 1e		sta ($1e),y			sta 	(zTemp0),y
.2d2c	a4 20		ldy $20				ldy 	zTemp1 						; restore zTemp1
.2d2e	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 				; check )
.2d31	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; if a comma, consume and go round again.
.2d33	c8		iny				iny
.2d34	c9 99		cmp #$99			cmp 	#PR_COMMA
.2d36	f0 c1		beq $2cf9			beq 	CommandDIM
.2d38	88		dey				dey
.2d39	60		rts				rts
.2d3a					_CDSyntax:
.2d3a	4c 25 3f	jmp $3f25		jmp	ErrorV_syntax
.2d3d					_CDExists:
.2d3d	4c e2 3f	jmp $3fe2		jmp	ErrorV_redefine
.2d40					CreateArray:
.2d40	8d 04 05	sta $0504			sta 	CAType						; save type
.2d43	20 6c 31	jsr $316c			jsr 	EXPEvalInteger16 			; get array dimension to R0
.2d46	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; does a comma follow, if so, 2 dimensions
.2d48	c9 99		cmp #$99			cmp 	#PR_COMMA
.2d4a	f0 04		beq $2d50			beq 	_CATwoDimensions
.2d4c	20 9c 2d	jsr $2d9c			jsr 	CreateSingleArray 			; create a lowest level array (e.g. data)
.2d4f	60		rts				rts
.2d50					_CATwoDimensions:
.2d50	a5 0d		lda $0d				lda 	IFR0+IM1 					; copy outer dimension to CADim1
.2d52	8d 06 05	sta $0506			sta 	CADim1+1
.2d55	a5 0c		lda $0c				lda 	IFR0+IM0
.2d57	8d 05 05	sta $0505			sta 	CADim1+0
.2d5a	20 ac 40	jsr $40ac			jsr 	ERRCheckComma 				; check comma
.2d5d	20 6c 31	jsr $316c			jsr 	EXPEvalInteger16 			; calculate size of 2nd dimension.
.2d60	5a		phy				phy 								; save Y position
.2d61	18		clc				clc 								; allocate the outer array of pointers.
.2d62	ae 06 05	ldx $0506			ldx 	CADim1+1
.2d65	ad 05 05	lda $0505			lda 	CADim1
.2d68	20 db 2d	jsr $2ddb			jsr 	CSAAllocate 				; allocate the outer array
.2d6b	da		phx				phx									; save this address on the stack
.2d6c	48		pha				pha
.2d6d	86 23		stx $23				stx 	zTemp2+1					; and in zTemp2
.2d6f	85 22		sta $22				sta 	zTemp2
.2d71					_CACreateSubLoop:
.2d71	38		sec				sec
.2d72	20 9c 2d	jsr $2d9c			jsr 	CreateSingleArray 			; create data array of required size.
.2d75	a0 02		ldy #$02			ldy 	#2 							; save two on missing the two byte header.
.2d77	91 22		sta ($22),y			sta 	(zTemp2),y
.2d79	8a		txa				txa
.2d7a	c8		iny				iny
.2d7b	91 22		sta ($22),y			sta 	(zTemp2),y
.2d7d	18		clc				clc  								; next slot.
.2d7e	a5 22		lda $22				lda 	zTemp2
.2d80	69 02		adc #$02			adc 	#2
.2d82	85 22		sta $22				sta 	zTemp2
.2d84	90 02		bcc $2d88			bcc 	_CACNoCarry
.2d86	e6 23		inc $23				inc 	zTemp2+1
.2d88					_CACNoCarry:
.2d88	ad 05 05	lda $0505			lda 	CADim1 						; use DIM1 as a counter
.2d8b	d0 03		bne $2d90			bne 	_CACNoBorrow
.2d8d	ce 06 05	dec $0506			dec 	CADim1+1
.2d90					_CACNoBorrow:
.2d90	ce 05 05	dec $0505			dec 	CADim1
.2d93	ad 06 05	lda $0506			lda 	CADim1+1 					; but do one more.
.2d96	10 d9		bpl $2d71			bpl 	_CACreateSubLoop
.2d98	68		pla				pla
.2d99	fa		plx				plx
.2d9a	7a		ply				ply
.2d9b	60		rts				rts
.2d9c					CreateSingleArray:
.2d9c	5a		phy				phy
.2d9d	38		sec				sec 								; allocate memory block all zeros.
.2d9e	a5 0c		lda $0c				lda 	IFR0+IM0
.2da0	a6 0d		ldx $0d				ldx 	IFR0+IM1
.2da2	20 db 2d	jsr $2ddb			jsr 	CSAAllocate
.2da5	ac 04 05	ldy $0504			ldy 	CAType 						; if numbers, we don't need to initialise.
.2da8	f0 2f		beq $2dd9			beq 	_CSANoInit
.2daa	da		phx				phx 								; save address of new array
.2dab	48		pha				pha
.2dac	85 1e		sta $1e				sta 	zTemp0 						; address in zTemp0
.2dae	86 1f		stx $1f				stx 	zTemp0+1
.2db0	a0 01		ldy #$01			ldy 	#1 							; count in YX - cannot be zero.
.2db2	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.2db4	a8		tay				tay
.2db5	b2 1e		lda ($1e)			lda 	(zTemp0)
.2db7	aa		tax				tax
.2db8					_CSAEraseString:
.2db8	5a		phy				phy
.2db9	a0 05		ldy #$05			ldy 	#5 							; 2 initial + 3 on
.2dbb	a9 80		lda #$80			lda 	#$80
.2dbd	91 1e		sta ($1e),y			sta 	(zTemp0),y
.2dbf	7a		ply				ply
.2dc0	18		clc				clc 								; add 4 to next slot.
.2dc1	a5 1e		lda $1e				lda 	zTemp0
.2dc3	69 04		adc #$04			adc 	#4
.2dc5	85 1e		sta $1e				sta 	zTemp0
.2dc7	90 02		bcc $2dcb			bcc 	_CSAENoCarry
.2dc9	e6 1f		inc $1f				inc 	zTemp0+1
.2dcb					_CSAENoCarry:
.2dcb	e0 00		cpx #$00			cpx 	#0
.2dcd	d0 01		bne $2dd0			bne 	_CSANoBorrow
.2dcf	88		dey				dey
.2dd0					_CSANoBorrow:
.2dd0	ca		dex				dex
.2dd1	d0 e5		bne $2db8			bne 	_CSAEraseString
.2dd3	c0 00		cpy #$00			cpy 	#0
.2dd5	d0 e1		bne $2db8			bne 	_CSAEraseString
.2dd7	68		pla				pla
.2dd8	fa		plx				plx
.2dd9					_CSANoInit:
.2dd9	7a		ply				ply
.2dda	60		rts				rts
.2ddb					CSAAllocate:
.2ddb	08		php				php 								; save type flag.
.2ddc	1a		inc a				inc 	a 							; add 1 because we store the size of the array block
.2ddd	d0 01		bne $2de0			bne 	_CSAANoCarry 				; for A(10) this is 11 elements.
.2ddf	e8		inx				inx
.2de0					_CSAANoCarry:
.2de0	e0 20		cpx #$20			cpx 	#$20 						; basic range check
.2de2	b0 2e		bcs $2e12			bcs 	_CSARange
.2de4	28		plp				plp 								; restore type flag
.2de5	08		php				php 								; save it back again.
.2de6	da		phx				phx 								; save size.
.2de7	48		pha				pha
.2de8	86 1f		stx $1f				stx  	zTemp0+1 					; now in ztemp0+1:X
.2dea	90 03		bcc $2def			bcc 	_CSAATimes2 				; if flag on entry clear multiply by 2, otherwise by 4.
.2dec	0a		asl a				asl 	a
.2ded	26 1f		rol $1f				rol 	zTemp0+1
.2def					_CSAATimes2:
.2def	0a		asl a				asl 	a
.2df0	26 1f		rol $1f				rol 	zTemp0+1
.2df2	18		clc				clc
.2df3	69 02		adc #$02			adc 	#2 							; add 2 bytes for size.
.2df5	90 02		bcc $2df9			bcc 	_CSAANoCarry2
.2df7	e6 1f		inc $1f				inc 	zTemp0+1
.2df9					_CSAANoCarry2:
.2df9	a6 1f		ldx $1f				ldx 	zTemp0+1 					; XA is the bytes required.
.2dfb	20 c3 2c	jsr $2cc3			jsr 	AllocateMemory 				; allocate memory to XA
.2dfe	86 1f		stx $1f				stx 	zTemp0+1 					; save pointers
.2e00	85 1e		sta $1e				sta 	zTemp0
.2e02	68		pla				pla  								; write element count to first 2 bytes
.2e03	92 1e		sta ($1e)			sta 	(zTemp0)
.2e05	68		pla				pla 								; msb of element count
.2e06	28		plp				plp 								; CC if pointer array
.2e07	b0 02		bcs $2e0b			bcs 	_CSAAIsData
.2e09	09 80		ora #$80			ora 	#$80 						; set bit 7 of MSB indicating has sub arrays.
.2e0b					_CSAAIsData:
.2e0b	a0 01		ldy #$01			ldy 	#1
.2e0d	91 1e		sta ($1e),y			sta 	(zTemp0),y
.2e0f	a5 1e		lda $1e				lda 	zTemp0 						; fix XA back up again
.2e11	60		rts				rts
.2e12					_CSARange:
.2e12	4c 35 3f	jmp $3f35		jmp	ErrorV_range
.0504					CAType:
>0504							.fill 	1
.0505					CADim1:
>0505							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/commands/dokepoke.asm

.2e15					Command_Doke:
.2e15	38		sec				sec
.2e16	80 01		bra $2e19			bra 	DPCommon
.2e18					Command_Poke:
.2e18	18		clc				clc
.2e19					DPCommon:
.2e19	08		php				php 								; CS if DOKE
.2e1a	20 6c 31	jsr $316c			jsr 	EXPEvalInteger16 			; address
.2e1d	a5 0c		lda $0c				lda 	IFR0+IM0 					; push on stack
.2e1f	48		pha				pha
.2e20	a5 0d		lda $0d				lda 	IFR0+IM1
.2e22	48		pha				pha
.2e23	20 ac 40	jsr $40ac			jsr 	ERRCheckComma 				; [dp]oke address,data
.2e26	20 6c 31	jsr $316c			jsr 	EXPEvalInteger16
.2e29	68		pla				pla 								; get address back
.2e2a	85 1f		sta $1f				sta 	zTemp0+1
.2e2c	68		pla				pla
.2e2d	85 1e		sta $1e				sta 	zTemp0
.2e2f	a5 0c		lda $0c				lda 	IFR0+IM0
.2e31	92 1e		sta ($1e)			sta 	(zTemp0)
.2e33	28		plp				plp
.2e34	90 08		bcc $2e3e			bcc 	_DPExit
.2e36	5a		phy				phy
.2e37	a5 0d		lda $0d				lda 	IFR0+IM1
.2e39	a0 01		ldy #$01			ldy 	#1
.2e3b	91 1e		sta ($1e),y			sta 	(zTemp0),y
.2e3d	7a		ply				ply
.2e3e					_DPExit:
.2e3e	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/inputprint.asm

.2e3f					Command_Print:
.2e3f					Command_IP_Main:
.2e3f	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.2e40					_CPLoop:
.2e40	08		php				php 								; save last action flag
.2e41	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get next character
.2e43	c9 8c		cmp #$8c			cmp  	#PR_LSQLSQENDRSQRSQ 		; end of line or colon, exit now.
.2e45	f0 3e		beq $2e85			beq 	_CPExit 					; without consuming
.2e47	c9 9b		cmp #$9b			cmp 	#PR_COLON
.2e49	f0 3a		beq $2e85			beq 	_CPExit
.2e4b	68		pla				pla 								; throw last action flag
.2e4c	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; next character and bump
.2e4e	c8		iny				iny
.2e4f	c9 9a		cmp #$9a			cmp 	#PR_SEMICOLON				; is it a semicolon
.2e51	f0 2f		beq $2e82			beq 	_CPContinueWithSameLine
.2e53	c9 99		cmp #$99			cmp 	#PR_COMMA 					; comma
.2e55	f0 26		beq $2e7d			beq 	_CPTab
.2e57	88		dey				dey 								; undo the get.
.2e58	20 1a 31	jsr $311a			jsr 	EXPEvaluateExpression 		; evaluate expression.
.2e5b	24 0f		bit $0f				bit 	IFR0+IExp 					; is it a number ?
.2e5d	10 14		bpl $2e73			bpl 	_CPNumber
.2e5f	5a		phy				phy
.2e60	18		clc				clc 								; string address to YX
.2e61	a5 0c		lda $0c				lda 	IFR0+IM0
.2e63	aa		tax				tax
.2e64	a5 0d		lda $0d				lda 	IFR0+IM1
.2e66	a8		tay				tay
.2e67	e8		inx				inx 								; point to 1st character
.2e68	d0 01		bne $2e6b			bne 	_CPNoCarry
.2e6a	c8		iny				iny
.2e6b					_CPNoCarry:
.2e6b	b2 0c		lda ($0c)			lda 	(IFR0+IM0)					; length to A
.2e6d	20 8e 2e	jsr $2e8e			jsr 	CPPrintAYX 					; print AYX
.2e70	7a		ply				ply
.2e71	80 cc		bra $2e3f			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.2e73					_CPNumber:
.2e73	5a		phy				phy
.2e74	20 a2 47	jsr $47a2			jsr 	IFloatFloatToStringR0 		; convert to string at YX length A
.2e77	20 8e 2e	jsr $2e8e			jsr 	CPPrintAYX 					; print AYX
.2e7a	7a		ply				ply
.2e7b	80 c2		bra $2e3f			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.2e7d					_CPTab:
.2e7d	a9 09		lda #$09			lda 	#9 							; print TAB
.2e7f	20 a1 2e	jsr $2ea1			jsr 	CPPrintA
.2e82					_CPContinueWithSameLine:
.2e82	38		sec				sec 								; loop round with carry set, which
.2e83	80 bb		bra $2e40			bra 	_CPLoop 					; will inhibit final CR
.2e85					_CPExit:
.2e85	28		plp				plp 								; get last action flag
.2e86	b0 05		bcs $2e8d			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.2e88	a9 0d		lda #$0d			lda 	#13 						; print new line
.2e8a	20 a1 2e	jsr $2ea1			jsr 	CPPrintA
.2e8d					_CPExit2:
.2e8d	60		rts				rts
.2e8e					CPPrintAYX:
.2e8e	86 1e		stx $1e				stx 	zTemp0
.2e90	84 1f		sty $1f				sty 	zTemp0+1
.2e92	aa		tax				tax
.2e93	f0 0b		beq $2ea0			beq 	_CPPrintExit
.2e95	a0 00		ldy #$00			ldy 	#0
.2e97					_CPPrintAYXLoop:
.2e97	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.2e99	20 a1 2e	jsr $2ea1			jsr 	CPPrintA
.2e9c	c8		iny				iny
.2e9d	ca		dex				dex
.2e9e	d0 f7		bne $2e97			bne 	_CPPrintAYXLoop
.2ea0					_CPPrintExit:
.2ea0	60		rts				rts
.2ea1					CPPrintA:
.2ea1	4c f1 ff	jmp $fff1			jmp 	OSWriteScreen

;******  Return to file: include.files


;******  Processing file: src/commands/let.asm

.2ea4					CommandLET:
.2ea4	20 e2 31	jsr $31e2			jsr 	EXPTermR0 					; get term
.2ea7	90 6d		bcc $2f16			bcc 	_CLError 					; must be a reference term.
.2ea9	a5 0c		lda $0c				lda 	IFR0+IM0 					; push address and type onto stack
.2eab	48		pha				pha
.2eac	a5 0d		lda $0d				lda 	IFR0+IM1
.2eae	48		pha				pha
.2eaf	a5 0f		lda $0f				lda 	IFR0+IExp
.2eb1	48		pha				pha
.2eb2	a9 ef		lda #$ef			lda 	#PR_EQUAL 					; equals for syntax
.2eb4	20 b4 40	jsr $40b4			jsr 	ERRCheckA
.2eb7	20 1a 31	jsr $311a			jsr 	EXPEvaluateExpression 		; right hand side.
.2eba	68		pla				pla 								; type of l-expr
.2ebb	45 0f		eor $0f				eor 	IFR0+IExp 					; check types match
.2ebd	30 5a		bmi $2f19			bmi 	_CLType
.2ebf	fa		plx				plx 	 							; pop target address to zTemp0
.2ec0	86 1f		stx $1f				stx 	zTemp0+1
.2ec2	fa		plx				plx
.2ec3	86 1e		stx $1e				stx 	zTemp0
.2ec5	a5 0f		lda $0f				lda 	IFR0+IExp 					; string assignment
.2ec7	30 15		bmi $2ede			bmi 	_CLStringAssign
.2ec9	5a		phy				phy
.2eca	a0 03		ldy #$03			ldy 	#3
.2ecc	91 1e		sta ($1e),y			sta 	(zTemp0),y
.2ece	88		dey				dey
.2ecf	a5 0e		lda $0e				lda 	IFR0+IM2
.2ed1	91 1e		sta ($1e),y			sta 	(zTemp0),y
.2ed3	88		dey				dey
.2ed4	a5 0d		lda $0d				lda 	IFR0+IM1
.2ed6	91 1e		sta ($1e),y			sta 	(zTemp0),y
.2ed8	a5 0c		lda $0c				lda 	IFR0+IM0
.2eda	92 1e		sta ($1e)			sta 	(zTemp0)
.2edc	7a		ply				ply
.2edd	60		rts				rts
.2ede					_CLStringAssign:
.2ede	5a		phy				phy
.2edf	a0 01		ldy #$01			ldy 	#1 							; check if any concreted string.
.2ee1	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.2ee3	12 1e		ora ($1e)			ora 	(zTemp0)
.2ee5	f0 23		beq $2f0a			beq 	_CLConcreteString
.2ee7	b2 1e		lda ($1e)			lda 	(zTemp0) 					; copy address of string to zTemp1
.2ee9	85 20		sta $20				sta 	zTemp1
.2eeb	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.2eed	85 21		sta $21				sta 	zTemp1+1
.2eef	b2 20		lda ($20)			lda 	(zTemp1) 					; bytes available in the new slot
.2ef1	38		sec				sec 								; we want 3 for slot size, status, string size.
.2ef2	e9 03		sbc #$03			sbc 	#3
.2ef4	d2 0c		cmp ($0c)			cmp 	(IFR0) 						; compare against string size.
.2ef6	90 12		bcc $2f0a			bcc 	_CLConcreteString 			; if so, concrete the string again.
.2ef8	b2 0c		lda ($0c)			lda 	(IFR0) 						; copy size + 1 bytes (for the length byte.)
.2efa	1a		inc a				inc 	a
.2efb	aa		tax				tax
.2efc	a0 00		ldy #$00			ldy 	#0 							; offset in replacement string.
.2efe					_CLReplaceString:
.2efe	b1 0c		lda ($0c),y			lda 	(IFR0),y 					; copy new string into previous space.
.2f00	c8		iny				iny
.2f01	c8		iny				iny
.2f02	91 20		sta ($20),y			sta 	(zTemp1),y
.2f04	88		dey				dey
.2f05	ca		dex				dex
.2f06	d0 f6		bne $2efe			bne 	_CLReplaceString
.2f08	80 0a		bra $2f14			bra 	_CLExit
.2f0a					_CLConcreteString:
.2f0a	20 27 41	jsr $4127			jsr 	StringConcrete  			; concreted string in XA.
.2f0d	a0 01		ldy #$01			ldy 	#1 							; store the address
.2f0f	92 1e		sta ($1e)			sta 	(zTemp0)
.2f11	8a		txa				txa
.2f12	91 1e		sta ($1e),y			sta 	(zTemp0),y
.2f14					_CLExit:
.2f14	7a		ply				ply
.2f15	60		rts				rts
.2f16					_CLError:
.2f16	4c 48 40	jmp $4048		jmp	ErrorV_variable
.2f19					_CLType:
.2f19	4c 52 3f	jmp $3f52		jmp	ErrorV_type

;******  Return to file: include.files


;******  Processing file: src/commands/new.asm

.2f1c					Command_NEW:
.2f1c	20 67 39	jsr $3967			jsr 	PGMNewProgram
.2f1f	20 a9 2c	jsr $2ca9			jsr 	Command_CLEAR
.2f22	4c 7f 2f	jmp $2f7f			jmp 	Command_END

;******  Return to file: include.files


;******  Processing file: src/commands/rem.asm

.2f25					Command_REM:
.2f25					Command_REM2:
.2f25	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; optional string parameter
.2f27	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ
.2f29	d0 06		bne $2f31			bne 	_CRExit
.2f2b	c8		iny				iny 								; skip over it, it's a comment.
.2f2c	98		tya				tya
.2f2d	38		sec				sec
.2f2e	71 1c		adc ($1c),y			adc 	(codePtr),y
.2f30	a8		tay				tay
.2f31					_CRExit:
.2f31	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/run.asm

.2f32					Command_RUN:
.2f32	20 a9 2c	jsr $2ca9			jsr 	Command_CLEAR 				; clear everything out.
.2f35	ad 10 05	lda $0510			lda 	PGMBaseHigh 				; back to the program start
.2f38	85 1d		sta $1d				sta 	codePtr+1
.2f3a	64 1c		stz $1c				stz 	codePtr
.2f3c	80 0b		bra $2f49			bra 	RUNNewLine
.2f3e					RUNEndOfLine:
.2f3e	18		clc				clc 								; advance to next line.
.2f3f	b2 1c		lda ($1c)			lda 	(codePtr)
.2f41	65 1c		adc $1c				adc 	codePtr
.2f43	85 1c		sta $1c				sta 	codePtr
.2f45	90 02		bcc $2f49			bcc 	_RELNoCarry
.2f47	e6 1d		inc $1d				inc 	codePtr+1
.2f49					_RELNoCarry:
.2f49					RUNNewLine:
.2f49	a2 ff		ldx #$ff			ldx 	#$FF 						; 6502 stack reset.
.2f4b	9a		txs				txs
.2f4c	b2 1c		lda ($1c)			lda 	(codePtr) 					; check off end of program
.2f4e	f0 2f		beq $2f7f			beq 	Command_END
.2f50	a0 03		ldy #$03			ldy 	#3 							; offset into codePtr for start of line.
.2f52					RUNNewCommand:
.2f52	9c 17 06	stz $0617			stz 	stringInitialised 			; reset string system.
.2f55	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get next token
.2f57	10 1a		bpl $2f73			bpl		_RUNNotToken 				; probably an identifier
.2f59	c8		iny				iny 								; consume token
.2f5a	c9 9b		cmp #$9b			cmp 	#PR_COLON 					; fast skip colon
.2f5c	f0 f4		beq $2f52			beq 	RUNNewCommand
.2f5e	c9 aa		cmp #$aa			cmp 	#PR_STANDARD_LAST+1 		; check unary function
.2f60	b0 0e		bcs $2f70			bcs 	_RUNSyntax
.2f62	c9 80		cmp #$80			cmp 	#PR_STRUCTURE_FIRST 		; adjust for binaries at start.
.2f64	90 0a		bcc $2f70			bcc 	_RUNSyntax
.2f66	0a		asl a				asl 	a 							; double into X.
.2f67	aa		tax				tax
.2f68	20 6d 2f	jsr $2f6d			jsr 	_RUNDispatchMain			; call the main dispatcher
.2f6b	80 e5		bra $2f52			bra 	RUNNewCommand
.2f6d					_RUNDispatchMain:
.2f6d	7c 7d 36	jmp ($367d,x)			jmp 	(VectorTable,x)
.2f70					_RUNSyntax:
.2f70	4c 25 3f	jmp $3f25		jmp	ErrorV_syntax
.2f73					_RUNNotToken:
.2f73	c9 40		cmp #$40			cmp 	#$40 						; 00-3F is a syntax error
.2f75	90 f9		bcc $2f70			bcc 	_RUNSyntax
.2f77	20 a4 2e	jsr $2ea4			jsr 	CommandLET 					; assignment
.2f7a	80 d6		bra $2f52			bra 	RUNNewCommand 				; loop round.
.2f7c					Command_Shift_Handler:
.2f7c	4c 63 3f	jmp $3f63		jmp	ErrorV_unimplemented
.2f7f					Command_END:
.2f7f	4c ff ff	jmp $ffff			jmp 	$FFFF

;******  Return to file: include.files


;******  Processing file: src/commands/stop.asm

.2f82					Command_STOP:
.2f82	4c c0 3f	jmp $3fc0		jmp	ErrorV_stop

;******  Return to file: include.files


;******  Processing file: src/commands/sys.asm

.2f85					Command_Sys:
.2f85	20 6c 31	jsr $316c			jsr 	EXPEvalInteger16 			; execution address
.2f88	5a		phy				phy
.2f89	ad 62 06	lda $0662			lda 	('A'-'A')*4 + FastVariables ; load AXY
.2f8c	ae be 06	ldx $06be			ldx 	('X'-'A')*4 + FastVariables
.2f8f	ac c2 06	ldy $06c2			ldy 	('Y'-'A')*4 + FastVariables
.2f92	20 97 2f	jsr $2f97			jsr 	_CSCallIFR0 				; call the code
.2f95	7a		ply				ply
.2f96	60		rts				rts
.2f97					_CSCallIFR0:
.2f97	6c 0c 00	jmp ($000c)			jmp 	(IFR0+IM0)

;******  Return to file: include.files


;******  Processing file: src/commands/unused.asm

.2f9a					NoExec01:
.2f9a					NoExec02:
.2f9a					NoExec03:
.2f9a					NoExec04:
.2f9a					NoExec05:
.2f9a					NoExec06:
.2f9a					NoExec07:
.2f9a					NoExec08:
.2f9a	4c 25 3f	jmp $3f25		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/binary/basic.asm

.2f9d					EXPBinAdd:
.2f9d	24 0f		bit $0f				bit 	IFR0+IExp
.2f9f	30 6f		bmi $3010			bmi 	EXPConcatenate
.2fa1	a2 10		ldx #$10			ldx 	#IFR1
.2fa3	4c 9b 43	jmp $439b			jmp 	IFloatAdd
.2fa6					EXPBinSub:
.2fa6	24 0f		bit $0f				bit 	IFR0+IExp
.2fa8	30 3f		bmi $2fe9			bmi 	EXPTypeError
.2faa	a2 10		ldx #$10			ldx 	#IFR1
.2fac	4c 94 43	jmp $4394			jmp 	IFloatSubtract
.2faf					EXPBinMul:
.2faf	24 0f		bit $0f				bit 	IFR0+IExp
.2fb1	30 36		bmi $2fe9			bmi 	EXPTypeError
.2fb3	a2 10		ldx #$10			ldx 	#IFR1
.2fb5	4c 45 44	jmp $4445			jmp 	IFloatMultiply
.2fb8					EXPBinFDiv:
.2fb8	24 0f		bit $0f				bit 	IFR0+IExp
.2fba	30 2d		bmi $2fe9			bmi 	EXPTypeError
.2fbc	a2 10		ldx #$10			ldx 	#IFR1
.2fbe	20 c8 46	jsr $46c8			jsr 	IFloatDivideFloat
.2fc1	b0 0f		bcs $2fd2			bcs 	EXPDZero
.2fc3	60		rts				rts
.2fc4					EXPBinIDiv:
.2fc4	24 0f		bit $0f				bit 	IFR0+IExp
.2fc6	30 21		bmi $2fe9			bmi 	EXPTypeError
.2fc8	a2 10		ldx #$10			ldx 	#IFR1
.2fca	20 c8 46	jsr $46c8			jsr 	IFloatDivideFloat
.2fcd	b0 03		bcs $2fd2			bcs 	EXPDZero
.2fcf	4c a5 46	jmp $46a5			jmp 	IFloatIntegerR0
.2fd2					EXPDZero:
.2fd2	4c 97 3f	jmp $3f97		jmp	ErrorV_divzero
.2fd5					EXPBinIMod:
.2fd5	24 0f		bit $0f				bit 	IFR0+IExp
.2fd7	30 10		bmi $2fe9			bmi 	EXPTypeError
.2fd9	a2 10		ldx #$10			ldx 	#IFR1
.2fdb	5a		phy				phy
.2fdc	20 dd 45	jsr $45dd			jsr 	IFPreProcessBitwise 		; set up everything.
.2fdf	d0 05		bne $2fe6			bne 	EXPDRange
.2fe1	20 16 45	jsr $4516			jsr 	IFloatModulusInteger
.2fe4	7a		ply				ply
.2fe5	60		rts				rts
.2fe6					EXPDRange:
.2fe6	4c 35 3f	jmp $3f35		jmp	ErrorV_range
.2fe9					EXPTypeError:
.2fe9	4c 52 3f	jmp $3f52		jmp	ErrorV_type
.2fec					EXPBinAnd:
.2fec	24 0f		bit $0f				bit 	IFR0+IExp
.2fee	30 f9		bmi $2fe9			bmi 	EXPTypeError
.2ff0	a2 10		ldx #$10			ldx 	#IFR1
.2ff2	20 98 45	jsr $4598			jsr 	IFloatBitwiseAnd
.2ff5	b0 ef		bcs $2fe6			bcs 	EXPDRange
.2ff7	60		rts				rts
.2ff8					EXPBinOr:
.2ff8	24 0f		bit $0f				bit 	IFR0+IExp
.2ffa	30 ed		bmi $2fe9			bmi 	EXPTypeError
.2ffc	a2 10		ldx #$10			ldx 	#IFR1
.2ffe	20 af 45	jsr $45af			jsr 	IFloatBitwiseOr
.3001	b0 e3		bcs $2fe6			bcs 	EXPDRange
.3003	60		rts				rts
.3004					EXPBinXor:
.3004	24 0f		bit $0f				bit 	IFR0+IExp
.3006	30 e1		bmi $2fe9			bmi 	EXPTypeError
.3008	a2 10		ldx #$10			ldx 	#IFR1
.300a	20 c6 45	jsr $45c6			jsr 	IFloatBitwiseXor
.300d	b0 d7		bcs $2fe6			bcs 	EXPDRange
.300f	60		rts				rts
.3010					EXPConcatenate:
.3010	18		clc				clc
.3011	b2 0c		lda ($0c)			lda 	(IFR0) 	 					; work out total length
.3013	72 10		adc ($10)			adc 	(IFR1)
.3015	b0 2d		bcs $3044			bcs 	_EXPCError
.3017	a6 0c		ldx $0c				ldx 	IFR0 						; push R0 string on stack.
.3019	da		phx				phx
.301a	a6 0d		ldx $0d				ldx 	IFR0+1
.301c	da		phx				phx
.301d	20 9a 41	jsr $419a			jsr 	StringTempAllocate 			; allocate string, set up return
.3020	a6 11		ldx $11				ldx 	IFR1+1 						; copy first string.
.3022	a5 10		lda $10				lda 	IFR1
.3024	20 2d 30	jsr $302d			jsr 	_EXPCCopyXA
.3027	fa		plx				plx 								; copy second string
.3028	68		pla				pla
.3029	20 2d 30	jsr $302d			jsr 	_EXPCCopyXA
.302c	60		rts				rts
.302d					_EXPCCopyXA:
.302d	86 1f		stx $1f				stx 	zTemp0+1 					; save address to zTemp0
.302f	85 1e		sta $1e				sta 	zTemp0
.3031	b2 1e		lda ($1e)			lda 	(zTemp0)					; length
.3033	f0 0e		beq $3043			beq 	_EXPCCExit 					; nothing.
.3035	aa		tax				tax 								; count
.3036	5a		phy				phy 								; start positioin
.3037	a0 01		ldy #$01			ldy 	#1
.3039					_EXPCCLoop:
.3039	b1 1e		lda ($1e),y			lda 	(zTemp0),y 					; write characters one at a time.
.303b	20 cf 41	jsr $41cf			jsr 	StringTempWrite
.303e	c8		iny				iny
.303f	ca		dex				dex
.3040	d0 f7		bne $3039			bne 	_EXPCCLoop
.3042	7a		ply				ply
.3043					_EXPCCExit:
.3043	60		rts				rts
.3044					_EXPCError:
.3044	4c 33 40	jmp $4033		jmp	ErrorV_string

;******  Return to file: include.files


;******  Processing file: src/expression/binary/compare.asm

.3047					EXPReturnTrue:
.3047	a2 0c		ldx #$0c			ldx 	#IFR0
.3049	a9 01		lda #$01			lda 	#1
.304b	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.304e	20 b0 49	jsr $49b0			jsr 	IFloatNegate
.3051	60		rts				rts
.3052					EXPReturnFalse:
.3052	a2 0c		ldx #$0c			ldx 	#IFR0
.3054	4c a5 49	jmp $49a5			jmp 	IFloatSetZero
.3057					EXPCompareEqual:
.3057	20 8d 30	jsr $308d			jsr 	EXPCompareBaseCode
.305a	c9 00		cmp #$00			cmp 	#0
.305c	f0 e9		beq $3047			beq 	EXPReturnTrue
.305e	80 f2		bra $3052			bra 	EXPReturnFalse
.3060					EXPCompareLess:
.3060	20 8d 30	jsr $308d			jsr 	EXPCompareBaseCode
.3063	c9 ff		cmp #$ff			cmp 	#$FF
.3065	f0 e0		beq $3047			beq 	EXPReturnTrue
.3067	80 e9		bra $3052			bra 	EXPReturnFalse
.3069					EXPCompareGreater:
.3069	20 8d 30	jsr $308d			jsr 	EXPCompareBaseCode
.306c	c9 01		cmp #$01			cmp 	#1
.306e	f0 d7		beq $3047			beq 	EXPReturnTrue
.3070	80 e0		bra $3052			bra 	EXPReturnFalse
.3072					EXPCompareNotEqual:
.3072	20 8d 30	jsr $308d			jsr 	EXPCompareBaseCode
.3075	c9 00		cmp #$00			cmp 	#0
.3077	d0 ce		bne $3047			bne 	EXPReturnTrue
.3079	80 d7		bra $3052			bra 	EXPReturnFalse
.307b					EXPCompareLessEqual:
.307b	20 8d 30	jsr $308d			jsr 	EXPCompareBaseCode
.307e	c9 01		cmp #$01			cmp 	#1
.3080	d0 c5		bne $3047			bne 	EXPReturnTrue
.3082	80 ce		bra $3052			bra 	EXPReturnFalse
.3084					EXPCompareGreaterEqual:
.3084	20 8d 30	jsr $308d			jsr 	EXPCompareBaseCode
.3087	c9 ff		cmp #$ff			cmp 	#$FF
.3089	d0 bc		bne $3047			bne 	EXPReturnTrue
.308b	80 c5		bra $3052			bra 	EXPReturnFalse
.308d					EXPCompareBaseCode:
.308d	24 0f		bit $0f				bit 	IFR0+IExp 					; string compare ?
.308f	30 10		bmi $30a1			bmi 	_EXCBCString
.3091	a2 10		ldx #$10			ldx 	#IFR1						; float compare
.3093	20 73 46	jsr $4673			jsr 	IFloatCompare
.3096	a5 0c		lda $0c				lda 	IFR0+IM0
.3098	f0 06		beq $30a0			beq 	_EXCBCExit 					; return 0 if zero
.309a	24 0f		bit $0f				bit 	IFR0+IExp 					; return 1 if +ve
.309c	50 02		bvc $30a0			bvc 	_EXCBCExit
.309e	a9 ff		lda #$ff			lda 	#255 						; return $FF if -ve
.30a0					_EXCBCExit:
.30a0	60		rts				rts
.30a1					_EXCBCString:
.30a1	5a		phy				phy
.30a2	b2 0c		lda ($0c)			lda 	(IFR0) 						; length of smaller of the two in X.
.30a4	d2 10		cmp ($10)			cmp 	(IFR1)
.30a6	90 02		bcc $30aa			bcc 	_EXCBCSmaller
.30a8	b2 10		lda ($10)			lda 	(IFR1)
.30aa					_EXCBCSmaller:
.30aa	aa		tax				tax
.30ab	f0 0d		beq $30ba			beq 	_EXCBCMatches 				; if zero common length matches
.30ad	a0 00		ldy #$00			ldy 	#0 							; match the strings.
.30af					_EXCBCCheckSmallerMatches:
.30af	c8		iny				iny 								; compare directly as far as common length
.30b0	38		sec				sec
.30b1	b1 10		lda ($10),y			lda 	(IFR1),y
.30b3	f1 0c		sbc ($0c),y			sbc 	(IFR0),y
.30b5	d0 08		bne $30bf			bne 	_EXCBCExit2
.30b7	ca		dex				dex
.30b8	d0 f5		bne $30af			bne 	_EXCBCCheckSmallerMatches
.30ba					_EXCBCMatches:
.30ba	38		sec				sec
.30bb	b2 10		lda ($10)			lda 	(IFR1) 						; common length matches. If same length equal
.30bd	f2 0c		sbc ($0c)			sbc 	(IFR0)						; if len(r1) > len(r0) then r1 is longer
.30bf					_EXCBCExit2:
.30bf	7a		ply				ply
.30c0	c9 00		cmp #$00			cmp 	#0
.30c2	f0 04		beq $30c8			beq 	_EXCBCReturn
.30c4	30 03		bmi $30c9			bmi 	_EXCBCFF
.30c6	a9 01		lda #$01			lda 	#1
.30c8					_EXCBCReturn:
.30c8	60		rts				rts
.30c9					_EXCBCFF:
.30c9	a9 ff		lda #$ff			lda 	#$FF
.30cb	60		rts				rts
.30cc					_EXCBCRange:
.30cc	4c 35 3f	jmp $3f35		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/binary/shift.asm

.30cf					EXPBinLeft:
.30cf	a9 ff		lda #$ff			lda 	#$FF
.30d1	8d 07 05	sta $0507			sta 	EXPShiftLeftFlag
.30d4	4c da 30	jmp $30da			jmp 	EXPShiftCommon
.30d7					EXPBinRight:
.30d7	9c 07 05	stz $0507			stz 	EXPShiftLeftFlag
.30da					EXPShiftCommon:
.30da	a5 0f		lda $0f				lda 	IFR0+IExp 					; both integers
.30dc	05 13		ora $13				ora 	IFR1+IExp
.30de	29 7f		and #$7f			and 	#$7F
.30e0	d0 35		bne $3117			bne 	_EXPSRange
.30e2	a5 0c		lda $0c				lda 	IFR0+IM0					; check shift >= 32
.30e4	29 e0		and #$e0			and 	#$E0
.30e6	05 0d		ora $0d				ora 	IFR0+IM1
.30e8	05 0e		ora $0e				ora 	IFR0+IM2
.30ea	d0 25		bne $3111			bne 	_EXPSShiftZero 				; if so return zero
.30ec	5a		phy				phy
.30ed	a5 0c		lda $0c				lda 	IFR0+IM0 					; get shift
.30ef	29 1f		and #$1f			and 	#$1F
.30f1	f0 17		beq $310a			beq 	_EXPSExit 					; exit if zero
.30f3	a8		tay				tay
.30f4					_EXPSLoop:
.30f4	a2 10		ldx #$10			ldx 	#IFR1
.30f6	2c 07 05	bit $0507			bit 	EXPShiftLeftFlag
.30f9	30 05		bmi $3100			bmi 	_EXPSShiftLeft
.30fb	20 d4 49	jsr $49d4			jsr 	IFloatShiftRight
.30fe	80 07		bra $3107			bra 	_EXPSContinue
.3100					_EXPSShiftLeft:
.3100	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.3103	24 0e		bit $0e				bit 	IFR0+IM2 					; too many shifts
.3105	30 10		bmi $3117			bmi 	_EXPSRange
.3107					_EXPSContinue:
.3107	88		dey				dey
.3108	d0 ea		bne $30f4			bne 	_EXPSLoop
.310a					_EXPSExit:
.310a	a2 10		ldx #$10			ldx 	#IFR1
.310c	20 36 49	jsr $4936			jsr 	IFloatCopyFromRegister
.310f	7a		ply				ply
.3110	60		rts				rts
.3111					_EXPSShiftZero:
.3111	a2 0c		ldx #$0c			ldx 	#IFR0
.3113	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.3116	60		rts				rts
.3117					_EXPSRange:
.3117	4c 35 3f	jmp $3f35		jmp	ErrorV_range
.0507					EXPShiftLeftFlag:
>0507							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/expression/expression.asm

.311a					EXPEvaluateExpression:
.311a	a9 00		lda #$00			lda 	#0 							; current precedence
.311c					EXPEvaluateExpressionPrecedenceA:
.311c	48		pha				pha
.311d	20 97 31	jsr $3197			jsr 	EXPTermValueR0				; do first term.
.3120					_EELoop:
.3120	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; what follows needs to be a binary operator
.3122	c9 ef		cmp #$ef			cmp 	#PR_BINARY_FIRST 			; binary tokens are the last ones up to $FF
.3124	90 31		bcc $3157			bcc 	_EEExit
.3126	aa		tax				tax 								; access the precedence of the operator.
.3127	68		pla				pla 								; restore precedence.if >= operator precedence then exit
.3128	dd d5 33	cmp $33d5,x			cmp 	BinaryPrecedence-PR_BINARY_FIRST,x
.312b	b0 2b		bcs $3158			bcs 	_EEExit2
.312d	48		pha				pha 								; save current precedence.
.312e	da		phx				phx 								; save operator
.312f	c8		iny				iny 								; consume operator
.3130	da		phx				phx
.3131	a2 0c		ldx #$0c			ldx 	#IFR0 						; push R0 on the stack
.3133	20 f4 48	jsr $48f4			jsr 	IFloatPushRx
.3136	fa		plx				plx
.3137	bd d5 33	lda $33d5,x			lda 	BinaryPrecedence-PR_BINARY_FIRST,x
.313a	20 1c 31	jsr $311c			jsr 	EXPEvaluateExpressionPrecedenceA
.313d	a2 10		ldx #$10			ldx 	#IFR1 						; pop LHS to R1.
.313f	20 15 49	jsr $4915			jsr 	IFloatPullRx
.3142	fa		plx				plx 								; operator
.3143	a5 0f		lda $0f				lda 	IFR0+IExp 					; if check types match.
.3145	45 13		eor $13				eor 	IFR1+IExp
.3147	30 08		bmi $3151			bmi 	_EEType
.3149					_EETypeOkay:
.3149	8a		txa				txa
.314a	0a		asl a				asl 	a 							; double -> X
.314b	aa		tax				tax
.314c	20 54 31	jsr $3154			jsr 	_EECallBinary 				; call the operator R0 := R1 <op> R0
.314f	80 cf		bra $3120			bra 	_EELoop
.3151					_EEType:
.3151	4c 52 3f	jmp $3f52		jmp	ErrorV_type
.3154					_EECallBinary:
.3154	7c 7d 36	jmp ($367d,x)			jmp 	(VectorTable,x)
.3157					_EEExit:
.3157	68		pla				pla 								; throw precedence
.3158					_EEExit2:
.3158	18		clc				clc
.3159	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/exprutils.asm

.315a					EXPEvalNumber:
.315a	20 1a 31	jsr $311a			jsr 	EXPEvaluateExpression
.315d	24 0f		bit $0f				bit 	IFR0+IExp
.315f	30 01		bmi $3162			bmi 	EVUType
.3161	60		rts				rts
.3162					EVUType:
.3162	4c 52 3f	jmp $3f52		jmp	ErrorV_type
.3165					EXPEvalInteger:
.3165	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 				; get number, coeerce to integer.
.3168	20 a5 46	jsr $46a5			jsr 	IFloatIntegerR0
.316b	60		rts				rts
.316c					EXPEvalInteger16:
.316c	20 65 31	jsr $3165			jsr 	EXPEvalInteger
.316f	a5 0e		lda $0e				lda 	IFR0+IM2
.3171	d0 21		bne $3194			bne 	EVURange
.3173	a6 0d		ldx $0d				ldx 	IFR0+IM1
.3175	a5 0c		lda $0c				lda 	IFR0+IM0
.3177	60		rts				rts
.3178					EXPEvalInteger8:
.3178	20 65 31	jsr $3165			jsr 	EXPEvalInteger
.317b	a5 0e		lda $0e				lda 	IFR0+IM2
.317d	05 0d		ora $0d				ora 	IFR0+IM1
.317f	d0 13		bne $3194			bne 	EVURange
.3181	a5 0c		lda $0c				lda 	IFR0+IM0
.3183	60		rts				rts
.3184					EXPEvalString:
.3184	20 1a 31	jsr $311a			jsr 	EXPEvaluateExpression
.3187	24 0f		bit $0f				bit 	IFR0+IExp
.3189	10 d7		bpl $3162			bpl 	EVUType
.318b	a6 0d		ldx $0d				ldx 	IFR0+IM1
.318d	86 1f		stx $1f				stx 	zTemp0+1
.318f	a5 0c		lda $0c				lda 	IFR0+IM0
.3191	85 1e		sta $1e				sta 	zTemp0
.3193	60		rts				rts
.3194					EVURange:
.3194	4c 35 3f	jmp $3f35		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/term.asm

.3197					EXPTermValueR0:
.3197	20 e2 31	jsr $31e2			jsr 	EXPTermR0 					; get term
.319a	90 45		bcc $31e1			bcc 	_ETVNotReference 			; exit if value.
.319c	5a		phy				phy
.319d	a0 03		ldy #$03			ldy 	#3 							; get type
.319f	b1 0c		lda ($0c),y			lda 	(IFR0),y
.31a1	30 14		bmi $31b7			bmi 	_ETVDereferenceString
.31a3	85 0f		sta $0f				sta 	IFR0+IExp 					; dereference to R0
.31a5	88		dey				dey
.31a6	b1 0c		lda ($0c),y			lda 	(IFR0),y
.31a8	85 0e		sta $0e				sta 	IFR0+IM2
.31aa	88		dey				dey
.31ab	b1 0c		lda ($0c),y			lda 	(IFR0),y
.31ad	aa		tax				tax
.31ae	b2 0c		lda ($0c)			lda 	(IFR0)
.31b0	86 0d		stx $0d				stx 	IFR0+IM1
.31b2	85 0c		sta $0c				sta 	IFR0+IM0
.31b4	7a		ply				ply
.31b5	18		clc				clc
.31b6	60		rts				rts
.31b7					_ETVDereferenceString:
.31b7	a0 01		ldy #$01			ldy 	#1 							; check if it is as yet unassigned.
.31b9	b1 0c		lda ($0c),y			lda 	(IFR0),y
.31bb	12 0c		ora ($0c)			ora 	(IFR0)
.31bd	f0 11		beq $31d0			beq 	_ETVNull
.31bf	b1 0c		lda ($0c),y			lda 	(IFR0),y 					; load address of string to XA
.31c1	aa		tax				tax
.31c2	b2 0c		lda ($0c)			lda 	(IFR0)
.31c4	18		clc				clc 								; add two so points to actual string.
.31c5	69 02		adc #$02			adc 	#2
.31c7	90 01		bcc $31ca			bcc 	_EVDSNoCarry
.31c9	e8		inx				inx
.31ca					_EVDSNoCarry:
.31ca	86 0d		stx $0d				stx 	IFR0+IM1 					; save in slots
.31cc	85 0c		sta $0c				sta 	IFR0
.31ce	80 08		bra $31d8			bra 	_ETVFillExit 				; tidy up and exit.
.31d0					_ETVNull:
.31d0	a9 e0		lda #$e0			lda 	#_EVTNString & $FF
.31d2	85 0c		sta $0c				sta 	IFR0+IM0
.31d4	a9 31		lda #$31			lda 	#_EVTNString >> 8
.31d6	85 0d		sta $0d				sta 	IFR0+IM1
.31d8					_ETVFillExit:
.31d8	64 0e		stz $0e				stz 	IFR0+IM2
.31da	a9 80		lda #$80			lda 	#$80
.31dc	85 0f		sta $0f				sta 	IFR0+IExp
.31de	7a		ply				ply
.31df	60		rts				rts
.31e0					_EVTNString:
>31e0	00						.byte 	0
.31e1					_ETVNotReference:
.31e1	60		rts				rts
.31e2					EXPTermR0:
.31e2	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get next token/element
.31e4	30 10		bmi $31f6			bmi 	_ETMIsUnaryOrMinus 			; if it's a token, it's a unary function, maybe -
.31e6	c8		iny				iny 								; consume element
.31e7	c9 40		cmp #$40			cmp 	#$40 						; 40-7F are identifiers.
.31e9	b0 08		bcs $31f3			bcs 	_ETMIdentifier
.31eb	20 1a 32	jsr $321a			jsr 	EXPExtractTokenisedInteger 	; pull out tokenised integer to R0
.31ee	20 4d 32	jsr $324d			jsr 	EXPCheckDecimalFollows 		; check for decimals.
.31f1	18		clc				clc 								; return value
.31f2	60		rts				rts
.31f3					_ETMIdentifier:
.31f3	4c 3c 43	jmp $433c			jmp 	VARCheckSimple 				; check simple variables A-Z
.31f6					_ETMIsUnaryOrMinus:
.31f6	c8		iny				iny 								; consume element
.31f7	c9 fe		cmp #$fe			cmp 	#PR_MINUS 					; handle - seperately as it has two roles.
.31f9	d0 0a		bne $3205			bne 	_ETMCheckUnary
.31fb	20 97 31	jsr $3197			jsr 	EXPTermValueR0 				; get a term to negate
.31fe	a2 0c		ldx #$0c			ldx 	#IFR0 						; and negate it
.3200	20 b0 49	jsr $49b0			jsr 	IFloatNegate
.3203	18		clc				clc
.3204	60		rts				rts
.3205					_ETMCheckUnary:
.3205	c9 d5		cmp #$d5			cmp 	#PR_UNARY_FIRST 			; check unary function.
.3207	90 0e		bcc $3217			bcc 	_ETMUnarySyntax
.3209	c9 ef		cmp #$ef			cmp 	#PR_UNARY_LAST+1
.320b	b0 0a		bcs $3217			bcs 	_ETMUnarySyntax
.320d	0a		asl a				asl 	a
.320e	aa		tax				tax
.320f	20 14 32	jsr $3214			jsr 	_ETMCallUnaryFunction
.3212	18		clc				clc
.3213	60		rts				rts
.3214					_ETMCallUnaryFunction:
.3214	7c 7d 36	jmp ($367d,x)			jmp 	(VectorTable,x)
.3217					_ETMUnarySyntax:
.3217	4c 25 3f	jmp $3f25		jmp	ErrorV_syntax
.321a					EXPExtractTokenisedInteger:
.321a	85 0c		sta $0c				sta 	IFR0+IM0 					; initial value in IM0
.321c	64 0f		stz $0f				stz 	IFR0+IExp
.321e	64 0d		stz $0d				stz 	IFR0+IM1
.3220	64 0e		stz $0e				stz 	IFR0+IM2
.3222					_ETMConstant:
.3222	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; what follows.
.3224	c9 40		cmp #$40			cmp 	#$40 						; continuing constant
.3226	b0 24		bcs $324c			bcs 	_ETMCExit 					; no.
.3228	a6 0e		ldx $0e				ldx 	IFR0+IM2 					; x 256 into A:M2 M1 M0
.322a	a5 0d		lda $0d				lda 	IFR0+IM1
.322c	85 0e		sta $0e				sta 	IFR0+IM2
.322e	a5 0c		lda $0c				lda 	IFR0+IM0
.3230	85 0d		sta $0d				sta 	IFR0+IM1
.3232	64 0c		stz $0c				stz 	IFR0+IM0
.3234	8a		txa				txa
.3235	4a		lsr a				lsr 	a 							; shift right twice, e.g. whole thing is x 64
.3236	66 0e		ror $0e				ror 	IFR0+IM2
.3238	66 0d		ror $0d				ror 	IFR0+IM1
.323a	66 0c		ror $0c				ror 	IFR0+IM0
.323c	4a		lsr a				lsr 	a
.323d	66 0e		ror $0e				ror 	IFR0+IM2
.323f	66 0d		ror $0d				ror 	IFR0+IM1
.3241	66 0c		ror $0c				ror 	IFR0+IM0
.3243	a5 0c		lda $0c				lda 	IFR0+IM0 					; LSB in.
.3245	11 1c		ora ($1c),y			ora 	(codePtr),y
.3247	85 0c		sta $0c				sta 	IFR0+IM0
.3249	c8		iny				iny 								; consume, loop back
.324a	80 d6		bra $3222			bra 	_ETMConstant
.324c					_ETMCExit:
.324c	60		rts				rts
.324d					EXPCheckDecimalFollows:
.324d	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; check for decimal
.324f	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ
.3251	d0 19		bne $326c			bne 	_ETMCDExit
.3253	c8		iny				iny 								; consume token.
.3254	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get count
.3256	5a		phy				phy									; save current position
.3257	48		pha				pha 								; save count of chars.
.3258	38		sec				sec 								; address into YX : y + codePtr+1
.3259	98		tya				tya
.325a	65 1c		adc $1c				adc 	codePtr
.325c	aa		tax				tax
.325d	a5 1d		lda $1d				lda 	codePtr+1
.325f	69 00		adc #$00			adc 	#0
.3261	a8		tay				tay
.3262	68		pla				pla 								; get count.
.3263	20 49 48	jsr $4849			jsr 	IFloatAddDecimalToR0 		; add the decimal to R0
.3266	7a		ply				ply 								; go to next token.
.3267	98		tya				tya
.3268	38		sec				sec
.3269	71 1c		adc ($1c),y			adc 	(codePtr),y
.326b	a8		tay				tay
.326c					_ETMCDExit:
.326c	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/abs.asm

.326d					EXPUnaryAbs:
.326d	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 					; number to R0
.3270	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.3273	20 e9 45	jsr $45e9			jsr 	IFloatAbsoluteR0
.3276	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/asc.asm

.3277					EXPUnaryAsc:
.3277	20 84 31	jsr $3184			jsr 	EXPEvalString 					; string to R0, zTemp0
.327a	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.327d	b2 1e		lda ($1e)			lda 	(zTemp0) 						; length 0 ?
.327f	f0 06		beq $3287			beq 	_EXAZero 						; if so return 0
.3281	5a		phy				phy 									; otherwise get first character
.3282	a0 01		ldy #$01			ldy 	#1
.3284	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3286	7a		ply				ply
.3287					_EXAZero:
.3287	a2 0c		ldx #$0c			ldx 	#IFR0
.3289	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.328c	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/chr.asm

.328d					EXPUnaryChr:
.328d	20 78 31	jsr $3178			jsr 	EXPEvalInteger8 				; expr
.3290	48		pha				pha 									; push on stack
.3291	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.3294	a9 01		lda #$01			lda 	#1 								; alloc temp mem for result
.3296	20 9a 41	jsr $419a			jsr 	StringTempAllocate
.3299	68		pla				pla
.329a	20 cf 41	jsr $41cf			jsr 	StringTempWrite
.329d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/dec.asm

.329e					EXPUnaryDec:
.329e	20 84 31	jsr $3184			jsr 	EXPEvalString 					; string to R0, zTemp0
.32a1	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.32a4	5a		phy				phy
.32a5	a2 0c		ldx #$0c			ldx 	#IFR0 							; zero the result
.32a7	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.32aa	b2 1e		lda ($1e)			lda 	(zTemp0)						; read the length to X
.32ac	f0 3b		beq $32e9			beq 	_EUDError 						; empty string
.32ae	aa		tax				tax
.32af	a0 01		ldy #$01			ldy 	#1 								; start at offset 1
.32b1					_EUDLoop:
.32b1	b1 1e		lda ($1e),y			lda 	(zTemp0),y 						; get next
.32b3	c9 61		cmp #$61			cmp 	#"a" 							; l/c -> u/c
.32b5	90 02		bcc $32b9			bcc 	_EUDNoCase
.32b7	e9 20		sbc #$20			sbc 	#$20
.32b9					_EUDNoCase:
.32b9	c9 30		cmp #$30			cmp 	#'0' 							; check 0..9
.32bb	90 2c		bcc $32e9			bcc 	_EUDError
.32bd	c9 3a		cmp #$3a			cmp 	#'9'+1
.32bf	90 0a		bcc $32cb			bcc 	_EUDOkay
.32c1	c9 41		cmp #$41			cmp 	#'A'							; check A-F
.32c3	90 24		bcc $32e9			bcc 	_EUDError
.32c5	c9 47		cmp #$47			cmp 	#'F'+1
.32c7	b0 20		bcs $32e9			bcs 	_EUDError
.32c9	e9 06		sbc #$06			sbc 	#6 								; hex adjust
.32cb					_EUDOkay:
.32cb	29 0f		and #$0f			and 	#15 							; make constant
.32cd	da		phx				phx
.32ce	48		pha				pha
.32cf	a2 0c		ldx #$0c			ldx 	#IFR0 							; multiply R0 x 16
.32d1	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.32d4	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.32d7	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.32da	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.32dd	68		pla				pla 									; pop constant and OR in
.32de	fa		plx				plx
.32df	05 0c		ora $0c				ora 	IFR0+IM0
.32e1	85 0c		sta $0c				sta 	IFR0+IM0
.32e3	c8		iny				iny 									; next
.32e4	ca		dex				dex
.32e5	d0 ca		bne $32b1			bne 	_EUDLoop
.32e7	7a		ply				ply
.32e8	60		rts				rts
.32e9					_EUDError:
.32e9	4c 45 3f	jmp $3f45		jmp	ErrorV_value

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/decimal.asm

.32ec					EXPUnaryInlineDec:
.32ec	4c 25 3f	jmp $3f25		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/deekpeek.asm

.32ef					EXPUnaryPeek:
.32ef	20 6c 31	jsr $316c			jsr 	EXPEvalInteger16 				; number to R0
.32f2	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.32f5	b2 0c		lda ($0c)			lda 	(IFR0)
.32f7	a2 0c		ldx #$0c			ldx 	#IFR0
.32f9	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.32fc	60		rts				rts
.32fd					EXPUnaryDeek:
.32fd	20 6c 31	jsr $316c			jsr 	EXPEvalInteger16 				; number to R0
.3300	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.3303	5a		phy				phy
.3304	a0 01		ldy #$01			ldy 	#1
.3306	b1 0c		lda ($0c),y			lda 	(IFR0),y
.3308	7a		ply				ply
.3309	48		pha				pha
.330a	b2 0c		lda ($0c)			lda 	(IFR0)
.330c	a2 0c		ldx #$0c			ldx 	#IFR0
.330e	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.3311	68		pla				pla
.3312	85 0d		sta $0d				sta 	IFR0+IM1
.3314	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/dollar.asm

.3315					EXPUnaryNull:
.3315	20 97 31	jsr $3197			jsr 	EXPTermValueR0
.3318	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/fractional.asm

.3319					EXPUnaryFrac:
.3319	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 					; number to R0
.331c	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.331f	20 4f 46	jsr $464f			jsr 	IFloatFractionalR0
.3322	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/intfn.asm

.3323					EXPUnaryInt:
.3323	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 					; number to R0
.3326	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.3329	20 a5 46	jsr $46a5			jsr 	IFloatIntegerR0
.332c	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/len.asm

.332d					EXPUnaryLen:
.332d	20 84 31	jsr $3184			jsr 	EXPEvalString 					; string to R0, zTemp0
.3330	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.3333	b2 1e		lda ($1e)			lda 	(zTemp0)
.3335	a2 0c		ldx #$0c			ldx 	#IFR0
.3337	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.333a	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/parenthesis.asm

.333b					EXPUnaryParenthesis:
.333b	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 					; number to R0
.333e	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.3341	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/random.asm

.3342					EXPUnaryRnd:
.3342	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 				; number to R0
.3345	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 				; )
.3348	a2 0c		ldx #$0c			ldx 	#IFR0
.334a	20 61 33	jsr $3361			jsr 	EXPLoadInRandom
.334d	a9 29		lda #$29			lda 	#64-23 						; hack the exponent to make it work.
.334f	85 0f		sta $0f				sta 	IFR0+IExp
.3351	60		rts				rts
.3352					ExpUnaryRand:
.3352	20 65 31	jsr $3165			jsr 	EXPEvalInteger 				; integer to R0
.3355	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 				; )
.3358	a2 10		ldx #$10			ldx 	#IFR1 						; random to R1
.335a	20 61 33	jsr $3361			jsr 	EXPLoadInRandom
.335d	20 16 45	jsr $4516			jsr 	IFloatModulusInteger 		; calculate mod r1,r2
.3360	60		rts				rts
.3361					EXPLoadInRandom:
.3361	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.3364	20 76 33	jsr $3376			jsr 	EXPRandom32
.3367	95 00		sta $00,x			sta 	IM0,x
.3369	20 76 33	jsr $3376			jsr 	EXPRandom32
.336c	95 01		sta $01,x			sta 	IM1,x
.336e	20 76 33	jsr $3376			jsr 	EXPRandom32
.3371	29 7f		and #$7f			and 	#$7F
.3373	95 02		sta $02,x			sta 	IM2,x
.3375	60		rts				rts
.3376					EXPRandom32:
.3376	5a		phy				phy
.3377	a0 08		ldy #$08			ldy 	#8
.3379	ad 08 05	lda $0508			lda 	EXPSeed+0
.337c	0d 09 05	ora $0509			ora 	EXPSeed+1
.337f	0d 0a 05	ora $050a			ora 	EXPSeed+2
.3382	0d 0b 05	ora $050b			ora 	EXPSeed+3
.3385	d0 08		bne $338f			bne 	_EXPRNoReset
.3387	ee 08 05	inc $0508			inc 	EXPSeed+0
.338a	a0 10		ldy #$10			ldy 	#16
.338c	8c 0b 05	sty $050b			sty 	EXPSeed+3
.338f					_EXPRNoReset:
.338f	ad 08 05	lda $0508			lda 	EXPSeed+0
.3392					_EXPRLoop:
.3392	0a		asl a				asl		a
.3393	2e 09 05	rol $0509			rol 	EXPSeed+1
.3396	2e 0a 05	rol $050a			rol 	EXPSeed+2
.3399	2e 0b 05	rol $050b			rol 	EXPSeed+3
.339c	90 02		bcc $33a0			bcc 	_EXPRNoEOR
.339e	49 c5		eor #$c5			eor 	#$C5
.33a0					_EXPRNoEOR:
.33a0	88		dey				dey
.33a1	d0 ef		bne $3392			bne 	_EXPRLoop
.33a3	8d 08 05	sta $0508			sta 	EXPSeed+0
.33a6	7a		ply				ply
.33a7	60		rts				rts
.0508					EXPSeed:
>0508							.fill 	4

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sgn.asm

.33a8					EXPUnarySgn:
.33a8	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 					; number to R0
.33ab	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.33ae	a2 10		ldx #$10			ldx 	#IFR1 							; copy to R1
.33b0	20 47 49	jsr $4947			jsr 	IFloatCopyToRegister
.33b3	a2 0c		ldx #$0c			ldx 	#IFR0 							; R0 = 0
.33b5	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.33b8	a2 10		ldx #$10			ldx 	#IFR1
.33ba	20 73 46	jsr $4673			jsr 	IFloatCompare 					; compare R1 vs 0.
.33bd	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sqr.asm

.33be					EXPUnarySqr:
.33be	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 					; number to R0
.33c1	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.33c4	20 f1 45	jsr $45f1			jsr 	IFloatSquareRootR0 				; square root.
.33c7	b0 01		bcs $33ca			bcs 	_EUSValue
.33c9	60		rts				rts
.33ca					_EUSValue:
.33ca	4c 35 3f	jmp $3f35		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/strhex.asm

.33cd					EXPUnaryHex:
.33cd	20 65 31	jsr $3165			jsr 	EXPEvalInteger 					; expr
.33d0	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.33d3	5a		phy				phy
.33d4	a9 10		lda #$10			lda 	#16
.33d6	20 46 47	jsr $4746			jsr 	IFloatIntegerToStringR0
.33d9	80 0a		bra $33e5			bra 	EUSMain
.33db					EXPUnaryStr:
.33db	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 					; expr
.33de	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.33e1	5a		phy				phy
.33e2	20 a2 47	jsr $47a2			jsr 	IFloatFloatToStringR0 			; convert to string
.33e5					EUSMain:
.33e5	b0 18		bcs $33ff			bcs 	_EUSError
.33e7	86 1e		stx $1e				stx 	zTemp0 							; save string address
.33e9	84 1f		sty $1f				sty 	zTemp0+1
.33eb	48		pha				pha 									; save count
.33ec	a9 20		lda #$20			lda 	#32 							; allocate space for result.
.33ee	20 9a 41	jsr $419a			jsr 	StringTempAllocate
.33f1	fa		plx				plx 									; count in X
.33f2	a0 00		ldy #$00			ldy 	#0
.33f4					_EUSCopy:
.33f4	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.33f6	c8		iny				iny
.33f7	20 cf 41	jsr $41cf			jsr 	StringTempWrite
.33fa	ca		dex				dex
.33fb	d0 f7		bne $33f4			bne	 	_EUSCopy
.33fd	7a		ply				ply
.33fe	60		rts				rts
.33ff					_EUSError:
.33ff	4c 35 3f	jmp $3f35		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/string.asm

.3402					EXPUnaryInlineString:
.3402	18		clc				clc 								; physical address -> IM0,1
.3403	98		tya				tya
.3404	65 1c		adc $1c				adc 	codePtr
.3406	85 0c		sta $0c				sta 	IFR0+IM0
.3408	a5 1d		lda $1d				lda 	codePtr+1
.340a	69 00		adc #$00			adc 	#0
.340c	85 0d		sta $0d				sta 	IFR0+IM1
.340e	64 0e		stz $0e				stz 	IFR0+IM2 					; fill in rest
.3410	a9 80		lda #$80			lda 	#$80
.3412	85 0f		sta $0f				sta 	IFR0+IExp
.3414	98		tya				tya	 								; skip over it.
.3415	38		sec				sec
.3416	71 1c		adc ($1c),y			adc 	(codePtr),y
.3418	a8		tay				tay
.3419	60		rts				rts
.341a					_EXPUISRange:
.341a	4c 35 3f	jmp $3f35		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/substring.asm

.341d					EXPUnaryLeft:
.341d	20 63 34	jsr $3463			jsr 	EXPCommonStart 					; <string>,
.3420	48		pha				pha 									; save string address on stack
.3421	da		phx				phx
.3422	a9 00		lda #$00			lda 	#0 								; start position (zero offset)
.3424	48		pha				pha
.3425	20 78 31	jsr $3178			jsr 	EXPEvalInteger8 				; characters to do
.3428	80 44		bra $346e			bra 	EXPSubstringCommon
.342a					EXPUnaryRight:
.342a	20 63 34	jsr $3463			jsr 	EXPCommonStart 					; <string>,
.342d	48		pha				pha 									; save string address on stack
.342e	da		phx				phx
.342f	b2 0c		lda ($0c)			lda 	(IFR0) 							; the string length => stack.
.3431	48		pha				pha
.3432	20 78 31	jsr $3178			jsr 	EXPEvalInteger8 				; characters to do
.3435	85 1e		sta $1e				sta 	zTemp0 							; calculate length - required, start point.
.3437	68		pla				pla
.3438	38		sec				sec
.3439	e5 1e		sbc $1e				sbc 	zTemp0
.343b	b0 02		bcs $343f			bcs 	_EUROffLeft
.343d	a9 00		lda #$00			lda 	#0
.343f					_EUROffLeft:
.343f	48		pha				pha 									; start pos
.3440	a9 ff		lda #$ff			lda 	#255
.3442	80 2a		bra $346e			bra 	EXPSubstringCommon
.3444					EXPUnaryMid:
.3444	20 63 34	jsr $3463			jsr 	EXPCommonStart 					; <string>,
.3447	48		pha				pha 									; save string address on stack
.3448	da		phx				phx
.3449	20 78 31	jsr $3178			jsr 	EXPEvalInteger8 				; characters start
.344c	f0 12		beq $3460			beq 	_EUSError 						; 1 is left
.344e	3a		dec a				dec 	a 								; zero based.
.344f	48		pha				pha
.3450	b1 1c		lda ($1c),y			lda 	(codePtr),y 					; comma follows
.3452	c9 99		cmp #$99			cmp 	#PR_COMMA
.3454	f0 04		beq $345a			beq 	_EUMLength 						; if so m is provided
.3456	a9 ff		lda #$ff			lda 	#255 							; default m
.3458	80 14		bra $346e			bra 	EXPSubstringCommon
.345a					_EUMLength:
.345a	c8		iny				iny 									; consume comma
.345b	20 78 31	jsr $3178			jsr 	EXPEvalInteger8 				; characters to do
.345e	80 0e		bra $346e			bra 	EXPSubstringCommon
.3460					_EUSError:
.3460	4c 45 3f	jmp $3f45		jmp	ErrorV_value
.3463					EXPCommonStart:
.3463	20 84 31	jsr $3184			jsr 	EXPEvalString
.3466	20 ac 40	jsr $40ac			jsr 	ERRCheckComma
.3469	a5 0c		lda $0c				lda 	IFR0+IM0
.346b	a6 0d		ldx $0d				ldx 	IFR0+IM1
.346d	60		rts				rts
.346e					EXPSubstringCommon:
.346e	85 20		sta $20				sta 	zTemp1 							; count to do in zTemp1.
.3470	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; check right bracket.
.3473	68		pla				pla 									; start position
.3474	85 21		sta $21				sta 	zTemp1+1 						; save in zTemp1+1
.3476	fa		plx				plx 									; get string address to zTemp2.
.3477	86 23		stx $23				stx 	zTemp2+1
.3479	68		pla				pla
.347a	85 22		sta $22				sta 	zTemp2
.347c	38		sec				sec 									; length - start is the max count of chars
.347d	b2 22		lda ($22)			lda 	(zTemp2)
.347f	e5 21		sbc $21				sbc 	zTemp1+1
.3481	c5 20		cmp $20				cmp 	zTemp1 							; if available < count
.3483	b0 02		bcs $3487			bcs 	_EXPSSNoTrim
.3485	85 20		sta $20				sta 	zTemp1 							; update count with available
.3487					_EXPSSNoTrim:
.3487	a5 20		lda $20				lda 	zTemp1 							; chars required.
.3489	20 9a 41	jsr $419a			jsr 	StringTempAllocate 				; allocate memory for it.
.348c	a5 20		lda $20				lda 	zTemp1 							; zero length string
.348e	f0 15		beq $34a5			beq 	_EXPSSExit
.3490	a5 21		lda $21				lda 	zTemp1+1 						; if length >= start exit
.3492	d2 22		cmp ($22)			cmp 	(zTemp2)
.3494	b0 0f		bcs $34a5			bcs 	_EXPSSExit
.3496	5a		phy				phy
.3497	a4 21		ldy $21				ldy 	zTemp1+1 						; start position
.3499	c8		iny				iny 									; +1 for the length byte
.349a					_EXPSSCopy:
.349a	b1 22		lda ($22),y			lda 	(zTemp2),y
.349c	20 cf 41	jsr $41cf			jsr 	StringTempWrite
.349f	c8		iny				iny
.34a0	c6 20		dec $20				dec 	zTemp1
.34a2	d0 f6		bne $349a			bne 	_EXPSSCopy
.34a4	7a		ply				ply
.34a5					_EXPSSExit:
.34a5	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/val.asm

.34a6					EXPUnaryVal:
.34a6	20 84 31	jsr $3184			jsr 	EXPEvalString 					; string to R0, zTemp0
.34a9	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 					; )
.34ac	5a		phy				phy
.34ad	18		clc				clc
.34ae	a5 1e		lda $1e				lda		zTemp0 							; point XY to the text
.34b0	69 01		adc #$01			adc 	#1
.34b2	aa		tax				tax
.34b3	a5 1f		lda $1f				lda 	zTemp0+1
.34b5	69 00		adc #$00			adc 	#0
.34b7	a8		tay				tay
.34b8	b2 1e		lda ($1e)			lda 	(zTemp0) 						; get length.
.34ba	20 09 48	jsr $4809			jsr 	IFloatStringToFloatR0 			; do conversion
.34bd	b0 02		bcs $34c1			bcs 	_EUVError
.34bf	7a		ply				ply
.34c0	60		rts				rts
.34c1					_EUVError:
.34c1	4c 45 3f	jmp $3f45		jmp	ErrorV_value

;******  Return to file: include.files


;******  Processing file: src/generated/precedence_table.asm

.34c4					BinaryPrecedence:
>34c4	02					.byte	 2	; $ef =
>34c5	02					.byte	 2	; $f0 <>
>34c6	02					.byte	 2	; $f1 <=
>34c7	02					.byte	 2	; $f2 <
>34c8	02					.byte	 2	; $f3 >=
>34c9	02					.byte	 2	; $f4 >
>34ca	01					.byte	 1	; $f5 XOR
>34cb	01					.byte	 1	; $f6 OR
>34cc	01					.byte	 1	; $f7 AND
>34cd	04					.byte	 4	; $f8 DIV
>34ce	04					.byte	 4	; $f9 MOD
>34cf	04					.byte	 4	; $fa <<
>34d0	04					.byte	 4	; $fb >>
>34d1	04					.byte	 4	; $fc /
>34d2	04					.byte	 4	; $fd *
>34d3	03					.byte	 3	; $fe -
>34d4	03					.byte	 3	; $ff +

;******  Return to file: include.files


;******  Processing file: src/generated/structure_table.asm

.34d5					StructureOffsets:
>34d5	01					.byte	1  	; $80 REPEAT
>34d6	ff					.byte	255	; $81 UNTIL
>34d7	01					.byte	1  	; $82 WHILE
>34d8	ff					.byte	255	; $83 WEND
>34d9	01					.byte	1  	; $84 IF
>34da	ff					.byte	255	; $85 ENDIF
>34db	01					.byte	1  	; $86 DO
>34dc	ff					.byte	255	; $87 LOOP
>34dd	01					.byte	1  	; $88 PROC
>34de	ff					.byte	255	; $89 ENDPROC
>34df	01					.byte	1  	; $8a FOR
>34e0	ff					.byte	255	; $8b NEXT

;******  Return to file: include.files


;******  Processing file: src/generated/token_text.asm

.34e1					StandardTokens:
>34e1	06 52 45 50 45 41 54			.byte	$06,$52,$45,$50,$45,$41,$54             	; $80 repeat
>34e8	05 55 4e 54 49 4c			.byte	$05,$55,$4e,$54,$49,$4c                 	; $81 until
>34ee	05 57 48 49 4c 45			.byte	$05,$57,$48,$49,$4c,$45                 	; $82 while
>34f4	04 57 45 4e 44				.byte	$04,$57,$45,$4e,$44                     	; $83 wend
>34f9	02 49 46				.byte	$02,$49,$46                             	; $84 if
>34fc	05 45 4e 44 49 46			.byte	$05,$45,$4e,$44,$49,$46                 	; $85 endif
>3502	02 44 4f				.byte	$02,$44,$4f                             	; $86 do
>3505	04 4c 4f 4f 50				.byte	$04,$4c,$4f,$4f,$50                     	; $87 loop
>350a	04 50 52 4f 43				.byte	$04,$50,$52,$4f,$43                     	; $88 proc
>350f	07 45 4e 44 50 52 4f 43			.byte	$07,$45,$4e,$44,$50,$52,$4f,$43         	; $89 endproc
>3517	03 46 4f 52				.byte	$03,$46,$4f,$52                         	; $8a for
>351b	04 4e 45 58 54				.byte	$04,$4e,$45,$58,$54                     	; $8b next
>3520	00					.byte	$00                                     	; $8c [[end]]
>3521	00					.byte	$00                                     	; $8d [[shift]]
>3522	04 45 4c 53 45				.byte	$04,$45,$4c,$53,$45                     	; $8e else
>3527	04 54 48 45 4e				.byte	$04,$54,$48,$45,$4e                     	; $8f then
>352c	02 54 4f				.byte	$02,$54,$4f                             	; $90 to
>352f	04 53 54 45 50				.byte	$04,$53,$54,$45,$50                     	; $91 step
>3534	03 4c 45 54				.byte	$03,$4c,$45,$54                         	; $92 let
>3538	05 50 52 49 4e 54			.byte	$05,$50,$52,$49,$4e,$54                 	; $93 print
>353e	05 49 4e 50 55 54			.byte	$05,$49,$4e,$50,$55,$54                 	; $94 input
>3544	04 43 41 4c 4c				.byte	$04,$43,$41,$4c,$4c                     	; $95 call
>3549	03 53 59 53				.byte	$03,$53,$59,$53                         	; $96 sys
>354d	03 52 45 4d				.byte	$03,$52,$45,$4d                         	; $97 rem
>3551	04 45 58 49 54				.byte	$04,$45,$58,$49,$54                     	; $98 exit
>3556	01 2c					.byte	$01,$2c                                 	; $99 ,
>3558	01 3b					.byte	$01,$3b                                 	; $9a ;
>355a	01 3a					.byte	$01,$3a                                 	; $9b :
>355c	01 27					.byte	$01,$27                                 	; $9c '
>355e	01 29					.byte	$01,$29                                 	; $9d )
>3560	03 44 49 4d				.byte	$03,$44,$49,$4d                         	; $9e dim
>3564	05 43 4c 45 41 52			.byte	$05,$43,$4c,$45,$41,$52                 	; $9f clear
>356a	03 4e 45 57				.byte	$03,$4e,$45,$57                         	; $a0 new
>356e	03 52 55 4e				.byte	$03,$52,$55,$4e                         	; $a1 run
>3572	04 53 54 4f 50				.byte	$04,$53,$54,$4f,$50                     	; $a2 stop
>3577	03 45 4e 44				.byte	$03,$45,$4e,$44                         	; $a3 end
>357b	06 41 53 53 45 52 54			.byte	$06,$41,$53,$53,$45,$52,$54             	; $a4 assert
>3582	04 4c 49 53 54				.byte	$04,$4c,$49,$53,$54                     	; $a5 list
>3587	04 53 41 56 45				.byte	$04,$53,$41,$56,$45                     	; $a6 save
>358c	04 4c 4f 41 44				.byte	$04,$4c,$4f,$41,$44                     	; $a7 load
>3591	04 50 4f 4b 45				.byte	$04,$50,$4f,$4b,$45                     	; $a8 poke
>3596	04 44 4f 4b 45				.byte	$04,$44,$4f,$4b,$45                     	; $a9 doke
>359b	00					.byte	0											; $aa
>359c	00					.byte	0											; $ab
>359d	00					.byte	0											; $ac
>359e	00					.byte	0											; $ad
>359f	00					.byte	0											; $ae
>35a0	00					.byte	0											; $af
>35a1	00					.byte	0											; $b0
>35a2	00					.byte	0											; $b1
>35a3	00					.byte	0											; $b2
>35a4	00					.byte	0											; $b3
>35a5	00					.byte	0											; $b4
>35a6	00					.byte	0											; $b5
>35a7	00					.byte	0											; $b6
>35a8	00					.byte	0											; $b7
>35a9	00					.byte	0											; $b8
>35aa	00					.byte	0											; $b9
>35ab	00					.byte	0											; $ba
>35ac	00					.byte	0											; $bb
>35ad	00					.byte	0											; $bc
>35ae	00					.byte	0											; $bd
>35af	00					.byte	0											; $be
>35b0	00					.byte	0											; $bf
>35b1	00					.byte	0											; $c0
>35b2	00					.byte	0											; $c1
>35b3	00					.byte	0											; $c2
>35b4	00					.byte	0											; $c3
>35b5	00					.byte	0											; $c4
>35b6	00					.byte	0											; $c5
>35b7	00					.byte	0											; $c6
>35b8	00					.byte	0											; $c7
>35b9	00					.byte	0											; $c8
>35ba	00					.byte	0											; $c9
>35bb	00					.byte	0											; $ca
>35bc	00					.byte	0											; $cb
>35bd	00					.byte	0											; $cc
>35be	00					.byte	0											; $cd
>35bf	00					.byte	0											; $ce
>35c0	00					.byte	0											; $cf
>35c1	00					.byte	0											; $d0
>35c2	00					.byte	0											; $d1
>35c3	00					.byte	0											; $d2
>35c4	00					.byte	0											; $d3
>35c5	00					.byte	0											; $d4
>35c6	05 44 45 45 4b 28			.byte	$05,$44,$45,$45,$4b,$28                 	; $d5 deek(
>35cc	05 50 45 45 4b 28			.byte	$05,$50,$45,$45,$4b,$28                 	; $d6 peek(
>35d2	07 52 49 47 48 54 24 28			.byte	$07,$52,$49,$47,$48,$54,$24,$28         	; $d7 right$(
>35da	06 4c 45 46 54 24 28			.byte	$06,$4c,$45,$46,$54,$24,$28             	; $d8 left$(
>35e1	05 4d 49 44 24 28			.byte	$05,$4d,$49,$44,$24,$28                 	; $d9 mid$(
>35e7	05 53 54 52 24 28			.byte	$05,$53,$54,$52,$24,$28                 	; $da str$(
>35ed	04 56 41 4c 28				.byte	$04,$56,$41,$4c,$28                     	; $db val(
>35f2	04 53 47 4e 28				.byte	$04,$53,$47,$4e,$28                     	; $dc sgn(
>35f7	04 41 42 53 28				.byte	$04,$41,$42,$53,$28                     	; $dd abs(
>35fc	04 4c 45 4e 28				.byte	$04,$4c,$45,$4e,$28                     	; $de len(
>3601	04 53 51 52 28				.byte	$04,$53,$51,$52,$28                     	; $df sqr(
>3606	05 43 48 52 24 28			.byte	$05,$43,$48,$52,$24,$28                 	; $e0 chr$(
>360c	04 41 53 43 28				.byte	$04,$41,$53,$43,$28                     	; $e1 asc(
>3611	07 49 4e 4b 45 59 24 28			.byte	$07,$49,$4e,$4b,$45,$59,$24,$28         	; $e2 inkey$(
>3619	06 45 56 45 4e 54 28			.byte	$06,$45,$56,$45,$4e,$54,$28             	; $e3 event(
>3620	04 54 49 4d 45				.byte	$04,$54,$49,$4d,$45                     	; $e4 time
>3625	04 49 4e 54 28				.byte	$04,$49,$4e,$54,$28                     	; $e5 int(
>362a	05 46 52 41 43 28			.byte	$05,$46,$52,$41,$43,$28                 	; $e6 frac(
>3630	04 44 45 43 28				.byte	$04,$44,$45,$43,$28                     	; $e7 dec(
>3635	05 48 45 58 24 28			.byte	$05,$48,$45,$58,$24,$28                 	; $e8 hex$(
>363b	04 52 4e 44 28				.byte	$04,$52,$4e,$44,$28                     	; $e9 rnd(
>3640	05 52 41 4e 44 28			.byte	$05,$52,$41,$4e,$44,$28                 	; $ea rand(
>3646	01 28					.byte	$01,$28                                 	; $eb (
>3648	01 24					.byte	$01,$24                                 	; $ec $
>364a	00					.byte	$00                                     	; $ed [[decimal]]
>364b	00					.byte	$00                                     	; $ee [[string]]
>364c	01 3d					.byte	$01,$3d                                 	; $ef =
>364e	02 3c 3e				.byte	$02,$3c,$3e                             	; $f0 <>
>3651	02 3c 3d				.byte	$02,$3c,$3d                             	; $f1 <=
>3654	01 3c					.byte	$01,$3c                                 	; $f2 <
>3656	02 3e 3d				.byte	$02,$3e,$3d                             	; $f3 >=
>3659	01 3e					.byte	$01,$3e                                 	; $f4 >
>365b	03 58 4f 52				.byte	$03,$58,$4f,$52                         	; $f5 xor
>365f	02 4f 52				.byte	$02,$4f,$52                             	; $f6 or
>3662	03 41 4e 44				.byte	$03,$41,$4e,$44                         	; $f7 and
>3666	03 44 49 56				.byte	$03,$44,$49,$56                         	; $f8 div
>366a	03 4d 4f 44				.byte	$03,$4d,$4f,$44                         	; $f9 mod
>366e	02 3c 3c				.byte	$02,$3c,$3c                             	; $fa <<
>3671	02 3e 3e				.byte	$02,$3e,$3e                             	; $fb >>
>3674	01 2f					.byte	$01,$2f                                 	; $fc /
>3676	01 2a					.byte	$01,$2a                                 	; $fd *
>3678	01 2d					.byte	$01,$2d                                 	; $fe -
>367a	01 2b					.byte	$01,$2b                                 	; $ff +
>367c	ff					.byte	$FF

;******  Return to file: include.files


;******  Processing file: src/generated/vector_table.asm

.367d					VectorTable:
>367d	19 3e					.word	Command_REPEAT           ; $80 REPEAT
>367f	22 3e					.word	Command_UNTIL            ; $81 UNTIL
>3681	fa 3e					.word	Command_WHILE            ; $82 WHILE
>3683	19 3f					.word	Command_WEND             ; $83 WEND
>3685	f1 3d					.word	IfCommand                ; $84 IF
>3687	18 3e					.word	EndIf                    ; $85 ENDIF
>3689	8e 3c					.word	Command_DO               ; $86 DO
>368b	a6 3c					.word	Command_LOOP             ; $87 LOOP
>368d	9a 2f					.word	NoExec08                 ; $88 PROC
>368f	82 3c					.word	Command_ENDPROC          ; $89 ENDPROC
>3691	af 3c					.word	Command_FOR              ; $8a FOR
>3693	3c 3d					.word	Command_NEXT             ; $8b NEXT
>3695	3e 2f					.word	RUNEndOfLine             ; $8c [[END]]
>3697	7c 2f					.word	Command_Shift_Handler    ; $8d [[SHIFT]]
>3699	11 3e					.word	ElseCode                 ; $8e ELSE
>369b	9a 2f					.word	NoExec01                 ; $8f THEN
>369d	9a 2f					.word	NoExec02                 ; $90 TO
>369f	9a 2f					.word	NoExec03                 ; $91 STEP
>36a1	a4 2e					.word	CommandLET               ; $92 LET
>36a3	3f 2e					.word	Command_Print            ; $93 PRINT
>36a5	83 4a					.word	NotImplemented           ; $94 INPUT
>36a7	46 3c					.word	Command_CALL             ; $95 CALL
>36a9	85 2f					.word	Command_Sys              ; $96 SYS
>36ab	25 2f					.word	Command_REM              ; $97 REM
>36ad	97 3c					.word	Command_EXIT             ; $98 EXIT
>36af	9a 2f					.word	NoExec04                 ; $99 ,
>36b1	9a 2f					.word	NoExec05                 ; $9a ;
>36b3	9a 2f					.word	NoExec06                 ; $9b :
>36b5	25 2f					.word	Command_REM2             ; $9c '
>36b7	9a 2f					.word	NoExec07                 ; $9d )
>36b9	f9 2c					.word	CommandDIM               ; $9e DIM
>36bb	a9 2c					.word	Command_CLEAR            ; $9f CLEAR
>36bd	1c 2f					.word	Command_NEW              ; $a0 NEW
>36bf	32 2f					.word	Command_RUN              ; $a1 RUN
>36c1	82 2f					.word	Command_STOP             ; $a2 STOP
>36c3	7f 2f					.word	Command_END              ; $a3 END
>36c5	9b 2c					.word	Command_ASSERT           ; $a4 ASSERT
>36c7	83 4a					.word	NotImplemented           ; $a5 LIST
>36c9	83 4a					.word	NotImplemented           ; $a6 SAVE
>36cb	83 4a					.word	NotImplemented           ; $a7 LOAD
>36cd	18 2e					.word	Command_Poke             ; $a8 POKE
>36cf	15 2e					.word	Command_Doke             ; $a9 DOKE
>36d1	83 4a					.word	NotImplemented           ; $aa
>36d3	83 4a					.word	NotImplemented           ; $ab
>36d5	83 4a					.word	NotImplemented           ; $ac
>36d7	83 4a					.word	NotImplemented           ; $ad
>36d9	83 4a					.word	NotImplemented           ; $ae
>36db	83 4a					.word	NotImplemented           ; $af
>36dd	83 4a					.word	NotImplemented           ; $b0
>36df	83 4a					.word	NotImplemented           ; $b1
>36e1	83 4a					.word	NotImplemented           ; $b2
>36e3	83 4a					.word	NotImplemented           ; $b3
>36e5	83 4a					.word	NotImplemented           ; $b4
>36e7	83 4a					.word	NotImplemented           ; $b5
>36e9	83 4a					.word	NotImplemented           ; $b6
>36eb	83 4a					.word	NotImplemented           ; $b7
>36ed	83 4a					.word	NotImplemented           ; $b8
>36ef	83 4a					.word	NotImplemented           ; $b9
>36f1	83 4a					.word	NotImplemented           ; $ba
>36f3	83 4a					.word	NotImplemented           ; $bb
>36f5	83 4a					.word	NotImplemented           ; $bc
>36f7	83 4a					.word	NotImplemented           ; $bd
>36f9	83 4a					.word	NotImplemented           ; $be
>36fb	83 4a					.word	NotImplemented           ; $bf
>36fd	83 4a					.word	NotImplemented           ; $c0
>36ff	83 4a					.word	NotImplemented           ; $c1
>3701	83 4a					.word	NotImplemented           ; $c2
>3703	83 4a					.word	NotImplemented           ; $c3
>3705	83 4a					.word	NotImplemented           ; $c4
>3707	83 4a					.word	NotImplemented           ; $c5
>3709	83 4a					.word	NotImplemented           ; $c6
>370b	83 4a					.word	NotImplemented           ; $c7
>370d	83 4a					.word	NotImplemented           ; $c8
>370f	83 4a					.word	NotImplemented           ; $c9
>3711	83 4a					.word	NotImplemented           ; $ca
>3713	83 4a					.word	NotImplemented           ; $cb
>3715	83 4a					.word	NotImplemented           ; $cc
>3717	83 4a					.word	NotImplemented           ; $cd
>3719	83 4a					.word	NotImplemented           ; $ce
>371b	83 4a					.word	NotImplemented           ; $cf
>371d	83 4a					.word	NotImplemented           ; $d0
>371f	83 4a					.word	NotImplemented           ; $d1
>3721	83 4a					.word	NotImplemented           ; $d2
>3723	83 4a					.word	NotImplemented           ; $d3
>3725	83 4a					.word	NotImplemented           ; $d4
>3727	fd 32					.word	EXPUnaryDeek             ; $d5 DEEK(
>3729	ef 32					.word	EXPUnaryPeek             ; $d6 PEEK(
>372b	2a 34					.word	EXPUnaryRight            ; $d7 RIGHT$(
>372d	1d 34					.word	EXPUnaryLeft             ; $d8 LEFT$(
>372f	44 34					.word	EXPUnaryMid              ; $d9 MID$(
>3731	db 33					.word	EXPUnaryStr              ; $da STR$(
>3733	a6 34					.word	EXPUnaryVal              ; $db VAL(
>3735	a8 33					.word	EXPUnarySgn              ; $dc SGN(
>3737	6d 32					.word	EXPUnaryAbs              ; $dd ABS(
>3739	2d 33					.word	EXPUnaryLen              ; $de LEN(
>373b	be 33					.word	EXPUnarySqr              ; $df SQR(
>373d	8d 32					.word	EXPUnaryChr              ; $e0 CHR$(
>373f	77 32					.word	EXPUnaryAsc              ; $e1 ASC(
>3741	83 4a					.word	NotImplemented           ; $e2 INKEY$(
>3743	83 4a					.word	NotImplemented           ; $e3 EVENT(
>3745	83 4a					.word	NotImplemented           ; $e4 TIME
>3747	23 33					.word	EXPUnaryInt              ; $e5 INT(
>3749	19 33					.word	EXPUnaryFrac             ; $e6 FRAC(
>374b	9e 32					.word	EXPUnaryDec              ; $e7 DEC(
>374d	cd 33					.word	EXPUnaryHex              ; $e8 HEX$(
>374f	42 33					.word	EXPUnaryRnd              ; $e9 RND(
>3751	52 33					.word	ExpUnaryRand             ; $ea RAND(
>3753	3b 33					.word	EXPUnaryParenthesis      ; $eb (
>3755	15 33					.word	EXPUnaryNull             ; $ec $
>3757	ec 32					.word	EXPUnaryInlineDec        ; $ed [[DECIMAL]]
>3759	02 34					.word	EXPUnaryInlineString     ; $ee [[STRING]]
>375b	57 30					.word	EXPCompareEqual          ; $ef =
>375d	72 30					.word	EXPCompareNotEqual       ; $f0 <>
>375f	7b 30					.word	EXPCompareLessEqual      ; $f1 <=
>3761	60 30					.word	EXPCompareLess           ; $f2 <
>3763	84 30					.word	EXPCompareGreaterEqual   ; $f3 >=
>3765	69 30					.word	EXPCompareGreater        ; $f4 >
>3767	04 30					.word	EXPBinXor                ; $f5 XOR
>3769	f8 2f					.word	EXPBinOr                 ; $f6 OR
>376b	ec 2f					.word	EXPBinAnd                ; $f7 AND
>376d	c4 2f					.word	EXPBinIDiv               ; $f8 DIV
>376f	d5 2f					.word	EXPBinIMod               ; $f9 MOD
>3771	cf 30					.word	EXPBinLeft               ; $fa <<
>3773	d7 30					.word	EXPBinRight              ; $fb >>
>3775	b8 2f					.word	EXPBinFDiv               ; $fc /
>3777	af 2f					.word	EXPBinMul                ; $fd *
>3779	a6 2f					.word	EXPBinSub                ; $fe -
>377b	9d 2f					.word	EXPBinAdd                ; $ff +

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/detokenise.asm

.377d					TOKDetokenise:
.377d	86 22		stx $22				stx 	zTemp2 						; save tokenised code in zTemp2
.377f	84 23		sty $23				sty 	zTemp2+1
.3781	9c 0e 05	stz $050e			stz		TOKLastCharacter 			; clear last character
.3784					_TOKDLoop:
.3784	20 b3 37	jsr $37b3			jsr 	TOKDGet 					; get next
.3787	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ			; end of line
.3789	f0 26		beq $37b1			beq 	_TOKDExit
.378b	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ		; is it a string/integer with additional data.
.378d	f0 1d		beq $37ac			beq 	_TOKDDataItem
.378f	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ
.3791	f0 19		beq $37ac			beq 	_TOKDDataItem
.3793	c9 00		cmp #$00			cmp 	#0 							; is it a token 80-FF
.3795	10 05		bpl $379c			bpl 	_TOKDNotToken
.3797	20 7b 38	jsr $387b			jsr 	TOKDToken 					; token to text.
.379a	80 e8		bra $3784			bra 	_TOKDLoop
.379c					_TOKDNotToken:
.379c	c9 40		cmp #$40			cmp 	#$40  						; 40-7F Identifier
.379e	90 05		bcc $37a5			bcc 	_TOKDNotIdentifier
.37a0	20 ee 37	jsr $37ee			jsr 	TOKDIdentifier
.37a3	80 df		bra $3784			bra 	_TOKDLoop
.37a5					_TOKDNotIdentifier:
.37a5	a0 0a		ldy #$0a			ldy 	#10
.37a7	20 37 38	jsr $3837			jsr 	TOKDInteger
.37aa	80 d8		bra $3784			bra 	_TOKDLoop
.37ac					_TOKDDataItem:
.37ac	20 c9 37	jsr $37c9			jsr 	TOKDDataItem
.37af	80 d3		bra $3784			bra 	_TOKDLoop
.37b1					_TOKDExit:
.37b1	18		clc				clc
.37b2	60		rts				rts
.37b3	b2 22		lda ($22)	TOKDGet:lda 	(zTemp2)
.37b5	e6 22		inc $22				inc 	zTemp2
.37b7	d0 02		bne $37bb			bne 	_TKDGExit
.37b9	e6 23		inc $23				inc 	zTemp2+1
.37bb					_TKDGExit:
.37bb	60		rts				rts
.37bc					TOKDOutput:
.37bc	8d 0e 05	sta $050e			sta 	TOKLastCharacter
.37bf	6c 0c 05	jmp ($050c)			jmp 	(TOKOutputMethod)
.37c2					TOKSetDetokeniseOutput:
.37c2	8e 0c 05	stx $050c			stx 	TOKOutputMethod
.37c5	8c 0d 05	sty $050d			sty 	TOKOutputMethod+1
.37c8	60		rts				rts
.050c					TOKOutputMethod:
>050c							.fill 	2
.050e					TOKLastCharacter:
>050e							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkdataitem.asm

.37c9					TOKDDataItem:
.37c9	a8		tay				tay 								; type in Y
.37ca	a9 22		lda #$22			lda 	#'"'						; start with " or .
.37cc	c0 ee		cpy #$ee			cpy 	#PR_LSQLSQSTRINGRSQRSQ
.37ce	f0 02		beq $37d2			beq 	_TOKDDIsString
.37d0	a9 2e		lda #$2e			lda 	#'.'
.37d2					_TOKDDIsString:
.37d2	20 bc 37	jsr $37bc			jsr 	TOKDOutput 					; dump it
.37d5	20 b3 37	jsr $37b3			jsr 	TOKDGet 					; get length into X
.37d8	aa		tax				tax
.37d9					_TOKDDOutput:
.37d9	ca		dex				dex 								; are we complete
.37da	30 08		bmi $37e4			bmi 	_TOKDDEnd
.37dc	20 b3 37	jsr $37b3			jsr 	TOKDGet 					; get character and output it
.37df	20 bc 37	jsr $37bc			jsr 	TOKDOutput
.37e2	80 f5		bra $37d9			bra 	_TOKDDOutput
.37e4					_TOKDDEnd:
.37e4	c0 ee		cpy #$ee			cpy 	#PR_LSQLSQSTRINGRSQRSQ 		; if string, do closing quote
.37e6	d0 05		bne $37ed			bne 	_TOKDDNotString
.37e8	a9 22		lda #$22			lda 	#'"'
.37ea	20 bc 37	jsr $37bc			jsr 	TOKDOutput
.37ed					_TOKDDNotString:
.37ed	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkidentifier.asm

.37ee					TOKDIdentifier:
.37ee	a0 ff		ldy #$ff			ldy 	#$FF
.37f0	8c 0f 05	sty $050f			sty 	TOKDIFirstChar
.37f3					_TOKDLoop:
.37f3	a8		tay				tay 								; token in Y
.37f4	a9 2e		lda #$2e			lda 	#'.' 						; handle special cases.
.37f6	c0 64		cpy #$64			cpy 	#$64
.37f8	f0 11		beq $380b			beq 	_TOKDIOutput
.37fa	a9 5f		lda #$5f			lda 	#'_'
.37fc	c0 65		cpy #$65			cpy 	#$65
.37fe	f0 0b		beq $380b			beq 	_TOKDIOutput
.3800	98		tya				tya 								; handle a-z
.3801	18		clc				clc
.3802	69 21		adc #$21			adc	 	#$21
.3804	c0 5a		cpy #$5a			cpy 	#$5A
.3806	90 03		bcc $380b			bcc 	_TOKDIOutput
.3808	38		sec				sec 								; handle 0-9
.3809	e9 4b		sbc #$4b			sbc 	#$4B
.380b					_TOKDIOutput:
.380b	2c 0f 05	bit $050f			bit 	TOKDIFirstChar
.380e	10 08		bpl $3818			bpl 	_TOKDINoSpacing
.3810	48		pha				pha
.3811	20 ad 38	jsr $38ad			jsr 	TOKDSpacing
.3814	9c 0f 05	stz $050f			stz 	TOKDIFirstChar
.3817	68		pla				pla
.3818					_TOKDINoSpacing:
.3818	20 bc 37	jsr $37bc			jsr 	TOKDOutput
.381b	20 b3 37	jsr $37b3			jsr 	TOKDGet 					; get next token
.381e	c9 7c		cmp #$7c			cmp 	#$7C
.3820	90 d1		bcc $37f3			bcc 	_TOKDLoop
.3822	f0 12		beq $3836			beq 	_TOKDIExit 					; it's a number, no tail.
.3824	4a		lsr a				lsr 	a 							; string ?
.3825	90 07		bcc $382e			bcc 	_TOKDICheckArray
.3827	48		pha				pha
.3828	a9 24		lda #$24			lda 	#"$"
.382a	20 bc 37	jsr $37bc			jsr 	TOKDOutput
.382d	68		pla				pla
.382e					_TOKDICheckArray:
.382e	4a		lsr a				lsr 	a 							; array ?
.382f	90 05		bcc $3836			bcc 	_TOKDIExit
.3831	a9 28		lda #$28			lda 	#"("
.3833	20 bc 37	jsr $37bc			jsr 	TOKDOutput
.3836					_TOKDIExit:
.3836	60		rts				rts
.050f					TOKDIFirstChar:
>050f							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkinteger.asm

.3837					TOKDInteger:
.3837	5a		phy				phy 								; save base
.3838	a2 0c		ldx #$0c			ldx 	#IFR0 						; set into R0
.383a	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.383d					_TOKDILoop:
.383d	b2 22		lda ($22)			lda 	(zTemp2) 					; followed by a 00-3F
.383f	c9 40		cmp #$40			cmp 	#$40
.3841	b0 1d		bcs $3860			bcs 	_TOKDIHaveInteger
.3843	a2 0c		ldx #$0c			ldx 	#IFR0 						; R0 << 6
.3845	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.3848	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.384b	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.384e	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.3851	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.3854	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.3857	20 b3 37	jsr $37b3			jsr 	TOKDGet 					; OR byte in.
.385a	05 0c		ora $0c				ora 	IFR0+IM0
.385c	85 0c		sta $0c				sta 	IFR0+IM0
.385e	80 dd		bra $383d			bra 	_TOKDILoop
.3860					_TOKDIHaveInteger:
.3860	7a		ply				ply 								; restore base
.3861	98		tya				tya 								; base in A
.3862	20 46 47	jsr $4746			jsr 	IFloatIntegerToStringR0
.3865	86 1e		stx $1e				stx 	zTemp0
.3867	84 1f		sty $1f				sty 	zTemp0+1
.3869	b2 1e		lda ($1e)			lda 	(zTemp0)
.386b	20 ad 38	jsr $38ad			jsr 	TOKDSpacing 				; check spacing okay.
.386e	a0 00		ldy #$00			ldy 	#0 							; output buffer.
.3870					_TOKDOutput:
.3870	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3872	20 bc 37	jsr $37bc			jsr 	TOKDOutput
.3875	c8		iny				iny
.3876	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3878	d0 f6		bne $3870			bne 	_TOKDOutput
.387a	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtktoken.asm

.387b					TOKDToken:
.387b	a2 e1		ldx #$e1			ldx 	#StandardTokens & $FF
.387d	a0 34		ldy #$34			ldy 	#StandardTokens >> 8
.387f					_TOKDSearch:
.387f	86 1e		stx $1e				stx 	zTemp0 						; put table in zTemp0
.3881	84 1f		sty $1f				sty 	zTemp0+1
.3883	aa		tax				tax 								; token ID in X.
.3884					_TOKDFind:
.3884	ca		dex				dex 								; reached the start
.3885	10 0d		bpl $3894			bpl 	_TOKDFound
.3887	38		sec				sec 								; go to next entry
.3888	b2 1e		lda ($1e)			lda 	(zTemp0)
.388a	65 1e		adc $1e				adc 	zTemp0
.388c	85 1e		sta $1e				sta 	zTemp0
.388e	90 f4		bcc $3884			bcc 	_TOKDFind
.3890	e6 1f		inc $1f				inc 	zTemp0+1
.3892	80 f0		bra $3884			bra 	_TOKDFind
.3894					_TOKDFound:
.3894	b2 1e		lda ($1e)			lda 	(zTemp0) 					; length to X
.3896	f0 14		beq $38ac			beq 	_TOKDExit
.3898	aa		tax				tax
.3899	a0 01		ldy #$01			ldy 	#1 							; output the token.
.389b	b1 1e		lda ($1e),y			lda 	(zTemp0),y 					; check spacing
.389d	20 ad 38	jsr $38ad			jsr 	TOKDSpacing
.38a0					_TOKDOutput:
.38a0	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.38a2	20 01 3c	jsr $3c01			jsr 	TOKToLower
.38a5	20 bc 37	jsr $37bc			jsr 	TOKDOutput
.38a8	c8		iny				iny
.38a9	ca		dex				dex
.38aa	d0 f4		bne $38a0			bne 	_TOKDOutput
.38ac					_TOKDExit:
.38ac	60		rts				rts
.38ad					TOKDSpacing:
.38ad	20 18 3c	jsr $3c18			jsr 	TOKIsIdentifierElement		; next character alphanumeric
.38b0	90 0d		bcc $38bf			bcc 	_TOKDSExit
.38b2	ad 0e 05	lda $050e			lda 	TOKLastCharacter			; and last character also alphanumeric
.38b5	20 18 3c	jsr $3c18			jsr 	TOKIsIdentifierElement
.38b8	90 05		bcc $38bf			bcc 	_TOKDSExit
.38ba	a9 20		lda #$20			lda 	#" " 						; we need a space.
.38bc	20 bc 37	jsr $37bc			jsr 	TOKDOutput
.38bf					_TOKDSExit:
.38bf	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/editing/delete.asm

.38c0					PGMDeleteLine:
.38c0	20 73 39	jsr $3973			jsr 	PGMEndProgram 				; end of program into zTemp0
.38c3	64 20		stz $20				stz 	zTemp1						; copy base address of code to zTemp1
.38c5	ad 10 05	lda $0510			lda 	PGMBaseHigh
.38c8	85 21		sta $21				sta 	zTemp1+1
.38ca					_PGMDLoop:
.38ca	b2 20		lda ($20)			lda 	(zTemp1) 					; finished, not found ?
.38cc	38		sec				sec
.38cd	f0 3a		beq $3909			beq 	_PGMDExit
.38cf	a0 01		ldy #$01			ldy 	#1 							; found line number ?
.38d1	b1 20		lda ($20),y			lda 	(zTemp1),y
.38d3	cd 02 04	cmp $0402			cmp 	TOKLineNumber
.38d6	d0 08		bne $38e0			bne 	_PGMDNext
.38d8	c8		iny				iny
.38d9	b1 20		lda ($20),y			lda 	(zTemp1),y
.38db	cd 03 04	cmp $0403			cmp 	TOKLineNumber+1
.38de	f0 0d		beq $38ed			beq 	_PGMDDelete
.38e0					_PGMDNext:
.38e0	18		clc				clc
.38e1	b2 20		lda ($20)			lda 	(zTemp1)
.38e3	65 20		adc $20				adc 	zTemp1
.38e5	85 20		sta $20				sta 	zTemp1
.38e7	90 e1		bcc $38ca			bcc 	_PGMDLoop
.38e9	e6 21		inc $21				inc 	zTemp1+1
.38eb	80 dd		bra $38ca			bra 	_PGMDLoop
.38ed					_PGMDDelete:
.38ed	b2 20		lda ($20)			lda 	(zTemp1) 					; offset to next in Y
.38ef	a8		tay				tay
.38f0					_PGMDCopy:
.38f0	b1 20		lda ($20),y			lda 	(zTemp1),y 					; copy down.
.38f2	92 20		sta ($20)			sta 	(zTemp1)
.38f4	a5 20		lda $20				lda 	zTemp1 						; reached the end ?
.38f6	c5 1e		cmp $1e				cmp 	zTemp0
.38f8	d0 07		bne $3901			bne 	_PGMDNext2
.38fa	a5 21		lda $21				lda 	zTemp1+1
.38fc	c5 1f		cmp $1f				cmp 	zTemp0+1
.38fe	18		clc				clc
.38ff	f0 08		beq $3909			beq 	_PGMDExit
.3901					_PGMDNext2:
.3901	e6 20		inc $20				inc 	zTemp1 						; advance pointer.
.3903	d0 eb		bne $38f0			bne 	_PGMDCopy
.3905	e6 21		inc $21				inc 	zTemp1+1
.3907	80 e7		bra $38f0			bra 	_PGMDCopy
.3909					_PGMDExit:
.3909	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/editing/insert.asm

.390a					PGMInsertLine:
.390a	20 73 39	jsr $3973			jsr 	PGMEndProgram 				; end of program into zTemp0
.390d	64 20		stz $20				stz 	zTemp1						; copy base address of code to zTemp1
.390f	ad 10 05	lda $0510			lda 	PGMBaseHigh
.3912	85 21		sta $21				sta 	zTemp1+1
.3914					_PGMILoop:
.3914	b2 20		lda ($20)			lda 	(zTemp1) 					; reached the end, it goes here on the end.
.3916	f0 1c		beq $3934			beq 	_PGMIInsert
.3918	a0 01		ldy #$01			ldy 	#1 							; compare in-program line vs token line.
.391a	b1 20		lda ($20),y			lda 	(zTemp1),y
.391c	cd 02 04	cmp $0402			cmp 	TOKLineNumber
.391f	c8		iny				iny
.3920	b1 20		lda ($20),y			lda 	(zTemp1),y
.3922	ed 03 04	sbc $0403			sbc 	TOKLineNumber+1
.3925	b0 0d		bcs $3934			bcs 	_PGMIInsert 				; insert here.
.3927	18		clc				clc
.3928	b2 20		lda ($20)			lda 	(zTemp1)
.392a	65 20		adc $20				adc 	zTemp1
.392c	85 20		sta $20				sta 	zTemp1
.392e	90 e4		bcc $3914			bcc 	_PGMILoop
.3930	e6 21		inc $21				inc 	zTemp1+1
.3932	80 e0		bra $3914			bra 	_PGMILoop
.3934					_PGMIInsert:
.3934	ac 01 04	ldy $0401			ldy 	TOKLineSize 				; space required
.3937					_PGMIInsertLoop:
.3937	b2 1e		lda ($1e)			lda 	(zTemp0)
.3939	91 1e		sta ($1e),y			sta 	(zTemp0),y
.393b	a5 20		lda $20				lda 	zTemp1 						; reached insert point
.393d	c5 1e		cmp $1e				cmp 	zTemp0
.393f	d0 06		bne $3947			bne 	_PGMINext
.3941	a5 21		lda $21				lda 	zTemp1+1
.3943	c5 1f		cmp $1f				cmp 	zTemp0+1
.3945	f0 0a		beq $3951			beq 	_PGMIInserted
.3947					_PGMINext:
.3947	a5 1e		lda $1e				lda 	zTemp0
.3949	d0 02		bne $394d			bne 	_PGMINoBorrow
.394b	c6 1f		dec $1f				dec 	zTemp0+1
.394d					_PGMINoBorrow:
.394d	c6 1e		dec $1e				dec 	zTemp0
.394f	80 e6		bra $3937			bra 	_PGMIInsertLoop
.3951					_PGMIInserted:
.3951	a0 00		ldy #$00			ldy 	#0 							; copy tokenbuffer to insert point
.3953					_PGMICopyLoop:
.3953	b9 01 04	lda $0401,y			lda 	TOKLineSize,y
.3956	91 20		sta ($20),y			sta 	(zTemp1),y
.3958	c8		iny				iny
.3959	cc 01 04	cpy $0401			cpy 	TOKLineSize
.395c	d0 f5		bne $3953			bne 	_PGMICopyLoop
.395e	18		clc				clc
.395f	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/setup.asm

.3960					PGMSetBaseAddress:
.3960	8e 10 05	stx $0510			stx 	PGMBaseHigh
.3963	8c 11 05	sty $0511			sty 	PGMEndMemoryHigh
.3966	60		rts				rts
.3967					PGMNewProgram:
.3967	64 1e		stz $1e				stz 	zTemp0						; copy base address to zTemp0
.3969	ad 10 05	lda $0510			lda 	PGMBaseHigh
.396c	85 1f		sta $1f				sta 	zTemp0+1
.396e	a9 00		lda #$00			lda 	#0 							; overwrite the offset
.3970	92 1e		sta ($1e)			sta 	(zTemp0)
.3972	60		rts				rts
.3973					PGMEndProgram:
.3973	64 1e		stz $1e				stz 	zTemp0 						; copy base address to zTemp0
.3975	ad 10 05	lda $0510			lda 	PGMBaseHigh
.3978	85 1f		sta $1f				sta 	zTemp0+1
.397a					_PGMEPLoop:
.397a	b2 1e		lda ($1e)			lda 	(zTemp0)
.397c	f0 0b		beq $3989			beq 	_PGMEPExit
.397e	18		clc				clc
.397f	65 1e		adc $1e				adc 	zTemp0
.3981	85 1e		sta $1e				sta 	zTemp0
.3983	90 f5		bcc $397a			bcc 	_PGMEPLoop
.3985	e6 1f		inc $1f				inc 	zTemp0+1
.3987	80 f1		bra $397a			bra 	_PGMEPLoop
.3989					_PGMEPExit:
.3989	60		rts				rts
.0510					PGMBaseHigh:
>0510							.fill 	1
.0511					PGMEndMemoryHigh:
>0511							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokbuffer.asm

.398a					TOKResetElement:
.398a	9c 12 05	stz $0512			stz 	TOKElement
.398d	60		rts				rts
.398e					TOKWriteElement:
.398e	da		phx				phx
.398f	ae 12 05	ldx $0512			ldx 	TOKElement
.3992	9d 13 05	sta $0513,x			sta 	TOKElementText,x
.3995	9e 14 05	stz $0514,x			stz 	TOKElementText+1,x
.3998	fa		plx				plx
.3999	ee 12 05	inc $0512			inc 	TOKElement
.399c	60		rts				rts
.0512					TOKElement:
>0512							.fill 	1
.0513					TOKElementText:
>0513							.fill 	255

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokconstant.asm

.399d					TOKTokeniseConstant:
.399d	a5 0c		lda $0c				lda 	IFR0+IM0 					; check > 64
.399f	48		pha				pha 								; save on stack
.39a0	29 c0		and #$c0			and 	#$C0
.39a2	05 0d		ora $0d				ora 	IFR0+IM1
.39a4	05 0e		ora $0e				ora 	IFR0+IM2
.39a6	f0 10		beq $39b8			beq 	_TTCLess
.39a8	da		phx				phx
.39a9	a2 06		ldx #$06			ldx 	#6 							; divide by 64
.39ab					_TTCShiftRight:
.39ab	46 0e		lsr $0e				lsr 	IFR0+IM2
.39ad	66 0d		ror $0d				ror 	IFR0+IM1
.39af	66 0c		ror $0c				ror 	IFR0+IM0
.39b1	ca		dex				dex
.39b2	d0 f7		bne $39ab			bne 	_TTCShiftRight
.39b4	fa		plx				plx
.39b5	20 9d 39	jsr $399d			jsr 	TOKTokeniseConstant
.39b8					_TTCLess:
.39b8	68		pla				pla
.39b9	29 3f		and #$3f			and 	#$3F 						; lower 6 bits
.39bb	20 54 3a	jsr $3a54			jsr 	TOKWriteA
.39be	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokdecimal.asm

.39bf					TOKTokeniseDecimals:
.39bf	20 64 3a	jsr $3a64			jsr 	TOKGetNext 					; consume the .
.39c2	20 8e 3b	jsr $3b8e			jsr 	TOKExtractInteger 			; pull an integer out as text.
.39c5	a9 ed		lda #$ed			lda 	#PR_LSQLSQDECIMALRSQRSQ	 	; decimal token
.39c7	20 54 3a	jsr $3a54			jsr 	TOKWriteA
.39ca	20 cf 39	jsr $39cf			jsr 	TOKOutputElementBuffer 		; then the buffer
.39cd	18		clc				clc
.39ce	60		rts				rts
.39cf					TOKOutputElementBuffer:
.39cf	ad 12 05	lda $0512			lda 	TOKElement 					; get count and write that
.39d2	20 54 3a	jsr $3a54			jsr 	TOKWriteA
.39d5	a8		tay				tay 								; put in Y
.39d6	f0 0c		beq $39e4			beq 	_TOEExit 					; exit if empty which is okay.
.39d8	a2 01		ldx #$01			ldx 	#1
.39da					_TOELoop:
.39da	bd 12 05	lda $0512,x			lda 	TOKElement,x
.39dd	20 54 3a	jsr $3a54			jsr 	TOKWriteA
.39e0	e8		inx				inx
.39e1	88		dey				dey
.39e2	d0 f6		bne $39da			bne 	_TOELoop
.39e4					_TOEExit:
.39e4	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokenise.asm

.39e5					TOKTokenise:
.39e5	8c 13 06	sty $0613			sty 	TOKDataSource+1 			; save source routine pointer
.39e8	8e 12 06	stx $0612			stx 	TOKDataSource
.39eb	a9 01		lda #$01			lda 	#1 							; set first element flag.
.39ed	8d 14 06	sta $0614			sta 	TOKIsFirstElement
.39f0	a9 03		lda #$03			lda 	#3 							; set the line length to three for the
.39f2	8d 01 04	sta $0401			sta 	TOKLineSize 				; line length itself and the line numbers.
.39f5					_TOKMainLoop:
.39f5	20 60 3a	jsr $3a60			jsr 	TOKGet 						; what follows.
.39f8	c9 00		cmp #$00			cmp 	#0 							; if zero, we are complete
.39fa	f0 4f		beq $3a4b			beq 	_TOKExit
.39fc	c9 20		cmp #$20			cmp 	#' '						; space, consume and loop back.
.39fe	d0 05		bne $3a05			bne 	_TOKElement
.3a00	20 64 3a	jsr $3a64			jsr 	TOKGetNext
.3a03	80 f0		bra $39f5			bra 	_TOKMainLoop
.3a05					_TOKElement:
.3a05	20 0c 3c	jsr $3c0c			jsr 	TOKIsDigit 					; is it 0..9
.3a08	90 0a		bcc $3a14			bcc 	_TOKNotDigit
.3a0a	20 65 3b	jsr $3b65			jsr 	TOKTokeniseInteger 			; get integer
.3a0d	b0 43		bcs $3a52			bcs 	_TOKFail 					; did it fail ?
.3a0f	9c 14 06	stz $0614			stz 	TOKIsFirstElement 			; clear first element flag
.3a12	80 e1		bra $39f5			bra 	_TOKMainLoop
.3a14					_TOKNotDigit:
.3a14	9c 14 06	stz $0614			stz 	TOKIsFirstElement 			; clear first element flag
.3a17	c9 24		cmp #$24			cmp 	#"$"						; check for hexadecimal ?
.3a19	d0 07		bne $3a22			bne 	_TOKNotHex
.3a1b	20 ad 3a	jsr $3aad			jsr 	TOKTokeniseHexadecimal
.3a1e	b0 32		bcs $3a52			bcs 	_TOKFail
.3a20	80 d3		bra $39f5			bra 	_TOKMainLoop
.3a22					_TOKNotHex:
.3a22	c9 2e		cmp #$2e			cmp 	#"."						; is it decimal e.g. .012345 etc.
.3a24	d0 07		bne $3a2d			bne 	_TOKNotDecimal
.3a26	20 bf 39	jsr $39bf			jsr 	TOKTokeniseDecimals
.3a29	b0 27		bcs $3a52			bcs 	_TOKFail
.3a2b	80 c8		bra $39f5			bra 	_TOKMainLoop
.3a2d					_TOKNotDecimal:
.3a2d	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.3a2f	d0 07		bne $3a38			bne 	_TOKNotString
.3a31	20 d3 3b	jsr $3bd3			jsr 	TOKTokeniseString
.3a34	b0 1c		bcs $3a52			bcs 	_TOKFail
.3a36	80 bd		bra $39f5			bra 	_TOKMainLoop
.3a38					_TOKNotString:
.3a38	20 29 3c	jsr $3c29			jsr 	TOKIsAlpha 					; identifier ?
.3a3b	b0 07		bcs $3a44			bcs 	_TOKIdentifier
.3a3d	20 a2 3b	jsr $3ba2			jsr 	TOKTokenisePunctuation 		; punctuation
.3a40	b0 10		bcs $3a52			bcs 	_TOKFail
.3a42	80 b1		bra $39f5			bra 	_TOKMainLoop
.3a44					_TOKIdentifier:
.3a44	20 e7 3a	jsr $3ae7			jsr 	TOKTokeniseIdentifier 		; identifier/token.
.3a47	b0 09		bcs $3a52			bcs 	_TOKFail
.3a49	80 aa		bra $39f5			bra 	_TOKMainLoop
.3a4b					_TOKExit:
.3a4b	a9 8c		lda #$8c			lda 	#PR_LSQLSQENDRSQRSQ 		; write EOL
.3a4d	20 54 3a	jsr $3a54			jsr 	TOKWriteA
.3a50	18		clc				clc									; return with carry set.
.3a51	60		rts				rts
.3a52					_TOKFail:
.3a52	38		sec				sec
.3a53	60		rts				rts
.3a54					TOKWriteA:
.3a54	da		phx				phx
.3a55	ae 01 04	ldx $0401			ldx 	TOKLineSize
.3a58	9d 01 04	sta $0401,x			sta 	TOKLineSize,x
.3a5b	fa		plx				plx
.3a5c	ee 01 04	inc $0401			inc 	TOKLineSize
.3a5f	60		rts				rts
.3a60					TOKGet:
.3a60	18		clc				clc
.3a61	6c 12 06	jmp ($0612)			jmp 	(TOKDataSource)
.3a64					TOKGetNext:
.3a64	38		sec				sec
.3a65	6c 12 06	jmp ($0612)			jmp 	(TOKDataSource)
.0612					TOKDataSource:
>0612							.fill 	2
.0614					TOKIsFirstElement:
>0614							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokfind.asm

.3a68					TOKFindToken:
.3a68	a2 e1		ldx #$e1			ldx 	#StandardTokens & $FF 		; do this table
.3a6a	a0 34		ldy #$34			ldy 	#StandardTokens >> 8
.3a6c	20 77 3a	jsr $3a77			jsr 	TOKFindTokenXY 				; find it, or not
.3a6f	90 04		bcc $3a75			bcc 	_TOKFTFail
.3a71	a2 00		ldx #$00			ldx 	#0
.3a73	38		sec				sec
.3a74	60		rts				rts
.3a75					_TOKFTFail
.3a75	18		clc				clc
.3a76	60		rts				rts
.3a77					TOKFindTokenXY:
.3a77	86 1e		stx $1e				stx 	zTemp0 						; save token table address
.3a79	84 1f		sty $1f				sty 	zTemp0+1
.3a7b	a9 80		lda #$80			lda 	#$80 						; table starts at $80
.3a7d	8d 15 06	sta $0615			sta 	TOKCurrent
.3a80					_TOKFindLoop:
.3a80	b2 1e		lda ($1e)			lda 	(zTemp0) 					; get token length from table
.3a82	18		clc				clc 		 						; clear carry in case of fail
.3a83	30 17		bmi $3a9c			bmi 	_TOKExit 					; end of table, fail, so return CC.
.3a85	cd 12 05	cmp $0512			cmp 	TOKElement 					; compare against the element length
.3a88	d0 13		bne $3a9d			bne 	_TOKNext 					; different, try next.
.3a8a	aa		tax				tax 								; number of chars to compare.
.3a8b	a0 01		ldy #$01			ldy 	#1 							; offset to actual text.
.3a8d					_TOKCompare:
.3a8d	b1 1e		lda ($1e),y			lda 	(zTemp0),y 					; compare the characters
.3a8f	d9 12 05	cmp $0512,y			cmp 	TOKElementText-1,y
.3a92	d0 09		bne $3a9d			bne 	_TOKNext 					; different ? try next
.3a94	c8		iny				iny 								; compare next two
.3a95	ca		dex				dex
.3a96	d0 f5		bne $3a8d			bne 	_TOKCompare 				; until done X characters.
.3a98	38		sec				sec
.3a99	ad 15 06	lda $0615			lda 	TOKCurrent 					; return current ID.
.3a9c					_TOKExit:
.3a9c	60		rts				rts
.3a9d					_TOKNext:
.3a9d	ee 15 06	inc $0615			inc 	TOKCurrent 					; increment token #
.3aa0	38		sec				sec 								; add length+1 to ptr
.3aa1	b2 1e		lda ($1e)			lda 	(zTemp0)
.3aa3	65 1e		adc $1e				adc 	zTemp0
.3aa5	85 1e		sta $1e				sta 	zTemp0
.3aa7	90 d7		bcc $3a80			bcc 	_TOKFindLoop
.3aa9	e6 1f		inc $1f				inc 	zTemp0+1
.3aab	80 d3		bra $3a80			bra 	_TOKFindLoop
.0615					TOKCurrent:
>0615							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokhexadecimal.asm

.3aad					TOKTokeniseHexadecimal:
.3aad	20 64 3a	jsr $3a64			jsr 	TOKGetNext 					; consume the $
.3ab0	a2 0c		ldx #$0c			ldx 	#IFR0
.3ab2	20 a5 49	jsr $49a5			jsr 	IFloatSetZero 				; set R0 = 0
.3ab5					_TTHLoop:
.3ab5	20 60 3a	jsr $3a60			jsr 	TOKGet 						; keep getting and copying while numeric.
.3ab8	20 36 3c	jsr $3c36			jsr 	TOKIsHexadecimal
.3abb	90 20		bcc $3add			bcc 	_TTHDone
.3abd	a2 0c		ldx #$0c			ldx 	#IFR0 						; shift R0 right 4
.3abf	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.3ac2	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.3ac5	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.3ac8	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.3acb	20 64 3a	jsr $3a64			jsr 	TOKGetNext
.3ace	38		sec				sec 								; convert to decimal.
.3acf	e9 30		sbc #$30			sbc 	#48
.3ad1	c9 0a		cmp #$0a			cmp 	#10
.3ad3	90 02		bcc $3ad7			bcc 	_TTHNotAlpha
.3ad5	e9 07		sbc #$07			sbc 	#7
.3ad7					_TTHNotAlpha:
.3ad7	05 0c		ora $0c				ora 	IFR0+IM0 					; OR in
.3ad9	85 0c		sta $0c				sta 	IFR0+IM0
.3adb	80 d8		bra $3ab5			bra 	_TTHLoop
.3add					_TTHDone:
.3add	a9 ec		lda #$ec			lda 	#PR_DOLLAR 					; write $ function out
.3adf	20 54 3a	jsr $3a54			jsr 	TOKWriteA
.3ae2	20 9d 39	jsr $399d			jsr 	TOKTokeniseConstant 		; write integer out.
.3ae5	18		clc				clc
.3ae6	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokidentifier.asm

.3ae7					TOKTokeniseIdentifier:
.3ae7	20 8a 39	jsr $398a			jsr 	TOKResetElement 			; extract an identifier
.3aea					_TOKGetIdentifier:
.3aea	20 60 3a	jsr $3a60			jsr 	TOKGet
.3aed	20 f6 3b	jsr $3bf6			jsr 	TOKToUpper
.3af0	20 18 3c	jsr $3c18			jsr 	TOKIsIdentifierElement
.3af3	90 08		bcc $3afd			bcc 	_TOKEndIdent
.3af5	20 8e 39	jsr $398e			jsr		TOKWriteElement
.3af8	20 64 3a	jsr $3a64			jsr 	TOKGetNext
.3afb	80 ed		bra $3aea			bra 	_TOKGetIdentifier
.3afd					_TOKEndIdent:
.3afd	c9 24		cmp #$24			cmp 	#"$" 						; last one $
.3aff	d0 06		bne $3b07			bne 	_TOKNotString
.3b01	20 8e 39	jsr $398e			jsr 	TOKWriteElement 			; add it
.3b04	20 64 3a	jsr $3a64			jsr 	TOKGetNext 					; consume it
.3b07					_TOKNotString:
.3b07	20 60 3a	jsr $3a60			jsr 	TOKGet 						; finally check for (
.3b0a	c9 28		cmp #$28			cmp 	#"("
.3b0c	d0 06		bne $3b14			bne 	_TOKNoArray
.3b0e	20 8e 39	jsr $398e			jsr 	TOKWriteElement 			; add it
.3b11	20 64 3a	jsr $3a64			jsr 	TOKGetNext 					; consume it
.3b14					_TOKNoArray:
.3b14	20 68 3a	jsr $3a68			jsr 	TOKFindToken 				; find it
.3b17	90 05		bcc $3b1e			bcc		_TOKIsVariable 				; it must be a variable or proc name if not found
.3b19	20 54 3a	jsr $3a54			jsr 	TOKWriteA
.3b1c	18		clc				clc
.3b1d	60		rts				rts
.3b1e					_TOKIsVariable:
.3b1e	a2 00		ldx #$00			ldx 	#0 							; output element buffer
.3b20					_TOKOutputBuffer:
.3b20	bd 13 05	lda $0513,x			lda 	TOKElementText,x 			; output it translated.
.3b23	20 4c 3b	jsr $3b4c			jsr 	TOKTranslateIdentifier
.3b26	20 54 3a	jsr $3a54			jsr 	TOKWriteA
.3b29	e8		inx				inx
.3b2a	bd 13 05	lda $0513,x			lda 	TOKElementText,x
.3b2d	20 18 3c	jsr $3c18			jsr 	TOKIsIdentifierElement
.3b30	b0 ee		bcs $3b20			bcs 	_TOKOutputBuffer
.3b32	a8		tay				tay 								; last char in Y
.3b33	a9 7c		lda #$7c			lda 	#$7C 						; token is $7C
.3b35	c0 00		cpy #$00			cpy 	#0 							; if no modifier use this
.3b37	f0 0e		beq $3b47			beq 	_TOKIVExit
.3b39	c0 24		cpy #$24			cpy 	#'$'						; array mod ?
.3b3b	d0 04		bne $3b41			bne 	_TOKIVCheckArray 			; no, check for (
.3b3d	1a		inc a				inc 	a 							; token is $7D
.3b3e	bc 14 05	ldy $0514,x			ldy 	TOKElementText+1,x 			; get next one.
.3b41					_TOKIVCheckArray:
.3b41	c0 28		cpy #$28			cpy 	#'('						; is it ( ?
.3b43	d0 02		bne $3b47			bne 	_TOKIVExit 					; yes, then add 2 more, so 7C->7E and 7D->7F
.3b45	1a		inc a				inc 	a
.3b46	1a		inc a				inc 	a
.3b47					_TOKIVExit:
.3b47	20 54 3a	jsr $3a54			jsr 	TOKWriteA 					; ending token
.3b4a	18		clc				clc
.3b4b	60		rts				rts
.3b4c					TOKTranslateIdentifier:
.3b4c	c9 2e		cmp #$2e			cmp 	#"." 						; . is 0x64
.3b4e	f0 0f		beq $3b5f			beq 	_TTI64
.3b50	c9 5f		cmp #$5f			cmp 	#"_"						; _ is 0x65
.3b52	f0 0e		beq $3b62			beq 	_TTI65
.3b54	38		sec				sec
.3b55	e9 41		sbc #$41			sbc 	#"A" 						; map A-Z onto 0-25
.3b57	10 03		bpl $3b5c			bpl 	_TTIExit
.3b59	18		clc				clc 								; map 09 onto 26-35
.3b5a	69 2b		adc #$2b			adc 	#"A"-"0"+26
.3b5c					_TTIExit:
.3b5c	09 40		ora #$40			ora 	#$40 						; correct range.
.3b5e	60		rts				rts
.3b5f	a9 64		lda #$64	_TTI64:	lda 	#$64
.3b61	60		rts				rts
.3b62	a9 65		lda #$65	_TTI65:	lda 	#$65
.3b64	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokinteger.asm

.3b65					TOKTokeniseInteger:
.3b65	20 8e 3b	jsr $3b8e			jsr 	TOKExtractInteger 			; pull an integer out as text.
.3b68	a2 13		ldx #$13			ldx 	#TOKElementText & $FF
.3b6a	a0 05		ldy #$05			ldy 	#TOKElementText >> 8
.3b6c	ad 12 05	lda $0512			lda		TOKElement
.3b6f	20 09 48	jsr $4809			jsr 	IFloatStringToFloatR0 		; convert to R0 integer
.3b72	ad 14 06	lda $0614			lda 	TOKIsFirstElement 			; first element ?
.3b75	f0 12		beq $3b89			beq 	_TOKNotLineNumber
.3b77	a5 0e		lda $0e				lda 	IFR0+IM2 					; check it's a 2 digit number
.3b79	d0 0c		bne $3b87			bne 	_TOKBadLineNumeber
.3b7b	a5 0c		lda $0c				lda 	IFR0+IM0 					; copy it to the line number section.
.3b7d	8d 02 04	sta $0402			sta 	TOKLineNumber
.3b80	a5 0d		lda $0d				lda 	IFR0+IM1
.3b82	8d 03 04	sta $0403			sta 	TOKLineNumber+1
.3b85	18		clc				clc
.3b86	60		rts				rts
.3b87					_TOKBadLineNumeber:
.3b87	38		sec				sec
.3b88	60		rts				rts
.3b89					_TOKNotLineNumber:
.3b89	20 9d 39	jsr $399d			jsr 	TOKTokeniseConstant 		; tokenise the constant in R0
.3b8c	18		clc				clc
.3b8d	60		rts				rts
.3b8e					TOKExtractInteger:
.3b8e	20 8a 39	jsr $398a			jsr 	TOKResetElement 			; restart
.3b91					_TTILoop:
.3b91	20 60 3a	jsr $3a60			jsr 	TOKGet 						; keep getting and copying while numeric.
.3b94	20 0c 3c	jsr $3c0c			jsr 	TOKIsDigit
.3b97	90 08		bcc $3ba1			bcc 	_TOKEIExit
.3b99	20 8e 39	jsr $398e			jsr 	TOKWriteElement
.3b9c	20 64 3a	jsr $3a64			jsr 	TOKGetNext
.3b9f	80 f0		bra $3b91			bra 	_TTILoop
.3ba1					_TOKEIExit:
.3ba1	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokpunctuation.asm

.3ba2					TOKTokenisePunctuation:
.3ba2	20 8a 39	jsr $398a			jsr 	TOKResetElement 			; copy first punctuation character into element.
.3ba5	20 64 3a	jsr $3a64			jsr 	TOKGetNext
.3ba8	20 8e 39	jsr $398e			jsr 	TOKWriteElement
.3bab	20 60 3a	jsr $3a60			jsr 	TOKGet 						; what follows ?
.3bae	c9 20		cmp #$20			cmp 	#' '						; space, not 2 character
.3bb0	f0 10		beq $3bc2			beq 	_TTPOne
.3bb2	20 20 3c	jsr $3c20			jsr 	TOKIsAlphaNumeric 			; if alphanumeric don't bother doing 2 character
.3bb5	b0 0b		bcs $3bc2			bcs 	_TTPOne 					; these speed things up a bit.
.3bb7	20 8e 39	jsr $398e			jsr 	TOKWriteElement 			; this is what we will search for.
.3bba	20 68 3a	jsr $3a68			jsr 	TOKFindToken
.3bbd	b0 0a		bcs $3bc9			bcs 	_TTPConsumeExit 			; it was found, consume, generate, exit.
.3bbf	ce 12 05	dec $0512			dec 	TOKElement 					; make it a single character
.3bc2					_TTPOne:
.3bc2	20 68 3a	jsr $3a68			jsr 	TOKFindToken 				; look for one character punctuation
.3bc5	b0 07		bcs $3bce			bcs 	_TTPOutputExit 				; we found it
.3bc7	38		sec				sec 								; not recognised.
.3bc8	60		rts				rts
.3bc9					_TTPConsumeExit:
.3bc9	48		pha				pha
.3bca	20 64 3a	jsr $3a64			jsr 	TOKGetNext 					; get the 2nd char out.
.3bcd	68		pla				pla
.3bce					_TTPOutputExit:
.3bce	20 54 3a	jsr $3a54			jsr  	TOKWriteA 					; write token out
.3bd1	18		clc				clc
.3bd2	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokstring.asm

.3bd3					TOKTokeniseString:
.3bd3	20 64 3a	jsr $3a64			jsr 	TOKGetNext 					; consume the "
.3bd6	20 8a 39	jsr $398a			jsr 	TOKResetElement 			; start getting the string
.3bd9					_TOKTSLoop:
.3bd9	20 60 3a	jsr $3a60			jsr 	TOKGet 						; check EOL
.3bdc	c9 00		cmp #$00			cmp 	#0
.3bde	f0 0c		beq $3bec			beq 	_TOKTSExit
.3be0	20 64 3a	jsr $3a64			jsr 	TOKGetNext 					; get and consume
.3be3	c9 22		cmp #$22			cmp 	#'"' 						; exit if " consumed
.3be5	f0 05		beq $3bec			beq 	_TOKTSExit
.3be7	20 8e 39	jsr $398e			jsr 	TOKWriteElement
.3bea	80 ed		bra $3bd9			bra 	_TOKTSLoop
.3bec					_TOKTSExit:
.3bec	a9 ee		lda #$ee			lda 	#PR_LSQLSQSTRINGRSQRSQ
.3bee	20 54 3a	jsr $3a54			jsr 	TOKWriteA
.3bf1	20 cf 39	jsr $39cf			jsr 	TOKOutputElementBuffer
.3bf4	18		clc				clc
.3bf5	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/toktypes.asm

.3bf6					TOKToUpper:
.3bf6	c9 61		cmp #$61			cmp 	#"a"
.3bf8	90 06		bcc $3c00			bcc 	_TTUNotLower
.3bfa	c9 7b		cmp #$7b			cmp 	#"z"+1
.3bfc	b0 02		bcs $3c00			bcs 	_TTUNotLower
.3bfe	49 20		eor #$20			eor 	#$20
.3c00					_TTUNotLower:
.3c00	60		rts				rts
.3c01					TOKToLower:
.3c01	c9 41		cmp #$41			cmp 	#"A"
.3c03	90 06		bcc $3c0b			bcc 	_TTUNotUpper
.3c05	c9 5b		cmp #$5b			cmp 	#"Z"+1
.3c07	b0 02		bcs $3c0b			bcs 	_TTUNotUpper
.3c09	49 20		eor #$20			eor 	#$20
.3c0b					_TTUNotUpper:
.3c0b	60		rts				rts
.3c0c					TOKIsDigit:
.3c0c	c9 30		cmp #$30			cmp 	#"0"
.3c0e	90 06		bcc $3c16			bcc 	TOKFail
.3c10	c9 3a		cmp #$3a			cmp 	#"9"+1
.3c12	b0 02		bcs $3c16			bcs 	TOKFail
.3c14					TOKSucceed:
.3c14	38		sec				sec
.3c15	60		rts				rts
.3c16					TOKFail:
.3c16	18		clc				clc
.3c17	60		rts				rts
.3c18					TOKIsIdentifierElement:
.3c18	c9 2e		cmp #$2e			cmp 	#"." 						; true if . or _
.3c1a	f0 f8		beq $3c14			beq 	TOKSucceed
.3c1c	c9 5f		cmp #$5f			cmp 	#"_"
.3c1e	f0 f4		beq $3c14			beq 	TOKSucceed 					; else fall through to alphanumeric
.3c20					TOKIsAlphaNumeric:
.3c20	20 29 3c	jsr $3c29			jsr 	TOKIsAlpha
.3c23	b0 ef		bcs $3c14			bcs 	TOKSucceed
.3c25	20 0c 3c	jsr $3c0c			jsr 	TOKIsDigit
.3c28	60		rts				rts
.3c29					TOKIsAlpha:
.3c29	20 f6 3b	jsr $3bf6			jsr 	TOKToUpper
.3c2c	c9 41		cmp #$41			cmp 	#"A"
.3c2e	90 e6		bcc $3c16			bcc 	TOKFail
.3c30	c9 5b		cmp #$5b			cmp 	#"Z"+1
.3c32	b0 e2		bcs $3c16			bcs 	TOKFail
.3c34	80 de		bra $3c14			bra 	TOKSucceed
.3c36					TOKIsHexadecimal:
.3c36	20 0c 3c	jsr $3c0c			jsr		TOKIsDigit
.3c39	b0 d9		bcs $3c14			bcs 	TOKSucceed
.3c3b	20 29 3c	jsr $3c29			jsr 	TOKIsAlpha
.3c3e	90 d6		bcc $3c16			bcc 	TOKFail
.3c40	c9 47		cmp #$47			cmp 	#"F"+1
.3c42	b0 d2		bcs $3c16			bcs 	TOKFail
.3c44	80 ce		bra $3c14			bra 	TOKSucceed

;******  Return to file: include.files


;******  Processing file: src/structures/call.asm

.3c46					Command_CALL:
.3c46	a9 42		lda #$42			lda 	#STK_CALL
.3c48	20 bd 40	jsr $40bd			jsr 	StackOpen
.3c4b	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; check identifier follows.
.3c4d	29 c0		and #$c0			and 	#$C0
.3c4f	c9 40		cmp #$40			cmp 	#$40
.3c51	d0 29		bne $3c7c			bne 	_CCSyntax
.3c53	20 e6 42	jsr $42e6			jsr 	VARGetInfo 					; get the information
.3c56	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 				; check right bracket follows.
.3c59	20 98 42	jsr $4298			jsr 	VARFind 					; exists ?
.3c5c	90 21		bcc $3c7f			bcc 	_CCUnknown
.3c5e	86 1f		stx $1f				stx 	zTemp0+1 					; save target in XA
.3c60	85 1e		sta $1e				sta 	zTemp0
.3c62	20 f1 40	jsr $40f1			jsr 	STKSaveCodePosition 		; save return address on stack.
.3c65	a0 03		ldy #$03			ldy 	#3 							; check $FF marker
.3c67	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3c69	c9 ff		cmp #$ff			cmp 	#$FF
.3c6b	d0 12		bne $3c7f			bne 	_CCUnknown
.3c6d	88		dey				dey 								; get Y offset to stack
.3c6e	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3c70	48		pha				pha
.3c71	88		dey				dey 								; get address
.3c72	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3c74	85 1d		sta $1d				sta 	codePtr+1
.3c76	b2 1e		lda ($1e)			lda 	(zTemp0)
.3c78	85 1c		sta $1c				sta 	codePtr
.3c7a	7a		ply				ply 								; restore Y
.3c7b	60		rts				rts
.3c7c					_CCSyntax:
.3c7c	4c 25 3f	jmp $3f25		jmp	ErrorV_syntax
.3c7f					_CCUnknown:
.3c7f	4c 87 40	jmp $4087		jmp	ErrorV_unknown
.3c82					Command_ENDPROC:
.3c82	a9 42		lda #$42			lda 	#STK_CALL
.3c84	20 e9 40	jsr $40e9			jsr 	StackCheckFrame
.3c87	20 03 41	jsr $4103			jsr 	STKLoadCodePosition 		; return
.3c8a	20 db 40	jsr $40db			jsr 	StackClose
.3c8d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/do.asm

.3c8e					Command_DO:
.3c8e	a9 22		lda #$22			lda 	#STK_DO
.3c90	20 bd 40	jsr $40bd			jsr 	StackOpen
.3c93	20 f1 40	jsr $40f1			jsr 	STKSaveCodePosition 		; save loop position
.3c96	60		rts				rts
.3c97					Command_EXIT:
.3c97	a9 22		lda #$22			lda 	#STK_DO 					; check in LOOP
.3c99	20 e9 40	jsr $40e9			jsr 	StackCheckFrame
.3c9c	20 db 40	jsr $40db			jsr 	StackClose 					; close it
.3c9f	a9 87		lda #$87			lda 	#PR_LOOP 					; forward to LOOP
.3ca1	aa		tax				tax
.3ca2	20 37 3e	jsr $3e37			jsr 	ScanForward
.3ca5	60		rts				rts
.3ca6					Command_LOOP:
.3ca6	a9 22		lda #$22			lda 	#STK_DO
.3ca8	20 e9 40	jsr $40e9			jsr 	StackCheckFrame
.3cab	20 03 41	jsr $4103			jsr 	STKLoadCodePosition 		; loop back
.3cae	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/for.asm

.3caf					Command_FOR:
.3caf	a9 37		lda #$37			lda 	#STK_FOR 					; create frame
.3cb1	20 bd 40	jsr $40bd			jsr 	StackOpen
.3cb4	20 a4 2e	jsr $2ea4			jsr 	CommandLET 					; do "I = 1" bit
.3cb7	5a		phy				phy 								; save variable address to +4,+5
.3cb8	a0 04		ldy #$04			ldy 	#4
.3cba	a5 1e		lda $1e				lda 	zTemp0
.3cbc	91 26		sta ($26),y			sta 	(basicStack),y
.3cbe	c8		iny				iny
.3cbf	a5 1f		lda $1f				lda 	zTemp0+1
.3cc1	91 26		sta ($26),y			sta 	(basicStack),y
.3cc3	7a		ply				ply
.3cc4	a9 90		lda #$90			lda 	#PR_TO 						; TO symbol required.
.3cc6	20 b4 40	jsr $40b4			jsr 	ERRCheckA
.3cc9	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 				; evaluate the terminal value.
.3ccc	a9 0a		lda #$0a			lda 	#10 						; save in slots 10-13
.3cce	a2 0c		ldx #$0c			ldx 	#IFR0
.3cd0	20 25 3d	jsr $3d25			jsr 	CFSaveR0X
.3cd3	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; STEP here ?
.3cd5	c9 91		cmp #$91			cmp 	#PR_STEP
.3cd7	d0 06		bne $3cdf			bne 	_CFStep1
.3cd9	c8		iny				iny 								; consume step
.3cda	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 				; evaluate STEP
.3cdd	80 24		bra $3d03			bra 	_CFWriteStep
.3cdf					_CFStep1:
.3cdf	a2 0c		ldx #$0c			ldx 	#IFR0 						; default R0, 1
.3ce1	a9 01		lda #$01			lda 	#1
.3ce3	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.3ce6	5a		phy				phy 								; check for fast loop,step 1, integer start/end.
.3ce7	a0 04		ldy #$04			ldy 	#4 							; get variable address
.3ce9	b1 26		lda ($26),y			lda 	(basicStack),y
.3ceb	85 1e		sta $1e				sta 	zTemp0
.3ced	c8		iny				iny
.3cee	b1 26		lda ($26),y			lda 	(basicStack),y
.3cf0	85 1f		sta $1f				sta 	zTemp0+1
.3cf2	a0 03		ldy #$03			ldy 	#IExp 						; check that's an integer
.3cf4	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.3cf6	d0 0a		bne $3d02			bne 	_CFNotOptimised
.3cf8	a0 0d		ldy #$0d			ldy 	#13 						; check terminal value is integer.
.3cfa	b1 26		lda ($26),y			lda 	(basicStack),y
.3cfc	d0 04		bne $3d02			bne 	_CFNotOptimised
.3cfe	a9 80		lda #$80			lda 	#$80 						; set the step so it's a string/
.3d00	85 0f		sta $0f				sta 	IFR0+IExp
.3d02					_CFNotOptimised:
.3d02	7a		ply				ply
.3d03					_CFWriteStep:
.3d03	a2 0c		ldx #$0c			ldx 	#IFR0 						; Write to additive.
.3d05	a9 06		lda #$06			lda 	#6
.3d07	20 25 3d	jsr $3d25			jsr 	CFSaveR0X
.3d0a	20 f1 40	jsr $40f1			jsr 	STKSaveCodePosition 		; save loop position
.3d0d	60		rts				rts
.3d0e					CFLoadR0X:
.3d0e	5a		phy				phy
.3d0f	a8		tay				tay
.3d10	b1 26		lda ($26),y			lda 	(basicStack),y
.3d12	95 00		sta $00,x			sta 	IM0,x
.3d14	c8		iny				iny
.3d15	b1 26		lda ($26),y			lda 	(basicStack),y
.3d17	95 01		sta $01,x			sta 	IM1,x
.3d19	c8		iny				iny
.3d1a	b1 26		lda ($26),y			lda 	(basicStack),y
.3d1c	95 02		sta $02,x			sta 	IM2,x
.3d1e	c8		iny				iny
.3d1f	b1 26		lda ($26),y			lda 	(basicStack),y
.3d21	95 03		sta $03,x			sta 	IExp,x
.3d23	7a		ply				ply
.3d24	60		rts				rts
.3d25					CFSaveR0X:
.3d25	5a		phy				phy
.3d26	a8		tay				tay
.3d27	b5 00		lda $00,x			lda 	IM0,x
.3d29	91 26		sta ($26),y			sta 	(basicStack),y
.3d2b	c8		iny				iny
.3d2c	b5 01		lda $01,x			lda 	IM1,x
.3d2e	91 26		sta ($26),y			sta 	(basicStack),y
.3d30	c8		iny				iny
.3d31	b5 02		lda $02,x			lda 	IM2,x
.3d33	91 26		sta ($26),y			sta 	(basicStack),y
.3d35	c8		iny				iny
.3d36	b5 03		lda $03,x			lda 	IExp,x
.3d38	91 26		sta ($26),y			sta 	(basicStack),y
.3d3a	7a		ply				ply
.3d3b	60		rts				rts
.3d3c					Command_NEXT:
.3d3c	a9 37		lda #$37			lda 	#STK_FOR
.3d3e	20 e9 40	jsr $40e9			jsr 	StackCheckFrame
.3d41	5a		phy				phy 								; check optimised loop
.3d42	a0 09		ldy #$09			ldy 	#9
.3d44	b1 26		lda ($26),y			lda 	(basicStack),y
.3d46	7a		ply				ply
.3d47	0a		asl a				asl 	a
.3d48	b0 35		bcs $3d7f			bcs 	_CNOptimised
.3d4a	20 b6 3d	jsr $3db6			jsr 	_CNLoadValue 				; load index value to R0.
.3d4d	a2 10		ldx #$10			ldx 	#IFR1 						; load adding value to R1.
.3d4f	a9 06		lda #$06			lda 	#6
.3d51	20 0e 3d	jsr $3d0e			jsr 	CFLoadR0X
.3d54	20 9b 43	jsr $439b			jsr 	IFloatAdd 					; add them together and write back.
.3d57	20 d9 3d	jsr $3dd9			jsr 	_CNSaveValue
.3d5a	a9 0a		lda #$0a			lda 	#10 						; terminal value in R1
.3d5c	a2 10		ldx #$10			ldx 	#IFR1
.3d5e	20 0e 3d	jsr $3d0e			jsr 	CFLoadR0X
.3d61	20 73 46	jsr $4673			jsr 	IFloatCompare 				; compare terminal vs current
.3d64	a2 0c		ldx #$0c			ldx 	#IFR0 						; if zero, e.g. equal, loop back.
.3d66	20 9e 49	jsr $499e			jsr 	IFloatCheckZero
.3d69	f0 10		beq $3d7b			beq 	_CNLoopBack
.3d6b	a5 0f		lda $0f				lda 	IFR0+IExp 					; if sign compare and sign add match, loop back.
.3d6d	5a		phy				phy
.3d6e	a0 09		ldy #$09			ldy 	#6+IExp
.3d70	51 26		eor ($26),y			eor 	(basicStack),y
.3d72	7a		ply				ply
.3d73	29 40		and #$40			and 	#IFSign
.3d75	f0 04		beq $3d7b			beq 	_CNLoopBack
.3d77					_CNExitLoop:
.3d77	20 db 40	jsr $40db			jsr 	StackClose		 			; return
.3d7a	60		rts				rts
.3d7b					_CNLoopBack:
.3d7b	20 03 41	jsr $4103			jsr 	STKLoadCodePosition 		; loop back
.3d7e	60		rts				rts
.3d7f					_CNOptimised:
.3d7f	5a		phy				phy
.3d80	a0 04		ldy #$04			ldy 	#4 							; copy address of index variable to zTemp2
.3d82	b1 26		lda ($26),y			lda 	(basicStack),y
.3d84	85 22		sta $22				sta 	zTemp2
.3d86	c8		iny				iny
.3d87	b1 26		lda ($26),y			lda 	(basicStack),y
.3d89	85 23		sta $23				sta 	zTemp2+1
.3d8b	a0 ff		ldy #$ff			ldy 	#$FF 						; increment that value. this won't go round
.3d8d					_CNIncrement:
.3d8d	c8		iny				iny
.3d8e	b1 22		lda ($22),y			lda 	(zTemp2),y
.3d90	1a		inc a				inc 	a
.3d91	91 22		sta ($22),y			sta 	(zTemp2),y
.3d93	f0 f8		beq $3d8d			beq 	_CNIncrement
.3d95	18		clc				clc 								; point zTemp0 to terminal value
.3d96	a5 26		lda $26				lda 	basicStack
.3d98	69 0a		adc #$0a			adc 	#10
.3d9a	85 1e		sta $1e				sta 	zTemp0
.3d9c	a5 27		lda $27				lda 	basicStack+1
.3d9e	69 00		adc #$00			adc 	#0
.3da0	85 1f		sta $1f				sta 	zTemp0+1
.3da2	a0 01		ldy #$01			ldy 	#1 							; compare value to terminal.
.3da4	b2 22		lda ($22)			lda 	(zTemp2)
.3da6	d2 1e		cmp ($1e)			cmp 	(zTemp0)
.3da8	b1 22		lda ($22),y			lda 	(zTemp2),y
.3daa	f1 1e		sbc ($1e),y			sbc 	(zTemp0),y
.3dac	c8		iny				iny
.3dad	b1 22		lda ($22),y			lda 	(zTemp2),y
.3daf	f1 1e		sbc ($1e),y			sbc 	(zTemp0),y
.3db1	7a		ply				ply
.3db2	b0 c3		bcs $3d77			bcs 	_CNExitLoop
.3db4	80 c5		bra $3d7b			bra 	_CNLoopBack
.3db6					_CNLoadValue:
.3db6	5a		phy				phy
.3db7	a0 04		ldy #$04			ldy 	#4 							; copy address to zTemp2
.3db9	b1 26		lda ($26),y			lda 	(basicStack),y
.3dbb	85 22		sta $22				sta 	zTemp2
.3dbd	c8		iny				iny
.3dbe	b1 26		lda ($26),y			lda 	(basicStack),y
.3dc0	85 23		sta $23				sta 	zTemp2+1
.3dc2	a0 00		ldy #$00			ldy 	#0 							; copy dword at zTemp2 to IFR0
.3dc4	b1 22		lda ($22),y			lda 	(zTemp2),y
.3dc6	85 0c		sta $0c				sta 	IFR0+IM0
.3dc8	c8		iny				iny
.3dc9	b1 22		lda ($22),y			lda 	(zTemp2),y
.3dcb	85 0d		sta $0d				sta 	IFR0+IM1
.3dcd	c8		iny				iny
.3dce	b1 22		lda ($22),y			lda 	(zTemp2),y
.3dd0	85 0e		sta $0e				sta 	IFR0+IM2
.3dd2	c8		iny				iny
.3dd3	b1 22		lda ($22),y			lda 	(zTemp2),y
.3dd5	85 0f		sta $0f				sta 	IFR0+IExp
.3dd7	7a		ply				ply
.3dd8	60		rts				rts
.3dd9					_CNSaveValue:
.3dd9	5a		phy				phy
.3dda	a0 00		ldy #$00			ldy 	#0
.3ddc	a5 0c		lda $0c				lda 	IFR0+IM0
.3dde	91 22		sta ($22),y			sta 	(zTemp2),y
.3de0	c8		iny				iny
.3de1	a5 0d		lda $0d				lda 	IFR0+IM1
.3de3	91 22		sta ($22),y			sta 	(zTemp2),y
.3de5	c8		iny				iny
.3de6	a5 0e		lda $0e				lda 	IFR0+IM2
.3de8	91 22		sta ($22),y			sta 	(zTemp2),y
.3dea	c8		iny				iny
.3deb	a5 0f		lda $0f				lda 	IFR0+IExp
.3ded	91 22		sta ($22),y			sta 	(zTemp2),y
.3def	7a		ply				ply
.3df0	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/if.asm

.3df1					IfCommand:
.3df1	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 				; Get the if test.
.3df4	b1 1c		lda ($1c),y			lda 	(codePtr),y					; what follows ?
.3df6	c9 8f		cmp #$8f			cmp 	#PR_THEN  					; could be THEN <stuff>
.3df8	d0 0a		bne $3e04			bne 	_IfStructured 				; we still support it.
.3dfa	c8		iny				iny 								; consume THEN
.3dfb	20 9e 49	jsr $499e			jsr 	IFloatCheckZero 			; is it zero
.3dfe	f0 01		beq $3e01			beq 	_IfFail 					; if fail, go to next line
.3e00	60		rts				rts 								; if THEN just continue
.3e01					_IfFail:
.3e01	4c 3e 2f	jmp $2f3e			jmp 	RUNEndOfLine
.3e04					_IfStructured:
.3e04	20 9e 49	jsr $499e			jsr 	IFloatCheckZero 			; is it zero
.3e07	d0 07		bne $3e10			bne 	_IfExit 					; if not, then continue normally.
.3e09	a9 8e		lda #$8e			lda 	#PR_ELSE 					; look for else/endif
.3e0b	a2 85		ldx #$85			ldx 	#PR_ENDIF
.3e0d	20 37 3e	jsr $3e37			jsr 	ScanForward 				; and run from there
.3e10					_IfExit:
.3e10	60		rts				rts
.3e11					ElseCode:
.3e11	a9 85		lda #$85			lda 	#PR_ENDIF 					; else is only run after the if clause succeeds
.3e13	aa		tax				tax 								; so just go to the structure exit
.3e14	20 37 3e	jsr $3e37			jsr 	ScanForward
.3e17	60		rts				rts
.3e18					EndIf:
.3e18	60		rts				rts 								; endif code does nothing

;******  Return to file: include.files


;******  Processing file: src/structures/repeat.asm

.3e19					Command_REPEAT:
.3e19	a9 02		lda #$02			lda 	#STK_REPEAT
.3e1b	20 bd 40	jsr $40bd			jsr 	StackOpen
.3e1e	20 f1 40	jsr $40f1			jsr 	STKSaveCodePosition 		; save loop position
.3e21	60		rts				rts
.3e22					Command_UNTIL:
.3e22	a9 02		lda #$02			lda 	#STK_REPEAT
.3e24	20 e9 40	jsr $40e9			jsr 	StackCheckFrame
.3e27	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 				; work out the test
.3e2a	20 9e 49	jsr $499e			jsr 	IFloatCheckZero 			; check if zero
.3e2d	f0 04		beq $3e33			beq 	_CULoopBack 				; if so keep looping
.3e2f	20 db 40	jsr $40db			jsr 	StackClose		 			; return
.3e32	60		rts				rts
.3e33					_CULoopBack:
.3e33	20 03 41	jsr $4103			jsr 	STKLoadCodePosition 		; loop back
.3e36	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/scanforward.asm

.3e37					ScanForward:
.3e37	85 1e		sta $1e				sta 	zTemp0 						; save scan options in zTemp0
.3e39	86 1f		stx $1f				stx 	zTemp0+1
.3e3b	64 20		stz $20				stz 	zTemp1 						; clear structure count.
.3e3d					_ScanForwardLoop:
.3e3d	a5 20		lda $20				lda 	zTemp1 						; if structure count non zero, don't check for end.
.3e3f	d0 0a		bne $3e4b			bne 	_ScanNoCheck
.3e41	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; reached either target token.
.3e43	c5 1e		cmp $1e				cmp 	zTemp0
.3e45	f0 49		beq $3e90			beq 	_ScanExit
.3e47	c5 1f		cmp $1f				cmp 	zTemp0+1
.3e49	f0 45		beq $3e90			beq 	_ScanExit
.3e4b					_ScanNoCheck:
.3e4b	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get the token and consume it.
.3e4d	c8		iny				iny
.3e4e	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ 	; check for special multi-byte elements
.3e50	f0 37		beq $3e89			beq		_ScanDataItem
.3e52	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ
.3e54	f0 33		beq $3e89			beq 	_ScanDataItem
.3e56	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; handle end of line.
.3e58	f0 1b		beq $3e75			beq 	_ScanNextLine
.3e5a	c9 8d		cmp #$8d			cmp 	#PR_LSQLSQSHIFTRSQRSQ 		; if shift, skip one.
.3e5c	d0 01		bne $3e5f			bne 	_ScanNoShift
.3e5e	c8		iny				iny
.3e5f					_ScanNoShift:
.3e5f	c9 8c		cmp #$8c			cmp 	#PR_STRUCTURE_LAST+1 		; nested structures
.3e61	b0 da		bcs $3e3d			bcs 	_ScanForwardLoop
.3e63	c9 80		cmp #$80			cmp 	#PR_STRUCTURE_FIRST
.3e65	90 d6		bcc $3e3d			bcc 	_ScanForwardLoop
.3e67	aa		tax				tax 								; access the table to get the adjustment.
.3e68	18		clc				clc
.3e69	a5 20		lda $20				lda 	zTemp1 						; add it to structure count.
.3e6b	7d 55 34	adc $3455,x			adc 	StructureOffsets-PR_STRUCTURE_FIRST,x
.3e6e	85 20		sta $20				sta 	zTemp1
.3e70	10 cb		bpl $3e3d			bpl		_ScanForwardLoop 			; error if -ve ?
.3e72	4c a9 3f	jmp $3fa9		jmp	ErrorV_structure
.3e75					_ScanNextLine:
.3e75	18		clc				clc	 								; forward to next line.
.3e76	b2 1c		lda ($1c)			lda 	(codePtr)
.3e78	65 1c		adc $1c				adc 	codePtr
.3e7a	85 1c		sta $1c				sta 	codePtr
.3e7c	90 02		bcc $3e80			bcc 	_ScanNoCarry
.3e7e	e6 1d		inc $1d				inc 	codePtr+1
.3e80					_ScanNoCarry:
.3e80	a0 03		ldy #$03			ldy 	#3
.3e82	b2 1c		lda ($1c)			lda 	(codePtr) 					; off end of program ?
.3e84	d0 b7		bne $3e3d			bne 	_ScanForwardLoop
.3e86	4c a9 3f	jmp $3fa9		jmp	ErrorV_structure
.3e89					_ScanDataItem:
.3e89	98		tya				tya
.3e8a	38		sec				sec
.3e8b	71 1c		adc ($1c),y			adc 	(codePtr),y
.3e8d	a8		tay				tay
.3e8e	80 ad		bra $3e3d			bra 	_ScanForwardLoop
.3e90					_ScanExit:
.3e90	c8		iny				iny 								; consume final token.
.3e91	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/scanproc.asm

.3e92					ScanProcedures:
.3e92	a5 1c		lda $1c				lda 	codePtr 					; push codePtr on the stack
.3e94	48		pha				pha
.3e95	a5 1d		lda $1d				lda 	codePtr+1
.3e97	48		pha				pha
.3e98	5a		phy				phy
.3e99	ad 10 05	lda $0510			lda 	PGMBaseHigh 				; back to the program start
.3e9c	85 1d		sta $1d				sta 	codePtr+1
.3e9e	64 1c		stz $1c				stz 	codePtr
.3ea0					_SPLoop:
.3ea0	b2 1c		lda ($1c)			lda 	(codePtr) 					; end of program
.3ea2	f0 18		beq $3ebc			beq 	_SPExit
.3ea4	a0 03		ldy #$03			ldy 	#3 							; first token PROC
.3ea6	b1 1c		lda ($1c),y			lda 	(codePtr),y
.3ea8	c9 88		cmp #$88			cmp 	#PR_PROC
.3eaa	d0 03		bne $3eaf			bne 	_SPNext
.3eac	20 c4 3e	jsr $3ec4			jsr 	_SPSetupRecord
.3eaf					_SPNext:
.3eaf	18		clc				clc 								; forward to next
.3eb0	b2 1c		lda ($1c)			lda 	(codePtr)
.3eb2	65 1c		adc $1c				adc 	codePtr
.3eb4	85 1c		sta $1c				sta 	codePtr
.3eb6	90 e8		bcc $3ea0			bcc 	_SPLoop
.3eb8	e6 1d		inc $1d				inc 	codePtr+1
.3eba	80 e4		bra $3ea0			bra 	_SPLoop
.3ebc					_SPExit:
.3ebc	7a		ply				ply
.3ebd	68		pla				pla
.3ebe	85 1d		sta $1d				sta 	codePtr+1
.3ec0	68		pla				pla
.3ec1	85 1c		sta $1c				sta 	codePtr
.3ec3	60		rts				rts
.3ec4					_SPSetupRecord:
.3ec4	c8		iny				iny 								; check identifier follows
.3ec5	b1 1c		lda ($1c),y			lda 	(codePtr),y
.3ec7	29 c0		and #$c0			and 	#$C0
.3ec9	c9 40		cmp #$40			cmp 	#$40
.3ecb	d0 27		bne $3ef4			bne 	_SPSyntax
.3ecd	20 e6 42	jsr $42e6			jsr 	VARGetInfo 					; get the information
.3ed0	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen 				; check right bracket follows.
.3ed3	20 98 42	jsr $4298			jsr 	VARFind 					; already exists ?
.3ed6	b0 1f		bcs $3ef7			bcs 	_SPUsed 					; error !
.3ed8	20 44 42	jsr $4244			jsr 	VARCreate 					; create, XA points to the data.
.3edb	85 1e		sta $1e				sta 	zTemp0
.3edd	86 1f		stx $1f				stx 	zTemp0+1
.3edf	5a		phy				phy 								; save Y pos on stack
.3ee0	a0 01		ldy #$01			ldy 	#1
.3ee2	a5 1c		lda $1c				lda 	codePtr 					; save codePtr/Y
.3ee4	92 1e		sta ($1e)			sta 	(zTemp0)
.3ee6	a5 1d		lda $1d				lda 	codePtr+1
.3ee8	91 1e		sta ($1e),y			sta 	(zTemp0),y
.3eea	c8		iny				iny
.3eeb	68		pla				pla
.3eec	91 1e		sta ($1e),y			sta 	(zTemp0),y
.3eee	c8		iny				iny
.3eef	a9 ff		lda #$ff			lda 	#$FF 						; fill rest with $FF
.3ef1	91 1e		sta ($1e),y			sta 	(zTemp0),y
.3ef3	60		rts				rts
.3ef4					_SPSyntax:
.3ef4	4c 25 3f	jmp $3f25		jmp	ErrorV_syntax
.3ef7					_SPUsed:
.3ef7	4c 6a 40	jmp $406a		jmp	ErrorV_dupproc

;******  Return to file: include.files


;******  Processing file: src/structures/while.asm

.3efa					Command_WHILE:
.3efa	5a		phy				phy 								; save position of the test
.3efb	20 5a 31	jsr $315a			jsr 	EXPEvalNumber 				; work out the while test.
.3efe	20 9e 49	jsr $499e			jsr 	IFloatCheckZero 			; check if zero
.3f01	f0 0e		beq $3f11			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.3f03	98		tya				tya 								; position *after* test.
.3f04	7a		ply				ply 								; restore position before test, at WHILE
.3f05	88		dey				dey 								; so we execute the WHILE command again.
.3f06	48		pha				pha 								; push after test on the stack
.3f07	a9 12		lda #$12			lda 	#STK_WHILE 					; open while frame
.3f09	20 bd 40	jsr $40bd			jsr 	StackOpen
.3f0c	20 f1 40	jsr $40f1			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.3f0f	7a		ply				ply 								; restore the position *after* the test
.3f10	60		rts				rts
.3f11					_WHExitLoop:
.3f11	68		pla				pla 								; throw post loop position
.3f12	a9 83		lda #$83			lda 	#PR_WEND 					; scan forward past WEND
.3f14	aa		tax				tax
.3f15	20 37 3e	jsr $3e37			jsr 	ScanForward
.3f18	60		rts				rts
.3f19					Command_WEND:
.3f19	a9 12		lda #$12			lda 	#STK_WHILE 					; check WHILE is TOS e.g. in a while loop :)
.3f1b	20 e9 40	jsr $40e9			jsr 	StackCheckFrame
.3f1e	20 03 41	jsr $4103			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.3f21	20 db 40	jsr $40db			jsr 	StackClose		 			; erase the frame
.3f24	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/support/errors/generated/errors.asm

.3f25					ErrorV_syntax:
.3f25	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3f28	53 79 6e 74 61 78 20 45			.text	"Syntax Error",0
>3f30	72 72 6f 72 00
.3f35					ErrorV_range:
.3f35	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3f38	4f 75 74 20 4f 66 20 52			.text	"Out Of Range",0
>3f40	61 6e 67 65 00
.3f45					ErrorV_value:
.3f45	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3f48	42 61 64 20 56 61 6c 75			.text	"Bad Value",0
>3f50	65 00
.3f52					ErrorV_type:
.3f52	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3f55	54 79 70 65 20 4d 69 73			.text	"Type Mismatch",0
>3f5d	6d 61 74 63 68 00
.3f63					ErrorV_unimplemented:
.3f63	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3f66	4e 6f 74 20 49 6d 70 6c			.text	"Not Implemented",0
>3f6e	65 6d 65 6e 74 65 64 00
.3f76					ErrorV_assert:
.3f76	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3f79	41 73 73 65 72 74 20 46			.text	"Assert Fail",0
>3f81	61 69 6c 00
.3f85					ErrorV_internal:
.3f85	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3f88	49 6e 74 65 72 6e 61 6c			.text	"Internal Error",0
>3f90	20 45 72 72 6f 72 00
.3f97					ErrorV_divzero:
.3f97	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3f9a	44 69 76 69 64 65 20 42			.text	"Divide By Zero",0
>3fa2	79 20 5a 65 72 6f 00
.3fa9					ErrorV_structure:
.3fa9	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3fac	53 74 72 75 63 74 75 72			.text	"Structure Imbalance",0
>3fb4	65 20 49 6d 62 61 6c 61 6e 63 65 00
.3fc0					ErrorV_stop:
.3fc0	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3fc3	50 72 6f 67 72 61 6d 20			.text	"Program Stopped",0
>3fcb	53 74 6f 70 70 65 64 00
.3fd3					ErrorV_data:
.3fd3	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3fd6	4f 75 74 20 4f 66 20 44			.text	"Out Of Data",0
>3fde	61 74 61 00
.3fe2					ErrorV_redefine:
.3fe2	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3fe5	41 72 72 61 79 20 52 65			.text	"Array Redefined",0
>3fed	64 65 66 69 6e 65 64 00
.3ff5					ErrorV_index:
.3ff5	20 87 4a	jsr $4a87		jsr	ErrorHandler
>3ff8	42 61 64 20 41 72 72 61			.text	"Bad Array Index",0
>4000	79 20 49 6e 64 65 78 00
.4008					ErrorV_memory:
.4008	20 87 4a	jsr $4a87		jsr	ErrorHandler
>400b	4f 75 74 20 4f 66 20 4d			.text	"Out Of Memory",0
>4013	65 6d 6f 72 79 00
.4019					ErrorV_uninitialised:
.4019	20 87 4a	jsr $4a87		jsr	ErrorHandler
>401c	56 61 72 69 61 62 6c 65			.text	"Variable Uninitialised",0
>4024	20 55 6e 69 6e 69 74 69 61 6c 69 73 65 64 00
.4033					ErrorV_string:
.4033	20 87 4a	jsr $4a87		jsr	ErrorHandler
>4036	42 61 64 20 53 74 72 69			.text	"Bad String Length",0
>403e	6e 67 20 4c 65 6e 67 74 68 00
.4048					ErrorV_variable:
.4048	20 87 4a	jsr $4a87		jsr	ErrorHandler
>404b	56 61 72 69 61 62 6c 65			.text	"Variable Missing",0
>4053	20 4d 69 73 73 69 6e 67 00
.405c					ErrorV_stack:
.405c	20 87 4a	jsr $4a87		jsr	ErrorHandler
>405f	53 74 61 63 6b 20 46 75			.text	"Stack Full",0
>4067	6c 6c 00
.406a					ErrorV_dupproc:
.406a	20 87 4a	jsr $4a87		jsr	ErrorHandler
>406d	50 72 6f 63 65 64 75 72			.text	"Procedure Identifier Used",0
>4075	65 20 49 64 65 6e 74 69 66 69 65 72 20 55 73 65
>4085	64 00
.4087					ErrorV_unknown:
.4087	20 87 4a	jsr $4a87		jsr	ErrorHandler
>408a	55 6e 6b 6e 6f 77 6e 20			.text	"Unknown Procedure",0
>4092	50 72 6f 63 65 64 75 72 65 00

;******  Return to file: include.files


;******  Processing file: src/support/errors/syntax.asm

.409c					ERRCheckLParen:
.409c	b1 1c		lda ($1c),y			lda 	(codePtr),y
.409e	c9 eb		cmp #$eb			cmp 	#PR_LPAREN
.40a0	d0 18		bne $40ba			bne 	ERRSyntaxError
.40a2	c8		iny				iny
.40a3	60		rts				rts
.40a4					ERRCheckRParen:
.40a4	b1 1c		lda ($1c),y			lda 	(codePtr),y
.40a6	c9 9d		cmp #$9d			cmp 	#PR_RPAREN
.40a8	d0 10		bne $40ba			bne 	ERRSyntaxError
.40aa	c8		iny				iny
.40ab	60		rts				rts
.40ac					ERRCheckComma:
.40ac	b1 1c		lda ($1c),y			lda 	(codePtr),y
.40ae	c9 99		cmp #$99			cmp 	#PR_COMMA
.40b0	d0 08		bne $40ba			bne 	ERRSyntaxError
.40b2	c8		iny				iny
.40b3	60		rts				rts
.40b4					ERRCheckA:
.40b4	d1 1c		cmp ($1c),y			cmp 	(codePtr),y
.40b6	d0 02		bne $40ba			bne 	ERRSyntaxError
.40b8	c8		iny				iny
.40b9	60		rts				rts
.40ba					ERRSyntaxError:
.40ba	4c 25 3f	jmp $3f25		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/support/stack/frames.asm

.40bd					StackOpen:
.40bd	48		pha				pha 								; save frame byte
.40be	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.40c0	0a		asl a				asl 	a 							; claim twice this for storage
.40c1	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.40c3	38		sec				sec 								; so basically subtracting from
.40c4	65 26		adc $26				adc 	basicStack 	 				; basicStack
.40c6	85 26		sta $26				sta 	basicStack
.40c8	b0 0a		bcs $40d4			bcs 	_SONoBorrow
>40ca	db						.byte 	$DB
.40cb	c6 27		dec $27				dec 	basicStack+1
.40cd	a5 27		lda $27				lda 	basicStack+1 				; reached the bottom ?
.40cf	cd 16 06	cmp $0616			cmp 	basicStackEnd
.40d2	f0 04		beq $40d8			beq 	_SOMemory
.40d4					_SONoBorrow:
.40d4	68		pla				pla 								; get marker back and write at TOS
.40d5	92 26		sta ($26)			sta 	(basicStack)
.40d7	60		rts				rts
.40d8					_SOMemory:
.40d8	4c 5c 40	jmp $405c		jmp	ErrorV_stack
.40db					StackClose:
.40db	b2 26		lda ($26)			lda 	(basicStack) 				; get TOS marker
.40dd	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.40df	0a		asl a				asl 	a 							; claim twice this.
.40e0	65 26		adc $26				adc 	basicStack 					; add to the stack pointer.
.40e2	85 26		sta $26				sta 	basicStack
.40e4	90 02		bcc $40e8			bcc 	_SCExit
.40e6	e6 27		inc $27				inc 	basicStack+1
.40e8					_SCExit:
.40e8	60		rts				rts
.40e9					StackCheckFrame:
.40e9	d2 26		cmp ($26)			cmp		(basicStack) 				; check  frames match
.40eb	d0 01		bne $40ee			bne 	_SCFError 					; different, we have structures mixed up
.40ed	60		rts				rts
.40ee					_SCFError:
.40ee	4c a9 3f	jmp $3fa9		jmp	ErrorV_structure

;******  Return to file: include.files


;******  Processing file: src/support/stack/location.asm

.40f1					STKSaveCodePosition:
.40f1	5a		phy				phy
.40f2	98		tya				tya 								; save Y at offset 1.
.40f3	a0 01		ldy #$01			ldy 	#1
.40f5	91 26		sta ($26),y			sta 	(basicStack),y
.40f7	a5 1c		lda $1c				lda 	codePtr 					; save code (low) at 2
.40f9	c8		iny				iny
.40fa	91 26		sta ($26),y			sta 	(basicStack),y
.40fc	a5 1d		lda $1d				lda 	codePtr+1 					; save code (high) at 3
.40fe	c8		iny				iny
.40ff	91 26		sta ($26),y			sta 	(basicStack),y
.4101	7a		ply				ply
.4102	60		rts				rts
.4103					STKLoadCodePosition:
.4103	a0 03		ldy #$03			ldy 	#3 							; load code pointer back
.4105	b1 26		lda ($26),y			lda 	(basicStack),y
.4107	85 1d		sta $1d				sta 	codePtr+1
.4109	88		dey				dey
.410a	b1 26		lda ($26),y			lda 	(basicStack),y
.410c	85 1c		sta $1c				sta 	codePtr
.410e	88		dey				dey
.410f	b1 26		lda ($26),y			lda 	(basicStack),y 				; line offset to Y
.4111	a8		tay				tay
.4112	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/support/stack/setup.asm

.4113					StackReset:
.4113	48		pha				pha 								; save top of memory
.4114	3a		dec a				dec 	a  							; end of stack = previous byte
.4115	85 27		sta $27				sta 	basicStack+1
.4117	a9 ff		lda #$ff			lda 	#$FF
.4119	85 26		sta $26				sta 	basicStack
.411b	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.411d	92 26		sta ($26)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.411f	68		pla				pla 								; allocate pages for stack.
.4120	38		sec				sec
.4121	e9 02		sbc #$02			sbc 	#STACKPAGES
.4123	8d 16 06	sta $0616			sta 	basicStackEnd 				; when stack MSB hits this, it's out of memory.
.4126	60		rts				rts
.0026					basicStack:
>0026							.fill 	2
.0616					basicStackEnd:
>0616							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/support/strings/concrete.asm

.4127					StringConcrete:
.4127	5a		phy				phy 								; save position on stack
.4128	b2 0c		lda ($0c)			lda 	(IFR0) 						; get string length
.412a	c9 fd		cmp #$fd			cmp 	#253 						; string too long - cannot concrete.
.412c	b0 41		bcs $416f			bcs 	_SALengthError
.412e	18		clc				clc 								; length of the new string
.412f	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.4131	90 02		bcc $4135			bcc 	_SAHaveLength
.4133	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.4135					_SAHaveLength:
.4135	48		pha				pha 								; save length to be allocated for concreting.
.4136	38		sec				sec
.4137	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.4139	6d 18 06	adc $0618			adc 	stringMemory
.413c	8d 18 06	sta $0618			sta 	stringMemory
.413f	85 22		sta $22				sta 	zTemp2 						; update storage address
.4141	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.4143	6d 19 06	adc $0619			adc 	stringMemory+1
.4146	8d 19 06	sta $0619			sta 	stringMemory+1
.4149	85 23		sta $23				sta 	zTemp2+1
.414b	68		pla				pla 								; save length allocated in +0
.414c	92 22		sta ($22)			sta 	(zTemp2)
.414e	a9 00		lda #$00			lda 	#0 							; clear the status byte in +1
.4150	a0 01		ldy #$01			ldy 	#1
.4152	91 22		sta ($22),y			sta 	(zTemp2),y
.4154					_SACopyNewString:
.4154	b2 0c		lda ($0c)			lda 	(IFR0) 						; copy length at +2
.4156	a0 02		ldy #$02			ldy 	#2
.4158	91 22		sta ($22),y			sta 	(zTemp2),y
.415a	aa		tax				tax 								; bytes to copy
.415b	f0 0c		beq $4169			beq 	_SACopyExit
.415d	a0 01		ldy #$01			ldy 	#1 							; first character from here
.415f					_SACopyNSLoop:
.415f	b1 0c		lda ($0c),y			lda 	(IFR0),y 					; get character from here
.4161	c8		iny				iny 								; write two on in string storage
.4162	c8		iny				iny
.4163	91 22		sta ($22),y			sta 	(zTemp2),y
.4165	88		dey				dey
.4166	ca		dex				dex									; until copied all the string lengths.
.4167	d0 f6		bne $415f			bne 	_SACopyNSLoop
.4169					_SACopyExit:
.4169	a6 23		ldx $23				ldx 	zTemp2+1 					; XA contain the concreted string.
.416b	a5 22		lda $22				lda 	zTemp2
.416d	7a		ply				ply
.416e	60		rts				rts
.416f					_SALengthError:
.416f	4c 33 40	jmp $4033		jmp	ErrorV_string

;******  Return to file: include.files


;******  Processing file: src/support/strings/stringalloc.asm

.4172					StringSystemInitialise:
.4172	3a		dec a				dec 	a 							; make last byte of previous page.
.4173	8d 19 06	sta $0619			sta 	stringMemory+1
.4176	85 1f		sta $1f				sta 	zTemp0+1
.4178	a9 ff		lda #$ff			lda 	#$FF
.417a	8d 18 06	sta $0618			sta 	stringMemory
.417d	85 1e		sta $1e				sta 	zTemp0
.417f	a9 00		lda #$00			lda 	#0 							; put a zero at the end, so know end of string memory.
.4181	92 1e		sta ($1e)			sta 	(zTemp0)
.4183	60		rts				rts
.4184					StringSpaceInitialise:
.4184	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.4186	8d 17 06	sta $0617			sta 	stringInitialised
.4189	ad 18 06	lda $0618			lda 	stringMemory 				; allocate 256 bytes for one concreted string
.418c	8d 1a 06	sta $061a			sta 	stringTempPointer 			; so temporary string space is allocated below that.
.418f	ad 19 06	lda $0619			lda 	stringMemory+1
.4192	3a		dec a				dec 	a
.4193	8d 1b 06	sta $061b			sta 	stringTempPointer+1
.4196	20 ec 2c	jsr $2cec			jsr 	ClearCheckMemory
.4199	60		rts				rts
.419a					StringTempAllocate:
.419a	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.419c	b0 2e		bcs $41cc			bcs 	_STALength
.419e	2c 17 06	bit $0617			bit 	stringInitialised 			; already initialised
.41a1	30 05		bmi $41a8			bmi 	_STAAllocate
.41a3	48		pha				pha 								; save value to subtract.
.41a4	20 84 41	jsr $4184			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.41a7	68		pla				pla 								; restore it
.41a8					_STAAllocate:
.41a8	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.41aa	18		clc				clc  								; deliberate allows one more
.41ab	6d 1a 06	adc $061a			adc 	stringTempPointer 			; subtract from temp pointer
.41ae	8d 1a 06	sta $061a			sta 	stringTempPointer
.41b1	85 0c		sta $0c				sta 	IFR0+IM0 					; address in mantissa too
.41b3	85 28		sta $28				sta 	zsTemp 						; and zsTemp
.41b5	ad 1b 06	lda $061b			lda 	stringTempPointer+1
.41b8	69 ff		adc #$ff			adc 	#$FF
.41ba	8d 1b 06	sta $061b			sta 	stringTempPointer+1
.41bd	85 29		sta $29				sta 	zsTemp+1
.41bf	85 0d		sta $0d				sta 	IFR0+IM1
.41c1	64 0e		stz $0e				stz 	IFR0+IM2 					; set the typing data and the upper address bytes.
.41c3	a9 80		lda #$80			lda 	#$80
.41c5	85 0f		sta $0f				sta 	IFR0+IExp
.41c7	a9 00		lda #$00			lda 	#0 							; clear the target string
.41c9	92 28		sta ($28)			sta 	(zsTemp)
.41cb	60		rts				rts
.41cc					_STALength:
.41cc	4c 33 40	jmp $4033		jmp	ErrorV_string
.41cf					StringTempWrite:
.41cf	5a		phy				phy
.41d0	48		pha				pha
.41d1	b2 28		lda ($28)			lda 	(zsTemp)
.41d3	1a		inc a				inc 	a
.41d4	92 28		sta ($28)			sta 	(zsTemp)
.41d6	a8		tay				tay
.41d7	68		pla				pla
.41d8	91 28		sta ($28),y			sta 	(zsTemp),y
.41da	7a		ply				ply
.41db	60		rts				rts
.0028					zsTemp:
>0028							.fill 	2
.0617					stringInitialised:
>0617							.fill 	1
.0618					stringMemory:
>0618							.fill 	2
.061a					stringTempPointer:
>061a							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/variables/array.asm

.41dc					VARArrayLookup:
.41dc	85 1e		sta $1e				sta 	zTemp0 						; save the array address pointer in zTemp0
.41de	86 1f		stx $1f				stx 	zTemp0+1
.41e0	b2 1e		lda ($1e)			lda 	(zTemp0)
.41e2	48		pha				pha
.41e3	5a		phy				phy
.41e4	a0 01		ldy #$01			ldy 	#1
.41e6	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.41e8	7a		ply				ply
.41e9	48		pha				pha
.41ea	20 6c 31	jsr $316c			jsr 	EXPEvalInteger16 			; R0 now contains the index
.41ed	68		pla				pla 								; array address to zTemp0
.41ee	85 1f		sta $1f				sta 	zTemp0+1
.41f0	68		pla				pla
.41f1	85 1e		sta $1e				sta 	zTemp0
.41f3	5a		phy				phy 								; save codePtr position.
.41f4	a0 01		ldy #$01			ldy 	#1 							; get 14-8 of size.
.41f6	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.41f8	48		pha				pha 								; save bit 15 on stack.
.41f9	29 7f		and #$7f			and 	#$7F
.41fb	85 20		sta $20				sta 	zTemp1
.41fd	a5 0c		lda $0c				lda 	IFR0+IM0 					; check range of index
.41ff	d2 1e		cmp ($1e)			cmp 	(zTemp0)
.4201	a5 0d		lda $0d				lda 	IFR0+IM1
.4203	e5 20		sbc $20				sbc 	zTemp1
.4205	b0 3a		bcs $4241			bcs 	_VALIndex
.4207	a5 0d		lda $0d				lda 	IFR0+IM1  					; sanity check
.4209	c9 40		cmp #$40			cmp 	#$40
.420b	b0 34		bcs $4241			bcs 	_VALIndex
.420d	06 0c		asl $0c				asl 	IFR0+IM0 					; index x 2 (has sub arrays) x 4 (is data)
.420f	26 0d		rol $0d				rol 	IFR0+IM1
.4211	fa		plx				plx 								; get msb of size -> X
.4212	30 04		bmi $4218			bmi 	_VARNotX4 					; if bit 15 set its an array of pointers so x 2
.4214	06 0c		asl $0c				asl 	IFR0+IM0
.4216	26 0d		rol $0d				rol 	IFR0+IM1
.4218					_VARNotX4:
.4218	18		clc				clc 								; add the two for the size bytes
.4219	a5 0c		lda $0c				lda 	IFR0+IM0
.421b	69 02		adc #$02			adc 	#2
.421d	85 0c		sta $0c				sta 	IFR0+IM0
.421f	90 02		bcc $4223			bcc 	_VARNoCarry1
.4221	e6 0d		inc $0d				inc 	IFR0+IM1
.4223					_VARNoCarry1:
.4223	18		clc				clc 								; calculate the element address and push to stack.
.4224	a5 0c		lda $0c				lda 	IFR0+IM0
.4226	65 1e		adc $1e				adc 	zTemp0
.4228	48		pha				pha
.4229	a5 0d		lda $0d				lda 	IFR0+IM1
.422b	65 1f		adc $1f				adc 	zTemp0+1
.422d	e0 00		cpx #$00			cpx 	#0 							; do we have a sub level ?
.422f	30 04		bmi $4235			bmi 	_VARHasSubLevel
.4231	aa		tax				tax 								; address in XA
.4232	68		pla				pla
.4233	7a		ply				ply 								; restore Y and exit
.4234	60		rts				rts
.4235					_VARHasSubLevel:
.4235	aa		tax				tax 								; get link address in XA
.4236	68		pla				pla
.4237	7a		ply				ply 								; restore code position.
.4238	48		pha				pha
.4239	20 ac 40	jsr $40ac			jsr 	ERRCheckComma 				; comma required.
.423c	68		pla				pla
.423d	20 dc 41	jsr $41dc			jsr 	VARArrayLookup 				; call it recursively
.4240	60		rts				rts
.4241					_VALIndex:
.4241	4c f5 3f	jmp $3ff5		jmp	ErrorV_index

;******  Return to file: include.files


;******  Processing file: src/variables/create.asm

.4244					VARCreate:
.4244	5a		phy				phy
.4245	a9 09		lda #$09			lda 	#9 							; create 9 bytes of space
.4247	a2 00		ldx #$00			ldx 	#0
.4249	20 c3 2c	jsr $2cc3			jsr 	AllocateMemory
.424c	85 20		sta $20				sta 	zTemp1 						; save new address in zTemp1
.424e	86 21		stx $21				stx 	zTemp1+1
.4250	a0 02		ldy #$02			ldy 	#2 							; put hash into +2
.4252	ad 1e 06	lda $061e			lda 	VARHash
.4255	91 20		sta ($20),y			sta 	(zTemp1),y
.4257	c8		iny				iny 								; put address of name into +3,+4
.4258	ad 1c 06	lda $061c			lda 	VARNameAddress
.425b	91 20		sta ($20),y			sta 	(zTemp1),y
.425d	c8		iny				iny
.425e	ad 1d 06	lda $061d			lda 	VARNameAddress+1
.4261	91 20		sta ($20),y			sta 	(zTemp1),y
.4263	ad 1f 06	lda $061f			lda 	VARType
.4266	29 01		and #$01			and 	#1
.4268	f0 06		beq $4270			beq 	_CVNotString
.426a	a0 08		ldy #$08			ldy 	#5+3
.426c	a9 80		lda #$80			lda 	#$80
.426e	91 20		sta ($20),y			sta 	(zTemp1),y
.4270					_CVNotString:
.4270	ad 40 06	lda $0640			lda 	VARHashEntry 				; hash table ptr -> zTemp0
.4273	85 1e		sta $1e				sta 	zTemp0
.4275	ad 41 06	lda $0641			lda 	VARHashEntry+1
.4278	85 1f		sta $1f				sta 	zTemp0+1
.427a	a0 01		ldy #$01			ldy 	#1 							; put current head into link.
.427c	b2 1e		lda ($1e)			lda 	(zTemp0)
.427e	92 20		sta ($20)			sta 	(zTemp1)
.4280	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.4282	91 20		sta ($20),y			sta 	(zTemp1),y
.4284	a5 20		lda $20				lda 	zTemp1 						; address of the new record into head
.4286	92 1e		sta ($1e)			sta 	(zTemp0)
.4288	a5 21		lda $21				lda 	zTemp1+1
.428a	91 1e		sta ($1e),y			sta 	(zTemp0),y
.428c	a5 20		lda $20				lda 	zTemp1 						; new record to XA
.428e	a6 21		ldx $21				ldx 	zTemp1+1
.4290	18		clc				clc 								; add 5 to point to the data.
.4291	69 05		adc #$05			adc 	#5
.4293	90 01		bcc $4296			bcc 	_VCNoCarry
.4295	e8		inx				inx
.4296					_VCNoCarry:
.4296	7a		ply				ply
.4297	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/variables/find.asm

.4298					VARFind:
.4298	5a		phy				phy
.4299	a0 01		ldy #$01			ldy 	#1 							; get first link -> zTemp1
.429b	b1 1e		lda ($1e),y			lda 	(zTemp0),y
.429d	85 21		sta $21				sta 	zTemp1+1
.429f	f0 1c		beq $42bd			beq 	_VFExitFail 				; first link is 00xx, so nothing in that list.
.42a1	b2 1e		lda ($1e)			lda 	(zTemp0)
.42a3	85 20		sta $20				sta 	zTemp1
.42a5					_VFLoop:
.42a5	a0 02		ldy #$02			ldy 	#2 							; check hashes match
.42a7	b1 20		lda ($20),y			lda 	(zTemp1),y
.42a9	cd 1e 06	cmp $061e			cmp 	VARHash
.42ac	f0 12		beq $42c0			beq 	_VFHashesMatch 				; if so, check the name.
.42ae					_VFNext:
.42ae	b2 20		lda ($20)			lda 	(zTemp1) 					; next link to AX
.42b0	aa		tax				tax
.42b1	a0 01		ldy #$01			ldy 	#1
.42b3	b1 20		lda ($20),y			lda 	(zTemp1),y
.42b5	85 21		sta $21				sta 	zTemp1+1
.42b7	86 20		stx $20				stx 	zTemp1
.42b9	c9 00		cmp #$00			cmp 	#0 							; if msb non zero, try again
.42bb	d0 e8		bne $42a5			bne 	_VFLoop
.42bd					_VFExitFail:
.42bd	7a		ply				ply
.42be	18		clc				clc
.42bf	60		rts				rts
.42c0					_VFHashesMatch:
.42c0	a0 03		ldy #$03			ldy 	#3 							; get address of name -> zTemp2
.42c2	b1 20		lda ($20),y			lda 	(zTemp1),y
.42c4	85 22		sta $22				sta 	zTemp2
.42c6	c8		iny				iny
.42c7	b1 20		lda ($20),y			lda 	(zTemp1),y
.42c9	85 23		sta $23				sta 	zTemp2+1
.42cb	a0 ff		ldy #$ff			ldy 	#$FF 						; now compare
.42cd					_VFNameCompLoop:
.42cd	c8		iny				iny 								; char at a time
.42ce	b9 20 06	lda $0620,y			lda 	VARBuffer,y
.42d1	d1 22		cmp ($22),y			cmp 	(zTemp2),y
.42d3	d0 d9		bne $42ae			bne 	_VFNext						; next entry if different.
.42d5	c9 7c		cmp #$7c			cmp 	#$7C
.42d7	90 f4		bcc $42cd			bcc 	_VFNameCompLoop 			; until done the whole lot.
.42d9	18		clc				clc
.42da	a5 20		lda $20				lda 	zTemp1
.42dc	a6 21		ldx $21				ldx 	zTemp1+1
.42de	69 05		adc #$05			adc 	#5
.42e0	90 01		bcc $42e3			bcc 	_VFNNoCarry
.42e2	e8		inx				inx
.42e3					_VFNNoCarry:
.42e3	7a		ply				ply
.42e4	38		sec				sec
.42e5	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/variables/info.asm

.42e6					VARGetInfo:
.42e6	98		tya				tya 								; calculate the address of the identifier start.
.42e7	18		clc				clc
.42e8	65 1c		adc $1c				adc 	codePtr
.42ea	8d 1c 06	sta $061c			sta 	VARNameAddress
.42ed	a5 1d		lda $1d				lda 	codePtr+1
.42ef	69 00		adc #$00			adc 	#0
.42f1	8d 1d 06	sta $061d			sta 	VARNameAddress+1
.42f4	9c 1e 06	stz $061e			stz 	VARHash
.42f7	a2 00		ldx #$00			ldx 	#0
.42f9					_VARCopyName:
.42f9	18		clc				clc 								; update the sum hash.
.42fa	ad 1e 06	lda $061e			lda 	VARHash
.42fd	71 1c		adc ($1c),y			adc 	(codePtr),y
.42ff	8d 1e 06	sta $061e			sta 	VARHash
.4302	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get character and save it in buffer
.4304	c8		iny				iny
.4305	9d 20 06	sta $0620,x			sta 	VARBuffer,x
.4308	e8		inx				inx
.4309	c9 7c		cmp #$7c			cmp 	#$7C 						; until copied the type byte
.430b	90 ec		bcc $42f9			bcc 	_VARCopyName
.430d	8d 1f 06	sta $061f			sta 	VARType 					; save type byte
.4310	29 03		and #$03			and 	#3 							; type is 0-3
.4312	0a		asl a				asl 	a
.4313	0a		asl a				asl 	a
.4314	85 1e		sta $1e				sta 	zTemp0
.4316	ad 1e 06	lda $061e			lda 	VARHash 					; force into range of hash entries per type.
.4319	29 03		and #$03			and		#(VARHashEntriesPerType-1)
.431b	65 1e		adc $1e				adc 	zTemp0 						; index of hash table
.431d	0a		asl a				asl 	a 							; offset as 2 bytes / word.
.431e	69 42		adc #$42			adc 	#VARHashTables & $FF 		; address of hash table start to zTemp0 & VARHashEntry
.4320	85 1e		sta $1e				sta 	zTemp0
.4322	8d 40 06	sta $0640			sta 	VARHashEntry
.4325	a9 06		lda #$06			lda 	#VARHashTables >> 8
.4327	69 00		adc #$00			adc 	#0
.4329	85 1f		sta $1f				sta 	zTemp0+1
.432b	8d 41 06	sta $0641			sta 	VARHashEntry+1
.432e	60		rts				rts
.432f					VARClearHashTables:
.432f	a2 00		ldx #$00			ldx 	#0
.4331					_VCHRLoop:
.4331	a9 00		lda #$00			lda 	#0
.4333	9d 42 06	sta $0642,x			sta 	VARHashTables,x
.4336	e8		inx				inx
.4337	e0 20		cpx #$20			cpx 	#VARHashEntriesPerType*4*2
.4339	d0 f6		bne $4331			bne 	_VCHRLoop
.433b	60		rts				rts
.061c					VARNameAddress:
>061c							.fill 	2
.061e					VARHash:
>061e							.fill 	1
.061f					VARType:
>061f							.fill 	1
.0620					VARBuffer:
>0620							.fill 	32
.0640					VARHashEntry:
>0640							.fill 	2
=4					VARHashEntriesPerType = 4 					; hash entries for each of the 4 types.
.0642					VARHashTables:
>0642							.fill 	VARHashEntriesPerType*4*2

;******  Return to file: include.files


;******  Processing file: src/variables/variables.asm

.433c					VARCheckSimple:
.433c	aa		tax				tax 								; save in X
.433d	b1 1c		lda ($1c),y			lda 	(codePtr),y
.433f	c9 7c		cmp #$7c			cmp 	#$7C
.4341	d0 15		bne $4358			bne 	_VCSComplex
.4343	c8		iny				iny 								; consume the second byte, the type.
.4344	8a		txa				txa  								; character (40-7F) x 4
.4345	0a		asl a				asl 	a
.4346	0a		asl a				asl  	a
.4347	18		clc				clc
.4348	69 62		adc #$62			adc 	#FastVariables & $FF
.434a	85 0c		sta $0c				sta 	IFR0+IM0
.434c	a9 06		lda #$06			lda 	#FastVariables >> 8
.434e	69 00		adc #$00			adc 	#0
.4350	85 0d		sta $0d				sta 	IFR0+IM1
.4352	64 0e		stz $0e				stz 	IFR0+IM2
.4354	64 0f		stz $0f				stz 	IFR0+IExp
.4356	38		sec				sec 								; it's a reference
.4357	60		rts				rts
.4358					_VCSComplex:
.4358	88		dey				dey	 								; extract information.
.4359	20 e6 42	jsr $42e6			jsr 	VARGetInfo
.435c	20 98 42	jsr $4298			jsr 	VARFind 					; search for variable
.435f	b0 0a		bcs $436b			bcs 	_VCSHaveVariable
.4361	ad 1f 06	lda $061f			lda 	VARType 					; error if arrays, cannot autocreate
.4364	29 02		and #$02			and 	#2
.4366	d0 25		bne $438d			bne 	_VCNoCreate
.4368	20 44 42	jsr $4244			jsr 	VARCreate 					; create variable
.436b					_VCSHaveVariable:
.436b	48		pha				pha 								; save LSB on the stack
.436c	ad 1f 06	lda $061f			lda 	VARType 					; get var type, and shift bit 1 into carry
.436f	6a		ror a				ror 	a
.4370	6a		ror a				ror 	a
.4371	68		pla				pla 								; restore LSB
.4372	90 08		bcc $437c			bcc 	_VCSNotArray 				; skip if not an array
.4374	20 dc 41	jsr $41dc			jsr 	VARArrayLookup 				; look for subscripts.
.4377	48		pha				pha 								; check )
.4378	20 a4 40	jsr $40a4			jsr 	ERRCheckRParen
.437b	68		pla				pla
.437c					_VCSNotArray:
.437c	86 0d		stx $0d				stx 	IFR0+IM1 					; save address
.437e	85 0c		sta $0c				sta 	IFR0+IM0
.4380	64 0e		stz $0e				stz 	IFR0+IM2 					; clear the unused byte.
.4382	ad 1f 06	lda $061f			lda 	VARType 					; number/string bit into carry
.4385	6a		ror a				ror 	a
.4386	a9 00		lda #$00			lda 	#0
.4388	6a		ror a				ror 	a 							; now $00 or $80
.4389	85 0f		sta $0f				sta 	IFR0+IExp
.438b	38		sec				sec 								; it's a reference
.438c	60		rts				rts
.438d					_VCNoCreate:
.438d	4c 19 40	jmp $4019		jmp	ErrorV_uninitialised
.0662					FastVariables:
>0662							.fill	26*4

;******  Return to file: include.files


;******  Return to file: basic.asm


;******  Processing file: build/libmathslib.asmlib

=0					IM0 = 0
=1					IM1 = 1
=2					IM2 = 2
=3					IExp = 3
=$3f					IFXMask = $3F
=$40					IFSign = $40
.4390					IFInitialise:
.4390	9c d2 06	stz $06d2			stz 	IFStackIndex
.4393	60		rts				rts
.4394					IFloatSubtract:
.4394	da		phx				phx
.4395	a2 0c		ldx #$0c			ldx 	#IFR0
.4397	20 b0 49	jsr $49b0			jsr 	IFloatNegate 				; negate R0 and fall through to add.
.439a	fa		plx				plx
.439b					IFloatAdd:
.439b	b5 03		lda $03,x			lda 	IExp,x 						; check if both exponents are zero.
.439d	05 0f		ora $0f				ora 	IFR0+IExp
.439f	29 3f		and #$3f			and 	#IFXMask 					; if not, then we have to do the
.43a1	d0 4e		bne $43f1			bne 	_IFloatAddDecimals 			; decimal version.
.43a3					_IFAddSubMantissa:
.43a3	b5 03		lda $03,x			lda 	IExp,x 						; are the signs different ?
.43a5	45 0f		eor $0f				eor 	IFR0+IExp
.43a7	29 40		and #$40			and 	#IFSign
.43a9	d0 21		bne $43cc			bne 	_IFloatSubMantissa
.43ab	18		clc				clc 								; do the actual addition
.43ac	a5 0c		lda $0c			lda 	IFR0+IM0
.43ae	75 00		adc $00,x		adc 		IM0,x
.43b0	85 0c		sta $0c			sta 	IFR0+IM0
.43b2	a5 0d		lda $0d			lda 	IFR0+IM1
.43b4	75 01		adc $01,x		adc 		IM1,x
.43b6	85 0d		sta $0d			sta 	IFR0+IM1
.43b8	a5 0e		lda $0e			lda 	IFR0+IM2
.43ba	75 02		adc $02,x		adc 		IM2,x
.43bc	85 0e		sta $0e			sta 	IFR0+IM2
.43be	10 29		bpl $43e9			bpl 	_IFloatAddExit 				; if no carry through to bit 23, then exit.
.43c0	a2 0c		ldx #$0c			ldx 	#IFR0						; shift R0 right, divide by 2
.43c2	20 d4 49	jsr $49d4			jsr 	IFloatShiftRight
.43c5	20 fe 49	jsr $49fe			jsr 	IFloatIncExponent
.43c8	d0 1f		bne $43e9			bne 	_IFloatAddExit
.43ca	38		sec				sec 								; overflowed numerically.
.43cb	60		rts				rts
.43cc					_IFloatSubMantissa:
.43cc	38		sec				sec 								; do the subtraction R0-Rx
.43cd	a5 0c		lda $0c			lda 	IFR0+IM0
.43cf	f5 00		sbc $00,x		sbc 		IM0,x
.43d1	85 0c		sta $0c			sta 	IFR0+IM0
.43d3	a5 0d		lda $0d			lda 	IFR0+IM1
.43d5	f5 01		sbc $01,x		sbc 		IM1,x
.43d7	85 0d		sta $0d			sta 	IFR0+IM1
.43d9	a5 0e		lda $0e			lda 	IFR0+IM2
.43db	f5 02		sbc $02,x		sbc 		IM2,x
.43dd	85 0e		sta $0e			sta 	IFR0+IM2
.43df	b0 08		bcs $43e9			bcs 	_IFloatAddExit 				; no borrow so we are done.
.43e1	a2 0c		ldx #$0c			ldx 	#IFR0
.43e3	20 b8 49	jsr $49b8			jsr 	IFloatMantissaNegate 		; 2's complement negate the mantissa
.43e6	20 b0 49	jsr $49b0			jsr 	IFloatNegate 				; negate
.43e9					_IFloatAddExit:
.43e9	18		clc				clc
.43ea	60		rts				rts
.43eb					_IFloatZeroAdd:
.43eb	fa		plx				plx 								; return this value in R0
.43ec	20 36 49	jsr $4936			jsr 	IFloatCopyFromRegister
.43ef	18		clc				clc
.43f0	60		rts				rts
.43f1					_IFloatAddDecimals:
.43f1	20 9e 49	jsr $499e			jsr		IFloatCheckZero 			; if RX = 0 then exit with R0
.43f4	f0 f3		beq $43e9			beq 	_IFloatAddExit
.43f6	20 dc 49	jsr $49dc			jsr 	IFloatNormalise 			; normalise RX
.43f9	da		phx				phx 								; normalise R0
.43fa	a2 0c		ldx #$0c			ldx 	#IFR0
.43fc	20 9e 49	jsr $499e			jsr 	IFloatCheckZero
.43ff	f0 ea		beq $43eb			beq 	_IFloatZeroAdd
.4401	20 dc 49	jsr $49dc			jsr 	IFloatNormalise
.4404	fa		plx				plx
.4405	a5 0f		lda $0f				lda 	IFR0+IExp 					; get the exponent of R0
.4407	29 3f		and #$3f			and 	#IFXMask
.4409	38		sec				sec
.440a	e9 20		sbc #$20			sbc 	#$20 						; map 20..3F..00..1F to 00..0F..E0..FF e.g. scaled unsigned
.440c	85 0a		sta $0a				sta 	iTemp0
.440e	b5 03		lda $03,x			lda 	IExp,x 						; repeat for exponent of Rx
.4410	29 3f		and #$3f			and 	#IFXMask
.4412	38		sec				sec
.4413	e9 20		sbc #$20			sbc 	#$20
.4415	c5 0a		cmp $0a				cmp 	iTemp0 						; get the larger adjusted
.4417	b0 02		bcs $441b			bcs 	_IFloatHaveLarger
.4419	a5 0a		lda $0a				lda 	iTemp0
.441b					_IFloatHaveLarger:
.441b	18		clc				clc 								; get the actual one back.
.441c	69 20		adc #$20			adc 	#$20 						; shift both to that.
.441e	20 2b 44	jsr $442b			jsr 	_IFShiftXToA
.4421	da		phx				phx
.4422	a2 0c		ldx #$0c			ldx 	#IFR0
.4424	20 2b 44	jsr $442b			jsr 	_IFShiftXToA
.4427	fa		plx				plx
.4428	4c a3 43	jmp $43a3			jmp 	_IFAddSubMantissa 			; do the adding bit.
.442b					_IFShiftXToA:
.442b	8d ca 06	sta $06ca			sta 	IFTarget
.442e	20 9e 49	jsr $499e			jsr 	IFloatCheckZero 			; check adding zero ?
.4431	f0 11		beq $4444			beq 	_IFSXExit
.4433					_IFSXLoop:
.4433	b5 03		lda $03,x			lda 	IExp,x 	 					; shifted to the right level yet ?
.4435	29 3f		and #$3f			and 	#IFXMask
.4437	cd ca 06	cmp $06ca			cmp 	IFTarget
.443a	f0 08		beq $4444			beq 	_IFSXExit
.443c	20 d4 49	jsr $49d4			jsr 	IFloatShiftRight
.443f	20 fe 49	jsr $49fe			jsr 	IFloatIncExponent
.4442	80 ef		bra $4433			bra 	_IFSXLoop
.4444					_IFSXExit:
.4444	60		rts				rts
.06ca					IFTarget:
>06ca							.fill 	1
.4445					IFloatMultiply:
.4445	8e ca 06	stx $06ca			stx 	IFTarget 					; save the multiplier (RX) which is "adder"
.4448	20 00 45	jsr $4500			jsr 	IFCalculateNewSign
.444b	b5 03		lda $03,x			lda 	IExp,x 						; check two positive 8 bit integers
.444d	05 0f		ora $0f				ora 	IFR0+IExp
.444f	29 3f		and #$3f			and 	#IFXMask
.4451	15 01		ora $01,x			ora 	IM1,x
.4453	05 0d		ora $0d				ora 	IFR0+IM1
.4455	15 02		ora $02,x			ora 	IM2,x
.4457	05 0e		ora $0e				ora 	IFR0+IM2
.4459	d0 0a		bne $4465			bne 	_IFMStandard
.445b	20 81 49	jsr $4981			jsr 	IFloatMultiply8BitRx
.445e	ad cc 06	lda $06cc			lda 	IFNewSign
.4461	85 0f		sta $0f				sta 	IFR0+IExp
.4463	18		clc				clc
.4464	60		rts				rts
.4465					_IFMStandard:
.4465	b5 03		lda $03,x			lda 	IExp,x 						; add the two exponents sign extended
.4467	20 f7 44	jsr $44f7			jsr 	IFMSignExtend
.446a	8d cb 06	sta $06cb			sta 	IFNewExponent
.446d	a5 0f		lda $0f				lda 	IFR0+IExp
.446f	20 f7 44	jsr $44f7			jsr 	IFMSignExtend
.4472	18		clc				clc
.4473	6d cb 06	adc $06cb			adc 	IFNewExponent
.4476	8d cb 06	sta $06cb			sta 	IFNewExponent
.4479	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy R0 to RTemp which is "shifter"
.447b	20 47 49	jsr $4947			jsr 	IFloatCopyToRegister
.447e	a2 0c		ldx #$0c			ldx 	#IFR0 						; zero R0 (the result)
.4480	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.4483					_IFMLoop:
.4483	a2 18		ldx #$18			ldx 	#IFRTemp
.4485	20 9e 49	jsr $499e			jsr 	IFloatCheckZero
.4488	f0 3a		beq $44c4			beq 	_IFMExit
.448a	ae ca 06	ldx $06ca			ldx 	IFTarget 					; look at adder MSB
.448d	b5 02		lda $02,x			lda 	IM2,x 						; if it is set we need to shift everything
.448f	10 03		bpl $4494			bpl	 	_IFMTargetOkay
.4491	20 e8 44	jsr $44e8			jsr 	_IFMShiftAll
.4494					_IFMTargetOkay:
.4494	a5 18		lda $18				lda 	IFRTemp+0 					; is bit 0 of the shifter (RTemp) set
.4496	29 01		and #$01			and 	#1
.4498	f0 16		beq $44b0			beq 	_IFMNoAdd
.449a	ae ca 06	ldx $06ca			ldx 	IFTarget 					; add adder
.449d	18		clc				clc
.449e	a5 0c		lda $0c			lda 	IFR0+IM0
.44a0	75 00		adc $00,x		adc 		IM0,x
.44a2	85 0c		sta $0c			sta 	IFR0+IM0
.44a4	a5 0d		lda $0d			lda 	IFR0+IM1
.44a6	75 01		adc $01,x		adc 		IM1,x
.44a8	85 0d		sta $0d			sta 	IFR0+IM1
.44aa	a5 0e		lda $0e			lda 	IFR0+IM2
.44ac	75 02		adc $02,x		adc 		IM2,x
.44ae	85 0e		sta $0e			sta 	IFR0+IM2
.44b0					_IFMNoAdd:
.44b0	a5 0e		lda $0e				lda 	IFR0+IM2
.44b2	10 03		bpl $44b7			bpl 	_IFMResultOkay
.44b4	20 e8 44	jsr $44e8			jsr 	_IFMShiftAll
.44b7					_IFMResultOkay:
.44b7	a2 18		ldx #$18			ldx 	#IFRTemp
.44b9	20 d4 49	jsr $49d4			jsr 	IFloatShiftRight
.44bc	ae ca 06	ldx $06ca			ldx 	IFTarget
.44bf	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.44c2	80 bf		bra $4483			bra 	_IFMLoop
.44c4					_IFMExit:
.44c4	ad cb 06	lda $06cb			lda 	IFNewExponent 				; validate new exponent.
.44c7	c9 20		cmp #$20			cmp 	#$20 						; valid exponent 00-1F E0-FF
.44c9	90 0f		bcc $44da			bcc 	_IFMOkay
.44cb	c9 e0		cmp #$e0			cmp 	#$E0
.44cd	b0 0b		bcs $44da			bcs 	_IFMOkay
.44cf	29 80		and #$80			and 	#$80 						; if +ve exponent then error overflow.
.44d1	f0 13		beq $44e6			beq 	_IFMError
.44d3	a2 0c		ldx #$0c			ldx 	#IFR0 						; return zero underflow
.44d5	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.44d8	18		clc				clc
.44d9	60		rts				rts
.44da					_IFMOkay:
.44da	29 3f		and #$3f			and 	#IFXMask 					; work out exponent + sign and exit
.44dc	0d cc 06	ora $06cc			ora 	IFNewSign
.44df	85 0f		sta $0f				sta 	IFR0+IExp
.44e1	18		clc				clc
.44e2	60		rts				rts
.44e3	4c ff ff	jmp $ffff			jmp 	$FFFF
.44e6					_IFMError:
.44e6	38		sec				sec
.44e7	60		rts				rts
.44e8					_IFMShiftAll:
.44e8	a2 0c		ldx #$0c			ldx 	#IFR0
.44ea	20 d4 49	jsr $49d4			jsr 	IFloatShiftRight
.44ed	ae ca 06	ldx $06ca			ldx 	IFTarget
.44f0	20 d4 49	jsr $49d4			jsr 	IFloatShiftRight
.44f3	ee cb 06	inc $06cb			inc 	IFNewExponent
.44f6	60		rts				rts
.44f7					IFMSignExtend:
.44f7	29 3f		and #$3f			and 	#IFXMask
.44f9	c9 1f		cmp #$1f			cmp 	#(IFXMask >> 1)
.44fb	90 02		bcc $44ff			bcc 	_IFMNoSXX
.44fd	09 c0		ora #$c0			ora 	#IFXMask ^ $FF
.44ff					_IFMNoSXX:
.44ff	60		rts				rts
.4500					IFCalculateNewSign:
.4500	b5 03		lda $03,x			lda 	IExp,x
.4502	45 0f		eor $0f				eor 	IFR0+IExp
.4504	29 40		and #$40			and 	#IFSign
.4506	8d cc 06	sta $06cc			sta 	IFNewSign
.4509	60		rts				rts
.06cb					IFNewExponent:
>06cb							.fill 	1
.06cc					IFNewSign:
>06cc							.fill 	1
.450a					IFloatDivideInteger:
.450a	20 23 45	jsr $4523			jsr 	IFloatDivideIntegerCommon 	; do the common code.
.450d	b0 06		bcs $4515			bcs 	_IFDIExit
.450f	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy result from register.
.4511	20 36 49	jsr $4936			jsr 	IFloatCopyFromRegister
.4514	18		clc				clc
.4515					_IFDIExit:
.4515	60		rts				rts
.4516					IFloatModulusInteger:
.4516	20 23 45	jsr $4523			jsr 	IFloatDivideIntegerCommon
.4519	b0 07		bcs $4522			bcs 	_IFMIExit
.451b	ae ca 06	ldx $06ca			ldx 	IFTarget
.451e	20 36 49	jsr $4936			jsr 	IFloatCopyFromRegister
.4521	18		clc				clc
.4522					_IFMIExit:
.4522	60		rts				rts
.4523					IFloatDivideIntegerCommon:
.4523	8e ca 06	stx $06ca			stx 	IFTarget  					; this is s1, s0 = R0
.4526	20 00 45	jsr $4500			jsr 	IFCalculateNewSign 			; calculate sign of result
.4529	20 51 45	jsr $4551			jsr 	IFDCopyRXToRTemp 			; copy S1 to RTemp
.452c	a2 0c		ldx #$0c			ldx 	#IFR0 						; check divide by zero
.452e	20 9e 49	jsr $499e			jsr 	IFloatCheckZero
.4531	f0 1c		beq $454f			beq 	_IFDIDivZero
.4533	ae ca 06	ldx $06ca			ldx 	IFTarget 					; zero Rx (S1)
.4536	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.4539	5a		phy				phy
.453a	a0 18		ldy #$18			ldy 	#24
.453c					_IFDILoop:
.453c	20 62 45	jsr $4562			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.453f	20 6e 45	jsr $456e			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.4542	88		dey				dey
.4543	d0 f7		bne $453c			bne 	_IFDILoop 					; do it 24 times
.4545	7a		ply				ply
.4546	ad cc 06	lda $06cc			lda 	IFNewSign 					; set sign of result.
.4549	29 40		and #$40			and 	#IFSign
.454b	85 1b		sta $1b				sta 	IFRTemp+IExp
.454d	18		clc				clc 								; is okay.
.454e	60		rts				rts
.454f					_IFDIDivZero:
.454f	38		sec				sec
.4550	60		rts				rts
.4551					IFDCopyRXToRTemp:
.4551	b5 00		lda $00,x			lda 	IM0,x
.4553	85 18		sta $18				sta 	IFRTemp+IM0
.4555	b5 01		lda $01,x			lda 	IM1,x
.4557	85 19		sta $19				sta 	IFRTemp+IM1
.4559	b5 02		lda $02,x			lda 	IM2,x
.455b	85 1a		sta $1a				sta 	IFRTemp+IM2
.455d	b5 03		lda $03,x			lda 	IExp,x
.455f	85 1b		sta $1b				sta 	IFRTemp+IExp
.4561	60		rts				rts
.4562					IFDShiftSTempS1Left:
.4562	a2 18		ldx #$18			ldx 	#IFRTemp
.4564	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft
.4567	ae ca 06	ldx $06ca			ldx 	IFTarget
.456a	20 cd 49	jsr $49cd			jsr 	IFloatRotateLeft
.456d	60		rts				rts
.456e					IFDTrySubtract:
.456e	ae ca 06	ldx $06ca			ldx 	IFTarget 					; s1 = Rx
.4571	38		sec				sec 								; subtract, saving the results on the stack.
.4572	b5 00		lda $00,x			lda 	IM0,x
.4574	e5 0c		sbc $0c				sbc 	IFR0+IM0
.4576	48		pha				pha
.4577	b5 01		lda $01,x			lda 	IM1,x
.4579	e5 0d		sbc $0d				sbc 	IFR0+IM1
.457b	48		pha				pha
.457c	b5 02		lda $02,x			lda 	IM2,x
.457e	e5 0e		sbc $0e				sbc 	IFR0+IM2
.4580	b0 03		bcs $4585			bcs 	_IFDCanSubtract
.4582	68		pla				pla 								; cannot subtract, so pop intermediate and exit.
.4583	68		pla				pla
.4584	60		rts				rts
.4585					_IFDCanSubtract:
.4585	95 02		sta $02,x			sta 	IM2,x 						; write back to S1.Mantissa
.4587	68		pla				pla
.4588	95 01		sta $01,x			sta 	IM1,x
.458a	68		pla				pla
.458b	95 00		sta $00,x			sta 	IM0,x
.458d	e6 18		inc $18				inc 	IFRTemp+IM0 				; increment temp
.458f	d0 06		bne $4597			bne 	_IFDCSExit
.4591	e6 19		inc $19				inc 	IFRTemp+IM1
.4593	d0 02		bne $4597			bne 	_IFDCSExit
.4595	e6 1a		inc $1a				inc 	IFRTemp+IM2
.4597					_IFDCSExit:
.4597	60		rts				rts
.4598					IFloatBitwiseAnd:
.4598	5a		phy				phy
.4599	20 dd 45	jsr $45dd			jsr 	IFPreProcessBitwise 		; set up everything.
.459c	d0 0f		bne $45ad			bne 	_IFBAExit
.459e					_IFBALoop:
.459e	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.45a1	35 00		and $00,x			and 	IM0,x
.45a3	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.45a6	e8		inx				inx
.45a7	c8		iny				iny
.45a8	c0 03		cpy #$03			cpy 	#3
.45aa	d0 f2		bne $459e			bne 	_IFBALoop
.45ac	18		clc				clc
.45ad					_IFBAExit:
.45ad	7a		ply				ply
.45ae	60		rts				rts
.45af					IFloatBitwiseOr:
.45af	5a		phy				phy
.45b0	20 dd 45	jsr $45dd			jsr 	IFPreProcessBitwise 		; set up everything.
.45b3	d0 0f		bne $45c4			bne 	_IFBAExit
.45b5					_IFBALoop:
.45b5	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.45b8	15 00		ora $00,x			ora 	IM0,x
.45ba	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.45bd	e8		inx				inx
.45be	c8		iny				iny
.45bf	c0 03		cpy #$03			cpy 	#3
.45c1	d0 f2		bne $45b5			bne 	_IFBALoop
.45c3	18		clc				clc
.45c4					_IFBAExit:
.45c4	7a		ply				ply
.45c5	60		rts				rts
.45c6					IFloatBitwiseXor:
.45c6	5a		phy				phy
.45c7	20 dd 45	jsr $45dd			jsr 	IFPreProcessBitwise 		; set up everything.
.45ca	d0 0f		bne $45db			bne 	_IFBAExit
.45cc					_IFBALoop:
.45cc	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.45cf	55 00		eor $00,x			eor 	IM0,x
.45d1	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.45d4	e8		inx				inx
.45d5	c8		iny				iny
.45d6	c0 03		cpy #$03			cpy 	#3
.45d8	d0 f2		bne $45cc			bne 	_IFBALoop
.45da	18		clc				clc
.45db					_IFBAExit:
.45db	7a		ply				ply
.45dc	60		rts				rts
.45dd					IFPreProcessBitwise:
.45dd	a0 00		ldy #$00			ldy 	#0 							; set index.
.45df	a5 0f		lda $0f				lda 	IFR0+IExp 					; OR exponents
.45e1	15 03		ora $03,x			ora 	IExp,x
.45e3	74 03		stz $03,x			stz 	IExp,x 						; zero the result exponent anyway.
.45e5	29 3f		and #$3f			and 	#IFXMask 					; NZ if error e.g. not integer
.45e7	38		sec				sec 								; carry set just in cases.
.45e8	60		rts				rts
.45e9					IFloatAbsoluteR0:
.45e9	a5 0f		lda $0f				lda 	IFR0+IExp					; reset the sign bit.
.45eb	29 bf		and #$bf			and 	#IFSign ^ 255
.45ed	85 0f		sta $0f				sta 	IFR0+IExp
.45ef	18		clc				clc
.45f0	60		rts				rts
.45f1					IFloatSquareRootR0:
.45f1	a2 0c		ldx #$0c			ldx 	#IFR0 						; if zero, return zero.
.45f3	20 9e 49	jsr $499e			jsr 	IFloatCheckZero
.45f6	a5 0f		lda $0f				lda	 	IFR0+IExp 					; if negative fail.
.45f8	29 40		and #$40			and 	#IFSign
.45fa	d0 2f		bne $462b			bne 	_IFSRFail
.45fc	20 dc 49	jsr $49dc			jsr 	IFloatNormalise 			; it will work better !
.45ff	a2 10		ldx #$10			ldx 	#IFR1 						; R1 contains original throughout
.4601	20 47 49	jsr $4947			jsr 	IFloatCopyToRegister
.4604	a5 0f		lda $0f				lda 	IFR0+IExp 					; if exponent is $2A..$3F * 64 otherwise is / 64
.4606	20 f7 44	jsr $44f7			jsr 	IFMSignExtend 				; sign extended version of the exponent
.4609	18		clc				clc
.460a	69 17		adc #$17			adc 	#23 						; this makes it a 0.xxx mantissa
.460c	85 0f		sta $0f				sta 	IFR0+IExp
.460e	4a		lsr a				lsr 	a 							; which we can halve.
.460f	38		sec				sec 								; convert back
.4610	e9 17		sbc #$17			sbc 	#23
.4612	29 3f		and #$3f			and 	#IFXMask 					; make appropriate
.4614	85 0f		sta $0f				sta 	IFR0+IExp 					; to R0
.4616	20 2d 46	jsr $462d			jsr 	_IFSRNewton
.4619	20 2d 46	jsr $462d			jsr 	_IFSRNewton
.461c	20 2d 46	jsr $462d			jsr 	_IFSRNewton
.461f	20 2d 46	jsr $462d			jsr 	_IFSRNewton
.4622	18		clc				clc
.4623	60		rts				rts
.4624					_IFSRZero:
.4624	a2 0c		ldx #$0c			ldx 	#IFR0
.4626	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.4629	18		clc				clc
.462a	60		rts				rts
.462b					_IFSRFail:
.462b	38		sec				sec
.462c	60		rts				rts
.462d					_IFSRNewton:
.462d	a2 10		ldx #$10			ldx 	#IFR1 						; push original value (R3) on the stack
.462f	20 f4 48	jsr $48f4			jsr 	IFloatPushRx
.4632	a2 0c		ldx #$0c			ldx 	#IFR0 						; push current guess (R0) on the stack.
.4634	20 f4 48	jsr $48f4			jsr 	IFloatPushRx
.4637	a2 10		ldx #$10			ldx 	#IFR1 						; guess = original / guess
.4639	20 c8 46	jsr $46c8			jsr 	IFloatDivideFloat
.463c	a2 10		ldx #$10			ldx 	#IFR1 						; restore current guess (was in R0) to R3
.463e	20 15 49	jsr $4915			jsr 	IFloatPullRx
.4641	20 9b 43	jsr $439b			jsr 	IFloatAdd 					; now guess + original/guess
.4644	a2 0c		ldx #$0c			ldx 	#IFR0 						; divide by 2
.4646	20 d4 49	jsr $49d4			jsr 	IFloatShiftRight
.4649	a2 10		ldx #$10			ldx 	#IFR1
.464b	20 15 49	jsr $4915			jsr 	IFloatPullRx 				; Finally pull the oeifinal
.464e	60		rts				rts
.464f					IFloatFractionalR0:
.464f	a5 0f		lda $0f				lda 	IFR0+IExp					; is it integer already ?
.4651	29 3f		and #$3f			and 	#IFXMask
.4653	f0 17		beq $466c			beq 	_FIPZero 					; if so, return with zero as no fractional part.
.4655	20 e9 45	jsr $45e9			jsr 	IFloatAbsoluteR0 			; absolute value R9
.4658	a2 0c		ldx #$0c			ldx 	#IFR0
.465a	20 dc 49	jsr $49dc			jsr 	IFloatNormalise 			; normalise R0
.465d	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy to RTemp
.465f	20 47 49	jsr $4947			jsr 	IFloatCopyToRegister
.4662	20 a5 46	jsr $46a5			jsr 	IFloatIntegerR0 			; take integer part of R0
.4665	a2 18		ldx #$18			ldx 	#IFRTemp 					; subtract
.4667	20 94 43	jsr $4394			jsr 	IFloatSubtract
.466a	80 05		bra $4671			bra 	_FIPExit
.466c					_FIPZero:
.466c	a2 0c		ldx #$0c			ldx 	#IFR0
.466e	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.4671					_FIPExit:
.4671	18		clc				clc
.4672	60		rts				rts
.4673					IFloatCompare:
.4673	20 94 43	jsr $4394			jsr 	IFloatSubtract 				; subtract R0 from RX.
.4676	b5 03		lda $03,x			lda 	IExp,x 						; check if integer comparison
.4678	05 0f		ora $0f				ora 	IFR0+IExp
.467a	a2 0c		ldx #$0c			ldx 	#IFR0 						; only using R0 from now on.
.467c	29 3f		and #$3f			and 	#IFXMask
.467e	d0 19		bne $4699			bne 	_IFCNonInteger
.4680	20 9e 49	jsr $499e			jsr 	IFloatCheckZero 			; check if zero
.4683	f0 0f		beq $4694			beq 	_IFCZero
.4685					_IFCReturnSign:
.4685	a5 0f		lda $0f				lda 	IFR0+IExp 					; get the sign bit/unused -> stack.
.4687	29 c0		and #$c0			and 	#(IFXMask ^ $FF)
.4689	48		pha				pha
.468a	a9 01		lda #$01			lda 	#1
.468c	20 a7 49	jsr $49a7			jsr 	IFloatSetByte 				; return to +1
.468f	68		pla				pla 								; sign bit back
.4690	85 0f		sta $0f				sta 	IFR0+IExp					; set that sign
.4692	18		clc				clc
.4693	60		rts				rts
.4694					_IFCZero:
.4694	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.4697	18		clc				clc
.4698	60		rts				rts
.4699					_IFCNonInteger:
.4699	a5 0c		lda $0c				lda 	IFR0+IM0
.469b	29 00		and #$00			and		#$00
.469d	05 0d		ora $0d				ora 	IFR0+IM1
.469f	05 0e		ora $0e				ora 	IFR0+IM2
.46a1	f0 f1		beq $4694			beq 	_IFCZero 					; near enough !
.46a3	80 e0		bra $4685			bra 	_IFCReturnSign 				; return the sign of the difference.
.46a5					IFloatIntegerR0:
.46a5	a5 0f		lda $0f				lda 	IFR0+IExp					; is it integer already ?
.46a7	29 3f		and #$3f			and 	#IFXMask
.46a9	f0 1b		beq $46c6			beq 	_FIPExit 					; if so do nothing
.46ab	a2 0c		ldx #$0c			ldx 	#IFR0
.46ad	20 dc 49	jsr $49dc			jsr 	IFloatNormalise 			; normalise
.46b0	20 9e 49	jsr $499e			jsr 	IFloatCheckZero 			; is it zero ?
.46b3	f0 0e		beq $46c3			beq 	_FIPZero 					; if so return zero.
.46b5					_FIPShift:
.46b5	a5 0f		lda $0f				lda 	IFR0+IExp 					; if Exponent >= 0 exit.
.46b7	29 20		and #$20			and 	#$20 						; still -ve
.46b9	f0 0b		beq $46c6			beq 	_FIPExit
.46bb	20 d4 49	jsr $49d4			jsr 	IFloatShiftRight 			; shift mantissa right
.46be	20 fe 49	jsr $49fe			jsr 	IFloatIncExponent 			; bump exponent
.46c1	80 f2		bra $46b5			bra 	_FIPShift
.46c3					_FIPZero:
.46c3	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.46c6					_FIPExit:
.46c6	18		clc				clc
.46c7	60		rts				rts
.46c8					IFloatDivideFloat:
.46c8	8e ca 06	stx $06ca			stx 	IFTarget  					; this is s1, s0 = R0
.46cb	20 00 45	jsr $4500			jsr 	IFCalculateNewSign 			; calculate sign of result
.46ce	20 dc 49	jsr $49dc			jsr 	IFloatNormalise 			; normalise RX
.46d1	a2 0c		ldx #$0c			ldx 	#IFR0 						; normalise R0
.46d3	20 dc 49	jsr $49dc			jsr 	IFloatNormalise
.46d6	20 9e 49	jsr $499e			jsr 	IFloatCheckZero
.46d9	f0 56		beq $4731			beq 	_IFDFDivZero 				; exit if this normalised to zero.
.46db	a5 0f		lda $0f				lda 	IFR0+IExp 					; calculate s0.exponent
.46dd	20 f7 44	jsr $44f7			jsr 	IFMSignExtend
.46e0	8d cb 06	sta $06cb			sta 	IFNewExponent
.46e3	ae ca 06	ldx $06ca			ldx 	IFTarget 					; calculate s1.exponent
.46e6	b5 03		lda $03,x			lda 	IExp,x
.46e8	20 f7 44	jsr $44f7			jsr 	IFMSignExtend
.46eb	38		sec				sec
.46ec	ed cb 06	sbc $06cb			sbc 	IFNewExponent 				; s1.exponent - s0.exponent - 23
.46ef	38		sec				sec
.46f0	e9 17		sbc #$17			sbc 	#23
.46f2	8d cb 06	sta $06cb			sta 	IFNewExponent
.46f5	20 33 47	jsr $4733			jsr 	IFloatDivideSupport 		; call the support routine (see maths.py)
.46f8	a5 1a		lda $1a				lda 	IFRTemp+IM2 				; result has overflowed ?
.46fa	10 08		bpl $4704			bpl 	_IFDFNoShiftResult
.46fc	a2 18		ldx #$18			ldx 	#IFRTemp 					; if so, fix it up.
.46fe	20 d4 49	jsr $49d4			jsr 	IFloatShiftRight
.4701	ee cb 06	inc $06cb			inc 	IFNewExponent
.4704					_IFDFNoShiftResult:
.4704	ad cb 06	lda $06cb			lda 	IFNewExponent 				; underflow/overflow check.
.4707	30 06		bmi $470f			bmi 	_IFDFCheckUnderflow
.4709	c9 20		cmp #$20			cmp 	#$20 						; overflow in division
.470b	b0 24		bcs $4731			bcs 	_IFDFDivZero
.470d	80 11		bra $4720			bra		_IFDFExit
.470f					_IFDFCheckUnderflow:
.470f	ad cb 06	lda $06cb			lda 	IFNewExponent 				; shift into a legal exponent.
.4712	c9 e0		cmp #$e0			cmp 	#$E0 						; if exponent < -32.
.4714	b0 0a		bcs $4720			bcs 	_IFDFExit
.4716	ee cb 06	inc $06cb			inc 	IFNewExponent
.4719	a2 18		ldx #$18			ldx 	#IFRTemp
.471b	20 d4 49	jsr $49d4			jsr 	IFloatShiftRight
.471e	80 ef		bra $470f			bra 	_IFDFCheckUnderflow
.4720					_IFDFExit:
.4720	ad cb 06	lda $06cb			lda 	IFNewExponent 				; combine exponent and sign.
.4723	29 3f		and #$3f			and 	#IFXMask
.4725	0d cc 06	ora $06cc			ora 	IFNewSign
.4728	85 1b		sta $1b				sta 	IFRTemp+IExp
.472a	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy RTemp to R0.
.472c	20 36 49	jsr $4936			jsr 	IFloatCopyFromRegister
.472f	18		clc				clc
.4730	60		rts				rts
.4731					_IFDFDivZero:
.4731	38		sec				sec
.4732	60		rts				rts
.4733					IFloatDivideSupport:
.4733	a2 18		ldx #$18			ldx 	#IFRTemp 					; zero RTemp
.4735	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.4738	5a		phy				phy 								; main division loop x 23
.4739	a0 17		ldy #$17			ldy 	#23
.473b					_IFDSLoop:
.473b	20 6e 45	jsr $456e			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.473e	20 62 45	jsr $4562			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.4741	88		dey				dey
.4742	d0 f7		bne $473b			bne 	_IFDSLoop 					; do it 24 times
.4744	7a		ply				ply
.4745	60		rts				rts
.4746					IFloatIntegerToStringR0:
.4746	8d cd 06	sta $06cd			sta 	IFBase 						; save base to use.
.4749	20 26 4a	jsr $4a26			jsr 	IFloatBufferReset			; empty buffer
.474c	a5 0f		lda $0f				lda 	IFR0+IExp					; check integer
.474e	29 3f		and #$3f			and 	#IFXMask
.4750	d0 1e		bne $4770			bne 	_IFIFail
.4752	a2 0c		ldx #$0c			ldx 	#IFR0 						; skip - check if zero.
.4754	20 9e 49	jsr $499e			jsr 	IFloatCheckZero
.4757	f0 0e		beq $4767			beq 	_IFINotNegative
.4759	a5 0f		lda $0f				lda 	IFR0+IExp 					; is signed ?
.475b	29 40		and #$40			and 	#IFSign
.475d	f0 08		beq $4767			beq 	_IFINotNegative
.475f	a9 2d		lda #$2d			lda 	#"-"						; output -
.4761	20 35 4a	jsr $4a35			jsr 	IFloatBufferWrite
.4764	20 b0 49	jsr $49b0			jsr 	IFloatNegate 				; tidy up !
.4767					_IFINotNegative:
.4767	20 72 47	jsr $4772			jsr 	_IFIRecursiveConvert 		; start converting
.476a	20 2d 4a	jsr $4a2d			jsr 	IFloatGetBufferAddress
.476d	18		clc				clc
.476e	80 01		bra $4771			bra 	_IFIExit
.4770					_IFIFail:
.4770	38		sec				sec
.4771					_IFIExit:
.4771	60		rts				rts
.4772					_IFIRecursiveConvert:
.4772	a2 10		ldx #$10			ldx 	#IFR1
.4774	20 47 49	jsr $4947			jsr 	IFloatCopyToRegister 		; R0->R1
.4777	a2 0c		ldx #$0c			ldx 	#IFR0
.4779	ad cd 06	lda $06cd			lda 	IFBase 						; Base -> R0
.477c	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.477f	a2 10		ldx #$10			ldx 	#IFR1 						; R0 = R1 / R0
.4781	20 0a 45	jsr $450a			jsr 	IFloatDivideInteger
.4784	a2 0c		ldx #$0c			ldx 	#IFR0 						; if result <> 0
.4786	20 9e 49	jsr $499e			jsr 	IFloatCheckZero
.4789	f0 09		beq $4794			beq 	_IFIOutDigit
.478b	a5 10		lda $10				lda 	IFR1+IM0 					; save remainder
.478d	48		pha				pha
.478e	20 72 47	jsr $4772			jsr 	_IFIRecursiveConvert 		; convert the divider
.4791	68		pla				pla
.4792	85 10		sta $10				sta 	IFR1+IM0 					; restore remainder
.4794					_IFIOutDigit:
.4794	a5 10		lda $10				lda 	IFR1+IM0 					; get remainder.
.4796	c9 0a		cmp #$0a			cmp	 	#10
.4798	90 02		bcc $479c			bcc 	_IFINotHex
.479a	69 06		adc #$06			adc 	#6
.479c					_IFINotHex:
.479c	69 30		adc #$30			adc 	#48
.479e	20 35 4a	jsr $4a35			jsr 	IFloatBufferWrite
.47a1	60		rts				rts
.06cd					IFBase:
>06cd							.fill 	1
.47a2					IFloatFloatToStringR0:
.47a2	a2 14		ldx #$14			ldx 	#IFR2 						; copy R2 to stack,value to R2
.47a4	20 f4 48	jsr $48f4			jsr 	IFloatPushRx
.47a7	20 47 49	jsr $4947			jsr 	IFloatCopyToRegister
.47aa	20 a5 46	jsr $46a5			jsr 	IFloatIntegerR0				; make R0 integer
.47ad	a9 0a		lda #$0a			lda 	#10 						; base 10.
.47af	20 46 47	jsr $4746			jsr 	IFloatIntegerToStringR0 	; do the integer part.
.47b2	9c ce 06	stz $06ce			stz 	IFloatDecimalCount 			; zero the decimal count.
.47b5	a5 17		lda $17				lda 	IFR2+IExp 					; is integer.
.47b7	29 3f		and #$3f			and 	#IFXMask
.47b9	f0 44		beq $47ff			beq 	_IFFSExit
.47bb					_IFloatFracLoop:
.47bb	a2 14		ldx #$14			ldx 	#IFR2 						; R0 = fractional part of R2
.47bd	20 36 49	jsr $4936			jsr 	IFloatCopyFromRegister
.47c0	20 4f 46	jsr $464f			jsr 	IFloatFractionalR0
.47c3	20 dc 49	jsr $49dc			jsr 	IFloatNormalise
.47c6	a2 14		ldx #$14			ldx 	#IFR2
.47c8	20 47 49	jsr $4947			jsr 	IFloatCopyToRegister 		; copy to R2
.47cb	a2 14		ldx #$14			ldx 	#IFR2 						; set R2 to 10
.47cd	a9 0a		lda #$0a			lda 	#10
.47cf	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.47d2	a2 14		ldx #$14			ldx 	#IFR2						; R0,R2 = R2 * 10
.47d4	20 45 44	jsr $4445			jsr 	IFloatMultiply
.47d7	a2 14		ldx #$14			ldx 	#IFR2
.47d9	20 47 49	jsr $4947			jsr 	IFloatCopyToRegister
.47dc	20 a5 46	jsr $46a5			jsr 	IFloatIntegerR0 			; get integer part of R0
.47df	ad ce 06	lda $06ce			lda 	IFloatDecimalCount 			; done 5 dp, no more
.47e2	c9 03		cmp #$03			cmp 	#3
.47e4	f0 16		beq $47fc			beq 	_IFFSExitStripZero
.47e6	ad ce 06	lda $06ce			lda 	IFloatDecimalCount 			; written the DP yet ?
.47e9	d0 05		bne $47f0			bne 	_IFloatNotFirst
.47eb	a9 2e		lda #$2e			lda 	#"." 						; write decimal point
.47ed	20 35 4a	jsr $4a35			jsr 	IFloatBufferWrite
.47f0					_IFloatNotFirst:
.47f0	ee ce 06	inc $06ce			inc 	IFloatDecimalCount
.47f3	a5 0c		lda $0c				lda 	IFR0+IM0 					; get digit
.47f5	09 30		ora #$30			ora 	#"0"						; ASCII
.47f7	20 35 4a	jsr $4a35			jsr 	IFloatBufferWrite 			; write to the buffer.
.47fa	80 bf		bra $47bb			bra 	_IFloatFracLoop
.47fc					_IFFSExitStripZero:
.47fc	20 44 4a	jsr $4a44			jsr 	IFloatStripTrailingZeros
.47ff					_IFFSExit:
.47ff	a2 14		ldx #$14			ldx 	#IFR2 						; restore R2
.4801	20 15 49	jsr $4915			jsr 	IFloatPullRx
.4804	20 2d 4a	jsr $4a2d			jsr 	IFloatGetBufferAddress
.4807	18		clc				clc
.4808	60		rts				rts
.06ce					IFloatDecimalCount:
>06ce							.fill 	1
.4809					IFloatStringToFloatR0:
.4809	8d cf 06	sta $06cf			sta 	IFCount 					; save it out.
.480c	86 0a		stx $0a				stx 	iTemp0
.480e	84 0b		sty $0b				sty 	iTemp0+1
.4810	a2 0c		ldx #$0c			ldx 	#IFR0 						; reset the current value.
.4812	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.4815	9c d0 06	stz $06d0			stz 	IFSignFlag 					; clear the sign flag
.4818	20 a5 48	jsr $48a5			jsr 	IFSTFGetNext 				; get first
.481b	f0 1b		beq $4838			beq 	_IFSTFFail 					; no character
.481d	90 10		bcc $482f			bcc 	_IFSTFHaveChar 				; legitimate character, go do it.
.481f	c9 2d		cmp #$2d			cmp 	#"-" 						; if not -, fail
.4821	d0 15		bne $4838			bne 	_IFSTFFail
.4823	a9 40		lda #$40			lda 	#IFSign 					; set sign flag
.4825	8d d0 06	sta $06d0			sta 	IFSignFlag
.4828					_IFSTFLoop:
.4828	20 a5 48	jsr $48a5			jsr 	IFSTFGetNext 				; get next
.482b	b0 0b		bcs $4838			bcs 	_IFSTFFail 					; bad character.
.482d	f0 11		beq $4840			beq 	_IFSTFExit 					; end of data
.482f					_IFSTFHaveChar:
.482f	c9 2e		cmp #$2e			cmp 	#"."						; decimal point ?
.4831	f0 08		beq $483b			beq 	_IFSTFDecimal
.4833	20 c9 48	jsr $48c9			jsr 	IFSTFAddR0 					; add number in
.4836	80 f0		bra $4828			bra 	_IFSTFLoop 					; keep going until . or end.
.4838					_IFSTFFail:
.4838	38		sec				sec
.4839	80 0d		bra $4848			bra 	_IFSTFReturn
.483b					_IFSTFDecimal:
.483b	20 50 48	jsr $4850			jsr 	IFSTFDecimal 				; call the decimal places code.
.483e	b0 08		bcs $4848			bcs 	_IFSTFReturn 				; error
.4840					_IFSTFExit:
.4840	a5 0f		lda $0f				lda 	IFR0+IExp 					; copy sign flag in.
.4842	0d d0 06	ora $06d0			ora 	IFSignFlag
.4845	85 0f		sta $0f				sta 	IFR0+IExp
.4847	18		clc				clc
.4848					_IFSTFReturn:
.4848	60		rts				rts
.4849					IFloatAddDecimalToR0:
.4849	8d cf 06	sta $06cf			sta 	IFCount 					; save it out.
.484c	86 0a		stx $0a				stx 	iTemp0
.484e	84 0b		sty $0b				sty 	iTemp0+1
.4850					IFSTFDecimal:
.4850	a2 0c		ldx #$0c			ldx 	#IFR0 						; push integer part on stack
.4852	20 f4 48	jsr $48f4			jsr 	IFloatPushRx
.4855	a2 0c		ldx #$0c			ldx 	#IFR0 						; R0 is the decimal digits so far.
.4857	20 a5 49	jsr $49a5			jsr 	IFloatSetZero
.485a	9c d1 06	stz $06d1			stz 	IFDecimalPlaces
.485d					_IFSTDLoop:
.485d	20 a5 48	jsr $48a5			jsr 	IFSTFGetNext 				; get next
.4860	b0 41		bcs $48a3			bcs 	_IFSTFFail2 				; bad character.
.4862	f0 11		beq $4875			beq 	_IFSTFComplete 				; end of data, work out the result.
.4864	c9 2e		cmp #$2e			cmp 	#"."						; only one decimal
.4866	f0 39		beq $48a1			beq 	_IFSTFExit2
.4868	20 c9 48	jsr $48c9			jsr 	IFSTFAddR0 					; add number in
.486b	ee d1 06	inc $06d1			inc 	IFDecimalPlaces 			; count decimals
.486e	ad d1 06	lda $06d1			lda 	IFDecimalPlaces 			; no more than 3 DP used.
.4871	c9 03		cmp #$03			cmp 	#3
.4873	90 e8		bcc $485d			bcc 	_IFSTDLoop
.4875					_IFSTFComplete:
.4875	ad d1 06	lda $06d1			lda 	IFDecimalPlaces 			; decimals x 4 as accessing multiplier from a LUT.
.4878	f0 27		beq $48a1			beq 	_IFSTFExit2					; if none, this is syntactically fine, just ignore
.487a	3a		dec a				dec 	a 							; table indexed from 1.
.487b	0a		asl a				asl 	a
.487c	0a		asl a				asl 	a
.487d	aa		tax				tax
.487e	bd e0 48	lda $48e0,x			lda 	TableTen,x 					; copy table entry into R0 - these are 0.1,0.01,0.001
.4881	85 10		sta $10				sta  	IFR1+IM0 					; 0.0001 etc, up to 5 decimals.
.4883	bd e1 48	lda $48e1,x			lda 	TableTen+1,x
.4886	85 11		sta $11				sta  	IFR1+IM1
.4888	bd e2 48	lda $48e2,x			lda 	TableTen+2,x
.488b	85 12		sta $12				sta  	IFR1+IM2
.488d	bd e3 48	lda $48e3,x			lda 	TableTen+3,x
.4890	85 13		sta $13				sta  	IFR1+IExp
.4892	a2 10		ldx #$10			ldx 	#IFR1 						; multiply into result
.4894	20 45 44	jsr $4445			jsr 	IFloatMultiply
.4897	a2 10		ldx #$10			ldx 	#IFR1  						; pop and add the decimal.
.4899	20 15 49	jsr $4915			jsr 	IFloatPullRx
.489c	a2 10		ldx #$10			ldx 	#IFR1
.489e	20 9b 43	jsr $439b			jsr 	IFloatAdd
.48a1					_IFSTFExit2:
.48a1	18		clc				clc
.48a2	60		rts				rts
.48a3					_IFSTFFail2:
.48a3	38		sec				sec
.48a4	60		rts				rts
.48a5					IFSTFGetNext:
.48a5	ad cf 06	lda $06cf			lda 	IFCount  					; if count is zero, return with Z set.
.48a8	f0 19		beq $48c3			beq 	_IFSTFReturnOk
.48aa	b2 0a		lda ($0a)			lda 	(iTemp0) 					; get next character
.48ac	e6 0a		inc $0a				inc 	iTemp0 						; point at next.
.48ae	d0 02		bne $48b2			bne 	_IFSTFGNNoCarry
.48b0	e6 0b		inc $0b				inc 	iTemp0+1
.48b2					_IFSTFGNNoCarry:
.48b2	ce cf 06	dec $06cf			dec 	IFCount 					; dec count.
.48b5	c9 2e		cmp #$2e			cmp 	#"."	 					; check, dp is allowed.
.48b7	f0 08		beq $48c1			beq 	_IFSTFGOkay
.48b9	c9 30		cmp #$30			cmp 	#"0"						; < 0 fail.
.48bb	90 08		bcc $48c5			bcc 	_IFSTFGFail
.48bd	c9 3a		cmp #$3a			cmp 	#"9"+1 						; > 9 fail.
.48bf	b0 04		bcs $48c5			bcs 	_IFSTFGFail
.48c1					_IFSTFGOkay:
.48c1	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.48c3					_IFSTFReturnOk:
.48c3	18		clc				clc
.48c4	60		rts				rts
.48c5					_IFSTFGFail:
.48c5	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.48c7	38		sec				sec
.48c8	60		rts				rts
.48c9					IFSTFAddR0:
.48c9	29 0f		and #$0f			and 	#15 						; to int value
.48cb	48		pha				pha 								; save it.
.48cc	a9 0a		lda #$0a			lda 	#10
.48ce	a2 10		ldx #$10			ldx 	#IFR1
.48d0	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.48d3	20 45 44	jsr $4445			jsr 	IFloatMultiply
.48d6	68		pla				pla
.48d7	a2 10		ldx #$10			ldx 	#IFR1
.48d9	20 a7 49	jsr $49a7			jsr 	IFloatSetByte
.48dc	20 9b 43	jsr $439b			jsr 	IFloatAdd
.48df	60		rts				rts
.06cf					IFCount:
>06cf							.fill 	1
.06d0					IFSignFlag:
>06d0							.fill 	1
.06d1					IFDecimalPlaces:
>06d1							.fill 	1
.48e0					TableTen:
>48e0	9a 19 00 30				.byte	$9a,$19,$00,$30 ; 0.10001
>48e4	8f 02 00 30				.byte	$8f,$02,$00,$30 ; 0.00999
>48e8	42 00 00 30				.byte	$42,$00,$00,$30 ; 0.00101
>48ec	07 00 00 30				.byte	$07,$00,$00,$30 ; 0.00011
>48f0	01 00 00 30				.byte	$01,$00,$00,$30 ; 2e-05
.48f4					IFloatPushRx:
.48f4	5a		phy				phy
.48f5	ac d2 06	ldy $06d2			ldy 	IFStackIndex
.48f8	b5 00		lda $00,x			lda 	IM0,x
.48fa	99 d3 06	sta $06d3,y			sta 	IFStack,y
.48fd	b5 01		lda $01,x			lda 	IM1,x
.48ff	99 d4 06	sta $06d4,y			sta 	IFStack+1,y
.4902	b5 02		lda $02,x			lda 	IM2,x
.4904	99 d5 06	sta $06d5,y			sta 	IFStack+2,y
.4907	b5 03		lda $03,x			lda 	IExp,x
.4909	99 d6 06	sta $06d6,y			sta 	IFStack+3,y
.490c	c8		iny				iny
.490d	c8		iny				iny
.490e	c8		iny				iny
.490f	c8		iny				iny
.4910	8c d2 06	sty $06d2			sty 	IFStackIndex
.4913	7a		ply				ply
.4914	60		rts				rts
.4915					IFloatPullRx:
.4915	5a		phy				phy
.4916	ac d2 06	ldy $06d2			ldy 	IFStackIndex
.4919	88		dey				dey
.491a	88		dey				dey
.491b	88		dey				dey
.491c	88		dey				dey
.491d	b9 d3 06	lda $06d3,y			lda 	IFStack,y
.4920	95 00		sta $00,x			sta 	IM0,x
.4922	b9 d4 06	lda $06d4,y			lda 	IFStack+1,y
.4925	95 01		sta $01,x			sta 	IM1,x
.4927	b9 d5 06	lda $06d5,y			lda 	IFStack+2,y
.492a	95 02		sta $02,x			sta 	IM2,x
.492c	b9 d6 06	lda $06d6,y			lda 	IFStack+3,y
.492f	95 03		sta $03,x			sta 	IExp,x
.4931	8c d2 06	sty $06d2			sty 	IFStackIndex
.4934	7a		ply				ply
.4935	60		rts				rts
.06d2					IFStackIndex:
>06d2							.fill 	1
.06d3					IFStack:
>06d3							.fill 	16*4
.4936					IFloatCopyFromRegister:
.4936	b5 00		lda $00,x			lda 	0,x
.4938	85 0c		sta $0c				sta 	IFR0
.493a	b5 01		lda $01,x			lda 	1,x
.493c	85 0d		sta $0d				sta 	IFR0+1
.493e	b5 02		lda $02,x			lda 	2,x
.4940	85 0e		sta $0e				sta 	IFR0+2
.4942	b5 03		lda $03,x			lda 	3,x
.4944	85 0f		sta $0f				sta 	IFR0+3
.4946	60		rts				rts
.4947					IFloatCopyToRegister:
.4947	a5 0c		lda $0c				lda 	IFR0
.4949	95 00		sta $00,x			sta 	0,x
.494b	a5 0d		lda $0d				lda 	IFR0+1
.494d	95 01		sta $01,x			sta 	1,x
.494f	a5 0e		lda $0e				lda 	IFR0+2
.4951	95 02		sta $02,x			sta 	2,x
.4953	a5 0f		lda $0f				lda 	IFR0+3
.4955	95 03		sta $03,x			sta 	3,x
.4957	60		rts				rts
.4958					IFloatLoadInline:
.4958	68		pla				pla 								; pop address off to iTemp0
.4959	85 0a		sta $0a				sta 	iTemp0
.495b	68		pla				pla
.495c	85 0b		sta $0b				sta 	iTemp0+1
.495e	a0 01		ldy #$01			ldy 	#1
.4960	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 0
.4962	95 00		sta $00,x			sta 	0,x
.4964	c8		iny				iny
.4965	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 1
.4967	95 01		sta $01,x			sta 	1,x
.4969	c8		iny				iny
.496a	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 2
.496c	95 02		sta $02,x			sta 	2,x
.496e	c8		iny				iny
.496f	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 3
.4971	95 03		sta $03,x			sta 	3,x
.4973	18		clc				clc 								; inc pointer, 1 for return, 4 for data
.4974	a5 0a		lda $0a				lda 	iTemp0
.4976	69 05		adc #$05			adc 	#5
.4978	85 0a		sta $0a				sta 	iTemp0
.497a	90 02		bcc $497e			bcc 	_IFLINoCarry
.497c	e6 0b		inc $0b				inc 	iTemp0+1
.497e					_IFLINoCarry:
.497e	6c 0a 00	jmp ($000a)			jmp 	(iTemp0)					; effectively RTS
.4981					IFloatMultiply8BitRx:
.4981	5a		phy		        phy
.4982	b5 00		lda $00,x	        lda     IM0,x                       ; AY are the two values
.4984	a4 0c		ldy $0c		        ldy     IFR0+IM0
.4986	4a		lsr a		        lsr     a                           ; prime the carry bit for the loop
.4987	85 0c		sta $0c		        sta     IFR0+IM0
.4989	84 0d		sty $0d		        sty     IFR0+IM1
.498b	a9 00		lda #$00	        lda     #0
.498d	a0 08		ldy #$08	        ldy     #8
.498f					_IFMLoop:
.498f	90 03		bcc $4994	        bcc     _IFMNoAdd
.4991	18		clc		        clc
.4992	65 0d		adc $0d		        adc     IFR0+IM1
.4994					_IFMNoAdd:
.4994	6a		ror a		        ror     a
.4995	66 0c		ror $0c		        ror     IFR0+IM0                    ; pull another bit out for the next iteration
.4997	88		dey		        dey
.4998	d0 f5		bne $498f	        bne     _IFMLoop
.499a	85 0d		sta $0d		        sta     IFR0+IM1                    ; write MSB out
.499c	7a		ply		        ply
.499d	60		rts		        rts
.499e					IFloatCheckZero:
.499e	b5 00		lda $00,x			lda 	IM0,x
.49a0	15 01		ora $01,x			ora 	IM1,x
.49a2	15 02		ora $02,x			ora 	IM2,x
.49a4	60		rts				rts
.49a5					IFloatSetZero:
.49a5	a9 00		lda #$00			lda 	#0
.49a7					IFloatSetByte:
.49a7	95 00		sta $00,x			sta 	IM0,x 						; set mantissa to 00A
.49a9	74 01		stz $01,x			stz 	IM1,x
.49ab	74 02		stz $02,x			stz 	IM2,x
.49ad	74 03		stz $03,x			stz 	IExp,x 						; zero the exponent.
.49af	60		rts				rts
.49b0					IFloatNegate:
.49b0	b5 03		lda $03,x			lda 	IExp,x
.49b2	49 40		eor #$40			eor 	#IFSign
.49b4	95 03		sta $03,x			sta 	IExp,x
.49b6	18		clc				clc
.49b7	60		rts				rts
.49b8					IFloatMantissaNegate:
.49b8	38		sec				sec
.49b9	a9 00		lda #$00			lda 	#0
.49bb	f5 00		sbc $00,x			sbc 	IM0,x
.49bd	95 00		sta $00,x			sta 	IM0,x
.49bf	a9 00		lda #$00			lda 	#0
.49c1	f5 01		sbc $01,x			sbc 	IM1,x
.49c3	95 01		sta $01,x			sta 	IM1,x
.49c5	a9 00		lda #$00			lda 	#0
.49c7	f5 02		sbc $02,x			sbc 	IM2,x
.49c9	95 02		sta $02,x			sta 	IM2,x
.49cb	60		rts				rts
.49cc					IFloatShiftLeft:
.49cc	18		clc				clc
.49cd					IFloatRotateLeft:
.49cd	36 00		rol $00,x			rol 	IM0,x
.49cf	36 01		rol $01,x			rol 	IM1,x
.49d1	36 02		rol $02,x			rol 	IM2,x
.49d3	60		rts				rts
.49d4					IFloatShiftRight:
.49d4	18		clc				clc
.49d5					IFloatRotateRight:
.49d5	76 02		ror $02,x			ror 	IM2,x
.49d7	76 01		ror $01,x			ror 	IM1,x
.49d9	76 00		ror $00,x			ror 	IM0,x
.49db	60		rts				rts
.49dc					IFloatNormalise:
.49dc	20 9e 49	jsr $499e			jsr 	IFloatCheckZero 			; is it zero
.49df	f0 18		beq $49f9			beq 	_IFNExitZero 				; if so exit
.49e1					_IFNLoop:
.49e1	b5 02		lda $02,x			lda 	IM2,x 						; is it normalised e.g. bits 7/6 are 01
.49e3	29 c0		and #$c0			and 	#$C0
.49e5	c9 40		cmp #$40			cmp 	#$40
.49e7	f0 13		beq $49fc			beq 	_IFNExitOkay 				; if so , then we are done.
.49e9	b5 03		lda $03,x			lda 	IExp,x 						; check exponent is not -32 already.
.49eb	29 3f		and #$3f			and 	#$3F
.49ed	c9 20		cmp #$20			cmp 	#$20
.49ef	f0 0b		beq $49fc			beq 	_IFNExitOkay 				; if so, then we cannot normalise any more.
.49f1	20 12 4a	jsr $4a12			jsr 	IFloatDecExponent
.49f4	20 cc 49	jsr $49cc			jsr 	IFloatShiftLeft 			; shift mantissa left, e.g. multiply by 2
.49f7	80 e8		bra $49e1			bra 	_IFNLoop
.49f9					_IFNExitZero:
.49f9	20 a5 49	jsr $49a5			jsr 	IFloatSetZero 				; set the result to zero
.49fc					_IFNExitOkay:
.49fc	18		clc				clc  								; return with CC.
.49fd	60		rts				rts
.49fe					IFloatIncExponent:
.49fe	b5 03		lda $03,x			lda 	IExp,x
.4a00	48		pha				pha
.4a01	29 c0		and #$c0			and 	#$C0
.4a03	8d 13 07	sta $0713			sta 	IFXTemp
.4a06	68		pla				pla
.4a07	1a		inc a				inc 	a
.4a08	29 3f		and #$3f			and 	#$3F
.4a0a	48		pha				pha
.4a0b	0d 13 07	ora $0713			ora 	IFXTemp
.4a0e	95 03		sta $03,x			sta 	IExp,x
.4a10	68		pla				pla
.4a11	60		rts				rts
.4a12					IFloatDecExponent:
.4a12	b5 03		lda $03,x			lda 	IExp,x
.4a14	48		pha				pha
.4a15	29 c0		and #$c0			and 	#$C0
.4a17	8d 13 07	sta $0713			sta 	IFXTemp
.4a1a	68		pla				pla
.4a1b	3a		dec a				dec 	a
.4a1c	29 3f		and #$3f			and 	#$3F
.4a1e	48		pha				pha
.4a1f	0d 13 07	ora $0713			ora 	IFXTemp
.4a22	95 03		sta $03,x			sta 	IExp,x
.4a24	68		pla				pla
.4a25	60		rts				rts
.0713					IFXTemp:
>0713							.fill 	1
.4a26					IFloatBufferReset:
.4a26	9c 14 07	stz $0714			stz 	IFBufferCount
.4a29	9c 15 07	stz $0715			stz 	IFBuffer
.4a2c	60		rts				rts
.4a2d					IFloatGetBufferAddress:
.4a2d	a0 07		ldy #$07			ldy 	#(IFBuffer >> 8)
.4a2f	a2 15		ldx #$15			ldx 	#(IFBuffer & $FF)
.4a31	ad 14 07	lda $0714			lda 	IFBufferCount
.4a34	60		rts				rts
.4a35					IFloatBufferWrite:
.4a35	da		phx				phx
.4a36	ae 14 07	ldx $0714			ldx 	IFBufferCount
.4a39	9d 15 07	sta $0715,x			sta 	IFBuffer,x
.4a3c	9e 16 07	stz $0716,x			stz 	IFBuffer+1,x
.4a3f	ee 14 07	inc $0714			inc 	IFBufferCount
.4a42	fa		plx				plx
.4a43	60		rts				rts
.4a44					IFloatStripTrailingZeros:
.4a44	ae 14 07	ldx $0714			ldx 	IFBufferCount
.4a47	bd 14 07	lda $0714,x			lda 	IFBuffer-1,x
.4a4a	c9 30		cmp #$30			cmp		#"0"
.4a4c	d0 0f		bne $4a5d			bne 	_IFSTExit
.4a4e	bd 13 07	lda $0713,x			lda 	IFBuffer-2,x
.4a51	c9 2e		cmp #$2e			cmp 	#"."
.4a53	f0 08		beq $4a5d			beq 	_IFSTExit
.4a55	ce 14 07	dec $0714			dec 	IFBufferCount
.4a58	9e 14 07	stz $0714,x			stz 	IFBuffer-1,x
.4a5b	80 e7		bra $4a44			bra 	IFloatStripTrailingZeros
.4a5d					_IFSTExit:
.4a5d	60		rts				rts
.0714					IFBufferCount:
>0714							.fill 	1
.0715					IFBuffer:
>0715							.fill 	25
.4a5e					IFloatCheck:
.4a5e	a5 0f		lda $0f				lda 	IFR0+IExp					; force it negative
.4a60	09 40		ora #$40			ora 	#IFSign
.4a62	85 0f		sta $0f				sta 	IFR0+IExp
.4a64	20 9b 43	jsr $439b			jsr 	IFloatAdd 					; add allowed to error.
.4a67	a2 0c		ldx #$0c			ldx 	#IFR0
.4a69	20 9e 49	jsr $499e			jsr 	IFloatCheckZero 			; error if < 0
.4a6c	f0 06		beq $4a74			beq 	_IFAOkay
.4a6e	a5 0f		lda $0f				lda 	IFR0+IExp
.4a70	29 40		and #$40			and 	#IFSign
.4a72	d0 01		bne $4a75			bne 	_IFAFail
.4a74					_IFAOkay:
.4a74	60		rts				rts
.4a75					_IFAFail:
.4a75	38		sec				sec
.4a76	68		pla				pla 								; get address - 2
.4a77	e9 02		sbc #$02			sbc 	#2
.4a79	aa		tax				tax
.4a7a	68		pla				pla
.4a7b	e9 00		sbc #$00			sbc 	#0
.4a7d	a8		tay				tay
.4a7e	a9 aa		lda #$aa			lda 	#$AA 						; sign assert
.4a80					_IFAStop:
>4a80	db						.byte 	$DB 						; display an error AA ADR ADR
.4a81	80 fd		bra $4a80			bra 	_IFAStop

;******  Return to file: basic.asm

.4a83					NotImplemented:
.4a83	a9 ff		lda #$ff			lda 	#$FF
.4a85	80 04		bra $4a8b			bra 	EnterDbg
.4a87					ErrorHandler:
.4a87	fa		plx				plx
.4a88	7a		ply				ply
.4a89	a9 ee		lda #$ee			lda 	#$EE
.4a8b					EnterDbg:
>4a8b	db						.byte 	$DB
.4a8c	4c 8b 4a	jmp $4a8b			jmp 	EnterDbg

;******  End of listing
