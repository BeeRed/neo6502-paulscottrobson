
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -q -Wall -c -C -b -L build/code.lst -l build/code.lbl -D "BASICLOAD=\$1000" -D "BASICCODE=\$3800" -D "ENDMEMORY=\$C000" -D STACKPAGES=2 -D runEdit=1 -o build/basic.bin basic.asm
; Sun Jun 25 08:28:33 2023

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=$1000					BASICLOAD=$1000
=$3800					BASICCODE=$3800
=$c000					ENDMEMORY=$C000
=2					STACKPAGES=2
=1					runEdit=1

;******  Processing input file: basic.asm


;******  Processing file: build/ramdata.inc

=$08					ZeroPageBase = $08 							; zero page usage
=$200					StorageBase = $200 							; ROM usage
.0008					IFR0:
>0008							.fill 	4
.000c					IFR1:
>000c							.fill 	4
.0010					IFR2:
>0010							.fill 	4
.0014					IFRTemp:
>0014							.fill 	4
.0018					codePtr:
>0018							.fill 	4
.001c					rTemp0:
>001c							.fill 	2
.001e					rTemp1:
>001e							.fill 	2
.0020					iTemp0:
>0020							.fill 	2
.0200					OSXPos:
>0200							.fill 	1
.0201					OSYPos:
>0201							.fill 	1
.0202					OSXSize:
>0202							.fill 	1
.0203					OSYSize:
>0203							.fill 	1
=16					OSKeyboardQueueMaxSize = 16					; keyboard queue max size.
.0204					OSKeyStatus:
>0204							.fill 	32
.0224					OSKeyboardQueue:
>0224							.fill 	OSKeyboardQueueMaxSize
.0234					OSKeyboardQueueSize:
>0234							.fill 	1
.0235					OSIsKeyUp:
>0235							.fill 	1
.0236					OSIsKeyShift:
>0236							.fill 	1
.0237					OSEscapePressed:
>0237							.fill 	1
.0238					OSRKOriginal:
>0238							.fill 	1
=192					OSTextBufferSize = 192
.0239					OSXEdit:
>0239							.fill 	1
.023a					OSYEdit:
>023a							.fill 	1
.023b					OSEditWidth:
>023b							.fill 	1
.023c					OSEditPos:
>023c							.fill 	1
.023d					OSEditScroll:
>023d							.fill 	1
.023e					OSEditLength:
>023e							.fill 	1
.023f					OSEditBuffer:
>023f							.fill 	OSTextBufferSize+1
>0300							.fill 	32
>0320							.align 	256

;******  Return to file: basic.asm


;******  Processing file: build/osvectors.inc

=$ffd3					OSEditLine               = $ffd3 ; Edit line, return completion in A, line in YX
=$ffd6					OSEditNewLine            = $ffd6 ; Edit line, start clear.
=$ffd9					OSWriteString            = $ffd9 ; Write length prefixed string YX to screen
=$ffdc					OSWriteStringZ           = $ffdc ; Write ASCIIZ string YX to screen
=$ffdf					OSGetScreenSize          = $ffdf ; Get size of screen to XY
=$ffe2					OSKeyboardDataProcess    = $ffe2 ; Keyboard update process.
=$ffe5					OSCheckBreak             = $ffe5 ; NZ if ESC pressed.
=$ffe8					OSIsKeyAvailable         = $ffe8 ; Check if key available (CS if so)
=$ffeb					OSReadKeystroke          = $ffeb ; Read A from keyboard, showing cursor while waiting.
=$ffee					OSReadKeyboard           = $ffee ; Read A from keyboard (device 1), CC = success
=$fff1					OSWriteScreen            = $fff1 ; Write A to screen (device 0), CC = success
=$fff4					OSReadDevice             = $fff4 ; Read device X to A, CC = success
=$fff7					OSWriteDevice            = $fff7 ; Write A to device X, CC = success

;******  Return to file: basic.asm

=0					runEdit = 0 								; setting to 1 builds with the program/testing stuff in.
=0					autoRun = 0 								; setting to 1 autoruns program in memory space.
=2					STACK_PAGES = 2 							; number of stack pages.
.1000					boot:
.1000	a2 38		ldx #$38			ldx 	#BASICCODE >> 8 			; common setup, tells BASIC where its memory area is.
.1002	a0 c0		ldy #$c0			ldy 	#ENDMEMORY >> 8
.1004	20 42 1f	jsr $1f42			jsr 	PGMSetBaseAddress
.1007	20 b6 2a	jsr $2ab6			jsr 	IFInitialise 				; setup math library
.100a	4c 1d 96	jmp $961d			jmp 	TestCode
.100d	4c 08 14	jmp $1408			jmp 	Command_NEW 				; most just start with this

;******  Processing file: include.files


;******  Processing file: src/data.inc

.0022					zTemp0:
>0022							.fill 	2
.0024					zTemp1:
>0024							.fill 	2
.0026					zTemp2:
>0026							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/generated/token_const.inc

=$80					PR_STRUCTURE_FIRST = $80
=$80					PR_REPEAT = $80
=$81					PR_UNTIL = $81
=$82					PR_WHILE = $82
=$83					PR_WEND = $83
=$84					PR_IF = $84
=$85					PR_ENDIF = $85
=$86					PR_DO = $86
=$87					PR_LOOP = $87
=$88					PR_PROC = $88
=$89					PR_ENDPROC = $89
=$8a					PR_FOR = $8a
=$8b					PR_NEXT = $8b
=$8b					PR_STRUCTURE_LAST = $8b
=$8c					PR_STANDARD_FIRST = $8c
=$8c					PR_LSQLSQENDRSQRSQ = $8c
=$8d					PR_LSQLSQSHIFTRSQRSQ = $8d
=$8e					PR_ELSE = $8e
=$8f					PR_THEN = $8f
=$90					PR_TO = $90
=$91					PR_STEP = $91
=$92					PR_LET = $92
=$93					PR_PRINT = $93
=$94					PR_INPUT = $94
=$95					PR_CALL = $95
=$96					PR_SYS = $96
=$97					PR_REM = $97
=$98					PR_EXIT = $98
=$99					PR_COMMA = $99
=$9a					PR_SEMICOLON = $9a
=$9b					PR_COLON = $9b
=$9c					PR_SQUOTE = $9c
=$9d					PR_RPAREN = $9d
=$9e					PR_DIM = $9e
=$9f					PR_CLEAR = $9f
=$a0					PR_NEW = $a0
=$a1					PR_RUN = $a1
=$a2					PR_STOP = $a2
=$a3					PR_END = $a3
=$a4					PR_ASSERT = $a4
=$a5					PR_LIST = $a5
=$a6					PR_SAVE = $a6
=$a7					PR_LOAD = $a7
=$a8					PR_POKE = $a8
=$a9					PR_DOKE = $a9
=$aa					PR_READ = $aa
=$ab					PR_DATA = $ab
=$ac					PR_RESTORE = $ac
=$ad					PR_GOTO = $ad
=$ae					PR_GOSUB = $ae
=$af					PR_RETURN = $af
=$af					PR_STANDARD_LAST = $af
=$d5					PR_DEEKLPAREN = $d5
=$d5					PR_UNARY_FIRST = $d5
=$d6					PR_PEEKLPAREN = $d6
=$d7					PR_RIGHTDOLLARLPAREN = $d7
=$d8					PR_LEFTDOLLARLPAREN = $d8
=$d9					PR_MIDDOLLARLPAREN = $d9
=$da					PR_STRDOLLARLPAREN = $da
=$db					PR_VALLPAREN = $db
=$dc					PR_SGNLPAREN = $dc
=$dd					PR_ABSLPAREN = $dd
=$de					PR_LENLPAREN = $de
=$df					PR_SQRLPAREN = $df
=$e0					PR_CHRDOLLARLPAREN = $e0
=$e1					PR_ASCLPAREN = $e1
=$e2					PR_INKEYDOLLARLPAREN = $e2
=$e3					PR_EVENTLPAREN = $e3
=$e4					PR_TIME = $e4
=$e5					PR_INTLPAREN = $e5
=$e6					PR_FRACLPAREN = $e6
=$e7					PR_DECLPAREN = $e7
=$e8					PR_HEXDOLLARLPAREN = $e8
=$e9					PR_RNDLPAREN = $e9
=$ea					PR_RANDLPAREN = $ea
=$eb					PR_LPAREN = $eb
=$ec					PR_DOLLAR = $ec
=$ed					PR_LSQLSQDECIMALRSQRSQ = $ed
=$ee					PR_UNARY_LAST = $ee
=$ee					PR_LSQLSQSTRINGRSQRSQ = $ee
=$ef					PR_EQUAL = $ef
=$ef					PR_BINARY_FIRST = $ef
=$f0					PR_LESSGREATER = $f0
=$f1					PR_LESSEQUAL = $f1
=$f2					PR_LESS = $f2
=$f3					PR_GREATEREQUAL = $f3
=$f4					PR_GREATER = $f4
=$f5					PR_XOR = $f5
=$f6					PR_OR = $f6
=$f7					PR_AND = $f7
=$f8					PR_DIV = $f8
=$f9					PR_MOD = $f9
=$fa					PR_LESSLESS = $fa
=$fb					PR_GREATERGREATER = $fb
=$fc					PR_SLASH = $fc
=$fd					PR_ASTERISK = $fd
=$fe					PR_MINUS = $fe
=$ff					PR_BINARY_LAST = $ff
=$ff					PR_PLUS = $ff

;******  Return to file: include.files


;******  Processing file: src/program/data.inc

.0400					TOKLineSize:
>0400							.fill 	1
.0401					TOKLineNumber:
>0401							.fill 	2
.0403					TOKBuffer:
>0403							.fill 	256

;******  Return to file: include.files


;******  Processing file: src/support/errors/generated/errors.inc


;******  Return to file: include.files


;******  Processing file: src/support/stack/stack.inc

=$02					STK_REPEAT = $02
=$12					STK_WHILE = $12
=$22					STK_DO = $22
=$37					STK_FOR = $37
=$42					STK_CALL = $42
=$52					STK_GOSUB = $52

;******  Return to file: include.files


;******  Processing file: src/commands/assert.asm

.1010					Command_ASSERT:
.1010	20 06 17	jsr $1706			jsr 	EXPEvalNumber
.1013	a2 08		ldx #$08			ldx 	#IFR0
.1015	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero
.1018	f0 01		beq $101b			beq 	_CAFail
.101a	60		rts				rts
.101b					_CAFail:
.101b	4c c4 25	jmp $25c4		jmp	ErrorV_assert

;******  Return to file: include.files


;******  Processing file: src/commands/clear.asm

.101e					Command_CLEAR:
.101e	b1 18		lda ($18),y			lda 	(codePtr),y 				; check for CLEAR <something>
.1020	c9 9b		cmp #$9b			cmp 	#PR_COLON
.1022	f0 14		beq $1038			beq 	_CLNoParam
.1024	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ
.1026	f0 10		beq $1038			beq 	_CLNoParam
.1028	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 			; address for CLEAR
.102b	a5 09		lda $09				lda 	IFR0+IM1 					; high byte
.102d	c9 c0		cmp #$c0			cmp 	#ENDMEMORY >> 8 			; too high
.102f	b0 0b		bcs $103c			bcs 	_CLMemory
.1031	c9 39		cmp #$39			cmp 	#(BASICCODE >> 8)+1 		; too low
.1033	90 07		bcc $103c			bcc 	_CLMemory
.1035	8d 1b 05	sta $051b			sta 	PGMEndMemoryHigh 			; update end of memory.
.1038					_CLNoParam:
.1038	20 3f 10	jsr $103f			jsr 	ClearCode
.103b	60		rts				rts
.103c					_CLMemory:
.103c	4c 5e 26	jmp $265e		jmp	ErrorV_memory
.103f					ClearCode:
.103f	20 55 1f	jsr $1f55			jsr 	PGMEndProgram 				; end program => zTemp0
.1042	64 28		stz $28				stz 	freeMemory 					; start on next free page
.1044	a5 23		lda $23				lda 	zTemp0+1
.1046	1a		inc a				inc 	a
.1047	85 29		sta $29				sta 	freeMemory+1
.1049	20 55 2a	jsr $2a55			jsr 	VARClearHashTables
.104c	ad 1b 05	lda $051b			lda 	PGMEndMemoryHigh
.104f	20 92 27	jsr $2792			jsr 	StackReset
.1052	20 f1 27	jsr $27f1			jsr 	StringSystemInitialise
.1055	20 d9 24	jsr $24d9			jsr 	ScanProcedures
.1058	20 92 14	jsr $1492			jsr 	Command_RESTORE
.105b	60		rts				rts
.105c					AllocateMemory:
.105c	5a		phy				phy 								; save Y
.105d	a4 28		ldy $28				ldy 	freeMemory 					; save addr.low
.105f	5a		phy				phy
.1060	a4 29		ldy $29				ldy 	freeMemory+1 				; save addr.high
.1062	5a		phy				phy
.1063	a8		tay				tay 								; count is now in XY
.1064					_AllocateLoop:
.1064	e0 00		cpx #$00			cpx 	#0 							; allocate count is zero ?
.1066	d0 04		bne $106c			bne 	_AllocateOne
.1068	c0 00		cpy #$00			cpy 	#0
.106a	f0 15		beq $1081			beq 	_AllocateExit
.106c					_AllocateOne:
.106c	a9 00		lda #$00			lda 	#0 							; zero byte
.106e	92 28		sta ($28)			sta 	(freeMemory)
.1070	e6 28		inc $28				inc 	freeMemory 					; bump pointer
.1072	d0 05		bne $1079			bne 	_AllocateSkipCarry
.1074	e6 29		inc $29				inc 	freeMemory+1
.1076	20 85 10	jsr $1085			jsr 	ClearCheckMemory
.1079					_AllocateSkipCarry:
.1079	c0 00		cpy #$00			cpy 	#0 							; decrement XY
.107b	d0 01		bne $107e			bne 	_AllocateSkipBorrow
.107d	ca		dex				dex
.107e					_AllocateSkipBorrow:
.107e	88		dey				dey
.107f	80 e3		bra $1064			bra 	_AllocateLoop
.1081					_AllocateExit:
.1081	fa		plx				plx 								; restore address
.1082	68		pla				pla
.1083	7a		ply				ply 								; restore Y
.1084	60		rts				rts
.1085					ClearCheckMemory:
.1085	a5 29		lda $29				lda 	freeMemory+1
.1087	1a		inc a				inc 	a
.1088	1a		inc a				inc 	a
.1089	cd 23 06	cmp $0623			cmp 	stringMemory+1
.108c	b0 01		bcs $108f			bcs  	_CCMError
.108e	60		rts				rts
.108f					_CCMError:
.108f	4c 5e 26	jmp $265e		jmp	ErrorV_memory
.0028					freeMemory:
>0028							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/commands/dim.asm

.1092					CommandDIM:
.1092	b1 18		lda ($18),y			lda 	(codePtr),y 				; check identifier follows.
.1094	29 c0		and #$c0			and 	#$C0
.1096	c9 40		cmp #$40			cmp 	#$40
.1098	d0 39		bne $10d3			bne 	_CDSyntax
.109a	20 0c 2a	jsr $2a0c			jsr 	VARGetInfo 					; get information
.109d	ad 2b 06	lda $062b			lda 	VARType 					; check array.
.10a0	29 02		and #$02			and 	#2
.10a2	f0 2f		beq $10d3			beq 	_CDSyntax
.10a4	20 be 29	jsr $29be			jsr 	VARFind 					; does it already exist
.10a7	b0 2d		bcs $10d6			bcs 	_CDExists
.10a9	20 6a 29	jsr $296a			jsr 	VARCreate 					; create it - returns data ptr in XA
.10ac	da		phx				phx 								; save target address
.10ad	48		pha				pha
.10ae	ad 2b 06	lda $062b			lda 	VARType 					; type ID.
.10b1	29 01		and #$01			and 	#1 							; 0 = Number, 1 = String.
.10b3	20 d9 10	jsr $10d9			jsr 	CreateArray 				; create array to XA
.10b6	84 24		sty $24				sty 	zTemp1 						; save Y
.10b8	7a		ply				ply 								; restore target to zTemp0
.10b9	84 22		sty $22				sty 	zTemp0
.10bb	7a		ply				ply
.10bc	84 23		sty $23				sty 	zTemp0+1
.10be	92 22		sta ($22)			sta 	(zTemp0) 					; save new array
.10c0	a0 01		ldy #$01			ldy 	#1
.10c2	8a		txa				txa
.10c3	91 22		sta ($22),y			sta 	(zTemp0),y
.10c5	a4 24		ldy $24				ldy 	zTemp1 						; restore zTemp1
.10c7	20 23 27	jsr $2723			jsr 	ERRCheckRParen 				; check )
.10ca	b1 18		lda ($18),y			lda 	(codePtr),y 				; if a comma, consume and go round again.
.10cc	c8		iny				iny
.10cd	c9 99		cmp #$99			cmp 	#PR_COMMA
.10cf	f0 c1		beq $1092			beq 	CommandDIM
.10d1	88		dey				dey
.10d2	60		rts				rts
.10d3					_CDSyntax:
.10d3	4c 6e 25	jmp $256e		jmp	ErrorV_syntax
.10d6					_CDExists:
.10d6	4c 36 26	jmp $2636		jmp	ErrorV_redefine
.10d9					CreateArray:
.10d9	8d 03 05	sta $0503			sta 	CAType						; save type
.10dc	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 			; get array dimension to R0
.10df	b1 18		lda ($18),y			lda 	(codePtr),y 				; does a comma follow, if so, 2 dimensions
.10e1	c9 99		cmp #$99			cmp 	#PR_COMMA
.10e3	f0 04		beq $10e9			beq 	_CATwoDimensions
.10e5	20 35 11	jsr $1135			jsr 	CreateSingleArray 			; create a lowest level array (e.g. data)
.10e8	60		rts				rts
.10e9					_CATwoDimensions:
.10e9	a5 09		lda $09				lda 	IFR0+IM1 					; copy outer dimension to CADim1
.10eb	8d 05 05	sta $0505			sta 	CADim1+1
.10ee	a5 08		lda $08				lda 	IFR0+IM0
.10f0	8d 04 05	sta $0504			sta 	CADim1+0
.10f3	20 2b 27	jsr $272b			jsr 	ERRCheckComma 				; check comma
.10f6	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 			; calculate size of 2nd dimension.
.10f9	5a		phy				phy 								; save Y position
.10fa	18		clc				clc 								; allocate the outer array of pointers.
.10fb	ae 05 05	ldx $0505			ldx 	CADim1+1
.10fe	ad 04 05	lda $0504			lda 	CADim1
.1101	20 74 11	jsr $1174			jsr 	CSAAllocate 				; allocate the outer array
.1104	da		phx				phx									; save this address on the stack
.1105	48		pha				pha
.1106	86 27		stx $27				stx 	zTemp2+1					; and in zTemp2
.1108	85 26		sta $26				sta 	zTemp2
.110a					_CACreateSubLoop:
.110a	38		sec				sec
.110b	20 35 11	jsr $1135			jsr 	CreateSingleArray 			; create data array of required size.
.110e	a0 02		ldy #$02			ldy 	#2 							; save two on missing the two byte header.
.1110	91 26		sta ($26),y			sta 	(zTemp2),y
.1112	8a		txa				txa
.1113	c8		iny				iny
.1114	91 26		sta ($26),y			sta 	(zTemp2),y
.1116	18		clc				clc  								; next slot.
.1117	a5 26		lda $26				lda 	zTemp2
.1119	69 02		adc #$02			adc 	#2
.111b	85 26		sta $26				sta 	zTemp2
.111d	90 02		bcc $1121			bcc 	_CACNoCarry
.111f	e6 27		inc $27				inc 	zTemp2+1
.1121					_CACNoCarry:
.1121	ad 04 05	lda $0504			lda 	CADim1 						; use DIM1 as a counter
.1124	d0 03		bne $1129			bne 	_CACNoBorrow
.1126	ce 05 05	dec $0505			dec 	CADim1+1
.1129					_CACNoBorrow:
.1129	ce 04 05	dec $0504			dec 	CADim1
.112c	ad 05 05	lda $0505			lda 	CADim1+1 					; but do one more.
.112f	10 d9		bpl $110a			bpl 	_CACreateSubLoop
.1131	68		pla				pla
.1132	fa		plx				plx
.1133	7a		ply				ply
.1134	60		rts				rts
.1135					CreateSingleArray:
.1135	5a		phy				phy
.1136	38		sec				sec 								; allocate memory block all zeros.
.1137	a5 08		lda $08				lda 	IFR0+IM0
.1139	a6 09		ldx $09				ldx 	IFR0+IM1
.113b	20 74 11	jsr $1174			jsr 	CSAAllocate
.113e	ac 03 05	ldy $0503			ldy 	CAType 						; if numbers, we don't need to initialise.
.1141	f0 2f		beq $1172			beq 	_CSANoInit
.1143	da		phx				phx 								; save address of new array
.1144	48		pha				pha
.1145	85 22		sta $22				sta 	zTemp0 						; address in zTemp0
.1147	86 23		stx $23				stx 	zTemp0+1
.1149	a0 01		ldy #$01			ldy 	#1 							; count in YX - cannot be zero.
.114b	b1 22		lda ($22),y			lda 	(zTemp0),y
.114d	a8		tay				tay
.114e	b2 22		lda ($22)			lda 	(zTemp0)
.1150	aa		tax				tax
.1151					_CSAEraseString:
.1151	5a		phy				phy
.1152	a0 05		ldy #$05			ldy 	#5 							; 2 initial + 3 on
.1154	a9 80		lda #$80			lda 	#$80
.1156	91 22		sta ($22),y			sta 	(zTemp0),y
.1158	7a		ply				ply
.1159	18		clc				clc 								; add 4 to next slot.
.115a	a5 22		lda $22				lda 	zTemp0
.115c	69 04		adc #$04			adc 	#4
.115e	85 22		sta $22				sta 	zTemp0
.1160	90 02		bcc $1164			bcc 	_CSAENoCarry
.1162	e6 23		inc $23				inc 	zTemp0+1
.1164					_CSAENoCarry:
.1164	e0 00		cpx #$00			cpx 	#0
.1166	d0 01		bne $1169			bne 	_CSANoBorrow
.1168	88		dey				dey
.1169					_CSANoBorrow:
.1169	ca		dex				dex
.116a	d0 e5		bne $1151			bne 	_CSAEraseString
.116c	c0 00		cpy #$00			cpy 	#0
.116e	d0 e1		bne $1151			bne 	_CSAEraseString
.1170	68		pla				pla
.1171	fa		plx				plx
.1172					_CSANoInit:
.1172	7a		ply				ply
.1173	60		rts				rts
.1174					CSAAllocate:
.1174	08		php				php 								; save type flag.
.1175	1a		inc a				inc 	a 							; add 1 because we store the size of the array block
.1176	d0 01		bne $1179			bne 	_CSAANoCarry 				; for A(10) this is 11 elements.
.1178	e8		inx				inx
.1179					_CSAANoCarry:
.1179	e0 20		cpx #$20			cpx 	#$20 						; basic range check
.117b	b0 2e		bcs $11ab			bcs 	_CSARange
.117d	28		plp				plp 								; restore type flag
.117e	08		php				php 								; save it back again.
.117f	da		phx				phx 								; save size.
.1180	48		pha				pha
.1181	86 23		stx $23				stx  	zTemp0+1 					; now in ztemp0+1:X
.1183	90 03		bcc $1188			bcc 	_CSAATimes2 				; if flag on entry clear multiply by 2, otherwise by 4.
.1185	0a		asl a				asl 	a
.1186	26 23		rol $23				rol 	zTemp0+1
.1188					_CSAATimes2:
.1188	0a		asl a				asl 	a
.1189	26 23		rol $23				rol 	zTemp0+1
.118b	18		clc				clc
.118c	69 02		adc #$02			adc 	#2 							; add 2 bytes for size.
.118e	90 02		bcc $1192			bcc 	_CSAANoCarry2
.1190	e6 23		inc $23				inc 	zTemp0+1
.1192					_CSAANoCarry2:
.1192	a6 23		ldx $23				ldx 	zTemp0+1 					; XA is the bytes required.
.1194	20 5c 10	jsr $105c			jsr 	AllocateMemory 				; allocate memory to XA
.1197	86 23		stx $23				stx 	zTemp0+1 					; save pointers
.1199	85 22		sta $22				sta 	zTemp0
.119b	68		pla				pla  								; write element count to first 2 bytes
.119c	92 22		sta ($22)			sta 	(zTemp0)
.119e	68		pla				pla 								; msb of element count
.119f	28		plp				plp 								; CC if pointer array
.11a0	b0 02		bcs $11a4			bcs 	_CSAAIsData
.11a2	09 80		ora #$80			ora 	#$80 						; set bit 7 of MSB indicating has sub arrays.
.11a4					_CSAAIsData:
.11a4	a0 01		ldy #$01			ldy 	#1
.11a6	91 22		sta ($22),y			sta 	(zTemp0),y
.11a8	a5 22		lda $22				lda 	zTemp0 						; fix XA back up again
.11aa	60		rts				rts
.11ab					_CSARange:
.11ab	4c 7f 25	jmp $257f		jmp	ErrorV_range
.0503					CAType:
>0503							.fill 	1
.0504					CADim1:
>0504							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/commands/dokepoke.asm

.11ae					Command_Doke:
.11ae	38		sec				sec
.11af	80 01		bra $11b2			bra 	DPCommon
.11b1					Command_Poke:
.11b1	18		clc				clc
.11b2					DPCommon:
.11b2	08		php				php 								; CS if DOKE
.11b3	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 			; address
.11b6	a5 08		lda $08				lda 	IFR0+IM0 					; push on stack
.11b8	48		pha				pha
.11b9	a5 09		lda $09				lda 	IFR0+IM1
.11bb	48		pha				pha
.11bc	20 2b 27	jsr $272b			jsr 	ERRCheckComma 				; [dp]oke address,data
.11bf	20 18 17	jsr $1718			jsr 	EXPEvalInteger16
.11c2	68		pla				pla 								; get address back
.11c3	85 23		sta $23				sta 	zTemp0+1
.11c5	68		pla				pla
.11c6	85 22		sta $22				sta 	zTemp0
.11c8	a5 08		lda $08				lda 	IFR0+IM0
.11ca	92 22		sta ($22)			sta 	(zTemp0)
.11cc	28		plp				plp
.11cd	90 08		bcc $11d7			bcc 	_DPExit
.11cf	5a		phy				phy
.11d0	a5 09		lda $09				lda 	IFR0+IM1
.11d2	a0 01		ldy #$01			ldy 	#1
.11d4	91 22		sta ($22),y			sta 	(zTemp0),y
.11d6	7a		ply				ply
.11d7					_DPExit:
.11d7	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/goto.asm

.11d8					Command_GOTO:
.11d8	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 			; get line number
.11db					GotoR0:
.11db	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; back to the program start
.11de	85 19		sta $19				sta 	codePtr+1
.11e0	64 18		stz $18				stz 	codePtr
.11e2					_GOSearch:
.11e2	b2 18		lda ($18)			lda 	(codePtr) 					; end of program.
.11e4	f0 1f		beq $1205			beq 	_GOError
.11e6	a0 01		ldy #$01			ldy 	#1 							; found line #
.11e8	b1 18		lda ($18),y			lda 	(codePtr),y
.11ea	c5 08		cmp $08				cmp 	IFR0+IM0
.11ec	d0 0a		bne $11f8			bne 	_GONext
.11ee	c8		iny				iny
.11ef	b1 18		lda ($18),y			lda 	(codePtr),y
.11f1	c5 09		cmp $09				cmp 	IFR0+IM1
.11f3	d0 03		bne $11f8			bne 	_GONext
.11f5	4c d7 14	jmp $14d7			jmp 	RUNNewLine
.11f8					_GONext:
.11f8	18		clc				clc 								; advance to next line.
.11f9	b2 18		lda ($18)			lda 	(codePtr)
.11fb	65 18		adc $18				adc 	codePtr
.11fd	85 18		sta $18				sta 	codePtr
.11ff	90 e1		bcc $11e2			bcc 	_GOSearch
.1201	e6 19		inc $19				inc 	codePtr+1
.1203	80 dd		bra $11e2			bra 	_GOSearch
.1205					_GOError:
.1205	4c 03 27	jmp $2703		jmp	ErrorV_line

;******  Return to file: include.files


;******  Processing file: src/commands/inputprint.asm

.1208					Command_Input:
.1208	a9 ff		lda #$ff			lda 	#$FF
.120a	8d 06 05	sta $0506			sta 	InputFlag
.120d	80 03		bra $1212			bra 	Command_IP_Main
.120f					Command_Print:
.120f	9c 06 05	stz $0506			stz 	InputFlag
.1212					Command_IP_Main:
.1212	18		clc				clc 								; carry being clear means last print wasn't comma/semicolon
.1213					_CPLoop:
.1213	08		php				php 								; save last action flag
.1214	b1 18		lda ($18),y			lda 	(codePtr),y 				; get next character
.1216	c9 8c		cmp #$8c			cmp  	#PR_LSQLSQENDRSQRSQ 		; end of line or colon, exit now.
.1218	f0 4e		beq $1268			beq 	_CPExit 					; without consuming
.121a	c9 9b		cmp #$9b			cmp 	#PR_COLON
.121c	f0 4a		beq $1268			beq 	_CPExit
.121e	68		pla				pla 								; throw last action flag
.121f	b1 18		lda ($18),y			lda 	(codePtr),y 				; next character and bump
.1221	c8		iny				iny
.1222	c9 9a		cmp #$9a			cmp 	#PR_SEMICOLON				; is it a semicolon
.1224	f0 3f		beq $1265			beq 	_CPContinueWithSameLine
.1226	c9 99		cmp #$99			cmp 	#PR_COMMA 					; comma
.1228	f0 36		beq $1260			beq 	_CPTab
.122a	88		dey				dey 								; undo the get.
.122b	2c 06 05	bit $0506			bit 	InputFlag 					; check for Input
.122e	10 0b		bpl $123b			bpl	 	_CPNotInput
.1230	29 c0		and #$c0			and 	#$C0 						; check 40-7F e.g. an identifier.
.1232	c9 40		cmp #$40			cmp 	#$40
.1234	d0 05		bne $123b			bne 	_CPNotInput
.1236	20 71 12	jsr $1271			jsr 	_CPInputCode 				; input code
.1239	80 d7		bra $1212			bra 	Command_IP_Main 			; and go round again.
.123b					_CPNotInput:
.123b	20 c6 16	jsr $16c6			jsr 	EXPEvaluateExpression 		; evaluate expression.
.123e	24 0b		bit $0b				bit 	IFR0+IExp 					; is it a number ?
.1240	10 14		bpl $1256			bpl 	_CPNumber
.1242	5a		phy				phy
.1243	18		clc				clc 								; string address to YX
.1244	a5 08		lda $08				lda 	IFR0+IM0
.1246	aa		tax				tax
.1247	a5 09		lda $09				lda 	IFR0+IM1
.1249	a8		tay				tay
.124a	e8		inx				inx 								; point to 1st character
.124b	d0 01		bne $124e			bne 	_CPNoCarry
.124d	c8		iny				iny
.124e					_CPNoCarry:
.124e	b2 08		lda ($08)			lda 	(IFR0+IM0)					; length to A
.1250	20 a5 12	jsr $12a5			jsr 	CPPrintAYX 					; print AYX
.1253	7a		ply				ply
.1254	80 bc		bra $1212			bra 	Command_IP_Main 			; loop round clearing carry so NL if end
.1256					_CPNumber:
.1256	5a		phy				phy
.1257	20 c8 2e	jsr $2ec8			jsr 	IFloatFloatToStringR0 		; convert to string at YX length A
.125a	20 a5 12	jsr $12a5			jsr 	CPPrintAYX 					; print AYX
.125d	7a		ply				ply
.125e	80 b2		bra $1212			bra 	Command_IP_Main				; loop round clearing carry so NL if end
.1260					_CPTab:
.1260	a9 09		lda #$09			lda 	#9 							; print TAB
.1262	20 bb 12	jsr $12bb			jsr 	CPPrintA
.1265					_CPContinueWithSameLine:
.1265	38		sec				sec 								; loop round with carry set, which
.1266	80 ab		bra $1213			bra 	_CPLoop 					; will inhibit final CR
.1268					_CPExit:
.1268	28		plp				plp 								; get last action flag
.1269	b0 05		bcs $1270			bcs 	_CPExit2  					; carry set, last was semicolon or comma
.126b	a9 0d		lda #$0d			lda 	#13 						; print new line
.126d	20 bb 12	jsr $12bb			jsr 	CPPrintA
.1270					_CPExit2:
.1270	60		rts				rts
.1271					_CPInputCode:
.1271	20 8e 17	jsr $178e			jsr 	EXPTermR0 					; get the term.
.1274	5a		phy				phy 								; save position
.1275	20 b8 12	jsr $12b8			jsr 	CPInputA					; input a line to YX
.1278	a5 0b		lda $0b				lda 	IFR0+IExp 					; string ?
.127a	30 18		bmi $1294			bmi 	_CPInputString
.127c	a5 08		lda $08				lda 	IFR0+IM0 					; push target address on stack
.127e	48		pha				pha
.127f	a5 09		lda $09				lda 	IFR0+IM1
.1281	48		pha				pha
.1282	86 22		stx $22				stx 	zTemp0 						; use VAL Code to convert.
.1284	84 23		sty $23				sty 	zTemp0+1
.1286	20 70 1a	jsr $1a70			jsr 	VALConversionZTemp0
.1289	68		pla				pla 								; do the assign.
.128a	85 23		sta $23				sta 	zTemp0+1
.128c	68		pla				pla
.128d	85 22		sta $22				sta 	zTemp0
.128f	20 e3 12	jsr $12e3			jsr 	AssignNumber
.1292	7a		ply				ply
.1293	60		rts				rts
.1294					_CPInputString:
.1294	a5 08		lda $08				lda 	IFR0+IM0 					; copy target address to zTemp0
.1296	85 22		sta $22				sta 	zTemp0
.1298	a5 09		lda $09				lda 	IFR0+IM1
.129a	85 23		sta $23				sta 	zTemp0+1
.129c	86 08		stx $08				stx 	IFR0+IM0 					; string YX in result register
.129e	84 09		sty $09				sty 	IFR0+IM1
.12a0	20 fa 12	jsr $12fa			jsr 	AssignString 				; assign the string
.12a3	7a		ply				ply 								; exit
.12a4	60		rts				rts
.12a5					CPPrintAYX:
.12a5	86 22		stx $22				stx 	zTemp0
.12a7	84 23		sty $23				sty 	zTemp0+1
.12a9	aa		tax				tax
.12aa	f0 0b		beq $12b7			beq 	_CPPrintExit
.12ac	a0 00		ldy #$00			ldy 	#0
.12ae					_CPPrintAYXLoop:
.12ae	b1 22		lda ($22),y			lda 	(zTemp0),y
.12b0	20 bb 12	jsr $12bb			jsr 	CPPrintA
.12b3	c8		iny				iny
.12b4	ca		dex				dex
.12b5	d0 f7		bne $12ae			bne 	_CPPrintAYXLoop
.12b7					_CPPrintExit:
.12b7	60		rts				rts
.12b8					CPInputA:
.12b8	4c d6 ff	jmp $ffd6			jmp 	OSEditNewLine
.12bb					CPPrintA:
.12bb	4c f1 ff	jmp $fff1			jmp 	OSWriteScreen
.0506					InputFlag:
>0506							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/commands/let.asm

.12be					CommandLET:
.12be	20 8e 17	jsr $178e			jsr 	EXPTermR0 					; get term
.12c1	90 6f		bcc $1332			bcc 	CLError 					; must be a reference term.
.12c3	a5 08		lda $08				lda 	IFR0+IM0 					; push address and type onto stack
.12c5	48		pha				pha
.12c6	a5 09		lda $09				lda 	IFR0+IM1
.12c8	48		pha				pha
.12c9	a5 0b		lda $0b				lda 	IFR0+IExp
.12cb	48		pha				pha
.12cc	a9 ef		lda #$ef			lda 	#PR_EQUAL 					; equals for syntax
.12ce	20 33 27	jsr $2733			jsr 	ERRCheckA
.12d1	20 c6 16	jsr $16c6			jsr 	EXPEvaluateExpression 		; right hand side.
.12d4	68		pla				pla 								; type of l-expr
.12d5	45 0b		eor $0b				eor 	IFR0+IExp 					; check types match
.12d7	30 5c		bmi $1335			bmi 	CLType
.12d9	fa		plx				plx 	 							; pop target address to zTemp0
.12da	86 23		stx $23				stx 	zTemp0+1
.12dc	fa		plx				plx
.12dd	86 22		stx $22				stx 	zTemp0
.12df					AssignData:
.12df	a5 0b		lda $0b				lda 	IFR0+IExp 					; string assignment
.12e1	30 17		bmi $12fa			bmi 	AssignString
.12e3					AssignNumber:
.12e3	5a		phy				phy
.12e4	a0 03		ldy #$03			ldy 	#3
.12e6	a5 0b		lda $0b				lda 	IFR0+IExp
.12e8	91 22		sta ($22),y			sta 	(zTemp0),y
.12ea	88		dey				dey
.12eb	a5 0a		lda $0a				lda 	IFR0+IM2
.12ed	91 22		sta ($22),y			sta 	(zTemp0),y
.12ef	88		dey				dey
.12f0	a5 09		lda $09				lda 	IFR0+IM1
.12f2	91 22		sta ($22),y			sta 	(zTemp0),y
.12f4	a5 08		lda $08				lda 	IFR0+IM0
.12f6	92 22		sta ($22)			sta 	(zTemp0)
.12f8	7a		ply				ply
.12f9	60		rts				rts
.12fa					AssignString:
.12fa	5a		phy				phy
.12fb	a0 01		ldy #$01			ldy 	#1 							; check if any concreted string.
.12fd	b1 22		lda ($22),y			lda 	(zTemp0),y
.12ff	12 22		ora ($22)			ora 	(zTemp0)
.1301	f0 23		beq $1326			beq 	_CLConcreteString
.1303	b2 22		lda ($22)			lda 	(zTemp0) 					; copy address of string to zTemp1
.1305	85 24		sta $24				sta 	zTemp1
.1307	b1 22		lda ($22),y			lda 	(zTemp0),y
.1309	85 25		sta $25				sta 	zTemp1+1
.130b	b2 24		lda ($24)			lda 	(zTemp1) 					; bytes available in the new slot
.130d	38		sec				sec 								; we want 3 for slot size, status, string size.
.130e	e9 03		sbc #$03			sbc 	#3
.1310	d2 08		cmp ($08)			cmp 	(IFR0) 						; compare against string size.
.1312	90 12		bcc $1326			bcc 	_CLConcreteString 			; if so, concrete the string again.
.1314	b2 08		lda ($08)			lda 	(IFR0) 						; copy size + 1 bytes (for the length byte.)
.1316	1a		inc a				inc 	a
.1317	aa		tax				tax
.1318	a0 00		ldy #$00			ldy 	#0 							; offset in replacement string.
.131a					_CLReplaceString:
.131a	b1 08		lda ($08),y			lda 	(IFR0),y 					; copy new string into previous space.
.131c	c8		iny				iny
.131d	c8		iny				iny
.131e	91 24		sta ($24),y			sta 	(zTemp1),y
.1320	88		dey				dey
.1321	ca		dex				dex
.1322	d0 f6		bne $131a			bne 	_CLReplaceString
.1324	80 0a		bra $1330			bra 	_CLExit
.1326					_CLConcreteString:
.1326	20 a6 27	jsr $27a6			jsr 	StringConcrete  			; concreted string in XA.
.1329	a0 01		ldy #$01			ldy 	#1 							; store the address
.132b	92 22		sta ($22)			sta 	(zTemp0)
.132d	8a		txa				txa
.132e	91 22		sta ($22),y			sta 	(zTemp0),y
.1330					_CLExit:
.1330	7a		ply				ply
.1331	60		rts				rts
.1332					CLError:
.1332	4c a1 26	jmp $26a1		jmp	ErrorV_variable
.1335					CLType:
.1335	4c 9e 25	jmp $259e		jmp	ErrorV_type

;******  Return to file: include.files


;******  Processing file: src/commands/list.asm

.1338					Command_LIST:
.1338	9c 07 05	stz $0507			stz 	CLFrom 						; default from
.133b	9c 08 05	stz $0508			stz 	CLFrom+1
.133e	b1 18		lda ($18),y			lda 	(codePtr),y 				; is there a to line (e.g. LIST ,xxx)
.1340	c9 99		cmp #$99			cmp 	#PR_COMMA
.1342	f0 1d		beq $1361			beq 	_CLToLine
.1344	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; EOL, default TO
.1346	f0 37		beq $137f			beq 	_CLDefaultTo
.1348	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 			; from value *and* to value now.
.134b	a5 08		lda $08				lda 	IFR0+IM0
.134d	8d 07 05	sta $0507			sta 	CLFrom
.1350	8d 09 05	sta $0509			sta 	CLTo
.1353	a5 09		lda $09				lda 	IFR0+IM1
.1355	8d 08 05	sta $0508			sta 	CLFrom+1
.1358	8d 0a 05	sta $050a			sta 	CLTo+1
.135b	b1 18		lda ($18),y			lda 	(codePtr),y
.135d	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; that's the lot ?
.135f	f0 26		beq $1387			beq 	_CLList
.1361					_CLToLine:
.1361	b1 18		lda ($18),y			lda 	(codePtr),y 				; what follows.
.1363	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; EOL, default TO
.1365	f0 18		beq $137f			beq 	_CLDefaultTo
.1367	20 2b 27	jsr $272b			jsr 	ERRCheckComma 				; sep comma
.136a	b1 18		lda ($18),y			lda 	(codePtr),y 				; if it is just LIST , then default TO
.136c	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ
.136e	f0 0f		beq $137f			beq 	_CLDefaultTo
.1370	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 			; there's a To value.
.1373	a5 08		lda $08				lda 	IFR0+IM0
.1375	8d 09 05	sta $0509			sta 	CLTo
.1378	a5 09		lda $09				lda 	IFR0+IM1
.137a	8d 0a 05	sta $050a			sta 	CLTo+1
.137d	80 08		bra $1387			bra 	_CLList
.137f					_CLDefaultTo:
.137f	a9 ff		lda #$ff			lda 	#$FF
.1381	8d 09 05	sta $0509			sta 	CLTo
.1384	8d 0a 05	sta $050a			sta 	CLTo+1
.1387					_CLList:
.1387	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; back to the program start
.138a	85 19		sta $19				sta 	codePtr+1
.138c	64 18		stz $18				stz 	codePtr
.138e	a2 f1		ldx #$f1			ldx 	#OSWriteScreen & $FF 		; tokenise output to screen.
.1390	a0 ff		ldy #$ff			ldy 	#OSWriteScreen >> 8
.1392	20 a4 1d	jsr $1da4			jsr 	TOKSetDetokeniseOutput
.1395					_CLLoop:
.1395	b2 18		lda ($18)			lda 	(codePtr) 					; finished
.1397	f0 4a		beq $13e3			beq 	_CLExit
.1399	20 e2 ff	jsr $ffe2			jsr 	OSKeyboardDataProcess
.139c	20 e5 ff	jsr $ffe5			jsr 	OSCheckBreak 				; check escape.
.139f	d0 45		bne $13e6			bne 	_CLBreak
.13a1	a2 00		ldx #$00			ldx 	#CLFrom-CLFrom 				; compare line number vs from
.13a3	20 e9 13	jsr $13e9			jsr 	_CLCompareLine
.13a6	c9 ff		cmp #$ff			cmp 	#255 						; < from then skip
.13a8	f0 2c		beq $13d6			beq 	_CLNext
.13aa	a2 02		ldx #$02			ldx 	#CLTo-CLFrom   				; compare line number vs IFR0
.13ac	20 e9 13	jsr $13e9			jsr 	_CLCompareLine
.13af	c9 01		cmp #$01			cmp 	#1 							; > to then skip
.13b1	f0 23		beq $13d6			beq 	_CLNext
.13b3	a0 02		ldy #$02			ldy 	#2 							; print line #
.13b5	b1 18		lda ($18),y			lda 	(codePtr),y
.13b7	aa		tax				tax
.13b8	88		dey				dey
.13b9	b1 18		lda ($18),y			lda 	(codePtr),y
.13bb	20 84 28	jsr $2884			jsr 	WriteIntXA
.13be	a9 20		lda #$20			lda 	#32
.13c0	20 f1 ff	jsr $fff1			jsr 	OSWriteScreen
.13c3	a4 19		ldy $19				ldy 	codePtr+1 					; point YX to tokenised code/
.13c5	a5 18		lda $18				lda 	codePtr
.13c7	18		clc				clc
.13c8	69 03		adc #$03			adc 	#3
.13ca	aa		tax				tax
.13cb	90 01		bcc $13ce			bcc 	_CLNoCarry2
.13cd	c8		iny				iny
.13ce					_CLNoCarry2:
.13ce	20 5f 1d	jsr $1d5f			jsr 	TOKDetokenise
.13d1	a9 0d		lda #$0d			lda 	#13	 						; next line
.13d3	20 f1 ff	jsr $fff1			jsr 	OSWriteScreen
.13d6					_CLNext:
.13d6	18		clc				clc 								; advance to next line.
.13d7	b2 18		lda ($18)			lda 	(codePtr)
.13d9	65 18		adc $18				adc 	codePtr
.13db	85 18		sta $18				sta 	codePtr
.13dd	90 02		bcc $13e1			bcc 	_CLNoCarry
.13df	e6 19		inc $19				inc 	codePtr+1
.13e1					_CLNoCarry:
.13e1	80 b2		bra $1395			bra 	_CLLoop
.13e3					_CLExit:
.13e3	4c a3 28	jmp $28a3			jmp 	WarmStart
.13e6					_CLBreak:
.13e6	4c f9 26	jmp $26f9		jmp	ErrorV_break
.13e9					_CLCompareLine:
.13e9	a0 01		ldy #$01			ldy 	#1
.13eb	38		sec				sec
.13ec	b1 18		lda ($18),y			lda 	(codePtr),y
.13ee	fd 07 05	sbc $0507,x			sbc 	CLFrom,x
.13f1	85 22		sta $22				sta 	zTemp0
.13f3	c8		iny				iny
.13f4	b1 18		lda ($18),y			lda 	(codePtr),y
.13f6	fd 08 05	sbc $0508,x			sbc 	CLFrom+1,x
.13f9	90 0a		bcc $1405			bcc 	_CLIsNegative
.13fb	d0 05		bne $1402			bne 	_CLIsPositive
.13fd	a5 22		lda $22				lda 	zTemp0
.13ff	d0 01		bne $1402			bne 	_CLIsPositive
.1401	60		rts				rts
.1402					_CLIsPositive:
.1402	a9 01		lda #$01			lda 	#1
.1404	60		rts				rts
.1405					_CLIsNegative:
.1405	a9 ff		lda #$ff			lda 	#255
.1407	60		rts				rts
.0507					CLFrom:
>0507							.fill 	2
.0509					CLTo:
>0509							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/commands/new.asm

.1408					Command_NEW:
.1408	20 49 1f	jsr $1f49			jsr 	PGMNewProgram
.140b	20 3f 10	jsr $103f			jsr 	ClearCode
.140e	4c 2b 15	jmp $152b			jmp 	Command_END

;******  Return to file: include.files


;******  Processing file: src/commands/readdata.asm

.1411					Command_READ:
.1411	20 8e 17	jsr $178e			jsr 	EXPTermR0 					; get term to R0
.1414	90 35		bcc $144b			bcc 	_CRSyntax 					; fail if not a reference.
.1416	a5 08		lda $08				lda 	IFR0+IM0 					; push address on the stack
.1418	48		pha				pha
.1419	a5 09		lda $09				lda 	IFR0+IM1
.141b	48		pha				pha
.141c	a5 0b		lda $0b				lda 	IFR0+IExp 					; push type on the stack
.141e	48		pha				pha
.141f	20 a4 14	jsr $14a4			jsr 	SwapCodeDataPointers 		; swap code and data pointers over
.1422	ad 0f 05	lda $050f			lda 	dataInStatement 			; if in a data statement, we don't need to search
.1425	d0 27		bne $144e			bne 	_CRHaveData  				; forward for the next one.
.1427					_CRNextLine:
.1427	b2 18		lda ($18)			lda 	(codePtr)					; check end of program, e.g. nothing more to READ.
.1429	f0 1a		beq $1445			beq 	_CRNoData
.142b					_CRKeepSearching:
.142b	a9 ab		lda #$ab			lda 	#PR_DATA 					; scan for instruction DATA or EOL.
.142d	a2 8c		ldx #$8c			ldx 	#PR_LSQLSQENDRSQRSQ
.142f	20 7e 24	jsr $247e			jsr 	ScanForward
.1432	c9 ab		cmp #$ab			cmp 	#PR_DATA 					; found data ?
.1434	f0 18		beq $144e			beq 	_CRHaveData 				; found it
.1436	a0 03		ldy #$03			ldy 	#3 							; position in next line.
.1438	18		clc				clc 								; try the next line, keep going.
.1439	b2 18		lda ($18)			lda 	(codePtr)
.143b	65 18		adc $18				adc 	codePtr
.143d	85 18		sta $18				sta 	codePtr
.143f	90 e6		bcc $1427			bcc 	_CRNextLine
.1441	e6 19		inc $19				inc 	codePtr+1
.1443	80 e2		bra $1427			bra 	_CRNextLine
.1445					_CRNoData:
.1445	4c 26 26	jmp $2626		jmp	ErrorV_data
.1448					_CLType:
.1448	4c 9e 25	jmp $259e		jmp	ErrorV_type
.144b					_CRSyntax:
.144b	4c 6e 25	jmp $256e		jmp	ErrorV_syntax
.144e					_CRHaveData:
.144e	20 c6 16	jsr $16c6			jsr 	EXPEvaluateExpression 		; some sort of value here -> R0
.1451	68		pla				pla 								; type of l-expr
.1452	45 0b		eor $0b				eor 	IFR0+IExp 					; check types match
.1454	30 f2		bmi $1448			bmi 	_CLType
.1456	68		pla				pla 								; restore address
.1457	85 23		sta $23				sta 	zTemp0+1
.1459	68		pla				pla
.145a	85 22		sta $22				sta 	zTemp0
.145c	20 df 12	jsr $12df			jsr 	AssignData 					; write R0 there.
.145f	9c 0f 05	stz $050f			stz 	dataInStatement 			; clear in data flag
.1462	b1 18		lda ($18),y			lda 	(codePtr),y 				; data followed by a comma,e.g. more data follows
.1464	c9 99		cmp #$99			cmp 	#PR_COMMA 					; if not, end of data statement and exit
.1466	d0 04		bne $146c			bne 	_CRSwapBack
.1468	c8		iny				iny 								; consume comma
.1469	ee 0f 05	inc $050f			inc 	dataInStatement 			; set in data statement flag.
.146c					_CRSwapBack:
.146c	20 a4 14	jsr $14a4			jsr 	SwapCodeDataPointers		; swap them back.
.146f	b1 18		lda ($18),y			lda 	(codePtr),y 				; l-expr was followed by a comma
.1471	c8		iny				iny
.1472	c9 99		cmp #$99			cmp 	#PR_COMMA
.1474	f0 9b		beq $1411			beq 	Command_READ 				; if so go round again.
.1476	88		dey				dey 								; unpick get.
.1477	60		rts				rts
.1478					Command_DATA:
.1478	a9 9b		lda #$9b			lda 	#PR_COLON 					; scan forward to : or EOL
.147a	a2 8c		ldx #$8c			ldx 	#PR_LSQLSQENDRSQRSQ
.147c	20 7e 24	jsr $247e			jsr 	ScanForward
.147f	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; unconsume the EOL
.1481	d0 01		bne $1484			bne 	_CDNotEOL
.1483	88		dey				dey
.1484					_CDNotEOL:
.1484	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/rem.asm

.1485					Command_REM:
.1485					Command_REM2:
.1485	b1 18		lda ($18),y			lda 	(codePtr),y 				; optional string parameter
.1487	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ
.1489	d0 06		bne $1491			bne 	_CRExit
.148b	c8		iny				iny 								; skip over it, it's a comment.
.148c	98		tya				tya
.148d	38		sec				sec
.148e	71 18		adc ($18),y			adc 	(codePtr),y
.1490	a8		tay				tay
.1491					_CRExit:
.1491	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/commands/restore.asm

.1492					S
.1492					Command_RESTORE:
.1492	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; back to the program start
.1495	8d 0c 05	sta $050c			sta 	dataPtr+1
.1498	9c 0b 05	stz $050b			stz 	dataPtr
.149b	a9 03		lda #$03			lda 	#3 							; position start of line
.149d	8d 0d 05	sta $050d			sta 	dataPos
.14a0	9c 0f 05	stz $050f			stz 	dataInStatement 			; not in statement
.14a3	60		rts				rts
.14a4					SwapCodeDataPointers:
.14a4	ad 0b 05	lda $050b			lda 	dataPtr 					; swap LSB of code/data
.14a7	a6 18		ldx $18				ldx 	codePtr
.14a9	85 18		sta $18				sta 	codePtr
.14ab	8e 0b 05	stx $050b			stx 	dataPtr
.14ae	ad 0c 05	lda $050c			lda 	dataPtr+1 					; swap MSB of code/data
.14b1	a6 19		ldx $19				ldx 	codePtr+1
.14b3	85 19		sta $19				sta 	codePtr+1
.14b5	8e 0c 05	stx $050c			stx 	dataPtr+1
.14b8	ad 0d 05	lda $050d			lda 	dataPos 					; swap dataPos and Y
.14bb	8c 0d 05	sty $050d			sty 	dataPos
.14be	a8		tay				tay
.14bf	60		rts				rts
.050b					dataPtr:
>050b							.fill 	2
.050d					dataPos:
>050d							.fill 	2
.050f					dataInStatement:
>050f							.fill 	1		 					; (should be pointing at , : or EOL)

;******  Return to file: include.files


;******  Processing file: src/commands/run.asm

.14c0					Command_RUN:
.14c0	20 3f 10	jsr $103f			jsr 	ClearCode					; clear everything out.
.14c3	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; back to the program start
.14c6	85 19		sta $19				sta 	codePtr+1
.14c8	64 18		stz $18				stz 	codePtr
.14ca	80 0b		bra $14d7			bra 	RUNNewLine
.14cc					RUNEndOfLine:
.14cc	18		clc				clc 								; advance to next line.
.14cd	b2 18		lda ($18)			lda 	(codePtr)
.14cf	65 18		adc $18				adc 	codePtr
.14d1	85 18		sta $18				sta 	codePtr
.14d3	90 02		bcc $14d7			bcc 	_RELNoCarry
.14d5	e6 19		inc $19				inc 	codePtr+1
.14d7					_RELNoCarry:
.14d7					RUNNewLine:
.14d7	a2 ff		ldx #$ff			ldx 	#$FF 						; 6502 stack reset.
.14d9	9a		txs				txs
.14da	b2 18		lda ($18)			lda 	(codePtr) 					; check off end of program
.14dc	f0 4d		beq $152b			beq 	Command_END
.14de	a0 01		ldy #$01			ldy 	#1 							; copy error line#
.14e0	b1 18		lda ($18),y			lda 	(codePtr),y
.14e2	8d 26 06	sta $0626			sta 	ERRLine
.14e5	c8		iny				iny
.14e6	b1 18		lda ($18),y			lda 	(codePtr),y
.14e8	8d 27 06	sta $0627			sta 	ERRLine+1
.14eb	c8		iny				iny 								; offset into codePtr for start of line.
.14ec					RUNNewCommand:
.14ec	9c 21 06	stz $0621			stz 	stringInitialised 			; reset string system.
.14ef	ce 10 05	dec $0510			dec 	checkCounter
.14f2	d0 0a		bne $14fe			bne 	_RNCNoCheck
.14f4	5a		phy				phy 								; keyboard check.
.14f5	20 e2 ff	jsr $ffe2			jsr 	OSKeyboardDataProcess
.14f8	7a		ply				ply
.14f9	20 e5 ff	jsr $ffe5			jsr 	OSCheckBreak 				; check escape.
.14fc	d0 1e		bne $151c			bne 	_RUNBreak
.14fe					_RNCNoCheck:
.14fe	b1 18		lda ($18),y			lda 	(codePtr),y 				; get next token
.1500	10 1d		bpl $151f			bpl		_RUNNotToken 				; probably an identifier
.1502	c8		iny				iny 								; consume token
.1503	c9 9b		cmp #$9b			cmp 	#PR_COLON 					; fast skip colon
.1505	f0 e5		beq $14ec			beq 	RUNNewCommand
.1507	c9 b0		cmp #$b0			cmp 	#PR_STANDARD_LAST+1 		; check unary function
.1509	b0 0e		bcs $1519			bcs 	_RUNSyntax
.150b	c9 80		cmp #$80			cmp 	#PR_STRUCTURE_FIRST 		; adjust for binaries at start.
.150d	90 0a		bcc $1519			bcc 	_RUNSyntax
.150f	0a		asl a				asl 	a 							; double into X.
.1510	aa		tax				tax
.1511	20 16 15	jsr $1516			jsr 	_RUNDispatchMain			; call the main dispatcher
.1514	80 d6		bra $14ec			bra 	RUNNewCommand
.1516					_RUNDispatchMain:
.1516	7c 5f 1c	jmp ($1c5f,x)			jmp 	(VectorTable,x)
.1519					_RUNSyntax:
.1519	4c 6e 25	jmp $256e		jmp	ErrorV_syntax
.151c					_RUNBreak:
.151c	4c f9 26	jmp $26f9		jmp	ErrorV_break
.151f					_RUNNotToken:
.151f	c9 40		cmp #$40			cmp 	#$40 						; 00-3F is a syntax error
.1521	90 f6		bcc $1519			bcc 	_RUNSyntax
.1523	20 be 12	jsr $12be			jsr 	CommandLET 					; assignment
.1526	80 c4		bra $14ec			bra 	RUNNewCommand 				; loop round.
.1528					Command_Shift_Handler:
.1528	4c b0 25	jmp $25b0		jmp	ErrorV_unimplemented
.152b					Command_END:
.152b	4c a3 28	jmp $28a3			jmp 	WarmStart
.0510					checkCounter:
>0510							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/commands/stop.asm

.152e					Command_STOP:
.152e	4c 12 26	jmp $2612		jmp	ErrorV_stop

;******  Return to file: include.files


;******  Processing file: src/commands/sys.asm

.1531					Command_Sys:
.1531	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 			; execution address
.1534	5a		phy				phy
.1535	ad 6e 06	lda $066e			lda 	('A'-'A')*4 + FastVariables ; load AXY
.1538	ae ca 06	ldx $06ca			ldx 	('X'-'A')*4 + FastVariables
.153b	ac ce 06	ldy $06ce			ldy 	('Y'-'A')*4 + FastVariables
.153e	20 43 15	jsr $1543			jsr 	_CSCallIFR0 				; call the code
.1541	7a		ply				ply
.1542	60		rts				rts
.1543					_CSCallIFR0:
.1543	6c 08 00	jmp ($0008)			jmp 	(IFR0+IM0)

;******  Return to file: include.files


;******  Processing file: src/commands/unused.asm

.1546					NoExec01:
.1546					NoExec02:
.1546					NoExec03:
.1546					NoExec04:
.1546					NoExec05:
.1546					NoExec06:
.1546					NoExec07:
.1546					NoExec08:
.1546	4c 6e 25	jmp $256e		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/binary/basic.asm

.1549					EXPBinAdd:
.1549	24 0b		bit $0b				bit 	IFR0+IExp
.154b	30 6f		bmi $15bc			bmi 	EXPConcatenate
.154d	a2 0c		ldx #$0c			ldx 	#IFR1
.154f	4c c1 2a	jmp $2ac1			jmp 	IFloatAdd
.1552					EXPBinSub:
.1552	24 0b		bit $0b				bit 	IFR0+IExp
.1554	30 3f		bmi $1595			bmi 	EXPTypeError
.1556	a2 0c		ldx #$0c			ldx 	#IFR1
.1558	4c ba 2a	jmp $2aba			jmp 	IFloatSubtract
.155b					EXPBinMul:
.155b	24 0b		bit $0b				bit 	IFR0+IExp
.155d	30 36		bmi $1595			bmi 	EXPTypeError
.155f	a2 0c		ldx #$0c			ldx 	#IFR1
.1561	4c 6b 2b	jmp $2b6b			jmp 	IFloatMultiply
.1564					EXPBinFDiv:
.1564	24 0b		bit $0b				bit 	IFR0+IExp
.1566	30 2d		bmi $1595			bmi 	EXPTypeError
.1568	a2 0c		ldx #$0c			ldx 	#IFR1
.156a	20 ee 2d	jsr $2dee			jsr 	IFloatDivideFloat
.156d	b0 0f		bcs $157e			bcs 	EXPDZero
.156f	60		rts				rts
.1570					EXPBinIDiv:
.1570	24 0b		bit $0b				bit 	IFR0+IExp
.1572	30 21		bmi $1595			bmi 	EXPTypeError
.1574	a2 0c		ldx #$0c			ldx 	#IFR1
.1576	20 ee 2d	jsr $2dee			jsr 	IFloatDivideFloat
.1579	b0 03		bcs $157e			bcs 	EXPDZero
.157b	4c cb 2d	jmp $2dcb			jmp 	IFloatIntegerR0
.157e					EXPDZero:
.157e	4c e7 25	jmp $25e7		jmp	ErrorV_divzero
.1581					EXPBinIMod:
.1581	24 0b		bit $0b				bit 	IFR0+IExp
.1583	30 10		bmi $1595			bmi 	EXPTypeError
.1585	a2 0c		ldx #$0c			ldx 	#IFR1
.1587	5a		phy				phy
.1588	20 03 2d	jsr $2d03			jsr 	IFPreProcessBitwise 		; set up everything.
.158b	d0 05		bne $1592			bne 	EXPDRange
.158d	20 3c 2c	jsr $2c3c			jsr 	IFloatModulusInteger
.1590	7a		ply				ply
.1591	60		rts				rts
.1592					EXPDRange:
.1592	4c 7f 25	jmp $257f		jmp	ErrorV_range
.1595					EXPTypeError:
.1595	4c 9e 25	jmp $259e		jmp	ErrorV_type
.1598					EXPBinAnd:
.1598	24 0b		bit $0b				bit 	IFR0+IExp
.159a	30 f9		bmi $1595			bmi 	EXPTypeError
.159c	a2 0c		ldx #$0c			ldx 	#IFR1
.159e	20 be 2c	jsr $2cbe			jsr 	IFloatBitwiseAnd
.15a1	b0 ef		bcs $1592			bcs 	EXPDRange
.15a3	60		rts				rts
.15a4					EXPBinOr:
.15a4	24 0b		bit $0b				bit 	IFR0+IExp
.15a6	30 ed		bmi $1595			bmi 	EXPTypeError
.15a8	a2 0c		ldx #$0c			ldx 	#IFR1
.15aa	20 d5 2c	jsr $2cd5			jsr 	IFloatBitwiseOr
.15ad	b0 e3		bcs $1592			bcs 	EXPDRange
.15af	60		rts				rts
.15b0					EXPBinXor:
.15b0	24 0b		bit $0b				bit 	IFR0+IExp
.15b2	30 e1		bmi $1595			bmi 	EXPTypeError
.15b4	a2 0c		ldx #$0c			ldx 	#IFR1
.15b6	20 ec 2c	jsr $2cec			jsr 	IFloatBitwiseXor
.15b9	b0 d7		bcs $1592			bcs 	EXPDRange
.15bb	60		rts				rts
.15bc					EXPConcatenate:
.15bc	18		clc				clc
.15bd	b2 08		lda ($08)			lda 	(IFR0) 	 					; work out total length
.15bf	72 0c		adc ($0c)			adc 	(IFR1)
.15c1	b0 2d		bcs $15f0			bcs 	_EXPCError
.15c3	a6 08		ldx $08				ldx 	IFR0 						; push R0 string on stack.
.15c5	da		phx				phx
.15c6	a6 09		ldx $09				ldx 	IFR0+1
.15c8	da		phx				phx
.15c9	20 19 28	jsr $2819			jsr 	StringTempAllocate 			; allocate string, set up return
.15cc	a6 0d		ldx $0d				ldx 	IFR1+1 						; copy first string.
.15ce	a5 0c		lda $0c				lda 	IFR1
.15d0	20 d9 15	jsr $15d9			jsr 	_EXPCCopyXA
.15d3	fa		plx				plx 								; copy second string
.15d4	68		pla				pla
.15d5	20 d9 15	jsr $15d9			jsr 	_EXPCCopyXA
.15d8	60		rts				rts
.15d9					_EXPCCopyXA:
.15d9	86 23		stx $23				stx 	zTemp0+1 					; save address to zTemp0
.15db	85 22		sta $22				sta 	zTemp0
.15dd	b2 22		lda ($22)			lda 	(zTemp0)					; length
.15df	f0 0e		beq $15ef			beq 	_EXPCCExit 					; nothing.
.15e1	aa		tax				tax 								; count
.15e2	5a		phy				phy 								; start positioin
.15e3	a0 01		ldy #$01			ldy 	#1
.15e5					_EXPCCLoop:
.15e5	b1 22		lda ($22),y			lda 	(zTemp0),y 					; write characters one at a time.
.15e7	20 4e 28	jsr $284e			jsr 	StringTempWrite
.15ea	c8		iny				iny
.15eb	ca		dex				dex
.15ec	d0 f7		bne $15e5			bne 	_EXPCCLoop
.15ee	7a		ply				ply
.15ef					_EXPCCExit:
.15ef	60		rts				rts
.15f0					_EXPCError:
.15f0	4c 8b 26	jmp $268b		jmp	ErrorV_string

;******  Return to file: include.files


;******  Processing file: src/expression/binary/compare.asm

.15f3					EXPReturnTrue:
.15f3	a2 08		ldx #$08			ldx 	#IFR0
.15f5	a9 01		lda #$01			lda 	#1
.15f7	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.15fa	20 d6 30	jsr $30d6			jsr 	IFloatNegate
.15fd	60		rts				rts
.15fe					EXPReturnFalse:
.15fe	a2 08		ldx #$08			ldx 	#IFR0
.1600	4c cb 30	jmp $30cb			jmp 	IFloatSetZero
.1603					EXPCompareEqual:
.1603	20 39 16	jsr $1639			jsr 	EXPCompareBaseCode
.1606	c9 00		cmp #$00			cmp 	#0
.1608	f0 e9		beq $15f3			beq 	EXPReturnTrue
.160a	80 f2		bra $15fe			bra 	EXPReturnFalse
.160c					EXPCompareLess:
.160c	20 39 16	jsr $1639			jsr 	EXPCompareBaseCode
.160f	c9 ff		cmp #$ff			cmp 	#$FF
.1611	f0 e0		beq $15f3			beq 	EXPReturnTrue
.1613	80 e9		bra $15fe			bra 	EXPReturnFalse
.1615					EXPCompareGreater:
.1615	20 39 16	jsr $1639			jsr 	EXPCompareBaseCode
.1618	c9 01		cmp #$01			cmp 	#1
.161a	f0 d7		beq $15f3			beq 	EXPReturnTrue
.161c	80 e0		bra $15fe			bra 	EXPReturnFalse
.161e					EXPCompareNotEqual:
.161e	20 39 16	jsr $1639			jsr 	EXPCompareBaseCode
.1621	c9 00		cmp #$00			cmp 	#0
.1623	d0 ce		bne $15f3			bne 	EXPReturnTrue
.1625	80 d7		bra $15fe			bra 	EXPReturnFalse
.1627					EXPCompareLessEqual:
.1627	20 39 16	jsr $1639			jsr 	EXPCompareBaseCode
.162a	c9 01		cmp #$01			cmp 	#1
.162c	d0 c5		bne $15f3			bne 	EXPReturnTrue
.162e	80 ce		bra $15fe			bra 	EXPReturnFalse
.1630					EXPCompareGreaterEqual:
.1630	20 39 16	jsr $1639			jsr 	EXPCompareBaseCode
.1633	c9 ff		cmp #$ff			cmp 	#$FF
.1635	d0 bc		bne $15f3			bne 	EXPReturnTrue
.1637	80 c5		bra $15fe			bra 	EXPReturnFalse
.1639					EXPCompareBaseCode:
.1639	24 0b		bit $0b				bit 	IFR0+IExp 					; string compare ?
.163b	30 10		bmi $164d			bmi 	_EXCBCString
.163d	a2 0c		ldx #$0c			ldx 	#IFR1						; float compare
.163f	20 99 2d	jsr $2d99			jsr 	IFloatCompare
.1642	a5 08		lda $08				lda 	IFR0+IM0
.1644	f0 06		beq $164c			beq 	_EXCBCExit 					; return 0 if zero
.1646	24 0b		bit $0b				bit 	IFR0+IExp 					; return 1 if +ve
.1648	50 02		bvc $164c			bvc 	_EXCBCExit
.164a	a9 ff		lda #$ff			lda 	#255 						; return $FF if -ve
.164c					_EXCBCExit:
.164c	60		rts				rts
.164d					_EXCBCString:
.164d	5a		phy				phy
.164e	b2 08		lda ($08)			lda 	(IFR0) 						; length of smaller of the two in X.
.1650	d2 0c		cmp ($0c)			cmp 	(IFR1)
.1652	90 02		bcc $1656			bcc 	_EXCBCSmaller
.1654	b2 0c		lda ($0c)			lda 	(IFR1)
.1656					_EXCBCSmaller:
.1656	aa		tax				tax
.1657	f0 0d		beq $1666			beq 	_EXCBCMatches 				; if zero common length matches
.1659	a0 00		ldy #$00			ldy 	#0 							; match the strings.
.165b					_EXCBCCheckSmallerMatches:
.165b	c8		iny				iny 								; compare directly as far as common length
.165c	38		sec				sec
.165d	b1 0c		lda ($0c),y			lda 	(IFR1),y
.165f	f1 08		sbc ($08),y			sbc 	(IFR0),y
.1661	d0 08		bne $166b			bne 	_EXCBCExit2
.1663	ca		dex				dex
.1664	d0 f5		bne $165b			bne 	_EXCBCCheckSmallerMatches
.1666					_EXCBCMatches:
.1666	38		sec				sec
.1667	b2 0c		lda ($0c)			lda 	(IFR1) 						; common length matches. If same length equal
.1669	f2 08		sbc ($08)			sbc 	(IFR0)						; if len(r1) > len(r0) then r1 is longer
.166b					_EXCBCExit2:
.166b	7a		ply				ply
.166c	c9 00		cmp #$00			cmp 	#0
.166e	f0 04		beq $1674			beq 	_EXCBCReturn
.1670	30 03		bmi $1675			bmi 	_EXCBCFF
.1672	a9 01		lda #$01			lda 	#1
.1674					_EXCBCReturn:
.1674	60		rts				rts
.1675					_EXCBCFF:
.1675	a9 ff		lda #$ff			lda 	#$FF
.1677	60		rts				rts
.1678					_EXCBCRange:
.1678	4c 7f 25	jmp $257f		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/binary/shift.asm

.167b					EXPBinLeft:
.167b	a9 ff		lda #$ff			lda 	#$FF
.167d	8d 11 05	sta $0511			sta 	EXPShiftLeftFlag
.1680	4c 86 16	jmp $1686			jmp 	EXPShiftCommon
.1683					EXPBinRight:
.1683	9c 11 05	stz $0511			stz 	EXPShiftLeftFlag
.1686					EXPShiftCommon:
.1686	a5 0b		lda $0b				lda 	IFR0+IExp 					; both integers
.1688	05 0f		ora $0f				ora 	IFR1+IExp
.168a	29 7f		and #$7f			and 	#$7F
.168c	d0 35		bne $16c3			bne 	_EXPSRange
.168e	a5 08		lda $08				lda 	IFR0+IM0					; check shift >= 32
.1690	29 e0		and #$e0			and 	#$E0
.1692	05 09		ora $09				ora 	IFR0+IM1
.1694	05 0a		ora $0a				ora 	IFR0+IM2
.1696	d0 25		bne $16bd			bne 	_EXPSShiftZero 				; if so return zero
.1698	5a		phy				phy
.1699	a5 08		lda $08				lda 	IFR0+IM0 					; get shift
.169b	29 1f		and #$1f			and 	#$1F
.169d	f0 17		beq $16b6			beq 	_EXPSExit 					; exit if zero
.169f	a8		tay				tay
.16a0					_EXPSLoop:
.16a0	a2 0c		ldx #$0c			ldx 	#IFR1
.16a2	2c 11 05	bit $0511			bit 	EXPShiftLeftFlag
.16a5	30 05		bmi $16ac			bmi 	_EXPSShiftLeft
.16a7	20 fa 30	jsr $30fa			jsr 	IFloatShiftRight
.16aa	80 07		bra $16b3			bra 	_EXPSContinue
.16ac					_EXPSShiftLeft:
.16ac	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.16af	24 0a		bit $0a				bit 	IFR0+IM2 					; too many shifts
.16b1	30 10		bmi $16c3			bmi 	_EXPSRange
.16b3					_EXPSContinue:
.16b3	88		dey				dey
.16b4	d0 ea		bne $16a0			bne 	_EXPSLoop
.16b6					_EXPSExit:
.16b6	a2 0c		ldx #$0c			ldx 	#IFR1
.16b8	20 5c 30	jsr $305c			jsr 	IFloatCopyFromRegister
.16bb	7a		ply				ply
.16bc	60		rts				rts
.16bd					_EXPSShiftZero:
.16bd	a2 08		ldx #$08			ldx 	#IFR0
.16bf	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.16c2	60		rts				rts
.16c3					_EXPSRange:
.16c3	4c 7f 25	jmp $257f		jmp	ErrorV_range
.0511					EXPShiftLeftFlag:
>0511							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/expression/expression.asm

.16c6					EXPEvaluateExpression:
.16c6	a9 00		lda #$00			lda 	#0 							; current precedence
.16c8					EXPEvaluateExpressionPrecedenceA:
.16c8	48		pha				pha
.16c9	20 43 17	jsr $1743			jsr 	EXPTermValueR0				; do first term.
.16cc					_EELoop:
.16cc	b1 18		lda ($18),y			lda 	(codePtr),y 				; what follows needs to be a binary operator
.16ce	c9 ef		cmp #$ef			cmp 	#PR_BINARY_FIRST 			; binary tokens are the last ones up to $FF
.16d0	90 31		bcc $1703			bcc 	_EEExit
.16d2	aa		tax				tax 								; access the precedence of the operator.
.16d3	68		pla				pla 								; restore precedence.if >= operator precedence then exit
.16d4	dd 99 19	cmp $1999,x			cmp 	BinaryPrecedence-PR_BINARY_FIRST,x
.16d7	b0 2b		bcs $1704			bcs 	_EEExit2
.16d9	48		pha				pha 								; save current precedence.
.16da	da		phx				phx 								; save operator
.16db	c8		iny				iny 								; consume operator
.16dc	da		phx				phx
.16dd	a2 08		ldx #$08			ldx 	#IFR0 						; push R0 on the stack
.16df	20 1a 30	jsr $301a			jsr 	IFloatPushRx
.16e2	fa		plx				plx
.16e3	bd 99 19	lda $1999,x			lda 	BinaryPrecedence-PR_BINARY_FIRST,x
.16e6	20 c8 16	jsr $16c8			jsr 	EXPEvaluateExpressionPrecedenceA
.16e9	a2 0c		ldx #$0c			ldx 	#IFR1 						; pop LHS to R1.
.16eb	20 3b 30	jsr $303b			jsr 	IFloatPullRx
.16ee	fa		plx				plx 								; operator
.16ef	a5 0b		lda $0b				lda 	IFR0+IExp 					; if check types match.
.16f1	45 0f		eor $0f				eor 	IFR1+IExp
.16f3	30 08		bmi $16fd			bmi 	_EEType
.16f5					_EETypeOkay:
.16f5	8a		txa				txa
.16f6	0a		asl a				asl 	a 							; double -> X
.16f7	aa		tax				tax
.16f8	20 00 17	jsr $1700			jsr 	_EECallBinary 				; call the operator R0 := R1 <op> R0
.16fb	80 cf		bra $16cc			bra 	_EELoop
.16fd					_EEType:
.16fd	4c 9e 25	jmp $259e		jmp	ErrorV_type
.1700					_EECallBinary:
.1700	7c 5f 1c	jmp ($1c5f,x)			jmp 	(VectorTable,x)
.1703					_EEExit:
.1703	68		pla				pla 								; throw precedence
.1704					_EEExit2:
.1704	18		clc				clc
.1705	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/exprutils.asm

.1706					EXPEvalNumber:
.1706	20 c6 16	jsr $16c6			jsr 	EXPEvaluateExpression
.1709	24 0b		bit $0b				bit 	IFR0+IExp
.170b	30 01		bmi $170e			bmi 	EVUType
.170d	60		rts				rts
.170e					EVUType:
.170e	4c 9e 25	jmp $259e		jmp	ErrorV_type
.1711					EXPEvalInteger:
.1711	20 06 17	jsr $1706			jsr 	EXPEvalNumber 				; get number, coeerce to integer.
.1714	20 cb 2d	jsr $2dcb			jsr 	IFloatIntegerR0
.1717	60		rts				rts
.1718					EXPEvalInteger16:
.1718	20 11 17	jsr $1711			jsr 	EXPEvalInteger
.171b	a5 0a		lda $0a				lda 	IFR0+IM2
.171d	d0 21		bne $1740			bne 	EVURange
.171f	a6 09		ldx $09				ldx 	IFR0+IM1
.1721	a5 08		lda $08				lda 	IFR0+IM0
.1723	60		rts				rts
.1724					EXPEvalInteger8:
.1724	20 11 17	jsr $1711			jsr 	EXPEvalInteger
.1727	a5 0a		lda $0a				lda 	IFR0+IM2
.1729	05 09		ora $09				ora 	IFR0+IM1
.172b	d0 13		bne $1740			bne 	EVURange
.172d	a5 08		lda $08				lda 	IFR0+IM0
.172f	60		rts				rts
.1730					EXPEvalString:
.1730	20 c6 16	jsr $16c6			jsr 	EXPEvaluateExpression
.1733	24 0b		bit $0b				bit 	IFR0+IExp
.1735	10 d7		bpl $170e			bpl 	EVUType
.1737	a6 09		ldx $09				ldx 	IFR0+IM1
.1739	86 23		stx $23				stx 	zTemp0+1
.173b	a5 08		lda $08				lda 	IFR0+IM0
.173d	85 22		sta $22				sta 	zTemp0
.173f	60		rts				rts
.1740					EVURange:
.1740	4c 7f 25	jmp $257f		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/term.asm

.1743					EXPTermValueR0:
.1743	20 8e 17	jsr $178e			jsr 	EXPTermR0 					; get term
.1746	90 45		bcc $178d			bcc 	_ETVNotReference 			; exit if value.
.1748	5a		phy				phy
.1749	a0 03		ldy #$03			ldy 	#3 							; get type
.174b	b1 08		lda ($08),y			lda 	(IFR0),y
.174d	30 14		bmi $1763			bmi 	_ETVDereferenceString
.174f	85 0b		sta $0b				sta 	IFR0+IExp 					; dereference to R0
.1751	88		dey				dey
.1752	b1 08		lda ($08),y			lda 	(IFR0),y
.1754	85 0a		sta $0a				sta 	IFR0+IM2
.1756	88		dey				dey
.1757	b1 08		lda ($08),y			lda 	(IFR0),y
.1759	aa		tax				tax
.175a	b2 08		lda ($08)			lda 	(IFR0)
.175c	86 09		stx $09				stx 	IFR0+IM1
.175e	85 08		sta $08				sta 	IFR0+IM0
.1760	7a		ply				ply
.1761	18		clc				clc
.1762	60		rts				rts
.1763					_ETVDereferenceString:
.1763	a0 01		ldy #$01			ldy 	#1 							; check if it is as yet unassigned.
.1765	b1 08		lda ($08),y			lda 	(IFR0),y
.1767	12 08		ora ($08)			ora 	(IFR0)
.1769	f0 11		beq $177c			beq 	_ETVNull
.176b	b1 08		lda ($08),y			lda 	(IFR0),y 					; load address of string to XA
.176d	aa		tax				tax
.176e	b2 08		lda ($08)			lda 	(IFR0)
.1770	18		clc				clc 								; add two so points to actual string.
.1771	69 02		adc #$02			adc 	#2
.1773	90 01		bcc $1776			bcc 	_EVDSNoCarry
.1775	e8		inx				inx
.1776					_EVDSNoCarry:
.1776	86 09		stx $09				stx 	IFR0+IM1 					; save in slots
.1778	85 08		sta $08				sta 	IFR0
.177a	80 08		bra $1784			bra 	_ETVFillExit 				; tidy up and exit.
.177c					_ETVNull:
.177c	a9 8c		lda #$8c			lda 	#_EVTNString & $FF
.177e	85 08		sta $08				sta 	IFR0+IM0
.1780	a9 17		lda #$17			lda 	#_EVTNString >> 8
.1782	85 09		sta $09				sta 	IFR0+IM1
.1784					_ETVFillExit:
.1784	64 0a		stz $0a				stz 	IFR0+IM2
.1786	a9 80		lda #$80			lda 	#$80
.1788	85 0b		sta $0b				sta 	IFR0+IExp
.178a	7a		ply				ply
.178b	60		rts				rts
.178c					_EVTNString:
>178c	00						.byte 	0
.178d					_ETVNotReference:
.178d	60		rts				rts
.178e					EXPTermR0:
.178e	b1 18		lda ($18),y			lda 	(codePtr),y 				; get next token/element
.1790	30 10		bmi $17a2			bmi 	_ETMIsUnaryOrMinus 			; if it's a token, it's a unary function, maybe -
.1792	c8		iny				iny 								; consume element
.1793	c9 40		cmp #$40			cmp 	#$40 						; 40-7F are identifiers.
.1795	b0 08		bcs $179f			bcs 	_ETMIdentifier
.1797	20 c6 17	jsr $17c6			jsr 	EXPExtractTokenisedInteger 	; pull out tokenised integer to R0
.179a	20 f9 17	jsr $17f9			jsr 	EXPCheckDecimalFollows 		; check for decimals.
.179d	18		clc				clc 								; return value
.179e	60		rts				rts
.179f					_ETMIdentifier:
.179f	4c 62 2a	jmp $2a62			jmp 	VARCheckSimple 				; check simple variables A-Z
.17a2					_ETMIsUnaryOrMinus:
.17a2	c8		iny				iny 								; consume element
.17a3	c9 fe		cmp #$fe			cmp 	#PR_MINUS 					; handle - seperately as it has two roles.
.17a5	d0 0a		bne $17b1			bne 	_ETMCheckUnary
.17a7	20 43 17	jsr $1743			jsr 	EXPTermValueR0 				; get a term to negate
.17aa	a2 08		ldx #$08			ldx 	#IFR0 						; and negate it
.17ac	20 d6 30	jsr $30d6			jsr 	IFloatNegate
.17af	18		clc				clc
.17b0	60		rts				rts
.17b1					_ETMCheckUnary:
.17b1	c9 d5		cmp #$d5			cmp 	#PR_UNARY_FIRST 			; check unary function.
.17b3	90 0e		bcc $17c3			bcc 	_ETMUnarySyntax
.17b5	c9 ef		cmp #$ef			cmp 	#PR_UNARY_LAST+1
.17b7	b0 0a		bcs $17c3			bcs 	_ETMUnarySyntax
.17b9	0a		asl a				asl 	a
.17ba	aa		tax				tax
.17bb	20 c0 17	jsr $17c0			jsr 	_ETMCallUnaryFunction
.17be	18		clc				clc
.17bf	60		rts				rts
.17c0					_ETMCallUnaryFunction:
.17c0	7c 5f 1c	jmp ($1c5f,x)			jmp 	(VectorTable,x)
.17c3					_ETMUnarySyntax:
.17c3	4c 6e 25	jmp $256e		jmp	ErrorV_syntax
.17c6					EXPExtractTokenisedInteger:
.17c6	85 08		sta $08				sta 	IFR0+IM0 					; initial value in IM0
.17c8	64 0b		stz $0b				stz 	IFR0+IExp
.17ca	64 09		stz $09				stz 	IFR0+IM1
.17cc	64 0a		stz $0a				stz 	IFR0+IM2
.17ce					_ETMConstant:
.17ce	b1 18		lda ($18),y			lda 	(codePtr),y 				; what follows.
.17d0	c9 40		cmp #$40			cmp 	#$40 						; continuing constant
.17d2	b0 24		bcs $17f8			bcs 	_ETMCExit 					; no.
.17d4	a6 0a		ldx $0a				ldx 	IFR0+IM2 					; x 256 into A:M2 M1 M0
.17d6	a5 09		lda $09				lda 	IFR0+IM1
.17d8	85 0a		sta $0a				sta 	IFR0+IM2
.17da	a5 08		lda $08				lda 	IFR0+IM0
.17dc	85 09		sta $09				sta 	IFR0+IM1
.17de	64 08		stz $08				stz 	IFR0+IM0
.17e0	8a		txa				txa
.17e1	4a		lsr a				lsr 	a 							; shift right twice, e.g. whole thing is x 64
.17e2	66 0a		ror $0a				ror 	IFR0+IM2
.17e4	66 09		ror $09				ror 	IFR0+IM1
.17e6	66 08		ror $08				ror 	IFR0+IM0
.17e8	4a		lsr a				lsr 	a
.17e9	66 0a		ror $0a				ror 	IFR0+IM2
.17eb	66 09		ror $09				ror 	IFR0+IM1
.17ed	66 08		ror $08				ror 	IFR0+IM0
.17ef	a5 08		lda $08				lda 	IFR0+IM0 					; LSB in.
.17f1	11 18		ora ($18),y			ora 	(codePtr),y
.17f3	85 08		sta $08				sta 	IFR0+IM0
.17f5	c8		iny				iny 								; consume, loop back
.17f6	80 d6		bra $17ce			bra 	_ETMConstant
.17f8					_ETMCExit:
.17f8	60		rts				rts
.17f9					EXPCheckDecimalFollows:
.17f9	b1 18		lda ($18),y			lda 	(codePtr),y 				; check for decimal
.17fb	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ
.17fd	d0 19		bne $1818			bne 	_ETMCDExit
.17ff	c8		iny				iny 								; consume token.
.1800	b1 18		lda ($18),y			lda 	(codePtr),y 				; get count
.1802	5a		phy				phy									; save current position
.1803	48		pha				pha 								; save count of chars.
.1804	38		sec				sec 								; address into YX : y + codePtr+1
.1805	98		tya				tya
.1806	65 18		adc $18				adc 	codePtr
.1808	aa		tax				tax
.1809	a5 19		lda $19				lda 	codePtr+1
.180b	69 00		adc #$00			adc 	#0
.180d	a8		tay				tay
.180e	68		pla				pla 								; get count.
.180f	20 6f 2f	jsr $2f6f			jsr 	IFloatAddDecimalToR0 		; add the decimal to R0
.1812	7a		ply				ply 								; go to next token.
.1813	98		tya				tya
.1814	38		sec				sec
.1815	71 18		adc ($18),y			adc 	(codePtr),y
.1817	a8		tay				tay
.1818					_ETMCDExit:
.1818	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/abs.asm

.1819					EXPUnaryAbs:
.1819	20 06 17	jsr $1706			jsr 	EXPEvalNumber 					; number to R0
.181c	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.181f	20 0f 2d	jsr $2d0f			jsr 	IFloatAbsoluteR0
.1822	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/asc.asm

.1823					EXPUnaryAsc:
.1823	20 30 17	jsr $1730			jsr 	EXPEvalString 					; string to R0, zTemp0
.1826	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.1829	b2 22		lda ($22)			lda 	(zTemp0) 						; length 0 ?
.182b	f0 06		beq $1833			beq 	_EXAZero 						; if so return 0
.182d	5a		phy				phy 									; otherwise get first character
.182e	a0 01		ldy #$01			ldy 	#1
.1830	b1 22		lda ($22),y			lda 	(zTemp0),y
.1832	7a		ply				ply
.1833					_EXAZero:
.1833	a2 08		ldx #$08			ldx 	#IFR0
.1835	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.1838	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/chr.asm

.1839					EXPUnaryChr:
.1839	20 24 17	jsr $1724			jsr 	EXPEvalInteger8 				; expr
.183c	48		pha				pha 									; push on stack
.183d	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.1840	a9 01		lda #$01			lda 	#1 								; alloc temp mem for result
.1842	20 19 28	jsr $2819			jsr 	StringTempAllocate
.1845	68		pla				pla
.1846	20 4e 28	jsr $284e			jsr 	StringTempWrite
.1849	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/dec.asm

.184a					EXPUnaryDec:
.184a	20 30 17	jsr $1730			jsr 	EXPEvalString 					; string to R0, zTemp0
.184d	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.1850	5a		phy				phy
.1851	a2 08		ldx #$08			ldx 	#IFR0 							; zero the result
.1853	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.1856	b2 22		lda ($22)			lda 	(zTemp0)						; read the length to X
.1858	f0 3b		beq $1895			beq 	_EUDError 						; empty string
.185a	aa		tax				tax
.185b	a0 01		ldy #$01			ldy 	#1 								; start at offset 1
.185d					_EUDLoop:
.185d	b1 22		lda ($22),y			lda 	(zTemp0),y 						; get next
.185f	c9 61		cmp #$61			cmp 	#"a" 							; l/c -> u/c
.1861	90 02		bcc $1865			bcc 	_EUDNoCase
.1863	e9 20		sbc #$20			sbc 	#$20
.1865					_EUDNoCase:
.1865	c9 30		cmp #$30			cmp 	#'0' 							; check 0..9
.1867	90 2c		bcc $1895			bcc 	_EUDError
.1869	c9 3a		cmp #$3a			cmp 	#'9'+1
.186b	90 0a		bcc $1877			bcc 	_EUDOkay
.186d	c9 41		cmp #$41			cmp 	#'A'							; check A-F
.186f	90 24		bcc $1895			bcc 	_EUDError
.1871	c9 47		cmp #$47			cmp 	#'F'+1
.1873	b0 20		bcs $1895			bcs 	_EUDError
.1875	e9 06		sbc #$06			sbc 	#6 								; hex adjust
.1877					_EUDOkay:
.1877	29 0f		and #$0f			and 	#15 							; make constant
.1879	da		phx				phx
.187a	48		pha				pha
.187b	a2 08		ldx #$08			ldx 	#IFR0 							; multiply R0 x 16
.187d	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.1880	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.1883	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.1886	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.1889	68		pla				pla 									; pop constant and OR in
.188a	fa		plx				plx
.188b	05 08		ora $08				ora 	IFR0+IM0
.188d	85 08		sta $08				sta 	IFR0+IM0
.188f	c8		iny				iny 									; next
.1890	ca		dex				dex
.1891	d0 ca		bne $185d			bne 	_EUDLoop
.1893	7a		ply				ply
.1894	60		rts				rts
.1895					_EUDError:
.1895	4c 90 25	jmp $2590		jmp	ErrorV_value

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/decimal.asm

.1898					EXPUnaryInlineDec:
.1898	4c 6e 25	jmp $256e		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/deekpeek.asm

.189b					EXPUnaryPeek:
.189b	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 				; number to R0
.189e	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.18a1	b2 08		lda ($08)			lda 	(IFR0)
.18a3	a2 08		ldx #$08			ldx 	#IFR0
.18a5	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.18a8	60		rts				rts
.18a9					EXPUnaryDeek:
.18a9	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 				; number to R0
.18ac	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.18af	5a		phy				phy
.18b0	a0 01		ldy #$01			ldy 	#1
.18b2	b1 08		lda ($08),y			lda 	(IFR0),y
.18b4	7a		ply				ply
.18b5	48		pha				pha
.18b6	b2 08		lda ($08)			lda 	(IFR0)
.18b8	a2 08		ldx #$08			ldx 	#IFR0
.18ba	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.18bd	68		pla				pla
.18be	85 09		sta $09				sta 	IFR0+IM1
.18c0	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/dollar.asm

.18c1					EXPUnaryNull:
.18c1	20 43 17	jsr $1743			jsr 	EXPTermValueR0
.18c4	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/fractional.asm

.18c5					EXPUnaryFrac:
.18c5	20 06 17	jsr $1706			jsr 	EXPEvalNumber 					; number to R0
.18c8	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.18cb	20 75 2d	jsr $2d75			jsr 	IFloatFractionalR0
.18ce	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/inkey.asm

.18cf					EXPUnaryInkey:
.18cf	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.18d2	a9 01		lda #$01			lda 	#1 								; alloc temp mem for result
.18d4	20 19 28	jsr $2819			jsr 	StringTempAllocate
.18d7	20 e8 ff	jsr $ffe8			jsr 	OSIsKeyAvailable 				; if no key exit
.18da	b0 06		bcs $18e2			bcs 	_EUIExit
.18dc	20 ee ff	jsr $ffee			jsr 	OSReadKeyboard 					; otherwise get it.
.18df	20 4e 28	jsr $284e			jsr 	StringTempWrite
.18e2					_EUIExit:
.18e2	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/intfn.asm

.18e3					EXPUnaryInt:
.18e3	20 06 17	jsr $1706			jsr 	EXPEvalNumber 					; number to R0
.18e6	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; check for )
.18e9	20 cb 2d	jsr $2dcb			jsr 	IFloatIntegerR0 				; force to integer.
.18ec	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/len.asm

.18ed					EXPUnaryLen:
.18ed	20 30 17	jsr $1730			jsr 	EXPEvalString 					; string to R0, zTemp0
.18f0	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.18f3	b2 22		lda ($22)			lda 	(zTemp0)
.18f5	a2 08		ldx #$08			ldx 	#IFR0
.18f7	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.18fa	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/parenthesis.asm

.18fb					EXPUnaryParenthesis:
.18fb	20 06 17	jsr $1706			jsr 	EXPEvalNumber 					; number to R0
.18fe	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.1901	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/random.asm

.1902					EXPUnaryRnd:
.1902	20 06 17	jsr $1706			jsr 	EXPEvalNumber 				; number to R0
.1905	20 23 27	jsr $2723			jsr 	ERRCheckRParen 				; )
.1908	a2 08		ldx #$08			ldx 	#IFR0
.190a	20 21 19	jsr $1921			jsr 	EXPLoadInRandom
.190d	a9 29		lda #$29			lda 	#64-23 						; hack the exponent to make it work.
.190f	85 0b		sta $0b				sta 	IFR0+IExp
.1911	60		rts				rts
.1912					ExpUnaryRand:
.1912	20 11 17	jsr $1711			jsr 	EXPEvalInteger 				; integer to R0
.1915	20 23 27	jsr $2723			jsr 	ERRCheckRParen 				; )
.1918	a2 0c		ldx #$0c			ldx 	#IFR1 						; random to R1
.191a	20 21 19	jsr $1921			jsr 	EXPLoadInRandom
.191d	20 3c 2c	jsr $2c3c			jsr 	IFloatModulusInteger 		; calculate mod r1,r2
.1920	60		rts				rts
.1921					EXPLoadInRandom:
.1921	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.1924	20 36 19	jsr $1936			jsr 	EXPRandom32
.1927	95 00		sta $00,x			sta 	IM0,x
.1929	20 36 19	jsr $1936			jsr 	EXPRandom32
.192c	95 01		sta $01,x			sta 	IM1,x
.192e	20 36 19	jsr $1936			jsr 	EXPRandom32
.1931	29 7f		and #$7f			and 	#$7F
.1933	95 02		sta $02,x			sta 	IM2,x
.1935	60		rts				rts
.1936					EXPRandom32:
.1936	5a		phy				phy
.1937	a0 08		ldy #$08			ldy 	#8
.1939	ad 12 05	lda $0512			lda 	EXPSeed+0
.193c	0d 13 05	ora $0513			ora 	EXPSeed+1
.193f	0d 14 05	ora $0514			ora 	EXPSeed+2
.1942	0d 15 05	ora $0515			ora 	EXPSeed+3
.1945	d0 08		bne $194f			bne 	_EXPRNoReset
.1947	ee 12 05	inc $0512			inc 	EXPSeed+0
.194a	a0 10		ldy #$10			ldy 	#16
.194c	8c 15 05	sty $0515			sty 	EXPSeed+3
.194f					_EXPRNoReset:
.194f	ad 12 05	lda $0512			lda 	EXPSeed+0
.1952					_EXPRLoop:
.1952	0a		asl a				asl		a
.1953	2e 13 05	rol $0513			rol 	EXPSeed+1
.1956	2e 14 05	rol $0514			rol 	EXPSeed+2
.1959	2e 15 05	rol $0515			rol 	EXPSeed+3
.195c	90 02		bcc $1960			bcc 	_EXPRNoEOR
.195e	49 c5		eor #$c5			eor 	#$C5
.1960					_EXPRNoEOR:
.1960	88		dey				dey
.1961	d0 ef		bne $1952			bne 	_EXPRLoop
.1963	8d 12 05	sta $0512			sta 	EXPSeed+0
.1966	7a		ply				ply
.1967	60		rts				rts
.0512					EXPSeed:
>0512							.fill 	4

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sgn.asm

.1968					EXPUnarySgn:
.1968	20 06 17	jsr $1706			jsr 	EXPEvalNumber 					; number to R0
.196b	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.196e	a2 0c		ldx #$0c			ldx 	#IFR1 							; copy to R1
.1970	20 6d 30	jsr $306d			jsr 	IFloatCopyToRegister
.1973	a2 08		ldx #$08			ldx 	#IFR0 							; R0 = 0
.1975	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.1978	a2 0c		ldx #$0c			ldx 	#IFR1
.197a	20 99 2d	jsr $2d99			jsr 	IFloatCompare 					; compare R1 vs 0.
.197d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sqr.asm

.197e					EXPUnarySqr:
.197e	20 06 17	jsr $1706			jsr 	EXPEvalNumber 					; number to R0
.1981	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.1984	20 17 2d	jsr $2d17			jsr 	IFloatSquareRootR0 				; square root.
.1987	b0 01		bcs $198a			bcs 	_EUSValue
.1989	60		rts				rts
.198a					_EUSValue:
.198a	4c 7f 25	jmp $257f		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/strhex.asm

.198d					EXPUnaryHex:
.198d	20 11 17	jsr $1711			jsr 	EXPEvalInteger 					; expr
.1990	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.1993	5a		phy				phy
.1994	a9 10		lda #$10			lda 	#16
.1996	20 6c 2e	jsr $2e6c			jsr 	IFloatIntegerToStringR0
.1999	80 0a		bra $19a5			bra 	EUSMain
.199b					EXPUnaryStr:
.199b	20 06 17	jsr $1706			jsr 	EXPEvalNumber 					; expr
.199e	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.19a1	5a		phy				phy
.19a2	20 c8 2e	jsr $2ec8			jsr 	IFloatFloatToStringR0 			; convert to string
.19a5					EUSMain:
.19a5	b0 18		bcs $19bf			bcs 	_EUSError
.19a7	86 22		stx $22				stx 	zTemp0 							; save string address
.19a9	84 23		sty $23				sty 	zTemp0+1
.19ab	48		pha				pha 									; save count
.19ac	a9 20		lda #$20			lda 	#32 							; allocate space for result.
.19ae	20 19 28	jsr $2819			jsr 	StringTempAllocate
.19b1	fa		plx				plx 									; count in X
.19b2	a0 00		ldy #$00			ldy 	#0
.19b4					_EUSCopy:
.19b4	b1 22		lda ($22),y			lda 	(zTemp0),y
.19b6	c8		iny				iny
.19b7	20 4e 28	jsr $284e			jsr 	StringTempWrite
.19ba	ca		dex				dex
.19bb	d0 f7		bne $19b4			bne	 	_EUSCopy
.19bd	7a		ply				ply
.19be	60		rts				rts
.19bf					_EUSError:
.19bf	4c 7f 25	jmp $257f		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/string.asm

.19c2					EXPUnaryInlineString:
.19c2	18		clc				clc 								; physical address -> IM0,1
.19c3	98		tya				tya
.19c4	65 18		adc $18				adc 	codePtr
.19c6	85 08		sta $08				sta 	IFR0+IM0
.19c8	a5 19		lda $19				lda 	codePtr+1
.19ca	69 00		adc #$00			adc 	#0
.19cc	85 09		sta $09				sta 	IFR0+IM1
.19ce	64 0a		stz $0a				stz 	IFR0+IM2 					; fill in rest
.19d0	a9 80		lda #$80			lda 	#$80
.19d2	85 0b		sta $0b				sta 	IFR0+IExp
.19d4	98		tya				tya	 								; skip over it.
.19d5	38		sec				sec
.19d6	71 18		adc ($18),y			adc 	(codePtr),y
.19d8	a8		tay				tay
.19d9	60		rts				rts
.19da					_EXPUISRange:
.19da	4c 7f 25	jmp $257f		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/substring.asm

.19dd					EXPUnaryLeft:
.19dd	20 23 1a	jsr $1a23			jsr 	EXPCommonStart 					; <string>,
.19e0	48		pha				pha 									; save string address on stack
.19e1	da		phx				phx
.19e2	a9 00		lda #$00			lda 	#0 								; start position (zero offset)
.19e4	48		pha				pha
.19e5	20 24 17	jsr $1724			jsr 	EXPEvalInteger8 				; characters to do
.19e8	80 44		bra $1a2e			bra 	EXPSubstringCommon
.19ea					EXPUnaryRight:
.19ea	20 23 1a	jsr $1a23			jsr 	EXPCommonStart 					; <string>,
.19ed	48		pha				pha 									; save string address on stack
.19ee	da		phx				phx
.19ef	b2 08		lda ($08)			lda 	(IFR0) 							; the string length => stack.
.19f1	48		pha				pha
.19f2	20 24 17	jsr $1724			jsr 	EXPEvalInteger8 				; characters to do
.19f5	85 22		sta $22				sta 	zTemp0 							; calculate length - required, start point.
.19f7	68		pla				pla
.19f8	38		sec				sec
.19f9	e5 22		sbc $22				sbc 	zTemp0
.19fb	b0 02		bcs $19ff			bcs 	_EUROffLeft
.19fd	a9 00		lda #$00			lda 	#0
.19ff					_EUROffLeft:
.19ff	48		pha				pha 									; start pos
.1a00	a9 ff		lda #$ff			lda 	#255
.1a02	80 2a		bra $1a2e			bra 	EXPSubstringCommon
.1a04					EXPUnaryMid:
.1a04	20 23 1a	jsr $1a23			jsr 	EXPCommonStart 					; <string>,
.1a07	48		pha				pha 									; save string address on stack
.1a08	da		phx				phx
.1a09	20 24 17	jsr $1724			jsr 	EXPEvalInteger8 				; characters start
.1a0c	f0 12		beq $1a20			beq 	_EUSError 						; 1 is left
.1a0e	3a		dec a				dec 	a 								; zero based.
.1a0f	48		pha				pha
.1a10	b1 18		lda ($18),y			lda 	(codePtr),y 					; comma follows
.1a12	c9 99		cmp #$99			cmp 	#PR_COMMA
.1a14	f0 04		beq $1a1a			beq 	_EUMLength 						; if so m is provided
.1a16	a9 ff		lda #$ff			lda 	#255 							; default m
.1a18	80 14		bra $1a2e			bra 	EXPSubstringCommon
.1a1a					_EUMLength:
.1a1a	c8		iny				iny 									; consume comma
.1a1b	20 24 17	jsr $1724			jsr 	EXPEvalInteger8 				; characters to do
.1a1e	80 0e		bra $1a2e			bra 	EXPSubstringCommon
.1a20					_EUSError:
.1a20	4c 90 25	jmp $2590		jmp	ErrorV_value
.1a23					EXPCommonStart:
.1a23	20 30 17	jsr $1730			jsr 	EXPEvalString
.1a26	20 2b 27	jsr $272b			jsr 	ERRCheckComma
.1a29	a5 08		lda $08				lda 	IFR0+IM0
.1a2b	a6 09		ldx $09				ldx 	IFR0+IM1
.1a2d	60		rts				rts
.1a2e					EXPSubstringCommon:
.1a2e	85 24		sta $24				sta 	zTemp1 							; count to do in zTemp1.
.1a30	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; check right bracket.
.1a33	68		pla				pla 									; start position
.1a34	85 25		sta $25				sta 	zTemp1+1 						; save in zTemp1+1
.1a36	fa		plx				plx 									; get string address to zTemp2.
.1a37	86 27		stx $27				stx 	zTemp2+1
.1a39	68		pla				pla
.1a3a	85 26		sta $26				sta 	zTemp2
.1a3c	38		sec				sec 									; length - start is the max count of chars
.1a3d	b2 26		lda ($26)			lda 	(zTemp2)
.1a3f	e5 25		sbc $25				sbc 	zTemp1+1
.1a41	c5 24		cmp $24				cmp 	zTemp1 							; if available < count
.1a43	b0 02		bcs $1a47			bcs 	_EXPSSNoTrim
.1a45	85 24		sta $24				sta 	zTemp1 							; update count with available
.1a47					_EXPSSNoTrim:
.1a47	a5 24		lda $24				lda 	zTemp1 							; chars required.
.1a49	20 19 28	jsr $2819			jsr 	StringTempAllocate 				; allocate memory for it.
.1a4c	a5 24		lda $24				lda 	zTemp1 							; zero length string
.1a4e	f0 15		beq $1a65			beq 	_EXPSSExit
.1a50	a5 25		lda $25				lda 	zTemp1+1 						; if length >= start exit
.1a52	d2 26		cmp ($26)			cmp 	(zTemp2)
.1a54	b0 0f		bcs $1a65			bcs 	_EXPSSExit
.1a56	5a		phy				phy
.1a57	a4 25		ldy $25				ldy 	zTemp1+1 						; start position
.1a59	c8		iny				iny 									; +1 for the length byte
.1a5a					_EXPSSCopy:
.1a5a	b1 26		lda ($26),y			lda 	(zTemp2),y
.1a5c	20 4e 28	jsr $284e			jsr 	StringTempWrite
.1a5f	c8		iny				iny
.1a60	c6 24		dec $24				dec 	zTemp1
.1a62	d0 f6		bne $1a5a			bne 	_EXPSSCopy
.1a64	7a		ply				ply
.1a65					_EXPSSExit:
.1a65	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/val.asm

.1a66					EXPUnaryVal:
.1a66	20 30 17	jsr $1730			jsr 	EXPEvalString 					; string to R0, zTemp0
.1a69	20 23 27	jsr $2723			jsr 	ERRCheckRParen 					; )
.1a6c	20 70 1a	jsr $1a70			jsr 	VALConversionZTemp0
.1a6f	60		rts				rts
.1a70					VALConversionZTemp0:
.1a70	5a		phy				phy
.1a71	18		clc				clc
.1a72	a5 22		lda $22				lda		zTemp0 							; point XY to the text
.1a74	69 01		adc #$01			adc 	#1
.1a76	aa		tax				tax
.1a77	a5 23		lda $23				lda 	zTemp0+1
.1a79	69 00		adc #$00			adc 	#0
.1a7b	a8		tay				tay
.1a7c	b2 22		lda ($22)			lda 	(zTemp0) 						; get length.
.1a7e	20 2f 2f	jsr $2f2f			jsr 	IFloatStringToFloatR0 			; do conversion
.1a81	b0 02		bcs $1a85			bcs 	_EUVError
.1a83	7a		ply				ply
.1a84	60		rts				rts
.1a85					_EUVError:
.1a85	4c 90 25	jmp $2590		jmp	ErrorV_value

;******  Return to file: include.files


;******  Processing file: src/generated/precedence_table.asm

.1a88					BinaryPrecedence:
>1a88	02					.byte	 2	; $ef =
>1a89	02					.byte	 2	; $f0 <>
>1a8a	02					.byte	 2	; $f1 <=
>1a8b	02					.byte	 2	; $f2 <
>1a8c	02					.byte	 2	; $f3 >=
>1a8d	02					.byte	 2	; $f4 >
>1a8e	01					.byte	 1	; $f5 XOR
>1a8f	01					.byte	 1	; $f6 OR
>1a90	01					.byte	 1	; $f7 AND
>1a91	04					.byte	 4	; $f8 DIV
>1a92	04					.byte	 4	; $f9 MOD
>1a93	04					.byte	 4	; $fa <<
>1a94	04					.byte	 4	; $fb >>
>1a95	04					.byte	 4	; $fc /
>1a96	04					.byte	 4	; $fd *
>1a97	03					.byte	 3	; $fe -
>1a98	03					.byte	 3	; $ff +

;******  Return to file: include.files


;******  Processing file: src/generated/structure_table.asm

.1a99					StructureOffsets:
>1a99	01					.byte	1  	; $80 REPEAT
>1a9a	ff					.byte	255	; $81 UNTIL
>1a9b	01					.byte	1  	; $82 WHILE
>1a9c	ff					.byte	255	; $83 WEND
>1a9d	01					.byte	1  	; $84 IF
>1a9e	ff					.byte	255	; $85 ENDIF
>1a9f	01					.byte	1  	; $86 DO
>1aa0	ff					.byte	255	; $87 LOOP
>1aa1	01					.byte	1  	; $88 PROC
>1aa2	ff					.byte	255	; $89 ENDPROC
>1aa3	01					.byte	1  	; $8a FOR
>1aa4	ff					.byte	255	; $8b NEXT

;******  Return to file: include.files


;******  Processing file: src/generated/token_text.asm

.1aa5					StandardTokens:
>1aa5	06 52 45 50 45 41 54			.byte	$06,$52,$45,$50,$45,$41,$54             	; $80 repeat
>1aac	05 55 4e 54 49 4c			.byte	$05,$55,$4e,$54,$49,$4c                 	; $81 until
>1ab2	05 57 48 49 4c 45			.byte	$05,$57,$48,$49,$4c,$45                 	; $82 while
>1ab8	04 57 45 4e 44				.byte	$04,$57,$45,$4e,$44                     	; $83 wend
>1abd	02 49 46				.byte	$02,$49,$46                             	; $84 if
>1ac0	05 45 4e 44 49 46			.byte	$05,$45,$4e,$44,$49,$46                 	; $85 endif
>1ac6	02 44 4f				.byte	$02,$44,$4f                             	; $86 do
>1ac9	04 4c 4f 4f 50				.byte	$04,$4c,$4f,$4f,$50                     	; $87 loop
>1ace	04 50 52 4f 43				.byte	$04,$50,$52,$4f,$43                     	; $88 proc
>1ad3	07 45 4e 44 50 52 4f 43			.byte	$07,$45,$4e,$44,$50,$52,$4f,$43         	; $89 endproc
>1adb	03 46 4f 52				.byte	$03,$46,$4f,$52                         	; $8a for
>1adf	04 4e 45 58 54				.byte	$04,$4e,$45,$58,$54                     	; $8b next
>1ae4	00					.byte	$00                                     	; $8c [[end]]
>1ae5	00					.byte	$00                                     	; $8d [[shift]]
>1ae6	04 45 4c 53 45				.byte	$04,$45,$4c,$53,$45                     	; $8e else
>1aeb	04 54 48 45 4e				.byte	$04,$54,$48,$45,$4e                     	; $8f then
>1af0	02 54 4f				.byte	$02,$54,$4f                             	; $90 to
>1af3	04 53 54 45 50				.byte	$04,$53,$54,$45,$50                     	; $91 step
>1af8	03 4c 45 54				.byte	$03,$4c,$45,$54                         	; $92 let
>1afc	05 50 52 49 4e 54			.byte	$05,$50,$52,$49,$4e,$54                 	; $93 print
>1b02	05 49 4e 50 55 54			.byte	$05,$49,$4e,$50,$55,$54                 	; $94 input
>1b08	04 43 41 4c 4c				.byte	$04,$43,$41,$4c,$4c                     	; $95 call
>1b0d	03 53 59 53				.byte	$03,$53,$59,$53                         	; $96 sys
>1b11	03 52 45 4d				.byte	$03,$52,$45,$4d                         	; $97 rem
>1b15	04 45 58 49 54				.byte	$04,$45,$58,$49,$54                     	; $98 exit
>1b1a	01 2c					.byte	$01,$2c                                 	; $99 ,
>1b1c	01 3b					.byte	$01,$3b                                 	; $9a ;
>1b1e	01 3a					.byte	$01,$3a                                 	; $9b :
>1b20	01 27					.byte	$01,$27                                 	; $9c '
>1b22	01 29					.byte	$01,$29                                 	; $9d )
>1b24	03 44 49 4d				.byte	$03,$44,$49,$4d                         	; $9e dim
>1b28	05 43 4c 45 41 52			.byte	$05,$43,$4c,$45,$41,$52                 	; $9f clear
>1b2e	03 4e 45 57				.byte	$03,$4e,$45,$57                         	; $a0 new
>1b32	03 52 55 4e				.byte	$03,$52,$55,$4e                         	; $a1 run
>1b36	04 53 54 4f 50				.byte	$04,$53,$54,$4f,$50                     	; $a2 stop
>1b3b	03 45 4e 44				.byte	$03,$45,$4e,$44                         	; $a3 end
>1b3f	06 41 53 53 45 52 54			.byte	$06,$41,$53,$53,$45,$52,$54             	; $a4 assert
>1b46	04 4c 49 53 54				.byte	$04,$4c,$49,$53,$54                     	; $a5 list
>1b4b	04 53 41 56 45				.byte	$04,$53,$41,$56,$45                     	; $a6 save
>1b50	04 4c 4f 41 44				.byte	$04,$4c,$4f,$41,$44                     	; $a7 load
>1b55	04 50 4f 4b 45				.byte	$04,$50,$4f,$4b,$45                     	; $a8 poke
>1b5a	04 44 4f 4b 45				.byte	$04,$44,$4f,$4b,$45                     	; $a9 doke
>1b5f	04 52 45 41 44				.byte	$04,$52,$45,$41,$44                     	; $aa read
>1b64	04 44 41 54 41				.byte	$04,$44,$41,$54,$41                     	; $ab data
>1b69	07 52 45 53 54 4f 52 45			.byte	$07,$52,$45,$53,$54,$4f,$52,$45         	; $ac restore
>1b71	04 47 4f 54 4f				.byte	$04,$47,$4f,$54,$4f                     	; $ad goto
>1b76	05 47 4f 53 55 42			.byte	$05,$47,$4f,$53,$55,$42                 	; $ae gosub
>1b7c	06 52 45 54 55 52 4e			.byte	$06,$52,$45,$54,$55,$52,$4e             	; $af return
>1b83	00					.byte	0											; $b0
>1b84	00					.byte	0											; $b1
>1b85	00					.byte	0											; $b2
>1b86	00					.byte	0											; $b3
>1b87	00					.byte	0											; $b4
>1b88	00					.byte	0											; $b5
>1b89	00					.byte	0											; $b6
>1b8a	00					.byte	0											; $b7
>1b8b	00					.byte	0											; $b8
>1b8c	00					.byte	0											; $b9
>1b8d	00					.byte	0											; $ba
>1b8e	00					.byte	0											; $bb
>1b8f	00					.byte	0											; $bc
>1b90	00					.byte	0											; $bd
>1b91	00					.byte	0											; $be
>1b92	00					.byte	0											; $bf
>1b93	00					.byte	0											; $c0
>1b94	00					.byte	0											; $c1
>1b95	00					.byte	0											; $c2
>1b96	00					.byte	0											; $c3
>1b97	00					.byte	0											; $c4
>1b98	00					.byte	0											; $c5
>1b99	00					.byte	0											; $c6
>1b9a	00					.byte	0											; $c7
>1b9b	00					.byte	0											; $c8
>1b9c	00					.byte	0											; $c9
>1b9d	00					.byte	0											; $ca
>1b9e	00					.byte	0											; $cb
>1b9f	00					.byte	0											; $cc
>1ba0	00					.byte	0											; $cd
>1ba1	00					.byte	0											; $ce
>1ba2	00					.byte	0											; $cf
>1ba3	00					.byte	0											; $d0
>1ba4	00					.byte	0											; $d1
>1ba5	00					.byte	0											; $d2
>1ba6	00					.byte	0											; $d3
>1ba7	00					.byte	0											; $d4
>1ba8	05 44 45 45 4b 28			.byte	$05,$44,$45,$45,$4b,$28                 	; $d5 deek(
>1bae	05 50 45 45 4b 28			.byte	$05,$50,$45,$45,$4b,$28                 	; $d6 peek(
>1bb4	07 52 49 47 48 54 24 28			.byte	$07,$52,$49,$47,$48,$54,$24,$28         	; $d7 right$(
>1bbc	06 4c 45 46 54 24 28			.byte	$06,$4c,$45,$46,$54,$24,$28             	; $d8 left$(
>1bc3	05 4d 49 44 24 28			.byte	$05,$4d,$49,$44,$24,$28                 	; $d9 mid$(
>1bc9	05 53 54 52 24 28			.byte	$05,$53,$54,$52,$24,$28                 	; $da str$(
>1bcf	04 56 41 4c 28				.byte	$04,$56,$41,$4c,$28                     	; $db val(
>1bd4	04 53 47 4e 28				.byte	$04,$53,$47,$4e,$28                     	; $dc sgn(
>1bd9	04 41 42 53 28				.byte	$04,$41,$42,$53,$28                     	; $dd abs(
>1bde	04 4c 45 4e 28				.byte	$04,$4c,$45,$4e,$28                     	; $de len(
>1be3	04 53 51 52 28				.byte	$04,$53,$51,$52,$28                     	; $df sqr(
>1be8	05 43 48 52 24 28			.byte	$05,$43,$48,$52,$24,$28                 	; $e0 chr$(
>1bee	04 41 53 43 28				.byte	$04,$41,$53,$43,$28                     	; $e1 asc(
>1bf3	07 49 4e 4b 45 59 24 28			.byte	$07,$49,$4e,$4b,$45,$59,$24,$28         	; $e2 inkey$(
>1bfb	06 45 56 45 4e 54 28			.byte	$06,$45,$56,$45,$4e,$54,$28             	; $e3 event(
>1c02	04 54 49 4d 45				.byte	$04,$54,$49,$4d,$45                     	; $e4 time
>1c07	04 49 4e 54 28				.byte	$04,$49,$4e,$54,$28                     	; $e5 int(
>1c0c	05 46 52 41 43 28			.byte	$05,$46,$52,$41,$43,$28                 	; $e6 frac(
>1c12	04 44 45 43 28				.byte	$04,$44,$45,$43,$28                     	; $e7 dec(
>1c17	05 48 45 58 24 28			.byte	$05,$48,$45,$58,$24,$28                 	; $e8 hex$(
>1c1d	04 52 4e 44 28				.byte	$04,$52,$4e,$44,$28                     	; $e9 rnd(
>1c22	05 52 41 4e 44 28			.byte	$05,$52,$41,$4e,$44,$28                 	; $ea rand(
>1c28	01 28					.byte	$01,$28                                 	; $eb (
>1c2a	01 24					.byte	$01,$24                                 	; $ec $
>1c2c	00					.byte	$00                                     	; $ed [[decimal]]
>1c2d	00					.byte	$00                                     	; $ee [[string]]
>1c2e	01 3d					.byte	$01,$3d                                 	; $ef =
>1c30	02 3c 3e				.byte	$02,$3c,$3e                             	; $f0 <>
>1c33	02 3c 3d				.byte	$02,$3c,$3d                             	; $f1 <=
>1c36	01 3c					.byte	$01,$3c                                 	; $f2 <
>1c38	02 3e 3d				.byte	$02,$3e,$3d                             	; $f3 >=
>1c3b	01 3e					.byte	$01,$3e                                 	; $f4 >
>1c3d	03 58 4f 52				.byte	$03,$58,$4f,$52                         	; $f5 xor
>1c41	02 4f 52				.byte	$02,$4f,$52                             	; $f6 or
>1c44	03 41 4e 44				.byte	$03,$41,$4e,$44                         	; $f7 and
>1c48	03 44 49 56				.byte	$03,$44,$49,$56                         	; $f8 div
>1c4c	03 4d 4f 44				.byte	$03,$4d,$4f,$44                         	; $f9 mod
>1c50	02 3c 3c				.byte	$02,$3c,$3c                             	; $fa <<
>1c53	02 3e 3e				.byte	$02,$3e,$3e                             	; $fb >>
>1c56	01 2f					.byte	$01,$2f                                 	; $fc /
>1c58	01 2a					.byte	$01,$2a                                 	; $fd *
>1c5a	01 2d					.byte	$01,$2d                                 	; $fe -
>1c5c	01 2b					.byte	$01,$2b                                 	; $ff +
>1c5e	ff					.byte	$FF

;******  Return to file: include.files


;******  Processing file: src/generated/vector_table.asm

.1c5f					VectorTable:
>1c5f	5e 24					.word	Command_REPEAT           ; $80 REPEAT
>1c61	67 24					.word	Command_UNTIL            ; $81 UNTIL
>1c63	41 25					.word	Command_WHILE            ; $82 WHILE
>1c65	62 25					.word	Command_WEND             ; $83 WEND
>1c67	34 24					.word	IfCommand                ; $84 IF
>1c69	5d 24					.word	EndIf                    ; $85 ENDIF
>1c6b	b7 22					.word	Command_DO               ; $86 DO
>1c6d	cf 22					.word	Command_LOOP             ; $87 LOOP
>1c6f	46 15					.word	NoExec08                 ; $88 PROC
>1c71	ab 22					.word	Command_ENDPROC          ; $89 ENDPROC
>1c73	d8 22					.word	Command_FOR              ; $8a FOR
>1c75	65 23					.word	Command_NEXT             ; $8b NEXT
>1c77	cc 14					.word	RUNEndOfLine             ; $8c [[END]]
>1c79	28 15					.word	Command_Shift_Handler    ; $8d [[SHIFT]]
>1c7b	56 24					.word	ElseCode                 ; $8e ELSE
>1c7d	46 15					.word	NoExec01                 ; $8f THEN
>1c7f	46 15					.word	NoExec02                 ; $90 TO
>1c81	46 15					.word	NoExec03                 ; $91 STEP
>1c83	be 12					.word	CommandLET               ; $92 LET
>1c85	0f 12					.word	Command_Print            ; $93 PRINT
>1c87	08 12					.word	Command_Input            ; $94 INPUT
>1c89	6f 22					.word	Command_CALL             ; $95 CALL
>1c8b	31 15					.word	Command_Sys              ; $96 SYS
>1c8d	85 14					.word	Command_REM              ; $97 REM
>1c8f	c0 22					.word	Command_EXIT             ; $98 EXIT
>1c91	46 15					.word	NoExec04                 ; $99 ,
>1c93	46 15					.word	NoExec05                 ; $9a ;
>1c95	46 15					.word	NoExec06                 ; $9b :
>1c97	85 14					.word	Command_REM2             ; $9c '
>1c99	46 15					.word	NoExec07                 ; $9d )
>1c9b	92 10					.word	CommandDIM               ; $9e DIM
>1c9d	1e 10					.word	Command_CLEAR            ; $9f CLEAR
>1c9f	08 14					.word	Command_NEW              ; $a0 NEW
>1ca1	c0 14					.word	Command_RUN              ; $a1 RUN
>1ca3	2e 15					.word	Command_STOP             ; $a2 STOP
>1ca5	2b 15					.word	Command_END              ; $a3 END
>1ca7	10 10					.word	Command_ASSERT           ; $a4 ASSERT
>1ca9	38 13					.word	Command_LIST             ; $a5 LIST
>1cab	a0 28					.word	NotImplemented           ; $a6 SAVE
>1cad	a0 28					.word	NotImplemented           ; $a7 LOAD
>1caf	b1 11					.word	Command_Poke             ; $a8 POKE
>1cb1	ae 11					.word	Command_Doke             ; $a9 DOKE
>1cb3	11 14					.word	Command_READ             ; $aa READ
>1cb5	78 14					.word	Command_DATA             ; $ab DATA
>1cb7	92 14					.word	Command_RESTORE          ; $ac RESTORE
>1cb9	d8 11					.word	Command_GOTO             ; $ad GOTO
>1cbb	1a 24					.word	Command_GOSUB            ; $ae GOSUB
>1cbd	28 24					.word	Command_RETURN           ; $af RETURN
>1cbf	a0 28					.word	NotImplemented           ; $b0
>1cc1	a0 28					.word	NotImplemented           ; $b1
>1cc3	a0 28					.word	NotImplemented           ; $b2
>1cc5	a0 28					.word	NotImplemented           ; $b3
>1cc7	a0 28					.word	NotImplemented           ; $b4
>1cc9	a0 28					.word	NotImplemented           ; $b5
>1ccb	a0 28					.word	NotImplemented           ; $b6
>1ccd	a0 28					.word	NotImplemented           ; $b7
>1ccf	a0 28					.word	NotImplemented           ; $b8
>1cd1	a0 28					.word	NotImplemented           ; $b9
>1cd3	a0 28					.word	NotImplemented           ; $ba
>1cd5	a0 28					.word	NotImplemented           ; $bb
>1cd7	a0 28					.word	NotImplemented           ; $bc
>1cd9	a0 28					.word	NotImplemented           ; $bd
>1cdb	a0 28					.word	NotImplemented           ; $be
>1cdd	a0 28					.word	NotImplemented           ; $bf
>1cdf	a0 28					.word	NotImplemented           ; $c0
>1ce1	a0 28					.word	NotImplemented           ; $c1
>1ce3	a0 28					.word	NotImplemented           ; $c2
>1ce5	a0 28					.word	NotImplemented           ; $c3
>1ce7	a0 28					.word	NotImplemented           ; $c4
>1ce9	a0 28					.word	NotImplemented           ; $c5
>1ceb	a0 28					.word	NotImplemented           ; $c6
>1ced	a0 28					.word	NotImplemented           ; $c7
>1cef	a0 28					.word	NotImplemented           ; $c8
>1cf1	a0 28					.word	NotImplemented           ; $c9
>1cf3	a0 28					.word	NotImplemented           ; $ca
>1cf5	a0 28					.word	NotImplemented           ; $cb
>1cf7	a0 28					.word	NotImplemented           ; $cc
>1cf9	a0 28					.word	NotImplemented           ; $cd
>1cfb	a0 28					.word	NotImplemented           ; $ce
>1cfd	a0 28					.word	NotImplemented           ; $cf
>1cff	a0 28					.word	NotImplemented           ; $d0
>1d01	a0 28					.word	NotImplemented           ; $d1
>1d03	a0 28					.word	NotImplemented           ; $d2
>1d05	a0 28					.word	NotImplemented           ; $d3
>1d07	a0 28					.word	NotImplemented           ; $d4
>1d09	a9 18					.word	EXPUnaryDeek             ; $d5 DEEK(
>1d0b	9b 18					.word	EXPUnaryPeek             ; $d6 PEEK(
>1d0d	ea 19					.word	EXPUnaryRight            ; $d7 RIGHT$(
>1d0f	dd 19					.word	EXPUnaryLeft             ; $d8 LEFT$(
>1d11	04 1a					.word	EXPUnaryMid              ; $d9 MID$(
>1d13	9b 19					.word	EXPUnaryStr              ; $da STR$(
>1d15	66 1a					.word	EXPUnaryVal              ; $db VAL(
>1d17	68 19					.word	EXPUnarySgn              ; $dc SGN(
>1d19	19 18					.word	EXPUnaryAbs              ; $dd ABS(
>1d1b	ed 18					.word	EXPUnaryLen              ; $de LEN(
>1d1d	7e 19					.word	EXPUnarySqr              ; $df SQR(
>1d1f	39 18					.word	EXPUnaryChr              ; $e0 CHR$(
>1d21	23 18					.word	EXPUnaryAsc              ; $e1 ASC(
>1d23	cf 18					.word	EXPUnaryInkey            ; $e2 INKEY$(
>1d25	a0 28					.word	NotImplemented           ; $e3 EVENT(
>1d27	a0 28					.word	NotImplemented           ; $e4 TIME
>1d29	e3 18					.word	EXPUnaryInt              ; $e5 INT(
>1d2b	c5 18					.word	EXPUnaryFrac             ; $e6 FRAC(
>1d2d	4a 18					.word	EXPUnaryDec              ; $e7 DEC(
>1d2f	8d 19					.word	EXPUnaryHex              ; $e8 HEX$(
>1d31	02 19					.word	EXPUnaryRnd              ; $e9 RND(
>1d33	12 19					.word	ExpUnaryRand             ; $ea RAND(
>1d35	fb 18					.word	EXPUnaryParenthesis      ; $eb (
>1d37	c1 18					.word	EXPUnaryNull             ; $ec $
>1d39	98 18					.word	EXPUnaryInlineDec        ; $ed [[DECIMAL]]
>1d3b	c2 19					.word	EXPUnaryInlineString     ; $ee [[STRING]]
>1d3d	03 16					.word	EXPCompareEqual          ; $ef =
>1d3f	1e 16					.word	EXPCompareNotEqual       ; $f0 <>
>1d41	27 16					.word	EXPCompareLessEqual      ; $f1 <=
>1d43	0c 16					.word	EXPCompareLess           ; $f2 <
>1d45	30 16					.word	EXPCompareGreaterEqual   ; $f3 >=
>1d47	15 16					.word	EXPCompareGreater        ; $f4 >
>1d49	b0 15					.word	EXPBinXor                ; $f5 XOR
>1d4b	a4 15					.word	EXPBinOr                 ; $f6 OR
>1d4d	98 15					.word	EXPBinAnd                ; $f7 AND
>1d4f	70 15					.word	EXPBinIDiv               ; $f8 DIV
>1d51	81 15					.word	EXPBinIMod               ; $f9 MOD
>1d53	7b 16					.word	EXPBinLeft               ; $fa <<
>1d55	83 16					.word	EXPBinRight              ; $fb >>
>1d57	64 15					.word	EXPBinFDiv               ; $fc /
>1d59	5b 15					.word	EXPBinMul                ; $fd *
>1d5b	52 15					.word	EXPBinSub                ; $fe -
>1d5d	49 15					.word	EXPBinAdd                ; $ff +

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/detokenise.asm

.1d5f					TOKDetokenise:
.1d5f	86 26		stx $26				stx 	zTemp2 						; save tokenised code in zTemp2
.1d61	84 27		sty $27				sty 	zTemp2+1
.1d63	9c 18 05	stz $0518			stz		TOKLastCharacter 			; clear last character
.1d66					_TOKDLoop:
.1d66	20 95 1d	jsr $1d95			jsr 	TOKDGet 					; get next
.1d69	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ			; end of line
.1d6b	f0 26		beq $1d93			beq 	_TOKDExit
.1d6d	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ		; is it a string/integer with additional data.
.1d6f	f0 1d		beq $1d8e			beq 	_TOKDDataItem
.1d71	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ
.1d73	f0 19		beq $1d8e			beq 	_TOKDDataItem
.1d75	c9 00		cmp #$00			cmp 	#0 							; is it a token 80-FF
.1d77	10 05		bpl $1d7e			bpl 	_TOKDNotToken
.1d79	20 5d 1e	jsr $1e5d			jsr 	TOKDToken 					; token to text.
.1d7c	80 e8		bra $1d66			bra 	_TOKDLoop
.1d7e					_TOKDNotToken:
.1d7e	c9 40		cmp #$40			cmp 	#$40  						; 40-7F Identifier
.1d80	90 05		bcc $1d87			bcc 	_TOKDNotIdentifier
.1d82	20 d0 1d	jsr $1dd0			jsr 	TOKDIdentifier
.1d85	80 df		bra $1d66			bra 	_TOKDLoop
.1d87					_TOKDNotIdentifier:
.1d87	a0 0a		ldy #$0a			ldy 	#10
.1d89	20 19 1e	jsr $1e19			jsr 	TOKDInteger
.1d8c	80 d8		bra $1d66			bra 	_TOKDLoop
.1d8e					_TOKDDataItem:
.1d8e	20 ab 1d	jsr $1dab			jsr 	TOKDDataItem
.1d91	80 d3		bra $1d66			bra 	_TOKDLoop
.1d93					_TOKDExit:
.1d93	18		clc				clc
.1d94	60		rts				rts
.1d95	b2 26		lda ($26)	TOKDGet:lda 	(zTemp2)
.1d97	e6 26		inc $26				inc 	zTemp2
.1d99	d0 02		bne $1d9d			bne 	_TKDGExit
.1d9b	e6 27		inc $27				inc 	zTemp2+1
.1d9d					_TKDGExit:
.1d9d	60		rts				rts
.1d9e					TOKDOutput:
.1d9e	8d 18 05	sta $0518			sta 	TOKLastCharacter
.1da1	6c 16 05	jmp ($0516)			jmp 	(TOKOutputMethod)
.1da4					TOKSetDetokeniseOutput:
.1da4	8e 16 05	stx $0516			stx 	TOKOutputMethod
.1da7	8c 17 05	sty $0517			sty 	TOKOutputMethod+1
.1daa	60		rts				rts
.0516					TOKOutputMethod:
>0516							.fill 	2
.0518					TOKLastCharacter:
>0518							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkdataitem.asm

.1dab					TOKDDataItem:
.1dab	a8		tay				tay 								; type in Y
.1dac	a9 22		lda #$22			lda 	#'"'						; start with " or .
.1dae	c0 ee		cpy #$ee			cpy 	#PR_LSQLSQSTRINGRSQRSQ
.1db0	f0 02		beq $1db4			beq 	_TOKDDIsString
.1db2	a9 2e		lda #$2e			lda 	#'.'
.1db4					_TOKDDIsString:
.1db4	20 9e 1d	jsr $1d9e			jsr 	TOKDOutput 					; dump it
.1db7	20 95 1d	jsr $1d95			jsr 	TOKDGet 					; get length into X
.1dba	aa		tax				tax
.1dbb					_TOKDDOutput:
.1dbb	ca		dex				dex 								; are we complete
.1dbc	30 08		bmi $1dc6			bmi 	_TOKDDEnd
.1dbe	20 95 1d	jsr $1d95			jsr 	TOKDGet 					; get character and output it
.1dc1	20 9e 1d	jsr $1d9e			jsr 	TOKDOutput
.1dc4	80 f5		bra $1dbb			bra 	_TOKDDOutput
.1dc6					_TOKDDEnd:
.1dc6	c0 ee		cpy #$ee			cpy 	#PR_LSQLSQSTRINGRSQRSQ 		; if string, do closing quote
.1dc8	d0 05		bne $1dcf			bne 	_TOKDDNotString
.1dca	a9 22		lda #$22			lda 	#'"'
.1dcc	20 9e 1d	jsr $1d9e			jsr 	TOKDOutput
.1dcf					_TOKDDNotString:
.1dcf	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkidentifier.asm

.1dd0					TOKDIdentifier:
.1dd0	a0 ff		ldy #$ff			ldy 	#$FF
.1dd2	8c 19 05	sty $0519			sty 	TOKDIFirstChar
.1dd5					_TOKDLoop:
.1dd5	a8		tay				tay 								; token in Y
.1dd6	a9 2e		lda #$2e			lda 	#'.' 						; handle special cases.
.1dd8	c0 64		cpy #$64			cpy 	#$64
.1dda	f0 11		beq $1ded			beq 	_TOKDIOutput
.1ddc	a9 5f		lda #$5f			lda 	#'_'
.1dde	c0 65		cpy #$65			cpy 	#$65
.1de0	f0 0b		beq $1ded			beq 	_TOKDIOutput
.1de2	98		tya				tya 								; handle a-z
.1de3	18		clc				clc
.1de4	69 21		adc #$21			adc	 	#$21
.1de6	c0 5a		cpy #$5a			cpy 	#$5A
.1de8	90 03		bcc $1ded			bcc 	_TOKDIOutput
.1dea	38		sec				sec 								; handle 0-9
.1deb	e9 4b		sbc #$4b			sbc 	#$4B
.1ded					_TOKDIOutput:
.1ded	2c 19 05	bit $0519			bit 	TOKDIFirstChar
.1df0	10 08		bpl $1dfa			bpl 	_TOKDINoSpacing
.1df2	48		pha				pha
.1df3	20 8f 1e	jsr $1e8f			jsr 	TOKDSpacing
.1df6	9c 19 05	stz $0519			stz 	TOKDIFirstChar
.1df9	68		pla				pla
.1dfa					_TOKDINoSpacing:
.1dfa	20 9e 1d	jsr $1d9e			jsr 	TOKDOutput
.1dfd	20 95 1d	jsr $1d95			jsr 	TOKDGet 					; get next token
.1e00	c9 7c		cmp #$7c			cmp 	#$7C
.1e02	90 d1		bcc $1dd5			bcc 	_TOKDLoop
.1e04	f0 12		beq $1e18			beq 	_TOKDIExit 					; it's a number, no tail.
.1e06	4a		lsr a				lsr 	a 							; string ?
.1e07	90 07		bcc $1e10			bcc 	_TOKDICheckArray
.1e09	48		pha				pha
.1e0a	a9 24		lda #$24			lda 	#"$"
.1e0c	20 9e 1d	jsr $1d9e			jsr 	TOKDOutput
.1e0f	68		pla				pla
.1e10					_TOKDICheckArray:
.1e10	4a		lsr a				lsr 	a 							; array ?
.1e11	90 05		bcc $1e18			bcc 	_TOKDIExit
.1e13	a9 28		lda #$28			lda 	#"("
.1e15	20 9e 1d	jsr $1d9e			jsr 	TOKDOutput
.1e18					_TOKDIExit:
.1e18	60		rts				rts
.0519					TOKDIFirstChar:
>0519							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtkinteger.asm

.1e19					TOKDInteger:
.1e19	5a		phy				phy 								; save base
.1e1a	a2 08		ldx #$08			ldx 	#IFR0 						; set into R0
.1e1c	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.1e1f					_TOKDILoop:
.1e1f	b2 26		lda ($26)			lda 	(zTemp2) 					; followed by a 00-3F
.1e21	c9 40		cmp #$40			cmp 	#$40
.1e23	b0 1d		bcs $1e42			bcs 	_TOKDIHaveInteger
.1e25	a2 08		ldx #$08			ldx 	#IFR0 						; R0 << 6
.1e27	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.1e2a	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.1e2d	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.1e30	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.1e33	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.1e36	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.1e39	20 95 1d	jsr $1d95			jsr 	TOKDGet 					; OR byte in.
.1e3c	05 08		ora $08				ora 	IFR0+IM0
.1e3e	85 08		sta $08				sta 	IFR0+IM0
.1e40	80 dd		bra $1e1f			bra 	_TOKDILoop
.1e42					_TOKDIHaveInteger:
.1e42	7a		ply				ply 								; restore base
.1e43	98		tya				tya 								; base in A
.1e44	20 6c 2e	jsr $2e6c			jsr 	IFloatIntegerToStringR0
.1e47	86 22		stx $22				stx 	zTemp0
.1e49	84 23		sty $23				sty 	zTemp0+1
.1e4b	b2 22		lda ($22)			lda 	(zTemp0)
.1e4d	20 8f 1e	jsr $1e8f			jsr 	TOKDSpacing 				; check spacing okay.
.1e50	a0 00		ldy #$00			ldy 	#0 							; output buffer.
.1e52					_TOKDOutput:
.1e52	b1 22		lda ($22),y			lda 	(zTemp0),y
.1e54	20 9e 1d	jsr $1d9e			jsr 	TOKDOutput
.1e57	c8		iny				iny
.1e58	b1 22		lda ($22),y			lda 	(zTemp0),y
.1e5a	d0 f6		bne $1e52			bne 	_TOKDOutput
.1e5c	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/detokenise/dtktoken.asm

.1e5d					TOKDToken:
.1e5d	a2 a5		ldx #$a5			ldx 	#StandardTokens & $FF
.1e5f	a0 1a		ldy #$1a			ldy 	#StandardTokens >> 8
.1e61					_TOKDSearch:
.1e61	86 22		stx $22				stx 	zTemp0 						; put table in zTemp0
.1e63	84 23		sty $23				sty 	zTemp0+1
.1e65	aa		tax				tax 								; token ID in X.
.1e66					_TOKDFind:
.1e66	ca		dex				dex 								; reached the start
.1e67	10 0d		bpl $1e76			bpl 	_TOKDFound
.1e69	38		sec				sec 								; go to next entry
.1e6a	b2 22		lda ($22)			lda 	(zTemp0)
.1e6c	65 22		adc $22				adc 	zTemp0
.1e6e	85 22		sta $22				sta 	zTemp0
.1e70	90 f4		bcc $1e66			bcc 	_TOKDFind
.1e72	e6 23		inc $23				inc 	zTemp0+1
.1e74	80 f0		bra $1e66			bra 	_TOKDFind
.1e76					_TOKDFound:
.1e76	b2 22		lda ($22)			lda 	(zTemp0) 					; length to X
.1e78	f0 14		beq $1e8e			beq 	_TOKDExit
.1e7a	aa		tax				tax
.1e7b	a0 01		ldy #$01			ldy 	#1 							; output the token.
.1e7d	b1 22		lda ($22),y			lda 	(zTemp0),y 					; check spacing
.1e7f	20 8f 1e	jsr $1e8f			jsr 	TOKDSpacing
.1e82					_TOKDOutput:
.1e82	b1 22		lda ($22),y			lda 	(zTemp0),y
.1e84	20 2a 22	jsr $222a			jsr 	TOKToLower
.1e87	20 9e 1d	jsr $1d9e			jsr 	TOKDOutput
.1e8a	c8		iny				iny
.1e8b	ca		dex				dex
.1e8c	d0 f4		bne $1e82			bne 	_TOKDOutput
.1e8e					_TOKDExit:
.1e8e	60		rts				rts
.1e8f					TOKDSpacing:
.1e8f	20 41 22	jsr $2241			jsr 	TOKIsIdentifierElement		; next character alphanumeric
.1e92	90 0d		bcc $1ea1			bcc 	_TOKDSExit
.1e94	ad 18 05	lda $0518			lda 	TOKLastCharacter			; and last character also alphanumeric
.1e97	20 41 22	jsr $2241			jsr 	TOKIsIdentifierElement
.1e9a	90 05		bcc $1ea1			bcc 	_TOKDSExit
.1e9c	a9 20		lda #$20			lda 	#" " 						; we need a space.
.1e9e	20 9e 1d	jsr $1d9e			jsr 	TOKDOutput
.1ea1					_TOKDSExit:
.1ea1	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/editing/delete.asm

.1ea2					PGMDeleteLine:
.1ea2	20 55 1f	jsr $1f55			jsr 	PGMEndProgram 				; end of program into zTemp0
.1ea5	64 24		stz $24				stz 	zTemp1						; copy base address of code to zTemp1
.1ea7	ad 1a 05	lda $051a			lda 	PGMBaseHigh
.1eaa	85 25		sta $25				sta 	zTemp1+1
.1eac					_PGMDLoop:
.1eac	b2 24		lda ($24)			lda 	(zTemp1) 					; finished, not found ?
.1eae	38		sec				sec
.1eaf	f0 3a		beq $1eeb			beq 	_PGMDExit
.1eb1	a0 01		ldy #$01			ldy 	#1 							; found line number ?
.1eb3	b1 24		lda ($24),y			lda 	(zTemp1),y
.1eb5	cd 01 04	cmp $0401			cmp 	TOKLineNumber
.1eb8	d0 08		bne $1ec2			bne 	_PGMDNext
.1eba	c8		iny				iny
.1ebb	b1 24		lda ($24),y			lda 	(zTemp1),y
.1ebd	cd 02 04	cmp $0402			cmp 	TOKLineNumber+1
.1ec0	f0 0d		beq $1ecf			beq 	_PGMDDelete
.1ec2					_PGMDNext:
.1ec2	18		clc				clc
.1ec3	b2 24		lda ($24)			lda 	(zTemp1)
.1ec5	65 24		adc $24				adc 	zTemp1
.1ec7	85 24		sta $24				sta 	zTemp1
.1ec9	90 e1		bcc $1eac			bcc 	_PGMDLoop
.1ecb	e6 25		inc $25				inc 	zTemp1+1
.1ecd	80 dd		bra $1eac			bra 	_PGMDLoop
.1ecf					_PGMDDelete:
.1ecf	b2 24		lda ($24)			lda 	(zTemp1) 					; offset to next in Y
.1ed1	a8		tay				tay
.1ed2					_PGMDCopy:
.1ed2	b1 24		lda ($24),y			lda 	(zTemp1),y 					; copy down.
.1ed4	92 24		sta ($24)			sta 	(zTemp1)
.1ed6	a5 24		lda $24				lda 	zTemp1 						; reached the end ?
.1ed8	c5 22		cmp $22				cmp 	zTemp0
.1eda	d0 07		bne $1ee3			bne 	_PGMDNext2
.1edc	a5 25		lda $25				lda 	zTemp1+1
.1ede	c5 23		cmp $23				cmp 	zTemp0+1
.1ee0	18		clc				clc
.1ee1	f0 08		beq $1eeb			beq 	_PGMDExit
.1ee3					_PGMDNext2:
.1ee3	e6 24		inc $24				inc 	zTemp1 						; advance pointer.
.1ee5	d0 eb		bne $1ed2			bne 	_PGMDCopy
.1ee7	e6 25		inc $25				inc 	zTemp1+1
.1ee9	80 e7		bra $1ed2			bra 	_PGMDCopy
.1eeb					_PGMDExit:
.1eeb	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/editing/insert.asm

.1eec					PGMInsertLine:
.1eec	20 55 1f	jsr $1f55			jsr 	PGMEndProgram 				; end of program into zTemp0
.1eef	64 24		stz $24				stz 	zTemp1						; copy base address of code to zTemp1
.1ef1	ad 1a 05	lda $051a			lda 	PGMBaseHigh
.1ef4	85 25		sta $25				sta 	zTemp1+1
.1ef6					_PGMILoop:
.1ef6	b2 24		lda ($24)			lda 	(zTemp1) 					; reached the end, it goes here on the end.
.1ef8	f0 1c		beq $1f16			beq 	_PGMIInsert
.1efa	a0 01		ldy #$01			ldy 	#1 							; compare in-program line vs token line.
.1efc	b1 24		lda ($24),y			lda 	(zTemp1),y
.1efe	cd 01 04	cmp $0401			cmp 	TOKLineNumber
.1f01	c8		iny				iny
.1f02	b1 24		lda ($24),y			lda 	(zTemp1),y
.1f04	ed 02 04	sbc $0402			sbc 	TOKLineNumber+1
.1f07	b0 0d		bcs $1f16			bcs 	_PGMIInsert 				; insert here.
.1f09	18		clc				clc
.1f0a	b2 24		lda ($24)			lda 	(zTemp1)
.1f0c	65 24		adc $24				adc 	zTemp1
.1f0e	85 24		sta $24				sta 	zTemp1
.1f10	90 e4		bcc $1ef6			bcc 	_PGMILoop
.1f12	e6 25		inc $25				inc 	zTemp1+1
.1f14	80 e0		bra $1ef6			bra 	_PGMILoop
.1f16					_PGMIInsert:
.1f16	ac 00 04	ldy $0400			ldy 	TOKLineSize 				; space required
.1f19					_PGMIInsertLoop:
.1f19	b2 22		lda ($22)			lda 	(zTemp0)
.1f1b	91 22		sta ($22),y			sta 	(zTemp0),y
.1f1d	a5 24		lda $24				lda 	zTemp1 						; reached insert point
.1f1f	c5 22		cmp $22				cmp 	zTemp0
.1f21	d0 06		bne $1f29			bne 	_PGMINext
.1f23	a5 25		lda $25				lda 	zTemp1+1
.1f25	c5 23		cmp $23				cmp 	zTemp0+1
.1f27	f0 0a		beq $1f33			beq 	_PGMIInserted
.1f29					_PGMINext:
.1f29	a5 22		lda $22				lda 	zTemp0
.1f2b	d0 02		bne $1f2f			bne 	_PGMINoBorrow
.1f2d	c6 23		dec $23				dec 	zTemp0+1
.1f2f					_PGMINoBorrow:
.1f2f	c6 22		dec $22				dec 	zTemp0
.1f31	80 e6		bra $1f19			bra 	_PGMIInsertLoop
.1f33					_PGMIInserted:
.1f33	a0 00		ldy #$00			ldy 	#0 							; copy tokenbuffer to insert point
.1f35					_PGMICopyLoop:
.1f35	b9 00 04	lda $0400,y			lda 	TOKLineSize,y
.1f38	91 24		sta ($24),y			sta 	(zTemp1),y
.1f3a	c8		iny				iny
.1f3b	cc 00 04	cpy $0400			cpy 	TOKLineSize
.1f3e	d0 f5		bne $1f35			bne 	_PGMICopyLoop
.1f40	18		clc				clc
.1f41	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/setup.asm

.1f42					PGMSetBaseAddress:
.1f42	8e 1a 05	stx $051a			stx 	PGMBaseHigh
.1f45	8c 1b 05	sty $051b			sty 	PGMEndMemoryHigh
.1f48	60		rts				rts
.1f49					PGMNewProgram:
.1f49	64 22		stz $22				stz 	zTemp0						; copy base address to zTemp0
.1f4b	ad 1a 05	lda $051a			lda 	PGMBaseHigh
.1f4e	85 23		sta $23				sta 	zTemp0+1
.1f50	a9 00		lda #$00			lda 	#0 							; overwrite the offset
.1f52	92 22		sta ($22)			sta 	(zTemp0)
.1f54	60		rts				rts
.1f55					PGMEndProgram:
.1f55	64 22		stz $22				stz 	zTemp0 						; copy base address to zTemp0
.1f57	ad 1a 05	lda $051a			lda 	PGMBaseHigh
.1f5a	85 23		sta $23				sta 	zTemp0+1
.1f5c					_PGMEPLoop:
.1f5c	b2 22		lda ($22)			lda 	(zTemp0)
.1f5e	f0 0b		beq $1f6b			beq 	_PGMEPExit
.1f60	18		clc				clc
.1f61	65 22		adc $22				adc 	zTemp0
.1f63	85 22		sta $22				sta 	zTemp0
.1f65	90 f5		bcc $1f5c			bcc 	_PGMEPLoop
.1f67	e6 23		inc $23				inc 	zTemp0+1
.1f69	80 f1		bra $1f5c			bra 	_PGMEPLoop
.1f6b					_PGMEPExit:
.1f6b	60		rts				rts
.051a					PGMBaseHigh:
>051a							.fill 	1
.051b					PGMEndMemoryHigh:
>051b							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokbuffer.asm

.1f6c					TOKResetElement:
.1f6c	9c 1c 05	stz $051c			stz 	TOKElement
.1f6f	60		rts				rts
.1f70					TOKWriteElement:
.1f70	da		phx				phx
.1f71	ae 1c 05	ldx $051c			ldx 	TOKElement
.1f74	9d 1d 05	sta $051d,x			sta 	TOKElementText,x
.1f77	9e 1e 05	stz $051e,x			stz 	TOKElementText+1,x
.1f7a	fa		plx				plx
.1f7b	ee 1c 05	inc $051c			inc 	TOKElement
.1f7e	60		rts				rts
.051c					TOKElement:
>051c							.fill 	1
.051d					TOKElementText:
>051d							.fill 	255

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokconstant.asm

.1f7f					TOKTokeniseConstant:
.1f7f	a5 08		lda $08				lda 	IFR0+IM0 					; check > 64
.1f81	48		pha				pha 								; save on stack
.1f82	29 c0		and #$c0			and 	#$C0
.1f84	05 09		ora $09				ora 	IFR0+IM1
.1f86	05 0a		ora $0a				ora 	IFR0+IM2
.1f88	f0 10		beq $1f9a			beq 	_TTCLess
.1f8a	da		phx				phx
.1f8b	a2 06		ldx #$06			ldx 	#6 							; divide by 64
.1f8d					_TTCShiftRight:
.1f8d	46 0a		lsr $0a				lsr 	IFR0+IM2
.1f8f	66 09		ror $09				ror 	IFR0+IM1
.1f91	66 08		ror $08				ror 	IFR0+IM0
.1f93	ca		dex				dex
.1f94	d0 f7		bne $1f8d			bne 	_TTCShiftRight
.1f96	fa		plx				plx
.1f97	20 7f 1f	jsr $1f7f			jsr 	TOKTokeniseConstant
.1f9a					_TTCLess:
.1f9a	68		pla				pla
.1f9b	29 3f		and #$3f			and 	#$3F 						; lower 6 bits
.1f9d	20 3c 20	jsr $203c			jsr 	TOKWriteA
.1fa0	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokdecimal.asm

.1fa1					TOKTokeniseDecimals:
.1fa1	20 4f 20	jsr $204f			jsr 	TOKGetNext 					; consume the .
.1fa4	20 b7 21	jsr $21b7			jsr 	TOKExtractInteger 			; pull an integer out as text.
.1fa7	a9 ed		lda #$ed			lda 	#PR_LSQLSQDECIMALRSQRSQ	 	; decimal token
.1fa9	20 3c 20	jsr $203c			jsr 	TOKWriteA
.1fac	20 b1 1f	jsr $1fb1			jsr 	TOKOutputElementBuffer 		; then the buffer
.1faf	18		clc				clc
.1fb0	60		rts				rts
.1fb1					TOKOutputElementBuffer:
.1fb1	ad 1c 05	lda $051c			lda 	TOKElement 					; get count and write that
.1fb4	20 3c 20	jsr $203c			jsr 	TOKWriteA
.1fb7	a8		tay				tay 								; put in Y
.1fb8	f0 0c		beq $1fc6			beq 	_TOEExit 					; exit if empty which is okay.
.1fba	a2 01		ldx #$01			ldx 	#1
.1fbc					_TOELoop:
.1fbc	bd 1c 05	lda $051c,x			lda 	TOKElement,x
.1fbf	20 3c 20	jsr $203c			jsr 	TOKWriteA
.1fc2	e8		inx				inx
.1fc3	88		dey				dey
.1fc4	d0 f6		bne $1fbc			bne 	_TOELoop
.1fc6					_TOEExit:
.1fc6	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokenise.asm

.1fc7					TOKTokenise:
.1fc7	8c 1d 06	sty $061d			sty 	TOKDataSource+1 			; save source routine pointer
.1fca	8e 1c 06	stx $061c			stx 	TOKDataSource
.1fcd	a9 01		lda #$01			lda 	#1 							; set first element flag.
.1fcf	8d 1e 06	sta $061e			sta 	TOKIsFirstElement
.1fd2	a9 03		lda #$03			lda 	#3 							; set the line length to three for the
.1fd4	8d 00 04	sta $0400			sta 	TOKLineSize 				; line length itself and the line numbers.
.1fd7	9c 01 04	stz $0401			stz 	TOKLineNumber
.1fda	9c 02 04	stz $0402			stz 	TOKLineNumber+1
.1fdd					_TOKMainLoop:
.1fdd	20 4b 20	jsr $204b			jsr 	TOKGet 						; what follows.
.1fe0	c9 00		cmp #$00			cmp 	#0 							; if zero, we are complete
.1fe2	f0 4f		beq $2033			beq 	_TOKExit
.1fe4	c9 20		cmp #$20			cmp 	#' '						; space, consume and loop back.
.1fe6	d0 05		bne $1fed			bne 	_TOKElement
.1fe8	20 4f 20	jsr $204f			jsr 	TOKGetNext
.1feb	80 f0		bra $1fdd			bra 	_TOKMainLoop
.1fed					_TOKElement:
.1fed	20 35 22	jsr $2235			jsr 	TOKIsDigit 					; is it 0..9
.1ff0	90 0a		bcc $1ffc			bcc 	_TOKNotDigit
.1ff2	20 8e 21	jsr $218e			jsr 	TOKTokeniseInteger 			; get integer
.1ff5	b0 43		bcs $203a			bcs 	_TOKFail 					; did it fail ?
.1ff7	9c 1e 06	stz $061e			stz 	TOKIsFirstElement 			; clear first element flag
.1ffa	80 e1		bra $1fdd			bra 	_TOKMainLoop
.1ffc					_TOKNotDigit:
.1ffc	9c 1e 06	stz $061e			stz 	TOKIsFirstElement 			; clear first element flag
.1fff	c9 24		cmp #$24			cmp 	#"$"						; check for hexadecimal ?
.2001	d0 07		bne $200a			bne 	_TOKNotHex
.2003	20 98 20	jsr $2098			jsr 	TOKTokeniseHexadecimal
.2006	b0 32		bcs $203a			bcs 	_TOKFail
.2008	80 d3		bra $1fdd			bra 	_TOKMainLoop
.200a					_TOKNotHex:
.200a	c9 2e		cmp #$2e			cmp 	#"."						; is it decimal e.g. .012345 etc.
.200c	d0 07		bne $2015			bne 	_TOKNotDecimal
.200e	20 a1 1f	jsr $1fa1			jsr 	TOKTokeniseDecimals
.2011	b0 27		bcs $203a			bcs 	_TOKFail
.2013	80 c8		bra $1fdd			bra 	_TOKMainLoop
.2015					_TOKNotDecimal:
.2015	c9 22		cmp #$22			cmp 	#'"'						; quoted string ?
.2017	d0 07		bne $2020			bne 	_TOKNotString
.2019	20 fc 21	jsr $21fc			jsr 	TOKTokeniseString
.201c	b0 1c		bcs $203a			bcs 	_TOKFail
.201e	80 bd		bra $1fdd			bra 	_TOKMainLoop
.2020					_TOKNotString:
.2020	20 52 22	jsr $2252			jsr 	TOKIsAlpha 					; identifier ?
.2023	b0 07		bcs $202c			bcs 	_TOKIdentifier
.2025	20 cb 21	jsr $21cb			jsr 	TOKTokenisePunctuation 		; punctuation
.2028	b0 10		bcs $203a			bcs 	_TOKFail
.202a	80 b1		bra $1fdd			bra 	_TOKMainLoop
.202c					_TOKIdentifier:
.202c	20 d2 20	jsr $20d2			jsr 	TOKTokeniseIdentifier 		; identifier/token.
.202f	b0 09		bcs $203a			bcs 	_TOKFail
.2031	80 aa		bra $1fdd			bra 	_TOKMainLoop
.2033					_TOKExit:
.2033	a9 8c		lda #$8c			lda 	#PR_LSQLSQENDRSQRSQ 		; write EOL
.2035	20 3c 20	jsr $203c			jsr 	TOKWriteA
.2038	18		clc				clc									; return with carry set.
.2039	60		rts				rts
.203a					_TOKFail:
.203a	38		sec				sec
.203b	60		rts				rts
.203c					TOKWriteA:
.203c	da		phx				phx
.203d	ae 00 04	ldx $0400			ldx 	TOKLineSize
.2040	9d 00 04	sta $0400,x			sta 	TOKLineSize,x
.2043	9e 01 04	stz $0401,x			stz 	TOKLineSize+1,x 			; makes it look like a line on its own for RUN.
.2046	fa		plx				plx
.2047	ee 00 04	inc $0400			inc 	TOKLineSize
.204a	60		rts				rts
.204b					TOKGet:
.204b	18		clc				clc
.204c	6c 1c 06	jmp ($061c)			jmp 	(TOKDataSource)
.204f					TOKGetNext:
.204f	38		sec				sec
.2050	6c 1c 06	jmp ($061c)			jmp 	(TOKDataSource)
.061c					TOKDataSource:
>061c							.fill 	2
.061e					TOKIsFirstElement:
>061e							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokfind.asm

.2053					TOKFindToken:
.2053	a2 a5		ldx #$a5			ldx 	#StandardTokens & $FF 		; do this table
.2055	a0 1a		ldy #$1a			ldy 	#StandardTokens >> 8
.2057	20 62 20	jsr $2062			jsr 	TOKFindTokenXY 				; find it, or not
.205a	90 04		bcc $2060			bcc 	_TOKFTFail
.205c	a2 00		ldx #$00			ldx 	#0
.205e	38		sec				sec
.205f	60		rts				rts
.2060					_TOKFTFail
.2060	18		clc				clc
.2061	60		rts				rts
.2062					TOKFindTokenXY:
.2062	86 22		stx $22				stx 	zTemp0 						; save token table address
.2064	84 23		sty $23				sty 	zTemp0+1
.2066	a9 80		lda #$80			lda 	#$80 						; table starts at $80
.2068	8d 1f 06	sta $061f			sta 	TOKCurrent
.206b					_TOKFindLoop:
.206b	b2 22		lda ($22)			lda 	(zTemp0) 					; get token length from table
.206d	18		clc				clc 		 						; clear carry in case of fail
.206e	30 17		bmi $2087			bmi 	_TOKExit 					; end of table, fail, so return CC.
.2070	cd 1c 05	cmp $051c			cmp 	TOKElement 					; compare against the element length
.2073	d0 13		bne $2088			bne 	_TOKNext 					; different, try next.
.2075	aa		tax				tax 								; number of chars to compare.
.2076	a0 01		ldy #$01			ldy 	#1 							; offset to actual text.
.2078					_TOKCompare:
.2078	b1 22		lda ($22),y			lda 	(zTemp0),y 					; compare the characters
.207a	d9 1c 05	cmp $051c,y			cmp 	TOKElementText-1,y
.207d	d0 09		bne $2088			bne 	_TOKNext 					; different ? try next
.207f	c8		iny				iny 								; compare next two
.2080	ca		dex				dex
.2081	d0 f5		bne $2078			bne 	_TOKCompare 				; until done X characters.
.2083	38		sec				sec
.2084	ad 1f 06	lda $061f			lda 	TOKCurrent 					; return current ID.
.2087					_TOKExit:
.2087	60		rts				rts
.2088					_TOKNext:
.2088	ee 1f 06	inc $061f			inc 	TOKCurrent 					; increment token #
.208b	38		sec				sec 								; add length+1 to ptr
.208c	b2 22		lda ($22)			lda 	(zTemp0)
.208e	65 22		adc $22				adc 	zTemp0
.2090	85 22		sta $22				sta 	zTemp0
.2092	90 d7		bcc $206b			bcc 	_TOKFindLoop
.2094	e6 23		inc $23				inc 	zTemp0+1
.2096	80 d3		bra $206b			bra 	_TOKFindLoop
.061f					TOKCurrent:
>061f							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokhexadecimal.asm

.2098					TOKTokeniseHexadecimal:
.2098	20 4f 20	jsr $204f			jsr 	TOKGetNext 					; consume the $
.209b	a2 08		ldx #$08			ldx 	#IFR0
.209d	20 cb 30	jsr $30cb			jsr 	IFloatSetZero 				; set R0 = 0
.20a0					_TTHLoop:
.20a0	20 4b 20	jsr $204b			jsr 	TOKGet 						; keep getting and copying while numeric.
.20a3	20 5f 22	jsr $225f			jsr 	TOKIsHexadecimal
.20a6	90 20		bcc $20c8			bcc 	_TTHDone
.20a8	a2 08		ldx #$08			ldx 	#IFR0 						; shift R0 right 4
.20aa	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.20ad	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.20b0	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.20b3	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.20b6	20 4f 20	jsr $204f			jsr 	TOKGetNext
.20b9	38		sec				sec 								; convert to decimal.
.20ba	e9 30		sbc #$30			sbc 	#48
.20bc	c9 0a		cmp #$0a			cmp 	#10
.20be	90 02		bcc $20c2			bcc 	_TTHNotAlpha
.20c0	e9 07		sbc #$07			sbc 	#7
.20c2					_TTHNotAlpha:
.20c2	05 08		ora $08				ora 	IFR0+IM0 					; OR in
.20c4	85 08		sta $08				sta 	IFR0+IM0
.20c6	80 d8		bra $20a0			bra 	_TTHLoop
.20c8					_TTHDone:
.20c8	a9 ec		lda #$ec			lda 	#PR_DOLLAR 					; write $ function out
.20ca	20 3c 20	jsr $203c			jsr 	TOKWriteA
.20cd	20 7f 1f	jsr $1f7f			jsr 	TOKTokeniseConstant 		; write integer out.
.20d0	18		clc				clc
.20d1	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokidentifier.asm

.20d2					TOKTokeniseIdentifier:
.20d2	20 6c 1f	jsr $1f6c			jsr 	TOKResetElement 			; extract an identifier
.20d5					_TOKGetIdentifier:
.20d5	20 4b 20	jsr $204b			jsr 	TOKGet
.20d8	20 1f 22	jsr $221f			jsr 	TOKToUpper
.20db	20 41 22	jsr $2241			jsr 	TOKIsIdentifierElement
.20de	90 08		bcc $20e8			bcc 	_TOKEndIdent
.20e0	20 70 1f	jsr $1f70			jsr		TOKWriteElement
.20e3	20 4f 20	jsr $204f			jsr 	TOKGetNext
.20e6	80 ed		bra $20d5			bra 	_TOKGetIdentifier
.20e8					_TOKEndIdent:
.20e8	c9 24		cmp #$24			cmp 	#"$" 						; last one $
.20ea	d0 06		bne $20f2			bne 	_TOKNotString
.20ec	20 70 1f	jsr $1f70			jsr 	TOKWriteElement 			; add it
.20ef	20 4f 20	jsr $204f			jsr 	TOKGetNext 					; consume it
.20f2					_TOKNotString:
.20f2	20 4b 20	jsr $204b			jsr 	TOKGet 						; finally check for (
.20f5	c9 28		cmp #$28			cmp 	#"("
.20f7	d0 06		bne $20ff			bne 	_TOKNoArray
.20f9	20 70 1f	jsr $1f70			jsr 	TOKWriteElement 			; add it
.20fc	20 4f 20	jsr $204f			jsr 	TOKGetNext 					; consume it
.20ff					_TOKNoArray:
.20ff	20 53 20	jsr $2053			jsr 	TOKFindToken 				; find it
.2102	90 0e		bcc $2112			bcc		_TOKIsVariable 				; it must be a variable or proc name if not found
.2104	c9 97		cmp #$97			cmp 	#PR_REM 					; is it REM ?
.2106	f0 05		beq $210d			beq 	_TOKComment 				; yes, do comment code.
.2108	20 3c 20	jsr $203c			jsr 	TOKWriteA
.210b	18		clc				clc
.210c	60		rts				rts
.210d					_TOKComment:
.210d	20 59 21	jsr $2159			jsr 	TOKDoComment
.2110	18		clc				clc
.2111	60		rts				rts
.2112					_TOKIsVariable:
.2112	a2 00		ldx #$00			ldx 	#0 							; output element buffer
.2114					_TOKOutputBuffer:
.2114	bd 1d 05	lda $051d,x			lda 	TOKElementText,x 			; output it translated.
.2117	20 40 21	jsr $2140			jsr 	TOKTranslateIdentifier
.211a	20 3c 20	jsr $203c			jsr 	TOKWriteA
.211d	e8		inx				inx
.211e	bd 1d 05	lda $051d,x			lda 	TOKElementText,x
.2121	20 41 22	jsr $2241			jsr 	TOKIsIdentifierElement
.2124	b0 ee		bcs $2114			bcs 	_TOKOutputBuffer
.2126	a8		tay				tay 								; last char in Y
.2127	a9 7c		lda #$7c			lda 	#$7C 						; token is $7C
.2129	c0 00		cpy #$00			cpy 	#0 							; if no modifier use this
.212b	f0 0e		beq $213b			beq 	_TOKIVExit
.212d	c0 24		cpy #$24			cpy 	#'$'						; array mod ?
.212f	d0 04		bne $2135			bne 	_TOKIVCheckArray 			; no, check for (
.2131	1a		inc a				inc 	a 							; token is $7D
.2132	bc 1e 05	ldy $051e,x			ldy 	TOKElementText+1,x 			; get next one.
.2135					_TOKIVCheckArray:
.2135	c0 28		cpy #$28			cpy 	#'('						; is it ( ?
.2137	d0 02		bne $213b			bne 	_TOKIVExit 					; yes, then add 2 more, so 7C->7E and 7D->7F
.2139	1a		inc a				inc 	a
.213a	1a		inc a				inc 	a
.213b					_TOKIVExit:
.213b	20 3c 20	jsr $203c			jsr 	TOKWriteA 					; ending token
.213e	18		clc				clc
.213f	60		rts				rts
.2140					TOKTranslateIdentifier:
.2140	c9 2e		cmp #$2e			cmp 	#"." 						; . is 0x64
.2142	f0 0f		beq $2153			beq 	_TTI64
.2144	c9 5f		cmp #$5f			cmp 	#"_"						; _ is 0x65
.2146	f0 0e		beq $2156			beq 	_TTI65
.2148	38		sec				sec
.2149	e9 41		sbc #$41			sbc 	#"A" 						; map A-Z onto 0-25
.214b	10 03		bpl $2150			bpl 	_TTIExit
.214d	18		clc				clc 								; map 09 onto 26-35
.214e	69 2b		adc #$2b			adc 	#"A"-"0"+26
.2150					_TTIExit:
.2150	09 40		ora #$40			ora 	#$40 						; correct range.
.2152	60		rts				rts
.2153	a9 64		lda #$64	_TTI64:	lda 	#$64
.2155	60		rts				rts
.2156	a9 65		lda #$65	_TTI65:	lda 	#$65
.2158	60		rts				rts
.2159					TOKDoComment:
.2159	20 4b 20	jsr $204b			jsr 	TOKGet 						; skip over spaces
.215c	c9 20		cmp #$20			cmp 	#' '
.215e	d0 05		bne $2165			bne 	_TOKEndSpaces
.2160	20 4f 20	jsr $204f			jsr 	TOKGetNext
.2163	80 f4		bra $2159			bra 	TOKDoComment
.2165					_TOKEndSpaces:
.2165	48		pha				pha 								; save it
.2166	a9 97		lda #$97			lda 	#PR_REM 					; output the comment token.
.2168	20 3c 20	jsr $203c			jsr 	TOKWriteA
.216b	68		pla				pla
.216c	f0 04		beq $2172			beq 	_TOKDCExit 					; end of line.
.216e	c9 22		cmp #$22			cmp 	#'"'						; does it have a speech mark ?
.2170	d0 01		bne $2173			bne 	_TOKDCDoLine 				; otherwise the comment is the whole line.
.2172					_TOKDCExit:
.2172	60		rts				rts
.2173					_TOKDCDoLine:
.2173	20 6c 1f	jsr $1f6c			jsr 	TOKResetElement 			; start getting the string
.2176					_TOKDCLoop:
.2176	20 4b 20	jsr $204b			jsr 	TOKGet 						; check EOL
.2179	c9 00		cmp #$00			cmp 	#0
.217b	f0 08		beq $2185			beq 	_TOKDCEndComment
.217d	20 4f 20	jsr $204f			jsr 	TOKGetNext 					; get and consume
.2180	20 70 1f	jsr $1f70			jsr 	TOKWriteElement
.2183	80 f1		bra $2176			bra 	_TOKDCLoop
.2185					_TOKDCEndComment:
.2185	a9 ee		lda #$ee			lda 	#PR_LSQLSQSTRINGRSQRSQ
.2187	20 3c 20	jsr $203c			jsr 	TOKWriteA
.218a	20 b1 1f	jsr $1fb1			jsr 	TOKOutputElementBuffer
.218d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokinteger.asm

.218e					TOKTokeniseInteger:
.218e	20 b7 21	jsr $21b7			jsr 	TOKExtractInteger 			; pull an integer out as text.
.2191	a2 1d		ldx #$1d			ldx 	#TOKElementText & $FF
.2193	a0 05		ldy #$05			ldy 	#TOKElementText >> 8
.2195	ad 1c 05	lda $051c			lda		TOKElement
.2198	20 2f 2f	jsr $2f2f			jsr 	IFloatStringToFloatR0 		; convert to R0 integer
.219b	ad 1e 06	lda $061e			lda 	TOKIsFirstElement 			; first element ?
.219e	f0 12		beq $21b2			beq 	_TOKNotLineNumber
.21a0	a5 0a		lda $0a				lda 	IFR0+IM2 					; check it's a 2 digit number
.21a2	d0 0c		bne $21b0			bne 	_TOKBadLineNumeber
.21a4	a5 08		lda $08				lda 	IFR0+IM0 					; copy it to the line number section.
.21a6	8d 01 04	sta $0401			sta 	TOKLineNumber
.21a9	a5 09		lda $09				lda 	IFR0+IM1
.21ab	8d 02 04	sta $0402			sta 	TOKLineNumber+1
.21ae	18		clc				clc
.21af	60		rts				rts
.21b0					_TOKBadLineNumeber:
.21b0	38		sec				sec
.21b1	60		rts				rts
.21b2					_TOKNotLineNumber:
.21b2	20 7f 1f	jsr $1f7f			jsr 	TOKTokeniseConstant 		; tokenise the constant in R0
.21b5	18		clc				clc
.21b6	60		rts				rts
.21b7					TOKExtractInteger:
.21b7	20 6c 1f	jsr $1f6c			jsr 	TOKResetElement 			; restart
.21ba					_TTILoop:
.21ba	20 4b 20	jsr $204b			jsr 	TOKGet 						; keep getting and copying while numeric.
.21bd	20 35 22	jsr $2235			jsr 	TOKIsDigit
.21c0	90 08		bcc $21ca			bcc 	_TOKEIExit
.21c2	20 70 1f	jsr $1f70			jsr 	TOKWriteElement
.21c5	20 4f 20	jsr $204f			jsr 	TOKGetNext
.21c8	80 f0		bra $21ba			bra 	_TTILoop
.21ca					_TOKEIExit:
.21ca	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokpunctuation.asm

.21cb					TOKTokenisePunctuation:
.21cb	20 6c 1f	jsr $1f6c			jsr 	TOKResetElement 			; copy first punctuation character into element.
.21ce	20 4f 20	jsr $204f			jsr 	TOKGetNext
.21d1	20 70 1f	jsr $1f70			jsr 	TOKWriteElement
.21d4	20 4b 20	jsr $204b			jsr 	TOKGet 						; what follows ?
.21d7	c9 20		cmp #$20			cmp 	#' '						; space, not 2 character
.21d9	f0 10		beq $21eb			beq 	_TTPOne
.21db	20 49 22	jsr $2249			jsr 	TOKIsAlphaNumeric 			; if alphanumeric don't bother doing 2 character
.21de	b0 0b		bcs $21eb			bcs 	_TTPOne 					; these speed things up a bit.
.21e0	20 70 1f	jsr $1f70			jsr 	TOKWriteElement 			; this is what we will search for.
.21e3	20 53 20	jsr $2053			jsr 	TOKFindToken
.21e6	b0 0a		bcs $21f2			bcs 	_TTPConsumeExit 			; it was found, consume, generate, exit.
.21e8	ce 1c 05	dec $051c			dec 	TOKElement 					; make it a single character
.21eb					_TTPOne:
.21eb	20 53 20	jsr $2053			jsr 	TOKFindToken 				; look for one character punctuation
.21ee	b0 07		bcs $21f7			bcs 	_TTPOutputExit 				; we found it
.21f0	38		sec				sec 								; not recognised.
.21f1	60		rts				rts
.21f2					_TTPConsumeExit:
.21f2	48		pha				pha
.21f3	20 4f 20	jsr $204f			jsr 	TOKGetNext 					; get the 2nd char out.
.21f6	68		pla				pla
.21f7					_TTPOutputExit:
.21f7	20 3c 20	jsr $203c			jsr  	TOKWriteA 					; write token out
.21fa	18		clc				clc
.21fb	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/tokstring.asm

.21fc					TOKTokeniseString:
.21fc	20 4f 20	jsr $204f			jsr 	TOKGetNext 					; consume the "
.21ff	20 6c 1f	jsr $1f6c			jsr 	TOKResetElement 			; start getting the string
.2202					_TOKTSLoop:
.2202	20 4b 20	jsr $204b			jsr 	TOKGet 						; check EOL
.2205	c9 00		cmp #$00			cmp 	#0
.2207	f0 0c		beq $2215			beq 	_TOKTSExit
.2209	20 4f 20	jsr $204f			jsr 	TOKGetNext 					; get and consume
.220c	c9 22		cmp #$22			cmp 	#'"' 						; exit if " consumed
.220e	f0 05		beq $2215			beq 	_TOKTSExit
.2210	20 70 1f	jsr $1f70			jsr 	TOKWriteElement
.2213	80 ed		bra $2202			bra 	_TOKTSLoop
.2215					_TOKTSExit:
.2215	a9 ee		lda #$ee			lda 	#PR_LSQLSQSTRINGRSQRSQ
.2217	20 3c 20	jsr $203c			jsr 	TOKWriteA
.221a	20 b1 1f	jsr $1fb1			jsr 	TOKOutputElementBuffer
.221d	18		clc				clc
.221e	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/program/tokenise/toktypes.asm

.221f					TOKToUpper:
.221f	c9 61		cmp #$61			cmp 	#"a"
.2221	90 06		bcc $2229			bcc 	_TTUNotLower
.2223	c9 7b		cmp #$7b			cmp 	#"z"+1
.2225	b0 02		bcs $2229			bcs 	_TTUNotLower
.2227	49 20		eor #$20			eor 	#$20
.2229					_TTUNotLower:
.2229	60		rts				rts
.222a					TOKToLower:
.222a	c9 41		cmp #$41			cmp 	#"A"
.222c	90 06		bcc $2234			bcc 	_TTUNotUpper
.222e	c9 5b		cmp #$5b			cmp 	#"Z"+1
.2230	b0 02		bcs $2234			bcs 	_TTUNotUpper
.2232	49 20		eor #$20			eor 	#$20
.2234					_TTUNotUpper:
.2234	60		rts				rts
.2235					TOKIsDigit:
.2235	c9 30		cmp #$30			cmp 	#"0"
.2237	90 06		bcc $223f			bcc 	TOKFail
.2239	c9 3a		cmp #$3a			cmp 	#"9"+1
.223b	b0 02		bcs $223f			bcs 	TOKFail
.223d					TOKSucceed:
.223d	38		sec				sec
.223e	60		rts				rts
.223f					TOKFail:
.223f	18		clc				clc
.2240	60		rts				rts
.2241					TOKIsIdentifierElement:
.2241	c9 2e		cmp #$2e			cmp 	#"." 						; true if . or _
.2243	f0 f8		beq $223d			beq 	TOKSucceed
.2245	c9 5f		cmp #$5f			cmp 	#"_"
.2247	f0 f4		beq $223d			beq 	TOKSucceed 					; else fall through to alphanumeric
.2249					TOKIsAlphaNumeric:
.2249	20 52 22	jsr $2252			jsr 	TOKIsAlpha
.224c	b0 ef		bcs $223d			bcs 	TOKSucceed
.224e	20 35 22	jsr $2235			jsr 	TOKIsDigit
.2251	60		rts				rts
.2252					TOKIsAlpha:
.2252	20 1f 22	jsr $221f			jsr 	TOKToUpper
.2255	c9 41		cmp #$41			cmp 	#"A"
.2257	90 e6		bcc $223f			bcc 	TOKFail
.2259	c9 5b		cmp #$5b			cmp 	#"Z"+1
.225b	b0 e2		bcs $223f			bcs 	TOKFail
.225d	80 de		bra $223d			bra 	TOKSucceed
.225f					TOKIsHexadecimal:
.225f	20 35 22	jsr $2235			jsr		TOKIsDigit
.2262	b0 d9		bcs $223d			bcs 	TOKSucceed
.2264	20 52 22	jsr $2252			jsr 	TOKIsAlpha
.2267	90 d6		bcc $223f			bcc 	TOKFail
.2269	c9 47		cmp #$47			cmp 	#"F"+1
.226b	b0 d2		bcs $223f			bcs 	TOKFail
.226d	80 ce		bra $223d			bra 	TOKSucceed

;******  Return to file: include.files


;******  Processing file: src/structures/call.asm

.226f					Command_CALL:
.226f	a9 42		lda #$42			lda 	#STK_CALL
.2271	20 3c 27	jsr $273c			jsr 	StackOpen
.2274	b1 18		lda ($18),y			lda 	(codePtr),y 				; check identifier follows.
.2276	29 c0		and #$c0			and 	#$C0
.2278	c9 40		cmp #$40			cmp 	#$40
.227a	d0 29		bne $22a5			bne 	_CCSyntax
.227c	20 0c 2a	jsr $2a0c			jsr 	VARGetInfo 					; get the information
.227f	20 23 27	jsr $2723			jsr 	ERRCheckRParen 				; check right bracket follows.
.2282	20 be 29	jsr $29be			jsr 	VARFind 					; exists ?
.2285	90 21		bcc $22a8			bcc 	_CCUnknown
.2287	86 23		stx $23				stx 	zTemp0+1 					; save target in XA
.2289	85 22		sta $22				sta 	zTemp0
.228b	20 70 27	jsr $2770			jsr 	STKSaveCodePosition 		; save return address on stack.
.228e	a0 03		ldy #$03			ldy 	#3 							; check $FF marker
.2290	b1 22		lda ($22),y			lda 	(zTemp0),y
.2292	c9 ff		cmp #$ff			cmp 	#$FF
.2294	d0 12		bne $22a8			bne 	_CCUnknown
.2296	88		dey				dey 								; get Y offset to stack
.2297	b1 22		lda ($22),y			lda 	(zTemp0),y
.2299	48		pha				pha
.229a	88		dey				dey 								; get address
.229b	b1 22		lda ($22),y			lda 	(zTemp0),y
.229d	85 19		sta $19				sta 	codePtr+1
.229f	b2 22		lda ($22)			lda 	(zTemp0)
.22a1	85 18		sta $18				sta 	codePtr
.22a3	7a		ply				ply 								; restore Y
.22a4	60		rts				rts
.22a5					_CCSyntax:
.22a5	4c 6e 25	jmp $256e		jmp	ErrorV_syntax
.22a8					_CCUnknown:
.22a8	4c e3 26	jmp $26e3		jmp	ErrorV_unknown
.22ab					Command_ENDPROC:
.22ab	a9 42		lda #$42			lda 	#STK_CALL
.22ad	20 68 27	jsr $2768			jsr 	StackCheckFrame
.22b0	20 82 27	jsr $2782			jsr 	STKLoadCodePosition 		; return
.22b3	20 5a 27	jsr $275a			jsr 	StackClose
.22b6	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/do.asm

.22b7					Command_DO:
.22b7	a9 22		lda #$22			lda 	#STK_DO
.22b9	20 3c 27	jsr $273c			jsr 	StackOpen
.22bc	20 70 27	jsr $2770			jsr 	STKSaveCodePosition 		; save loop position
.22bf	60		rts				rts
.22c0					Command_EXIT:
.22c0	a9 22		lda #$22			lda 	#STK_DO 					; check in LOOP
.22c2	20 68 27	jsr $2768			jsr 	StackCheckFrame
.22c5	20 5a 27	jsr $275a			jsr 	StackClose 					; close it
.22c8	a9 87		lda #$87			lda 	#PR_LOOP 					; forward to LOOP
.22ca	aa		tax				tax
.22cb	20 7e 24	jsr $247e			jsr 	ScanForward
.22ce	60		rts				rts
.22cf					Command_LOOP:
.22cf	a9 22		lda #$22			lda 	#STK_DO
.22d1	20 68 27	jsr $2768			jsr 	StackCheckFrame
.22d4	20 82 27	jsr $2782			jsr 	STKLoadCodePosition 		; loop back
.22d7	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/for.asm

.22d8					Command_FOR:
.22d8	a9 37		lda #$37			lda 	#STK_FOR 					; create frame
.22da	20 3c 27	jsr $273c			jsr 	StackOpen
.22dd	20 be 12	jsr $12be			jsr 	CommandLET 					; do "I = 1" bit
.22e0	5a		phy				phy 								; save variable address to +4,+5
.22e1	a0 04		ldy #$04			ldy 	#4
.22e3	a5 22		lda $22				lda 	zTemp0
.22e5	91 2a		sta ($2a),y			sta 	(basicStack),y
.22e7	c8		iny				iny
.22e8	a5 23		lda $23				lda 	zTemp0+1
.22ea	91 2a		sta ($2a),y			sta 	(basicStack),y
.22ec	7a		ply				ply
.22ed	a9 90		lda #$90			lda 	#PR_TO 						; TO symbol required.
.22ef	20 33 27	jsr $2733			jsr 	ERRCheckA
.22f2	20 06 17	jsr $1706			jsr 	EXPEvalNumber 				; evaluate the terminal value.
.22f5	a9 0a		lda #$0a			lda 	#10 						; save in slots 10-13
.22f7	a2 08		ldx #$08			ldx 	#IFR0
.22f9	20 4e 23	jsr $234e			jsr 	CFSaveR0X
.22fc	b1 18		lda ($18),y			lda 	(codePtr),y 				; STEP here ?
.22fe	c9 91		cmp #$91			cmp 	#PR_STEP
.2300	d0 06		bne $2308			bne 	_CFStep1
.2302	c8		iny				iny 								; consume step
.2303	20 06 17	jsr $1706			jsr 	EXPEvalNumber 				; evaluate STEP
.2306	80 24		bra $232c			bra 	_CFWriteStep
.2308					_CFStep1:
.2308	a2 08		ldx #$08			ldx 	#IFR0 						; default R0, 1
.230a	a9 01		lda #$01			lda 	#1
.230c	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.230f	5a		phy				phy 								; check for fast loop,step 1, integer start/end.
.2310	a0 04		ldy #$04			ldy 	#4 							; get variable address
.2312	b1 2a		lda ($2a),y			lda 	(basicStack),y
.2314	85 22		sta $22				sta 	zTemp0
.2316	c8		iny				iny
.2317	b1 2a		lda ($2a),y			lda 	(basicStack),y
.2319	85 23		sta $23				sta 	zTemp0+1
.231b	a0 03		ldy #$03			ldy 	#IExp 						; check that's an integer
.231d	b1 22		lda ($22),y			lda 	(zTemp0),y
.231f	d0 0a		bne $232b			bne 	_CFNotOptimised
.2321	a0 0d		ldy #$0d			ldy 	#13 						; check terminal value is integer.
.2323	b1 2a		lda ($2a),y			lda 	(basicStack),y
.2325	d0 04		bne $232b			bne 	_CFNotOptimised
.2327	a9 80		lda #$80			lda 	#$80 						; set the step so it's a string/
.2329	85 0b		sta $0b				sta 	IFR0+IExp
.232b					_CFNotOptimised:
.232b	7a		ply				ply
.232c					_CFWriteStep:
.232c	a2 08		ldx #$08			ldx 	#IFR0 						; Write to additive.
.232e	a9 06		lda #$06			lda 	#6
.2330	20 4e 23	jsr $234e			jsr 	CFSaveR0X
.2333	20 70 27	jsr $2770			jsr 	STKSaveCodePosition 		; save loop position
.2336	60		rts				rts
.2337					CFLoadR0X:
.2337	5a		phy				phy
.2338	a8		tay				tay
.2339	b1 2a		lda ($2a),y			lda 	(basicStack),y
.233b	95 00		sta $00,x			sta 	IM0,x
.233d	c8		iny				iny
.233e	b1 2a		lda ($2a),y			lda 	(basicStack),y
.2340	95 01		sta $01,x			sta 	IM1,x
.2342	c8		iny				iny
.2343	b1 2a		lda ($2a),y			lda 	(basicStack),y
.2345	95 02		sta $02,x			sta 	IM2,x
.2347	c8		iny				iny
.2348	b1 2a		lda ($2a),y			lda 	(basicStack),y
.234a	95 03		sta $03,x			sta 	IExp,x
.234c	7a		ply				ply
.234d	60		rts				rts
.234e					CFSaveR0X:
.234e	5a		phy				phy
.234f	a8		tay				tay
.2350	b5 00		lda $00,x			lda 	IM0,x
.2352	91 2a		sta ($2a),y			sta 	(basicStack),y
.2354	c8		iny				iny
.2355	b5 01		lda $01,x			lda 	IM1,x
.2357	91 2a		sta ($2a),y			sta 	(basicStack),y
.2359	c8		iny				iny
.235a	b5 02		lda $02,x			lda 	IM2,x
.235c	91 2a		sta ($2a),y			sta 	(basicStack),y
.235e	c8		iny				iny
.235f	b5 03		lda $03,x			lda 	IExp,x
.2361	91 2a		sta ($2a),y			sta 	(basicStack),y
.2363	7a		ply				ply
.2364	60		rts				rts
.2365					Command_NEXT:
.2365	a9 37		lda #$37			lda 	#STK_FOR
.2367	20 68 27	jsr $2768			jsr 	StackCheckFrame
.236a	5a		phy				phy 								; check optimised loop
.236b	a0 09		ldy #$09			ldy 	#9
.236d	b1 2a		lda ($2a),y			lda 	(basicStack),y
.236f	7a		ply				ply
.2370	0a		asl a				asl 	a
.2371	b0 35		bcs $23a8			bcs 	_CNOptimised
.2373	20 df 23	jsr $23df			jsr 	_CNLoadValue 				; load index value to R0.
.2376	a2 0c		ldx #$0c			ldx 	#IFR1 						; load adding value to R1.
.2378	a9 06		lda #$06			lda 	#6
.237a	20 37 23	jsr $2337			jsr 	CFLoadR0X
.237d	20 c1 2a	jsr $2ac1			jsr 	IFloatAdd 					; add them together and write back.
.2380	20 02 24	jsr $2402			jsr 	_CNSaveValue
.2383	a9 0a		lda #$0a			lda 	#10 						; terminal value in R1
.2385	a2 0c		ldx #$0c			ldx 	#IFR1
.2387	20 37 23	jsr $2337			jsr 	CFLoadR0X
.238a	20 99 2d	jsr $2d99			jsr 	IFloatCompare 				; compare terminal vs current
.238d	a2 08		ldx #$08			ldx 	#IFR0 						; if zero, e.g. equal, loop back.
.238f	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero
.2392	f0 10		beq $23a4			beq 	_CNLoopBack
.2394	a5 0b		lda $0b				lda 	IFR0+IExp 					; if sign compare and sign add match, loop back.
.2396	5a		phy				phy
.2397	a0 09		ldy #$09			ldy 	#6+IExp
.2399	51 2a		eor ($2a),y			eor 	(basicStack),y
.239b	7a		ply				ply
.239c	29 40		and #$40			and 	#IFSign
.239e	f0 04		beq $23a4			beq 	_CNLoopBack
.23a0					_CNExitLoop:
.23a0	20 5a 27	jsr $275a			jsr 	StackClose		 			; return
.23a3	60		rts				rts
.23a4					_CNLoopBack:
.23a4	20 82 27	jsr $2782			jsr 	STKLoadCodePosition 		; loop back
.23a7	60		rts				rts
.23a8					_CNOptimised:
.23a8	5a		phy				phy
.23a9	a0 04		ldy #$04			ldy 	#4 							; copy address of index variable to zTemp2
.23ab	b1 2a		lda ($2a),y			lda 	(basicStack),y
.23ad	85 26		sta $26				sta 	zTemp2
.23af	c8		iny				iny
.23b0	b1 2a		lda ($2a),y			lda 	(basicStack),y
.23b2	85 27		sta $27				sta 	zTemp2+1
.23b4	a0 ff		ldy #$ff			ldy 	#$FF 						; increment that value. this won't go round
.23b6					_CNIncrement:
.23b6	c8		iny				iny
.23b7	b1 26		lda ($26),y			lda 	(zTemp2),y
.23b9	1a		inc a				inc 	a
.23ba	91 26		sta ($26),y			sta 	(zTemp2),y
.23bc	f0 f8		beq $23b6			beq 	_CNIncrement
.23be	18		clc				clc 								; point zTemp0 to terminal value
.23bf	a5 2a		lda $2a				lda 	basicStack
.23c1	69 0a		adc #$0a			adc 	#10
.23c3	85 22		sta $22				sta 	zTemp0
.23c5	a5 2b		lda $2b				lda 	basicStack+1
.23c7	69 00		adc #$00			adc 	#0
.23c9	85 23		sta $23				sta 	zTemp0+1
.23cb	a0 01		ldy #$01			ldy 	#1 							; compare value to terminal.
.23cd	b2 26		lda ($26)			lda 	(zTemp2)
.23cf	d2 22		cmp ($22)			cmp 	(zTemp0)
.23d1	b1 26		lda ($26),y			lda 	(zTemp2),y
.23d3	f1 22		sbc ($22),y			sbc 	(zTemp0),y
.23d5	c8		iny				iny
.23d6	b1 26		lda ($26),y			lda 	(zTemp2),y
.23d8	f1 22		sbc ($22),y			sbc 	(zTemp0),y
.23da	7a		ply				ply
.23db	b0 c3		bcs $23a0			bcs 	_CNExitLoop
.23dd	80 c5		bra $23a4			bra 	_CNLoopBack
.23df					_CNLoadValue:
.23df	5a		phy				phy
.23e0	a0 04		ldy #$04			ldy 	#4 							; copy address to zTemp2
.23e2	b1 2a		lda ($2a),y			lda 	(basicStack),y
.23e4	85 26		sta $26				sta 	zTemp2
.23e6	c8		iny				iny
.23e7	b1 2a		lda ($2a),y			lda 	(basicStack),y
.23e9	85 27		sta $27				sta 	zTemp2+1
.23eb	a0 00		ldy #$00			ldy 	#0 							; copy dword at zTemp2 to IFR0
.23ed	b1 26		lda ($26),y			lda 	(zTemp2),y
.23ef	85 08		sta $08				sta 	IFR0+IM0
.23f1	c8		iny				iny
.23f2	b1 26		lda ($26),y			lda 	(zTemp2),y
.23f4	85 09		sta $09				sta 	IFR0+IM1
.23f6	c8		iny				iny
.23f7	b1 26		lda ($26),y			lda 	(zTemp2),y
.23f9	85 0a		sta $0a				sta 	IFR0+IM2
.23fb	c8		iny				iny
.23fc	b1 26		lda ($26),y			lda 	(zTemp2),y
.23fe	85 0b		sta $0b				sta 	IFR0+IExp
.2400	7a		ply				ply
.2401	60		rts				rts
.2402					_CNSaveValue:
.2402	5a		phy				phy
.2403	a0 00		ldy #$00			ldy 	#0
.2405	a5 08		lda $08				lda 	IFR0+IM0
.2407	91 26		sta ($26),y			sta 	(zTemp2),y
.2409	c8		iny				iny
.240a	a5 09		lda $09				lda 	IFR0+IM1
.240c	91 26		sta ($26),y			sta 	(zTemp2),y
.240e	c8		iny				iny
.240f	a5 0a		lda $0a				lda 	IFR0+IM2
.2411	91 26		sta ($26),y			sta 	(zTemp2),y
.2413	c8		iny				iny
.2414	a5 0b		lda $0b				lda 	IFR0+IExp
.2416	91 26		sta ($26),y			sta 	(zTemp2),y
.2418	7a		ply				ply
.2419	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/gosub.asm

.241a					Command_GOSUB:
.241a	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 			; get line number
.241d	a9 52		lda #$52			lda 	#STK_GOSUB
.241f	20 3c 27	jsr $273c			jsr 	StackOpen
.2422	20 70 27	jsr $2770			jsr 	STKSaveCodePosition 		; save return address on stack.
.2425	4c db 11	jmp $11db			jmp 	GotoR0
.2428					Command_RETURN:
.2428	a9 52		lda #$52			lda 	#STK_GOSUB
.242a	20 68 27	jsr $2768			jsr 	StackCheckFrame
.242d	20 82 27	jsr $2782			jsr 	STKLoadCodePosition 		; return
.2430	20 5a 27	jsr $275a			jsr 	StackClose
.2433	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/if.asm

.2434					IfCommand:
.2434	20 06 17	jsr $1706			jsr 	EXPEvalNumber 				; Get the if test.
.2437	b1 18		lda ($18),y			lda 	(codePtr),y					; what follows ?
.2439	c9 8f		cmp #$8f			cmp 	#PR_THEN  					; could be THEN <stuff>
.243b	d0 0c		bne $2449			bne 	_IfStructured 				; we still support it.
.243d	c8		iny				iny 								; consume THEN
.243e	a2 08		ldx #$08			ldx 	#IFR0
.2440	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero 			; is it zero
.2443	f0 01		beq $2446			beq 	_IfFail 					; if fail, go to next line
.2445	60		rts				rts 								; if THEN just continue
.2446					_IfFail:
.2446	4c cc 14	jmp $14cc			jmp 	RUNEndOfLine
.2449					_IfStructured:
.2449	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero 			; is it zero
.244c	d0 07		bne $2455			bne 	_IfExit 					; if not, then continue normally.
.244e	a9 8e		lda #$8e			lda 	#PR_ELSE 					; look for else/endif
.2450	a2 85		ldx #$85			ldx 	#PR_ENDIF
.2452	20 7e 24	jsr $247e			jsr 	ScanForward 				; and run from there
.2455					_IfExit:
.2455	60		rts				rts
.2456					ElseCode:
.2456	a9 85		lda #$85			lda 	#PR_ENDIF 					; else is only run after the if clause succeeds
.2458	aa		tax				tax 								; so just go to the structure exit
.2459	20 7e 24	jsr $247e			jsr 	ScanForward
.245c	60		rts				rts
.245d					EndIf:
.245d	60		rts				rts 								; endif code does nothing

;******  Return to file: include.files


;******  Processing file: src/structures/repeat.asm

.245e					Command_REPEAT:
.245e	a9 02		lda #$02			lda 	#STK_REPEAT
.2460	20 3c 27	jsr $273c			jsr 	StackOpen
.2463	20 70 27	jsr $2770			jsr 	STKSaveCodePosition 		; save loop position
.2466	60		rts				rts
.2467					Command_UNTIL:
.2467	a9 02		lda #$02			lda 	#STK_REPEAT
.2469	20 68 27	jsr $2768			jsr 	StackCheckFrame
.246c	20 06 17	jsr $1706			jsr 	EXPEvalNumber 				; work out the test
.246f	a2 08		ldx #$08			ldx 	#IFR0
.2471	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero 			; check if zero
.2474	f0 04		beq $247a			beq 	_CULoopBack 				; if so keep looping
.2476	20 5a 27	jsr $275a			jsr 	StackClose		 			; return
.2479	60		rts				rts
.247a					_CULoopBack:
.247a	20 82 27	jsr $2782			jsr 	STKLoadCodePosition 		; loop back
.247d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/scanforward.asm

.247e					ScanForward:
.247e	85 22		sta $22				sta 	zTemp0 						; save scan options in zTemp0
.2480	86 23		stx $23				stx 	zTemp0+1
.2482	64 24		stz $24				stz 	zTemp1 						; clear structure count.
.2484					_ScanForwardLoop:
.2484	a5 24		lda $24				lda 	zTemp1 						; if structure count non zero, don't check for end.
.2486	d0 0a		bne $2492			bne 	_ScanNoCheck
.2488	b1 18		lda ($18),y			lda 	(codePtr),y 				; reached either target token.
.248a	c5 22		cmp $22				cmp 	zTemp0
.248c	f0 49		beq $24d7			beq 	_ScanExit
.248e	c5 23		cmp $23				cmp 	zTemp0+1
.2490	f0 45		beq $24d7			beq 	_ScanExit
.2492					_ScanNoCheck:
.2492	b1 18		lda ($18),y			lda 	(codePtr),y 				; get the token and consume it.
.2494	c8		iny				iny
.2495	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ 	; check for special multi-byte elements
.2497	f0 37		beq $24d0			beq		_ScanDataItem
.2499	c9 ee		cmp #$ee			cmp 	#PR_LSQLSQSTRINGRSQRSQ
.249b	f0 33		beq $24d0			beq 	_ScanDataItem
.249d	c9 8c		cmp #$8c			cmp 	#PR_LSQLSQENDRSQRSQ 		; handle end of line.
.249f	f0 1b		beq $24bc			beq 	_ScanNextLine
.24a1	c9 8d		cmp #$8d			cmp 	#PR_LSQLSQSHIFTRSQRSQ 		; if shift, skip one.
.24a3	d0 01		bne $24a6			bne 	_ScanNoShift
.24a5	c8		iny				iny
.24a6					_ScanNoShift:
.24a6	c9 8c		cmp #$8c			cmp 	#PR_STRUCTURE_LAST+1 		; nested structures
.24a8	b0 da		bcs $2484			bcs 	_ScanForwardLoop
.24aa	c9 80		cmp #$80			cmp 	#PR_STRUCTURE_FIRST
.24ac	90 d6		bcc $2484			bcc 	_ScanForwardLoop
.24ae	aa		tax				tax 								; access the table to get the adjustment.
.24af	18		clc				clc
.24b0	a5 24		lda $24				lda 	zTemp1 						; add it to structure count.
.24b2	7d 19 1a	adc $1a19,x			adc 	StructureOffsets-PR_STRUCTURE_FIRST,x
.24b5	85 24		sta $24				sta 	zTemp1
.24b7	10 cb		bpl $2484			bpl		_ScanForwardLoop 			; error if -ve ?
.24b9	4c fa 25	jmp $25fa		jmp	ErrorV_structure
.24bc					_ScanNextLine:
.24bc	18		clc				clc	 								; forward to next line.
.24bd	b2 18		lda ($18)			lda 	(codePtr)
.24bf	65 18		adc $18				adc 	codePtr
.24c1	85 18		sta $18				sta 	codePtr
.24c3	90 02		bcc $24c7			bcc 	_ScanNoCarry
.24c5	e6 19		inc $19				inc 	codePtr+1
.24c7					_ScanNoCarry:
.24c7	a0 03		ldy #$03			ldy 	#3
.24c9	b2 18		lda ($18)			lda 	(codePtr) 					; off end of program ?
.24cb	d0 b7		bne $2484			bne 	_ScanForwardLoop
.24cd	4c fa 25	jmp $25fa		jmp	ErrorV_structure
.24d0					_ScanDataItem:
.24d0	98		tya				tya
.24d1	38		sec				sec
.24d2	71 18		adc ($18),y			adc 	(codePtr),y
.24d4	a8		tay				tay
.24d5	80 ad		bra $2484			bra 	_ScanForwardLoop
.24d7					_ScanExit:
.24d7	c8		iny				iny 								; consume final token.
.24d8	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/structures/scanproc.asm

.24d9					ScanProcedures:
.24d9	a5 18		lda $18				lda 	codePtr 					; push codePtr on the stack
.24db	48		pha				pha
.24dc	a5 19		lda $19				lda 	codePtr+1
.24de	48		pha				pha
.24df	5a		phy				phy
.24e0	ad 1a 05	lda $051a			lda 	PGMBaseHigh 				; back to the program start
.24e3	85 19		sta $19				sta 	codePtr+1
.24e5	64 18		stz $18				stz 	codePtr
.24e7					_SPLoop:
.24e7	b2 18		lda ($18)			lda 	(codePtr) 					; end of program
.24e9	f0 18		beq $2503			beq 	_SPExit
.24eb	a0 03		ldy #$03			ldy 	#3 							; first token PROC
.24ed	b1 18		lda ($18),y			lda 	(codePtr),y
.24ef	c9 88		cmp #$88			cmp 	#PR_PROC
.24f1	d0 03		bne $24f6			bne 	_SPNext
.24f3	20 0b 25	jsr $250b			jsr 	_SPSetupRecord
.24f6					_SPNext:
.24f6	18		clc				clc 								; forward to next
.24f7	b2 18		lda ($18)			lda 	(codePtr)
.24f9	65 18		adc $18				adc 	codePtr
.24fb	85 18		sta $18				sta 	codePtr
.24fd	90 e8		bcc $24e7			bcc 	_SPLoop
.24ff	e6 19		inc $19				inc 	codePtr+1
.2501	80 e4		bra $24e7			bra 	_SPLoop
.2503					_SPExit:
.2503	7a		ply				ply
.2504	68		pla				pla
.2505	85 19		sta $19				sta 	codePtr+1
.2507	68		pla				pla
.2508	85 18		sta $18				sta 	codePtr
.250a	60		rts				rts
.250b					_SPSetupRecord:
.250b	c8		iny				iny 								; check identifier follows
.250c	b1 18		lda ($18),y			lda 	(codePtr),y
.250e	29 c0		and #$c0			and 	#$C0
.2510	c9 40		cmp #$40			cmp 	#$40
.2512	d0 27		bne $253b			bne 	_SPSyntax
.2514	20 0c 2a	jsr $2a0c			jsr 	VARGetInfo 					; get the information
.2517	20 23 27	jsr $2723			jsr 	ERRCheckRParen 				; check right bracket follows.
.251a	20 be 29	jsr $29be			jsr 	VARFind 					; already exists ?
.251d	b0 1f		bcs $253e			bcs 	_SPUsed 					; error !
.251f	20 6a 29	jsr $296a			jsr 	VARCreate 					; create, XA points to the data.
.2522	85 22		sta $22				sta 	zTemp0
.2524	86 23		stx $23				stx 	zTemp0+1
.2526	5a		phy				phy 								; save Y pos on stack
.2527	a0 01		ldy #$01			ldy 	#1
.2529	a5 18		lda $18				lda 	codePtr 					; save codePtr/Y
.252b	92 22		sta ($22)			sta 	(zTemp0)
.252d	a5 19		lda $19				lda 	codePtr+1
.252f	91 22		sta ($22),y			sta 	(zTemp0),y
.2531	c8		iny				iny
.2532	68		pla				pla
.2533	91 22		sta ($22),y			sta 	(zTemp0),y
.2535	c8		iny				iny
.2536	a9 ff		lda #$ff			lda 	#$FF 						; fill rest with $FF
.2538	91 22		sta ($22),y			sta 	(zTemp0),y
.253a	60		rts				rts
.253b					_SPSyntax:
.253b	4c 6e 25	jmp $256e		jmp	ErrorV_syntax
.253e					_SPUsed:
.253e	4c c5 26	jmp $26c5		jmp	ErrorV_dupproc

;******  Return to file: include.files


;******  Processing file: src/structures/while.asm

.2541					Command_WHILE:
.2541	5a		phy				phy 								; save position of the test
.2542	20 06 17	jsr $1706			jsr 	EXPEvalNumber 				; work out the while test.
.2545	a2 08		ldx #$08			ldx 	#IFR0
.2547	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero 			; check if zero
.254a	f0 0e		beq $255a			beq 	_WHExitLoop 				; if so exit the loop, while has failed.
.254c	98		tya				tya 								; position *after* test.
.254d	7a		ply				ply 								; restore position before test, at WHILE
.254e	88		dey				dey 								; so we execute the WHILE command again.
.254f	48		pha				pha 								; push after test on the stack
.2550	a9 12		lda #$12			lda 	#STK_WHILE 					; open while frame
.2552	20 3c 27	jsr $273c			jsr 	StackOpen
.2555	20 70 27	jsr $2770			jsr 	STKSaveCodePosition 		; save loop position - where the test value expr is.
.2558	7a		ply				ply 								; restore the position *after* the test
.2559	60		rts				rts
.255a					_WHExitLoop:
.255a	68		pla				pla 								; throw post loop position
.255b	a9 83		lda #$83			lda 	#PR_WEND 					; scan forward past WEND
.255d	aa		tax				tax
.255e	20 7e 24	jsr $247e			jsr 	ScanForward
.2561	60		rts				rts
.2562					Command_WEND:
.2562	a9 12		lda #$12			lda 	#STK_WHILE 					; check WHILE is TOS e.g. in a while loop :)
.2564	20 68 27	jsr $2768			jsr 	StackCheckFrame
.2567	20 82 27	jsr $2782			jsr 	STKLoadCodePosition 		; loop back to the WHILE keyword.
.256a	20 5a 27	jsr $275a			jsr 	StackClose		 			; erase the frame
.256d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/support/errors/generated/errors.asm

.256e					ErrorV_syntax:
.256e	20 5b 28	jsr $285b		jsr	ErrorHandler
>2571	0c 53 79 6e 74 61 78 20			.text	12,"Syntax Error",0
>2579	45 72 72 6f 72 00
.257f					ErrorV_range:
.257f	20 5b 28	jsr $285b		jsr	ErrorHandler
>2582	0c 4f 75 74 20 4f 66 20			.text	12,"Out Of Range",0
>258a	52 61 6e 67 65 00
.2590					ErrorV_value:
.2590	20 5b 28	jsr $285b		jsr	ErrorHandler
>2593	09 42 61 64 20 56 61 6c			.text	9,"Bad Value",0
>259b	75 65 00
.259e					ErrorV_type:
.259e	20 5b 28	jsr $285b		jsr	ErrorHandler
>25a1	0d 54 79 70 65 20 4d 69			.text	13,"Type Mismatch",0
>25a9	73 6d 61 74 63 68 00
.25b0					ErrorV_unimplemented:
.25b0	20 5b 28	jsr $285b		jsr	ErrorHandler
>25b3	0f 4e 6f 74 20 49 6d 70			.text	15,"Not Implemented",0
>25bb	6c 65 6d 65 6e 74 65 64 00
.25c4					ErrorV_assert:
.25c4	20 5b 28	jsr $285b		jsr	ErrorHandler
>25c7	0b 41 73 73 65 72 74 20			.text	11,"Assert Fail",0
>25cf	46 61 69 6c 00
.25d4					ErrorV_internal:
.25d4	20 5b 28	jsr $285b		jsr	ErrorHandler
>25d7	0e 49 6e 74 65 72 6e 61			.text	14,"Internal Error",0
>25df	6c 20 45 72 72 6f 72 00
.25e7					ErrorV_divzero:
.25e7	20 5b 28	jsr $285b		jsr	ErrorHandler
>25ea	0e 44 69 76 69 64 65 20			.text	14,"Divide By Zero",0
>25f2	42 79 20 5a 65 72 6f 00
.25fa					ErrorV_structure:
.25fa	20 5b 28	jsr $285b		jsr	ErrorHandler
>25fd	13 53 74 72 75 63 74 75			.text	19,"Structure Imbalance",0
>2605	72 65 20 49 6d 62 61 6c 61 6e 63 65 00
.2612					ErrorV_stop:
.2612	20 5b 28	jsr $285b		jsr	ErrorHandler
>2615	0f 50 72 6f 67 72 61 6d			.text	15,"Program Stopped",0
>261d	20 53 74 6f 70 70 65 64 00
.2626					ErrorV_data:
.2626	20 5b 28	jsr $285b		jsr	ErrorHandler
>2629	0b 4f 75 74 20 4f 66 20			.text	11,"Out Of Data",0
>2631	44 61 74 61 00
.2636					ErrorV_redefine:
.2636	20 5b 28	jsr $285b		jsr	ErrorHandler
>2639	0f 41 72 72 61 79 20 52			.text	15,"Array Redefined",0
>2641	65 64 65 66 69 6e 65 64 00
.264a					ErrorV_index:
.264a	20 5b 28	jsr $285b		jsr	ErrorHandler
>264d	0f 42 61 64 20 41 72 72			.text	15,"Bad Array Index",0
>2655	61 79 20 49 6e 64 65 78 00
.265e					ErrorV_memory:
.265e	20 5b 28	jsr $285b		jsr	ErrorHandler
>2661	0d 4f 75 74 20 4f 66 20			.text	13,"Out Of Memory",0
>2669	4d 65 6d 6f 72 79 00
.2670					ErrorV_uninitialised:
.2670	20 5b 28	jsr $285b		jsr	ErrorHandler
>2673	16 56 61 72 69 61 62 6c			.text	22,"Variable Uninitialised",0
>267b	65 20 55 6e 69 6e 69 74 69 61 6c 69 73 65 64 00
.268b					ErrorV_string:
.268b	20 5b 28	jsr $285b		jsr	ErrorHandler
>268e	11 42 61 64 20 53 74 72			.text	17,"Bad String Length",0
>2696	69 6e 67 20 4c 65 6e 67 74 68 00
.26a1					ErrorV_variable:
.26a1	20 5b 28	jsr $285b		jsr	ErrorHandler
>26a4	10 56 61 72 69 61 62 6c			.text	16,"Variable Missing",0
>26ac	65 20 4d 69 73 73 69 6e 67 00
.26b6					ErrorV_stack:
.26b6	20 5b 28	jsr $285b		jsr	ErrorHandler
>26b9	0a 53 74 61 63 6b 20 46			.text	10,"Stack Full",0
>26c1	75 6c 6c 00
.26c5					ErrorV_dupproc:
.26c5	20 5b 28	jsr $285b		jsr	ErrorHandler
>26c8	19 50 72 6f 63 65 64 75			.text	25,"Procedure Identifier Used",0
>26d0	72 65 20 49 64 65 6e 74 69 66 69 65 72 20 55 73
>26e0	65 64 00
.26e3					ErrorV_unknown:
.26e3	20 5b 28	jsr $285b		jsr	ErrorHandler
>26e6	11 55 6e 6b 6e 6f 77 6e			.text	17,"Unknown Procedure",0
>26ee	20 50 72 6f 63 65 64 75 72 65 00
.26f9					ErrorV_break:
.26f9	20 5b 28	jsr $285b		jsr	ErrorHandler
>26fc	05 42 72 65 61 6b 00			.text	5,"Break",0
.2703					ErrorV_line:
.2703	20 5b 28	jsr $285b		jsr	ErrorHandler
>2706	13 55 6e 6b 6e 6f 77 6e			.text	19,"Unknown Line Number",0
>270e	20 4c 69 6e 65 20 4e 75 6d 62 65 72 00

;******  Return to file: include.files


;******  Processing file: src/support/errors/syntax.asm

.271b					ERRCheckLParen:
.271b	b1 18		lda ($18),y			lda 	(codePtr),y
.271d	c9 eb		cmp #$eb			cmp 	#PR_LPAREN
.271f	d0 18		bne $2739			bne 	ERRSyntaxError
.2721	c8		iny				iny
.2722	60		rts				rts
.2723					ERRCheckRParen:
.2723	b1 18		lda ($18),y			lda 	(codePtr),y
.2725	c9 9d		cmp #$9d			cmp 	#PR_RPAREN
.2727	d0 10		bne $2739			bne 	ERRSyntaxError
.2729	c8		iny				iny
.272a	60		rts				rts
.272b					ERRCheckComma:
.272b	b1 18		lda ($18),y			lda 	(codePtr),y
.272d	c9 99		cmp #$99			cmp 	#PR_COMMA
.272f	d0 08		bne $2739			bne 	ERRSyntaxError
.2731	c8		iny				iny
.2732	60		rts				rts
.2733					ERRCheckA:
.2733	d1 18		cmp ($18),y			cmp 	(codePtr),y
.2735	d0 02		bne $2739			bne 	ERRSyntaxError
.2737	c8		iny				iny
.2738	60		rts				rts
.2739					ERRSyntaxError:
.2739	4c 6e 25	jmp $256e		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/support/stack/frames.asm

.273c					StackOpen:
.273c	48		pha				pha 								; save frame byte
.273d	29 0f		and #$0f			and 	#$0F 						; the bytes to subtract.
.273f	0a		asl a				asl 	a 							; claim twice this for storage
.2740	49 ff		eor #$ff			eor 	#$FF 						; 2's complement addition
.2742	38		sec				sec 								; so basically subtracting from
.2743	65 2a		adc $2a				adc 	basicStack 	 				; basicStack
.2745	85 2a		sta $2a				sta 	basicStack
.2747	b0 0a		bcs $2753			bcs 	_SONoBorrow
>2749	db						.byte 	$DB
.274a	c6 2b		dec $2b				dec 	basicStack+1
.274c	a5 2b		lda $2b				lda 	basicStack+1 				; reached the bottom ?
.274e	cd 20 06	cmp $0620			cmp 	basicStackEnd
.2751	f0 04		beq $2757			beq 	_SOMemory
.2753					_SONoBorrow:
.2753	68		pla				pla 								; get marker back and write at TOS
.2754	92 2a		sta ($2a)			sta 	(basicStack)
.2756	60		rts				rts
.2757					_SOMemory:
.2757	4c b6 26	jmp $26b6		jmp	ErrorV_stack
.275a					StackClose:
.275a	b2 2a		lda ($2a)			lda 	(basicStack) 				; get TOS marker
.275c	29 0f		and #$0f			and 	#$0F 						; bytes to add back
.275e	0a		asl a				asl 	a 							; claim twice this.
.275f	65 2a		adc $2a				adc 	basicStack 					; add to the stack pointer.
.2761	85 2a		sta $2a				sta 	basicStack
.2763	90 02		bcc $2767			bcc 	_SCExit
.2765	e6 2b		inc $2b				inc 	basicStack+1
.2767					_SCExit:
.2767	60		rts				rts
.2768					StackCheckFrame:
.2768	d2 2a		cmp ($2a)			cmp		(basicStack) 				; check  frames match
.276a	d0 01		bne $276d			bne 	_SCFError 					; different, we have structures mixed up
.276c	60		rts				rts
.276d					_SCFError:
.276d	4c fa 25	jmp $25fa		jmp	ErrorV_structure

;******  Return to file: include.files


;******  Processing file: src/support/stack/location.asm

.2770					STKSaveCodePosition:
.2770	5a		phy				phy
.2771	98		tya				tya 								; save Y at offset 1.
.2772	a0 01		ldy #$01			ldy 	#1
.2774	91 2a		sta ($2a),y			sta 	(basicStack),y
.2776	a5 18		lda $18				lda 	codePtr 					; save code (low) at 2
.2778	c8		iny				iny
.2779	91 2a		sta ($2a),y			sta 	(basicStack),y
.277b	a5 19		lda $19				lda 	codePtr+1 					; save code (high) at 3
.277d	c8		iny				iny
.277e	91 2a		sta ($2a),y			sta 	(basicStack),y
.2780	7a		ply				ply
.2781	60		rts				rts
.2782					STKLoadCodePosition:
.2782	a0 03		ldy #$03			ldy 	#3 							; load code pointer back
.2784	b1 2a		lda ($2a),y			lda 	(basicStack),y
.2786	85 19		sta $19				sta 	codePtr+1
.2788	88		dey				dey
.2789	b1 2a		lda ($2a),y			lda 	(basicStack),y
.278b	85 18		sta $18				sta 	codePtr
.278d	88		dey				dey
.278e	b1 2a		lda ($2a),y			lda 	(basicStack),y 				; line offset to Y
.2790	a8		tay				tay
.2791	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/support/stack/setup.asm

.2792					StackReset:
.2792	48		pha				pha 								; save top of memory
.2793	3a		dec a				dec 	a  							; end of stack = previous byte
.2794	85 2b		sta $2b				sta 	basicStack+1
.2796	a9 ff		lda #$ff			lda 	#$FF
.2798	85 2a		sta $2a				sta 	basicStack
.279a	a9 f0		lda #$f0			lda 	#$F0 						; impossible frame marker - cannot have one with 0 bytes.
.279c	92 2a		sta ($2a)			sta 	(basicStack) 				; puts a dummy marker at TOS which will never match things like NEXT/RETURN
.279e	68		pla				pla 								; allocate pages for stack.
.279f	38		sec				sec
.27a0	e9 02		sbc #$02			sbc 	#STACKPAGES
.27a2	8d 20 06	sta $0620			sta 	basicStackEnd 				; when stack MSB hits this, it's out of memory.
.27a5	60		rts				rts
.002a					basicStack:
>002a							.fill 	2
.0620					basicStackEnd:
>0620							.fill 	1

;******  Return to file: include.files


;******  Processing file: src/support/strings/concrete.asm

.27a6					StringConcrete:
.27a6	5a		phy				phy 								; save position on stack
.27a7	b2 08		lda ($08)			lda 	(IFR0) 						; get string length
.27a9	c9 fd		cmp #$fd			cmp 	#253 						; string too long - cannot concrete.
.27ab	b0 41		bcs $27ee			bcs 	_SALengthError
.27ad	18		clc				clc 								; length of the new string
.27ae	69 08		adc #$08			adc 	#5+3 						; add 5 characters total plus 3 (length,status,EOS)
.27b0	90 02		bcc $27b4			bcc 	_SAHaveLength
.27b2	a9 ff		lda #$ff			lda 	#255 						; string max length is 255
.27b4					_SAHaveLength:
.27b4	48		pha				pha 								; save length to be allocated for concreting.
.27b5	38		sec				sec
.27b6	49 ff		eor #$ff			eor 	#$FF 						; add to StringMemory using 2's complement
.27b8	6d 22 06	adc $0622			adc 	stringMemory
.27bb	8d 22 06	sta $0622			sta 	stringMemory
.27be	85 26		sta $26				sta 	zTemp2 						; update storage address
.27c0	a9 ff		lda #$ff			lda 	#$FF 						; now do the MSB
.27c2	6d 23 06	adc $0623			adc 	stringMemory+1
.27c5	8d 23 06	sta $0623			sta 	stringMemory+1
.27c8	85 27		sta $27				sta 	zTemp2+1
.27ca	68		pla				pla 								; save length allocated in +0
.27cb	92 26		sta ($26)			sta 	(zTemp2)
.27cd	a9 00		lda #$00			lda 	#0 							; clear the status byte in +1
.27cf	a0 01		ldy #$01			ldy 	#1
.27d1	91 26		sta ($26),y			sta 	(zTemp2),y
.27d3					_SACopyNewString:
.27d3	b2 08		lda ($08)			lda 	(IFR0) 						; copy length at +2
.27d5	a0 02		ldy #$02			ldy 	#2
.27d7	91 26		sta ($26),y			sta 	(zTemp2),y
.27d9	aa		tax				tax 								; bytes to copy
.27da	f0 0c		beq $27e8			beq 	_SACopyExit
.27dc	a0 01		ldy #$01			ldy 	#1 							; first character from here
.27de					_SACopyNSLoop:
.27de	b1 08		lda ($08),y			lda 	(IFR0),y 					; get character from here
.27e0	c8		iny				iny 								; write two on in string storage
.27e1	c8		iny				iny
.27e2	91 26		sta ($26),y			sta 	(zTemp2),y
.27e4	88		dey				dey
.27e5	ca		dex				dex									; until copied all the string lengths.
.27e6	d0 f6		bne $27de			bne 	_SACopyNSLoop
.27e8					_SACopyExit:
.27e8	a6 27		ldx $27				ldx 	zTemp2+1 					; XA contain the concreted string.
.27ea	a5 26		lda $26				lda 	zTemp2
.27ec	7a		ply				ply
.27ed	60		rts				rts
.27ee					_SALengthError:
.27ee	4c 8b 26	jmp $268b		jmp	ErrorV_string

;******  Return to file: include.files


;******  Processing file: src/support/strings/stringalloc.asm

.27f1					StringSystemInitialise:
.27f1	3a		dec a				dec 	a 							; make last byte of previous page.
.27f2	8d 23 06	sta $0623			sta 	stringMemory+1
.27f5	85 23		sta $23				sta 	zTemp0+1
.27f7	a9 ff		lda #$ff			lda 	#$FF
.27f9	8d 22 06	sta $0622			sta 	stringMemory
.27fc	85 22		sta $22				sta 	zTemp0
.27fe	a9 00		lda #$00			lda 	#0 							; put a zero at the end, so know end of string memory.
.2800	92 22		sta ($22)			sta 	(zTemp0)
.2802	60		rts				rts
.2803					StringSpaceInitialise:
.2803	a9 ff		lda #$ff			lda 	#$FF 						; only initialise once (set to $FF, bit used to test it)
.2805	8d 21 06	sta $0621			sta 	stringInitialised
.2808	ad 22 06	lda $0622			lda 	stringMemory 				; allocate 256 bytes for one concreted string
.280b	8d 24 06	sta $0624			sta 	stringTempPointer 			; so temporary string space is allocated below that.
.280e	ad 23 06	lda $0623			lda 	stringMemory+1
.2811	3a		dec a				dec 	a
.2812	8d 25 06	sta $0625			sta 	stringTempPointer+1
.2815	20 85 10	jsr $1085			jsr 	ClearCheckMemory
.2818	60		rts				rts
.2819					StringTempAllocate:
.2819	c9 fd		cmp #$fd			cmp 	#252+1 						; max length of strings
.281b	b0 2e		bcs $284b			bcs 	_STALength
.281d	2c 21 06	bit $0621			bit 	stringInitialised 			; already initialised
.2820	30 05		bmi $2827			bmi 	_STAAllocate
.2822	48		pha				pha 								; save value to subtract.
.2823	20 03 28	jsr $2803			jsr 	StringSpaceInitialise 		; initialise string memory allocation
.2826	68		pla				pla 								; restore it
.2827					_STAAllocate:
.2827	49 ff		eor #$ff			eor 	#$FF 						; 2's complement add to StringTempPointer
.2829	18		clc				clc  								; deliberate allows one more
.282a	6d 24 06	adc $0624			adc 	stringTempPointer 			; subtract from temp pointer
.282d	8d 24 06	sta $0624			sta 	stringTempPointer
.2830	85 08		sta $08				sta 	IFR0+IM0 					; address in mantissa too
.2832	85 2c		sta $2c				sta 	zsTemp 						; and zsTemp
.2834	ad 25 06	lda $0625			lda 	stringTempPointer+1
.2837	69 ff		adc #$ff			adc 	#$FF
.2839	8d 25 06	sta $0625			sta 	stringTempPointer+1
.283c	85 2d		sta $2d				sta 	zsTemp+1
.283e	85 09		sta $09				sta 	IFR0+IM1
.2840	64 0a		stz $0a				stz 	IFR0+IM2 					; set the typing data and the upper address bytes.
.2842	a9 80		lda #$80			lda 	#$80
.2844	85 0b		sta $0b				sta 	IFR0+IExp
.2846	a9 00		lda #$00			lda 	#0 							; clear the target string
.2848	92 2c		sta ($2c)			sta 	(zsTemp)
.284a	60		rts				rts
.284b					_STALength:
.284b	4c 8b 26	jmp $268b		jmp	ErrorV_string
.284e					StringTempWrite:
.284e	5a		phy				phy
.284f	48		pha				pha
.2850	b2 2c		lda ($2c)			lda 	(zsTemp)
.2852	1a		inc a				inc 	a
.2853	92 2c		sta ($2c)			sta 	(zsTemp)
.2855	a8		tay				tay
.2856	68		pla				pla
.2857	91 2c		sta ($2c),y			sta 	(zsTemp),y
.2859	7a		ply				ply
.285a	60		rts				rts
.002c					zsTemp:
>002c							.fill 	2
.0621					stringInitialised:
>0621							.fill 	1
.0622					stringMemory:
>0622							.fill 	2
.0624					stringTempPointer:
>0624							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/ui/errorhandler.asm

.285b					ErrorHandler:
.285b	fa		plx				plx 								; get address of msg
.285c	7a		ply				ply
.285d	e8		inx				inx 								; bump past RTS
.285e	d0 01		bne $2861			bne 	_EHNoInc
.2860	c8		iny				iny
.2861					_EHNoInc:
.2861	20 d9 ff	jsr $ffd9			jsr	 	OSWriteString 				; print it.
.2864	ad 26 06	lda $0626			lda 	ERRLine 					; direct command ?
.2867	0d 27 06	ora $0627			ora 	ERRLine+1
.286a	f0 10		beq $287c			beq 	_EHNoNumber
.286c	a2 7f		ldx #$7f			ldx 	#_EHAtMsg & $FF
.286e	a0 28		ldy #$28			ldy 	#_EHAtMsg >> 8
.2870	20 dc ff	jsr $ffdc			jsr 	OSWriteStringZ
.2873	ad 26 06	lda $0626			lda 	ERRLine 					; line number -> XA
.2876	ae 27 06	ldx $0627			ldx 	ERRLine+1
.2879	20 84 28	jsr $2884			jsr 	WriteIntXA
.287c					_EHNoNumber:
.287c	4c ad 28	jmp $28ad			jmp 	WarmStartNewLine
.287f					_EHAtMsg:
>287f	20 61 74 20 00					.text 	" at ",0
.2884					WriteIntXA:
.2884	da		phx				phx
.2885	48		pha				pha
.2886	a2 08		ldx #$08			ldx 	#IFR0
.2888	20 1a 30	jsr $301a			jsr 	IFloatPushRx
.288b	68		pla				pla
.288c	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.288f	68		pla				pla
.2890	85 09		sta $09				sta 	IFR0+IM1
.2892	a9 0a		lda #$0a			lda 	#10 						; decimal
.2894	20 6c 2e	jsr $2e6c			jsr 	IFloatIntegerToStringR0	 	; convert
.2897	20 dc ff	jsr $ffdc			jsr 	OSWriteStringZ 				; print
.289a	a2 08		ldx #$08			ldx 	#IFR0
.289c	20 3b 30	jsr $303b			jsr 	IFloatPullRx
.289f	60		rts				rts
.28a0					NotImplemented:
.28a0	4c b0 25	jmp $25b0		jmp	ErrorV_unimplemented
.0626					ERRLine:
>0626							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/ui/warmstart.asm

.28a3					WarmStart:
.28a3	a9 4f		lda #$4f			lda 	#"O" 						; Ready prompt
.28a5	20 f1 ff	jsr $fff1			jsr 	OSWriteScreen
.28a8	a9 6b		lda #$6b			lda 	#"k"
.28aa	20 f1 ff	jsr $fff1			jsr 	OSWriteScreen
.28ad					WarmStartNewLine:
.28ad	a9 0d		lda #$0d			lda 	#13
.28af	20 f1 ff	jsr $fff1			jsr 	OSWriteScreen
.28b2					WarmStartNoPrompt:
.28b2	a2 ff		ldx #$ff			ldx 	#$FF 						; 6502 stack reset.
.28b4	9a		txs				txs
.28b5	20 d6 ff	jsr $ffd6			jsr 	OSEditNewLine 				; edit
.28b8	c9 1b		cmp #$1b			cmp 	#27  						; ESC new line/ignore
.28ba	f0 f1		beq $28ad			beq 	WarmStartNewLine
.28bc	c9 0d		cmp #$0d			cmp 	#13 						; anything other than CR keep going
.28be	d0 f2		bne $28b2			bne 	WarmStartNoPrompt
.28c0	20 f1 ff	jsr $fff1			jsr 	OSWriteScreen 				; echo the CR
.28c3	e8		inx				inx 								; skip length byte to make it ASCIIZ
.28c4	d0 01		bne $28c7			bne 	_WSSkip
.28c6	c8		iny				iny
.28c7					_WSSkip:
.28c7	86 26		stx $26				stx 	zTemp2 						; save address
.28c9	84 27		sty $27				sty 	zTemp2+1
.28cb	a2 f5		ldx #$f5			ldx 	#TOKGetCharacter & $FF 		; tokenise it.
.28cd	a0 28		ldy #$28			ldy 	#TOKGetCharacter >> 8
.28cf	38		sec				sec
.28d0	20 c7 1f	jsr $1fc7			jsr 	TOKTokenise
.28d3	ad 01 04	lda $0401			lda 	TOKLineNumber 				; if line number zero
.28d6	0d 02 04	ora $0402			ora 	TOKLineNumber+1
.28d9	d0 0b		bne $28e6			bne 	_WSLineEdit
.28db	a9 00		lda #$00			lda 	#TOKLineSize & $FF 			; execute code.
.28dd	85 18		sta $18				sta 	codePtr
.28df	a9 04		lda #$04			lda 	#TOKLineSize >> 8
.28e1	85 19		sta $19				sta 	codePtr+1
.28e3	4c d7 14	jmp $14d7			jmp 	RUNNewLine
.28e6					_WSLineEdit:
.28e6	20 a2 1e	jsr $1ea2			jsr 	PGMDeleteLine 				; delete line, perhaps ?
.28e9	ad 00 04	lda $0400			lda 	TOKLineSize 				; check line is empty.
.28ec	c9 04		cmp #$04			cmp 	#4
.28ee	f0 03		beq $28f3			beq 	_WSNoInsert
.28f0	20 ec 1e	jsr $1eec			jsr 	PGMInsertLine				; if not, maybe insert
.28f3					_WSNoInsert:
.28f3	80 bd		bra $28b2			bra 	WarmStartNoPrompt
.28f5					TOKGetCharacter:
.28f5	b2 26		lda ($26)			lda 	(zTemp2)
.28f7	90 06		bcc $28ff			bcc 	_GSNoIncrement
.28f9	e6 26		inc $26				inc 	zTemp2
.28fb	d0 02		bne $28ff			bne 	_GSNoIncrement
.28fd	e6 27		inc $27				inc 	zTemp2+1
.28ff					_GSNoIncrement:
.28ff	c9 00		cmp #$00			cmp 	#0
.2901	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/variables/array.asm

.2902					VARArrayLookup:
.2902	85 22		sta $22				sta 	zTemp0 						; save the array address pointer in zTemp0
.2904	86 23		stx $23				stx 	zTemp0+1
.2906	b2 22		lda ($22)			lda 	(zTemp0)
.2908	48		pha				pha
.2909	5a		phy				phy
.290a	a0 01		ldy #$01			ldy 	#1
.290c	b1 22		lda ($22),y			lda 	(zTemp0),y
.290e	7a		ply				ply
.290f	48		pha				pha
.2910	20 18 17	jsr $1718			jsr 	EXPEvalInteger16 			; R0 now contains the index
.2913	68		pla				pla 								; array address to zTemp0
.2914	85 23		sta $23				sta 	zTemp0+1
.2916	68		pla				pla
.2917	85 22		sta $22				sta 	zTemp0
.2919	5a		phy				phy 								; save codePtr position.
.291a	a0 01		ldy #$01			ldy 	#1 							; get 14-8 of size.
.291c	b1 22		lda ($22),y			lda 	(zTemp0),y
.291e	48		pha				pha 								; save bit 15 on stack.
.291f	29 7f		and #$7f			and 	#$7F
.2921	85 24		sta $24				sta 	zTemp1
.2923	a5 08		lda $08				lda 	IFR0+IM0 					; check range of index
.2925	d2 22		cmp ($22)			cmp 	(zTemp0)
.2927	a5 09		lda $09				lda 	IFR0+IM1
.2929	e5 24		sbc $24				sbc 	zTemp1
.292b	b0 3a		bcs $2967			bcs 	_VALIndex
.292d	a5 09		lda $09				lda 	IFR0+IM1  					; sanity check
.292f	c9 40		cmp #$40			cmp 	#$40
.2931	b0 34		bcs $2967			bcs 	_VALIndex
.2933	06 08		asl $08				asl 	IFR0+IM0 					; index x 2 (has sub arrays) x 4 (is data)
.2935	26 09		rol $09				rol 	IFR0+IM1
.2937	fa		plx				plx 								; get msb of size -> X
.2938	30 04		bmi $293e			bmi 	_VARNotX4 					; if bit 15 set its an array of pointers so x 2
.293a	06 08		asl $08				asl 	IFR0+IM0
.293c	26 09		rol $09				rol 	IFR0+IM1
.293e					_VARNotX4:
.293e	18		clc				clc 								; add the two for the size bytes
.293f	a5 08		lda $08				lda 	IFR0+IM0
.2941	69 02		adc #$02			adc 	#2
.2943	85 08		sta $08				sta 	IFR0+IM0
.2945	90 02		bcc $2949			bcc 	_VARNoCarry1
.2947	e6 09		inc $09				inc 	IFR0+IM1
.2949					_VARNoCarry1:
.2949	18		clc				clc 								; calculate the element address and push to stack.
.294a	a5 08		lda $08				lda 	IFR0+IM0
.294c	65 22		adc $22				adc 	zTemp0
.294e	48		pha				pha
.294f	a5 09		lda $09				lda 	IFR0+IM1
.2951	65 23		adc $23				adc 	zTemp0+1
.2953	e0 00		cpx #$00			cpx 	#0 							; do we have a sub level ?
.2955	30 04		bmi $295b			bmi 	_VARHasSubLevel
.2957	aa		tax				tax 								; address in XA
.2958	68		pla				pla
.2959	7a		ply				ply 								; restore Y and exit
.295a	60		rts				rts
.295b					_VARHasSubLevel:
.295b	aa		tax				tax 								; get link address in XA
.295c	68		pla				pla
.295d	7a		ply				ply 								; restore code position.
.295e	48		pha				pha
.295f	20 2b 27	jsr $272b			jsr 	ERRCheckComma 				; comma required.
.2962	68		pla				pla
.2963	20 02 29	jsr $2902			jsr 	VARArrayLookup 				; call it recursively
.2966	60		rts				rts
.2967					_VALIndex:
.2967	4c 4a 26	jmp $264a		jmp	ErrorV_index

;******  Return to file: include.files


;******  Processing file: src/variables/create.asm

.296a					VARCreate:
.296a	5a		phy				phy
.296b	a9 09		lda #$09			lda 	#9 							; create 9 bytes of space
.296d	a2 00		ldx #$00			ldx 	#0
.296f	20 5c 10	jsr $105c			jsr 	AllocateMemory
.2972	85 24		sta $24				sta 	zTemp1 						; save new address in zTemp1
.2974	86 25		stx $25				stx 	zTemp1+1
.2976	a0 02		ldy #$02			ldy 	#2 							; put hash into +2
.2978	ad 2a 06	lda $062a			lda 	VARHash
.297b	91 24		sta ($24),y			sta 	(zTemp1),y
.297d	c8		iny				iny 								; put address of name into +3,+4
.297e	ad 28 06	lda $0628			lda 	VARNameAddress
.2981	91 24		sta ($24),y			sta 	(zTemp1),y
.2983	c8		iny				iny
.2984	ad 29 06	lda $0629			lda 	VARNameAddress+1
.2987	91 24		sta ($24),y			sta 	(zTemp1),y
.2989	ad 2b 06	lda $062b			lda 	VARType
.298c	29 01		and #$01			and 	#1
.298e	f0 06		beq $2996			beq 	_CVNotString
.2990	a0 08		ldy #$08			ldy 	#5+3
.2992	a9 80		lda #$80			lda 	#$80
.2994	91 24		sta ($24),y			sta 	(zTemp1),y
.2996					_CVNotString:
.2996	ad 4c 06	lda $064c			lda 	VARHashEntry 				; hash table ptr -> zTemp0
.2999	85 22		sta $22				sta 	zTemp0
.299b	ad 4d 06	lda $064d			lda 	VARHashEntry+1
.299e	85 23		sta $23				sta 	zTemp0+1
.29a0	a0 01		ldy #$01			ldy 	#1 							; put current head into link.
.29a2	b2 22		lda ($22)			lda 	(zTemp0)
.29a4	92 24		sta ($24)			sta 	(zTemp1)
.29a6	b1 22		lda ($22),y			lda 	(zTemp0),y
.29a8	91 24		sta ($24),y			sta 	(zTemp1),y
.29aa	a5 24		lda $24				lda 	zTemp1 						; address of the new record into head
.29ac	92 22		sta ($22)			sta 	(zTemp0)
.29ae	a5 25		lda $25				lda 	zTemp1+1
.29b0	91 22		sta ($22),y			sta 	(zTemp0),y
.29b2	a5 24		lda $24				lda 	zTemp1 						; new record to XA
.29b4	a6 25		ldx $25				ldx 	zTemp1+1
.29b6	18		clc				clc 								; add 5 to point to the data.
.29b7	69 05		adc #$05			adc 	#5
.29b9	90 01		bcc $29bc			bcc 	_VCNoCarry
.29bb	e8		inx				inx
.29bc					_VCNoCarry:
.29bc	7a		ply				ply
.29bd	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/variables/find.asm

.29be					VARFind:
.29be	5a		phy				phy
.29bf	a0 01		ldy #$01			ldy 	#1 							; get first link -> zTemp1
.29c1	b1 22		lda ($22),y			lda 	(zTemp0),y
.29c3	85 25		sta $25				sta 	zTemp1+1
.29c5	f0 1c		beq $29e3			beq 	_VFExitFail 				; first link is 00xx, so nothing in that list.
.29c7	b2 22		lda ($22)			lda 	(zTemp0)
.29c9	85 24		sta $24				sta 	zTemp1
.29cb					_VFLoop:
.29cb	a0 02		ldy #$02			ldy 	#2 							; check hashes match
.29cd	b1 24		lda ($24),y			lda 	(zTemp1),y
.29cf	cd 2a 06	cmp $062a			cmp 	VARHash
.29d2	f0 12		beq $29e6			beq 	_VFHashesMatch 				; if so, check the name.
.29d4					_VFNext:
.29d4	b2 24		lda ($24)			lda 	(zTemp1) 					; next link to AX
.29d6	aa		tax				tax
.29d7	a0 01		ldy #$01			ldy 	#1
.29d9	b1 24		lda ($24),y			lda 	(zTemp1),y
.29db	85 25		sta $25				sta 	zTemp1+1
.29dd	86 24		stx $24				stx 	zTemp1
.29df	c9 00		cmp #$00			cmp 	#0 							; if msb non zero, try again
.29e1	d0 e8		bne $29cb			bne 	_VFLoop
.29e3					_VFExitFail:
.29e3	7a		ply				ply
.29e4	18		clc				clc
.29e5	60		rts				rts
.29e6					_VFHashesMatch:
.29e6	a0 03		ldy #$03			ldy 	#3 							; get address of name -> zTemp2
.29e8	b1 24		lda ($24),y			lda 	(zTemp1),y
.29ea	85 26		sta $26				sta 	zTemp2
.29ec	c8		iny				iny
.29ed	b1 24		lda ($24),y			lda 	(zTemp1),y
.29ef	85 27		sta $27				sta 	zTemp2+1
.29f1	a0 ff		ldy #$ff			ldy 	#$FF 						; now compare
.29f3					_VFNameCompLoop:
.29f3	c8		iny				iny 								; char at a time
.29f4	b9 2c 06	lda $062c,y			lda 	VARBuffer,y
.29f7	d1 26		cmp ($26),y			cmp 	(zTemp2),y
.29f9	d0 d9		bne $29d4			bne 	_VFNext						; next entry if different.
.29fb	c9 7c		cmp #$7c			cmp 	#$7C
.29fd	90 f4		bcc $29f3			bcc 	_VFNameCompLoop 			; until done the whole lot.
.29ff	18		clc				clc
.2a00	a5 24		lda $24				lda 	zTemp1
.2a02	a6 25		ldx $25				ldx 	zTemp1+1
.2a04	69 05		adc #$05			adc 	#5
.2a06	90 01		bcc $2a09			bcc 	_VFNNoCarry
.2a08	e8		inx				inx
.2a09					_VFNNoCarry:
.2a09	7a		ply				ply
.2a0a	38		sec				sec
.2a0b	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/variables/info.asm

.2a0c					VARGetInfo:
.2a0c	98		tya				tya 								; calculate the address of the identifier start.
.2a0d	18		clc				clc
.2a0e	65 18		adc $18				adc 	codePtr
.2a10	8d 28 06	sta $0628			sta 	VARNameAddress
.2a13	a5 19		lda $19				lda 	codePtr+1
.2a15	69 00		adc #$00			adc 	#0
.2a17	8d 29 06	sta $0629			sta 	VARNameAddress+1
.2a1a	9c 2a 06	stz $062a			stz 	VARHash
.2a1d	a2 00		ldx #$00			ldx 	#0
.2a1f					_VARCopyName:
.2a1f	18		clc				clc 								; update the sum hash.
.2a20	ad 2a 06	lda $062a			lda 	VARHash
.2a23	71 18		adc ($18),y			adc 	(codePtr),y
.2a25	8d 2a 06	sta $062a			sta 	VARHash
.2a28	b1 18		lda ($18),y			lda 	(codePtr),y 				; get character and save it in buffer
.2a2a	c8		iny				iny
.2a2b	9d 2c 06	sta $062c,x			sta 	VARBuffer,x
.2a2e	e8		inx				inx
.2a2f	c9 7c		cmp #$7c			cmp 	#$7C 						; until copied the type byte
.2a31	90 ec		bcc $2a1f			bcc 	_VARCopyName
.2a33	8d 2b 06	sta $062b			sta 	VARType 					; save type byte
.2a36	29 03		and #$03			and 	#3 							; type is 0-3
.2a38	0a		asl a				asl 	a
.2a39	0a		asl a				asl 	a
.2a3a	85 22		sta $22				sta 	zTemp0
.2a3c	ad 2a 06	lda $062a			lda 	VARHash 					; force into range of hash entries per type.
.2a3f	29 03		and #$03			and		#(VARHashEntriesPerType-1)
.2a41	65 22		adc $22				adc 	zTemp0 						; index of hash table
.2a43	0a		asl a				asl 	a 							; offset as 2 bytes / word.
.2a44	69 4e		adc #$4e			adc 	#VARHashTables & $FF 		; address of hash table start to zTemp0 & VARHashEntry
.2a46	85 22		sta $22				sta 	zTemp0
.2a48	8d 4c 06	sta $064c			sta 	VARHashEntry
.2a4b	a9 06		lda #$06			lda 	#VARHashTables >> 8
.2a4d	69 00		adc #$00			adc 	#0
.2a4f	85 23		sta $23				sta 	zTemp0+1
.2a51	8d 4d 06	sta $064d			sta 	VARHashEntry+1
.2a54	60		rts				rts
.2a55					VARClearHashTables:
.2a55	a2 00		ldx #$00			ldx 	#0
.2a57					_VCHRLoop:
.2a57	a9 00		lda #$00			lda 	#0
.2a59	9d 4e 06	sta $064e,x			sta 	VARHashTables,x
.2a5c	e8		inx				inx
.2a5d	e0 20		cpx #$20			cpx 	#VARHashEntriesPerType*4*2
.2a5f	d0 f6		bne $2a57			bne 	_VCHRLoop
.2a61	60		rts				rts
.0628					VARNameAddress:
>0628							.fill 	2
.062a					VARHash:
>062a							.fill 	1
.062b					VARType:
>062b							.fill 	1
.062c					VARBuffer:
>062c							.fill 	32
.064c					VARHashEntry:
>064c							.fill 	2
=4					VARHashEntriesPerType = 4 					; hash entries for each of the 4 types.
.064e					VARHashTables:
>064e							.fill 	VARHashEntriesPerType*4*2

;******  Return to file: include.files


;******  Processing file: src/variables/variables.asm

.2a62					VARCheckSimple:
.2a62	aa		tax				tax 								; save in X
.2a63	b1 18		lda ($18),y			lda 	(codePtr),y
.2a65	c9 7c		cmp #$7c			cmp 	#$7C
.2a67	d0 15		bne $2a7e			bne 	_VCSComplex
.2a69	c8		iny				iny 								; consume the second byte, the type.
.2a6a	8a		txa				txa  								; character (40-7F) x 4
.2a6b	0a		asl a				asl 	a
.2a6c	0a		asl a				asl  	a
.2a6d	18		clc				clc
.2a6e	69 6e		adc #$6e			adc 	#FastVariables & $FF
.2a70	85 08		sta $08				sta 	IFR0+IM0
.2a72	a9 06		lda #$06			lda 	#FastVariables >> 8
.2a74	69 00		adc #$00			adc 	#0
.2a76	85 09		sta $09				sta 	IFR0+IM1
.2a78	64 0a		stz $0a				stz 	IFR0+IM2
.2a7a	64 0b		stz $0b				stz 	IFR0+IExp
.2a7c	38		sec				sec 								; it's a reference
.2a7d	60		rts				rts
.2a7e					_VCSComplex:
.2a7e	88		dey				dey	 								; extract information.
.2a7f	20 0c 2a	jsr $2a0c			jsr 	VARGetInfo
.2a82	20 be 29	jsr $29be			jsr 	VARFind 					; search for variable
.2a85	b0 0a		bcs $2a91			bcs 	_VCSHaveVariable
.2a87	ad 2b 06	lda $062b			lda 	VARType 					; error if arrays, cannot autocreate
.2a8a	29 02		and #$02			and 	#2
.2a8c	d0 25		bne $2ab3			bne 	_VCNoCreate
.2a8e	20 6a 29	jsr $296a			jsr 	VARCreate 					; create variable
.2a91					_VCSHaveVariable:
.2a91	48		pha				pha 								; save LSB on the stack
.2a92	ad 2b 06	lda $062b			lda 	VARType 					; get var type, and shift bit 1 into carry
.2a95	6a		ror a				ror 	a
.2a96	6a		ror a				ror 	a
.2a97	68		pla				pla 								; restore LSB
.2a98	90 08		bcc $2aa2			bcc 	_VCSNotArray 				; skip if not an array
.2a9a	20 02 29	jsr $2902			jsr 	VARArrayLookup 				; look for subscripts.
.2a9d	48		pha				pha 								; check )
.2a9e	20 23 27	jsr $2723			jsr 	ERRCheckRParen
.2aa1	68		pla				pla
.2aa2					_VCSNotArray:
.2aa2	86 09		stx $09				stx 	IFR0+IM1 					; save address
.2aa4	85 08		sta $08				sta 	IFR0+IM0
.2aa6	64 0a		stz $0a				stz 	IFR0+IM2 					; clear the unused byte.
.2aa8	ad 2b 06	lda $062b			lda 	VARType 					; number/string bit into carry
.2aab	6a		ror a				ror 	a
.2aac	a9 00		lda #$00			lda 	#0
.2aae	6a		ror a				ror 	a 							; now $00 or $80
.2aaf	85 0b		sta $0b				sta 	IFR0+IExp
.2ab1	38		sec				sec 								; it's a reference
.2ab2	60		rts				rts
.2ab3					_VCNoCreate:
.2ab3	4c 70 26	jmp $2670		jmp	ErrorV_uninitialised
.066e					FastVariables:
>066e							.fill	26*4

;******  Return to file: include.files


;******  Return to file: basic.asm


;******  Processing file: build/libmathslib.asmlib

=0					IM0 = 0 									; offsets in 4 byte records
=1					IM1 = 1
=2					IM2 = 2
=3					IExp = 3
=$3f					IFXMask = $3F 								; mask out the exponent
=$40					IFSign = $40 								; sign bit.
.2ab6					IFInitialise:
.2ab6	9c de 06	stz $06de			stz 	IFStackIndex 				; reset the internal stack.
.2ab9	60		rts				rts
.2aba					IFloatSubtract:
.2aba	da		phx				phx
.2abb	a2 08		ldx #$08			ldx 	#IFR0
.2abd	20 d6 30	jsr $30d6			jsr 	IFloatNegate 				; negate R0 and fall through to add.
.2ac0	fa		plx				plx
.2ac1					IFloatAdd:
.2ac1	b5 03		lda $03,x			lda 	IExp,x 						; check if both exponents are zero.
.2ac3	05 0b		ora $0b				ora 	IFR0+IExp
.2ac5	29 3f		and #$3f			and 	#IFXMask 					; if not, then we have to do the
.2ac7	d0 4e		bne $2b17			bne 	_IFloatAddDecimals 			; decimal version.
.2ac9					_IFAddSubMantissa:
.2ac9	b5 03		lda $03,x			lda 	IExp,x 						; are the signs different ?
.2acb	45 0b		eor $0b				eor 	IFR0+IExp
.2acd	29 40		and #$40			and 	#IFSign
.2acf	d0 21		bne $2af2			bne 	_IFloatSubMantissa
.2ad1	18		clc				clc 								; do the actual addition
.2ad2	a5 08		lda $08				lda 	IFR0+IM0
.2ad4	75 00		adc $00,x			adc 		IM0,x
.2ad6	85 08		sta $08				sta 	IFR0+IM0
.2ad8	a5 09		lda $09				lda 	IFR0+IM1
.2ada	75 01		adc $01,x			adc 		IM1,x
.2adc	85 09		sta $09				sta 	IFR0+IM1
.2ade	a5 0a		lda $0a				lda 	IFR0+IM2
.2ae0	75 02		adc $02,x			adc 		IM2,x
.2ae2	85 0a		sta $0a				sta 	IFR0+IM2
.2ae4	10 29		bpl $2b0f			bpl 	_IFloatAddExit 				; if no carry through to bit 23, then exit.
.2ae6	a2 08		ldx #$08			ldx 	#IFR0						; shift R0 right, divide by 2
.2ae8	20 fa 30	jsr $30fa			jsr 	IFloatShiftRight
.2aeb	20 24 31	jsr $3124			jsr 	IFloatIncExponent
.2aee	d0 1f		bne $2b0f			bne 	_IFloatAddExit
.2af0	38		sec				sec 								; overflowed numerically.
.2af1	60		rts				rts
.2af2					_IFloatSubMantissa:
.2af2	38		sec				sec 								; do the subtraction R0-Rx
.2af3	a5 08		lda $08				lda 	IFR0+IM0
.2af5	f5 00		sbc $00,x			sbc 		IM0,x
.2af7	85 08		sta $08				sta 	IFR0+IM0
.2af9	a5 09		lda $09				lda 	IFR0+IM1
.2afb	f5 01		sbc $01,x			sbc 		IM1,x
.2afd	85 09		sta $09				sta 	IFR0+IM1
.2aff	a5 0a		lda $0a				lda 	IFR0+IM2
.2b01	f5 02		sbc $02,x			sbc 		IM2,x
.2b03	85 0a		sta $0a				sta 	IFR0+IM2
.2b05	b0 08		bcs $2b0f			bcs 	_IFloatAddExit 				; no borrow so we are done.
.2b07	a2 08		ldx #$08			ldx 	#IFR0
.2b09	20 de 30	jsr $30de			jsr 	IFloatMantissaNegate 		; 2's complement negate the mantissa
.2b0c	20 d6 30	jsr $30d6			jsr 	IFloatNegate 				; negate
.2b0f					_IFloatAddExit:
.2b0f	18		clc				clc
.2b10	60		rts				rts
.2b11					_IFloatZeroAdd:
.2b11	fa		plx				plx 								; return this value in R0
.2b12	20 5c 30	jsr $305c			jsr 	IFloatCopyFromRegister
.2b15	18		clc				clc
.2b16	60		rts				rts
.2b17					_IFloatAddDecimals:
.2b17	20 c4 30	jsr $30c4			jsr		IFloatCheckZero 			; if RX = 0 then exit with R0
.2b1a	f0 f3		beq $2b0f			beq 	_IFloatAddExit
.2b1c	20 02 31	jsr $3102			jsr 	IFloatNormalise 			; normalise RX
.2b1f	da		phx				phx 								; normalise R0
.2b20	a2 08		ldx #$08			ldx 	#IFR0
.2b22	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero
.2b25	f0 ea		beq $2b11			beq 	_IFloatZeroAdd
.2b27	20 02 31	jsr $3102			jsr 	IFloatNormalise
.2b2a	fa		plx				plx
.2b2b	a5 0b		lda $0b				lda 	IFR0+IExp 					; get the exponent of R0
.2b2d	29 3f		and #$3f			and 	#IFXMask
.2b2f	38		sec				sec
.2b30	e9 20		sbc #$20			sbc 	#$20 						; map 20..3F..00..1F to 00..0F..E0..FF e.g. scaled unsigned
.2b32	85 20		sta $20				sta 	iTemp0
.2b34	b5 03		lda $03,x			lda 	IExp,x 						; repeat for exponent of Rx
.2b36	29 3f		and #$3f			and 	#IFXMask
.2b38	38		sec				sec
.2b39	e9 20		sbc #$20			sbc 	#$20
.2b3b	c5 20		cmp $20				cmp 	iTemp0 						; get the larger adjusted
.2b3d	b0 02		bcs $2b41			bcs 	_IFloatHaveLarger
.2b3f	a5 20		lda $20				lda 	iTemp0
.2b41					_IFloatHaveLarger:
.2b41	18		clc				clc 								; get the actual one back.
.2b42	69 20		adc #$20			adc 	#$20 						; shift both to that.
.2b44	20 51 2b	jsr $2b51			jsr 	_IFShiftXToA
.2b47	da		phx				phx
.2b48	a2 08		ldx #$08			ldx 	#IFR0
.2b4a	20 51 2b	jsr $2b51			jsr 	_IFShiftXToA
.2b4d	fa		plx				plx
.2b4e	4c c9 2a	jmp $2ac9			jmp 	_IFAddSubMantissa 			; do the adding bit.
.2b51					_IFShiftXToA:
.2b51	8d d6 06	sta $06d6			sta 	IFTarget
.2b54	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero 			; check adding zero ?
.2b57	f0 11		beq $2b6a			beq 	_IFSXExit
.2b59					_IFSXLoop:
.2b59	b5 03		lda $03,x			lda 	IExp,x 	 					; shifted to the right level yet ?
.2b5b	29 3f		and #$3f			and 	#IFXMask
.2b5d	cd d6 06	cmp $06d6			cmp 	IFTarget
.2b60	f0 08		beq $2b6a			beq 	_IFSXExit
.2b62	20 fa 30	jsr $30fa			jsr 	IFloatShiftRight
.2b65	20 24 31	jsr $3124			jsr 	IFloatIncExponent
.2b68	80 ef		bra $2b59			bra 	_IFSXLoop
.2b6a					_IFSXExit:
.2b6a	60		rts				rts
.06d6					IFTarget:
>06d6							.fill 	1
.2b6b					IFloatMultiply:
.2b6b	8e d6 06	stx $06d6			stx 	IFTarget 					; save the multiplier (RX) which is "adder"
.2b6e	20 26 2c	jsr $2c26			jsr 	IFCalculateNewSign
.2b71	b5 03		lda $03,x			lda 	IExp,x 						; check two positive 8 bit integers
.2b73	05 0b		ora $0b				ora 	IFR0+IExp
.2b75	29 3f		and #$3f			and 	#IFXMask
.2b77	15 01		ora $01,x			ora 	IM1,x
.2b79	05 09		ora $09				ora 	IFR0+IM1
.2b7b	15 02		ora $02,x			ora 	IM2,x
.2b7d	05 0a		ora $0a				ora 	IFR0+IM2
.2b7f	d0 0a		bne $2b8b			bne 	_IFMStandard
.2b81	20 a7 30	jsr $30a7			jsr 	IFloatMultiply8BitRx
.2b84	ad d8 06	lda $06d8			lda 	IFNewSign
.2b87	85 0b		sta $0b				sta 	IFR0+IExp
.2b89	18		clc				clc
.2b8a	60		rts				rts
.2b8b					_IFMStandard:
.2b8b	b5 03		lda $03,x			lda 	IExp,x 						; add the two exponents sign extended
.2b8d	20 1d 2c	jsr $2c1d			jsr 	IFMSignExtend
.2b90	8d d7 06	sta $06d7			sta 	IFNewExponent
.2b93	a5 0b		lda $0b				lda 	IFR0+IExp
.2b95	20 1d 2c	jsr $2c1d			jsr 	IFMSignExtend
.2b98	18		clc				clc
.2b99	6d d7 06	adc $06d7			adc 	IFNewExponent
.2b9c	8d d7 06	sta $06d7			sta 	IFNewExponent
.2b9f	a2 14		ldx #$14			ldx 	#IFRTemp 					; copy R0 to RTemp which is "shifter"
.2ba1	20 6d 30	jsr $306d			jsr 	IFloatCopyToRegister
.2ba4	a2 08		ldx #$08			ldx 	#IFR0 						; zero R0 (the result)
.2ba6	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.2ba9					_IFMLoop:
.2ba9	a2 14		ldx #$14			ldx 	#IFRTemp
.2bab	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero
.2bae	f0 3a		beq $2bea			beq 	_IFMExit
.2bb0	ae d6 06	ldx $06d6			ldx 	IFTarget 					; look at adder MSB
.2bb3	b5 02		lda $02,x			lda 	IM2,x 						; if it is set we need to shift everything
.2bb5	10 03		bpl $2bba			bpl	 	_IFMTargetOkay
.2bb7	20 0e 2c	jsr $2c0e			jsr 	_IFMShiftAll
.2bba					_IFMTargetOkay:
.2bba	a5 14		lda $14				lda 	IFRTemp+0 					; is bit 0 of the shifter (RTemp) set
.2bbc	29 01		and #$01			and 	#1
.2bbe	f0 16		beq $2bd6			beq 	_IFMNoAdd
.2bc0	ae d6 06	ldx $06d6			ldx 	IFTarget 					; add adder
.2bc3	18		clc				clc
.2bc4	a5 08		lda $08				lda 	IFR0+IM0
.2bc6	75 00		adc $00,x			adc 		IM0,x
.2bc8	85 08		sta $08				sta 	IFR0+IM0
.2bca	a5 09		lda $09				lda 	IFR0+IM1
.2bcc	75 01		adc $01,x			adc 		IM1,x
.2bce	85 09		sta $09				sta 	IFR0+IM1
.2bd0	a5 0a		lda $0a				lda 	IFR0+IM2
.2bd2	75 02		adc $02,x			adc 		IM2,x
.2bd4	85 0a		sta $0a				sta 	IFR0+IM2
.2bd6					_IFMNoAdd:
.2bd6	a5 0a		lda $0a				lda 	IFR0+IM2
.2bd8	10 03		bpl $2bdd			bpl 	_IFMResultOkay
.2bda	20 0e 2c	jsr $2c0e			jsr 	_IFMShiftAll
.2bdd					_IFMResultOkay:
.2bdd	a2 14		ldx #$14			ldx 	#IFRTemp
.2bdf	20 fa 30	jsr $30fa			jsr 	IFloatShiftRight
.2be2	ae d6 06	ldx $06d6			ldx 	IFTarget
.2be5	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.2be8	80 bf		bra $2ba9			bra 	_IFMLoop
.2bea					_IFMExit:
.2bea	ad d7 06	lda $06d7			lda 	IFNewExponent 				; validate new exponent.
.2bed	c9 20		cmp #$20			cmp 	#$20 						; valid exponent 00-1F E0-FF
.2bef	90 0f		bcc $2c00			bcc 	_IFMOkay
.2bf1	c9 e0		cmp #$e0			cmp 	#$E0
.2bf3	b0 0b		bcs $2c00			bcs 	_IFMOkay
.2bf5	29 80		and #$80			and 	#$80 						; if +ve exponent then error overflow.
.2bf7	f0 13		beq $2c0c			beq 	_IFMError
.2bf9	a2 08		ldx #$08			ldx 	#IFR0 						; return zero underflow
.2bfb	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.2bfe	18		clc				clc
.2bff	60		rts				rts
.2c00					_IFMOkay:
.2c00	29 3f		and #$3f			and 	#IFXMask 					; work out exponent + sign and exit
.2c02	0d d8 06	ora $06d8			ora 	IFNewSign
.2c05	85 0b		sta $0b				sta 	IFR0+IExp
.2c07	18		clc				clc
.2c08	60		rts				rts
.2c09	4c ff ff	jmp $ffff			jmp 	$FFFF
.2c0c					_IFMError:
.2c0c	38		sec				sec
.2c0d	60		rts				rts
.2c0e					_IFMShiftAll:
.2c0e	a2 08		ldx #$08			ldx 	#IFR0
.2c10	20 fa 30	jsr $30fa			jsr 	IFloatShiftRight
.2c13	ae d6 06	ldx $06d6			ldx 	IFTarget
.2c16	20 fa 30	jsr $30fa			jsr 	IFloatShiftRight
.2c19	ee d7 06	inc $06d7			inc 	IFNewExponent
.2c1c	60		rts				rts
.2c1d					IFMSignExtend:
.2c1d	29 3f		and #$3f			and 	#IFXMask
.2c1f	c9 1f		cmp #$1f			cmp 	#(IFXMask >> 1)
.2c21	90 02		bcc $2c25			bcc 	_IFMNoSXX
.2c23	09 c0		ora #$c0			ora 	#IFXMask ^ $FF
.2c25					_IFMNoSXX:
.2c25	60		rts				rts
.2c26					IFCalculateNewSign:
.2c26	b5 03		lda $03,x			lda 	IExp,x
.2c28	45 0b		eor $0b				eor 	IFR0+IExp
.2c2a	29 40		and #$40			and 	#IFSign
.2c2c	8d d8 06	sta $06d8			sta 	IFNewSign
.2c2f	60		rts				rts
.06d7					IFNewExponent:
>06d7							.fill 	1
.06d8					IFNewSign:
>06d8							.fill 	1
.2c30					IFloatDivideInteger:
.2c30	20 49 2c	jsr $2c49			jsr 	IFloatDivideIntegerCommon 	; do the common code.
.2c33	b0 06		bcs $2c3b			bcs 	_IFDIExit
.2c35	a2 14		ldx #$14			ldx 	#IFRTemp 					; copy result from register.
.2c37	20 5c 30	jsr $305c			jsr 	IFloatCopyFromRegister
.2c3a	18		clc				clc
.2c3b					_IFDIExit:
.2c3b	60		rts				rts
.2c3c					IFloatModulusInteger:
.2c3c	20 49 2c	jsr $2c49			jsr 	IFloatDivideIntegerCommon
.2c3f	b0 07		bcs $2c48			bcs 	_IFMIExit
.2c41	ae d6 06	ldx $06d6			ldx 	IFTarget
.2c44	20 5c 30	jsr $305c			jsr 	IFloatCopyFromRegister
.2c47	18		clc				clc
.2c48					_IFMIExit:
.2c48	60		rts				rts
.2c49					IFloatDivideIntegerCommon:
.2c49	8e d6 06	stx $06d6			stx 	IFTarget  					; this is s1, s0 = R0
.2c4c	20 26 2c	jsr $2c26			jsr 	IFCalculateNewSign 			; calculate sign of result
.2c4f	20 77 2c	jsr $2c77			jsr 	IFDCopyRXToRTemp 			; copy S1 to RTemp
.2c52	a2 08		ldx #$08			ldx 	#IFR0 						; check divide by zero
.2c54	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero
.2c57	f0 1c		beq $2c75			beq 	_IFDIDivZero
.2c59	ae d6 06	ldx $06d6			ldx 	IFTarget 					; zero Rx (S1)
.2c5c	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.2c5f	5a		phy				phy
.2c60	a0 18		ldy #$18			ldy 	#24
.2c62					_IFDILoop:
.2c62	20 88 2c	jsr $2c88			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.2c65	20 94 2c	jsr $2c94			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.2c68	88		dey				dey
.2c69	d0 f7		bne $2c62			bne 	_IFDILoop 					; do it 24 times
.2c6b	7a		ply				ply
.2c6c	ad d8 06	lda $06d8			lda 	IFNewSign 					; set sign of result.
.2c6f	29 40		and #$40			and 	#IFSign
.2c71	85 17		sta $17				sta 	IFRTemp+IExp
.2c73	18		clc				clc 								; is okay.
.2c74	60		rts				rts
.2c75					_IFDIDivZero:
.2c75	38		sec				sec
.2c76	60		rts				rts
.2c77					IFDCopyRXToRTemp:
.2c77	b5 00		lda $00,x			lda 	IM0,x
.2c79	85 14		sta $14				sta 	IFRTemp+IM0
.2c7b	b5 01		lda $01,x			lda 	IM1,x
.2c7d	85 15		sta $15				sta 	IFRTemp+IM1
.2c7f	b5 02		lda $02,x			lda 	IM2,x
.2c81	85 16		sta $16				sta 	IFRTemp+IM2
.2c83	b5 03		lda $03,x			lda 	IExp,x
.2c85	85 17		sta $17				sta 	IFRTemp+IExp
.2c87	60		rts				rts
.2c88					IFDShiftSTempS1Left:
.2c88	a2 14		ldx #$14			ldx 	#IFRTemp
.2c8a	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft
.2c8d	ae d6 06	ldx $06d6			ldx 	IFTarget
.2c90	20 f3 30	jsr $30f3			jsr 	IFloatRotateLeft
.2c93	60		rts				rts
.2c94					IFDTrySubtract:
.2c94	ae d6 06	ldx $06d6			ldx 	IFTarget 					; s1 = Rx
.2c97	38		sec				sec 								; subtract, saving the results on the stack.
.2c98	b5 00		lda $00,x			lda 	IM0,x
.2c9a	e5 08		sbc $08				sbc 	IFR0+IM0
.2c9c	48		pha				pha
.2c9d	b5 01		lda $01,x			lda 	IM1,x
.2c9f	e5 09		sbc $09				sbc 	IFR0+IM1
.2ca1	48		pha				pha
.2ca2	b5 02		lda $02,x			lda 	IM2,x
.2ca4	e5 0a		sbc $0a				sbc 	IFR0+IM2
.2ca6	b0 03		bcs $2cab			bcs 	_IFDCanSubtract
.2ca8	68		pla				pla 								; cannot subtract, so pop intermediate and exit.
.2ca9	68		pla				pla
.2caa	60		rts				rts
.2cab					_IFDCanSubtract:
.2cab	95 02		sta $02,x			sta 	IM2,x 						; write back to S1.Mantissa
.2cad	68		pla				pla
.2cae	95 01		sta $01,x			sta 	IM1,x
.2cb0	68		pla				pla
.2cb1	95 00		sta $00,x			sta 	IM0,x
.2cb3	e6 14		inc $14				inc 	IFRTemp+IM0 				; increment temp
.2cb5	d0 06		bne $2cbd			bne 	_IFDCSExit
.2cb7	e6 15		inc $15				inc 	IFRTemp+IM1
.2cb9	d0 02		bne $2cbd			bne 	_IFDCSExit
.2cbb	e6 16		inc $16				inc 	IFRTemp+IM2
.2cbd					_IFDCSExit:
.2cbd	60		rts				rts
.2cbe					IFloatBitwiseAnd:
.2cbe	5a		phy				phy
.2cbf	20 03 2d	jsr $2d03			jsr 	IFPreProcessBitwise 		; set up everything.
.2cc2	d0 0f		bne $2cd3			bne 	_IFBAExit
.2cc4					_IFBALoop:
.2cc4	b9 08 00	lda $0008,y			lda 	IFR0+IM0,y
.2cc7	35 00		and $00,x			and 	IM0,x
.2cc9	99 08 00	sta $0008,y			sta 	IFR0+IM0,y
.2ccc	e8		inx				inx
.2ccd	c8		iny				iny
.2cce	c0 03		cpy #$03			cpy 	#3
.2cd0	d0 f2		bne $2cc4			bne 	_IFBALoop
.2cd2	18		clc				clc
.2cd3					_IFBAExit:
.2cd3	7a		ply				ply
.2cd4	60		rts				rts
.2cd5					IFloatBitwiseOr:
.2cd5	5a		phy				phy
.2cd6	20 03 2d	jsr $2d03			jsr 	IFPreProcessBitwise 		; set up everything.
.2cd9	d0 0f		bne $2cea			bne 	_IFBAExit
.2cdb					_IFBALoop:
.2cdb	b9 08 00	lda $0008,y			lda 	IFR0+IM0,y
.2cde	15 00		ora $00,x			ora 	IM0,x
.2ce0	99 08 00	sta $0008,y			sta 	IFR0+IM0,y
.2ce3	e8		inx				inx
.2ce4	c8		iny				iny
.2ce5	c0 03		cpy #$03			cpy 	#3
.2ce7	d0 f2		bne $2cdb			bne 	_IFBALoop
.2ce9	18		clc				clc
.2cea					_IFBAExit:
.2cea	7a		ply				ply
.2ceb	60		rts				rts
.2cec					IFloatBitwiseXor:
.2cec	5a		phy				phy
.2ced	20 03 2d	jsr $2d03			jsr 	IFPreProcessBitwise 		; set up everything.
.2cf0	d0 0f		bne $2d01			bne 	_IFBAExit
.2cf2					_IFBALoop:
.2cf2	b9 08 00	lda $0008,y			lda 	IFR0+IM0,y
.2cf5	55 00		eor $00,x			eor 	IM0,x
.2cf7	99 08 00	sta $0008,y			sta 	IFR0+IM0,y
.2cfa	e8		inx				inx
.2cfb	c8		iny				iny
.2cfc	c0 03		cpy #$03			cpy 	#3
.2cfe	d0 f2		bne $2cf2			bne 	_IFBALoop
.2d00	18		clc				clc
.2d01					_IFBAExit:
.2d01	7a		ply				ply
.2d02	60		rts				rts
.2d03					IFPreProcessBitwise:
.2d03	a0 00		ldy #$00			ldy 	#0 							; set index.
.2d05	a5 0b		lda $0b				lda 	IFR0+IExp 					; OR exponents
.2d07	15 03		ora $03,x			ora 	IExp,x
.2d09	74 03		stz $03,x			stz 	IExp,x 						; zero the result exponent anyway.
.2d0b	29 3f		and #$3f			and 	#IFXMask 					; NZ if error e.g. not integer
.2d0d	38		sec				sec 								; carry set just in cases.
.2d0e	60		rts				rts
.2d0f					IFloatAbsoluteR0:
.2d0f	a5 0b		lda $0b				lda 	IFR0+IExp					; reset the sign bit.
.2d11	29 bf		and #$bf			and 	#IFSign ^ 255
.2d13	85 0b		sta $0b				sta 	IFR0+IExp
.2d15	18		clc				clc
.2d16	60		rts				rts
.2d17					IFloatSquareRootR0:
.2d17	a2 08		ldx #$08			ldx 	#IFR0 						; if zero, return zero.
.2d19	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero
.2d1c	a5 0b		lda $0b				lda	 	IFR0+IExp 					; if negative fail.
.2d1e	29 40		and #$40			and 	#IFSign
.2d20	d0 2f		bne $2d51			bne 	_IFSRFail
.2d22	20 02 31	jsr $3102			jsr 	IFloatNormalise 			; it will work better !
.2d25	a2 0c		ldx #$0c			ldx 	#IFR1 						; R1 contains original throughout
.2d27	20 6d 30	jsr $306d			jsr 	IFloatCopyToRegister
.2d2a	a5 0b		lda $0b				lda 	IFR0+IExp 					; if exponent is $2A..$3F * 64 otherwise is / 64
.2d2c	20 1d 2c	jsr $2c1d			jsr 	IFMSignExtend 				; sign extended version of the exponent
.2d2f	18		clc				clc
.2d30	69 17		adc #$17			adc 	#23 						; this makes it a 0.xxx mantissa
.2d32	85 0b		sta $0b				sta 	IFR0+IExp
.2d34	4a		lsr a				lsr 	a 							; which we can halve.
.2d35	38		sec				sec 								; convert back
.2d36	e9 17		sbc #$17			sbc 	#23
.2d38	29 3f		and #$3f			and 	#IFXMask 					; make appropriate
.2d3a	85 0b		sta $0b				sta 	IFR0+IExp 					; to R0
.2d3c	20 53 2d	jsr $2d53			jsr 	_IFSRNewton
.2d3f	20 53 2d	jsr $2d53			jsr 	_IFSRNewton
.2d42	20 53 2d	jsr $2d53			jsr 	_IFSRNewton
.2d45	20 53 2d	jsr $2d53			jsr 	_IFSRNewton
.2d48	18		clc				clc
.2d49	60		rts				rts
.2d4a					_IFSRZero:
.2d4a	a2 08		ldx #$08			ldx 	#IFR0
.2d4c	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.2d4f	18		clc				clc
.2d50	60		rts				rts
.2d51					_IFSRFail:
.2d51	38		sec				sec
.2d52	60		rts				rts
.2d53					_IFSRNewton:
.2d53	a2 0c		ldx #$0c			ldx 	#IFR1 						; push original value (R3) on the stack
.2d55	20 1a 30	jsr $301a			jsr 	IFloatPushRx
.2d58	a2 08		ldx #$08			ldx 	#IFR0 						; push current guess (R0) on the stack.
.2d5a	20 1a 30	jsr $301a			jsr 	IFloatPushRx
.2d5d	a2 0c		ldx #$0c			ldx 	#IFR1 						; guess = original / guess
.2d5f	20 ee 2d	jsr $2dee			jsr 	IFloatDivideFloat
.2d62	a2 0c		ldx #$0c			ldx 	#IFR1 						; restore current guess (was in R0) to R3
.2d64	20 3b 30	jsr $303b			jsr 	IFloatPullRx
.2d67	20 c1 2a	jsr $2ac1			jsr 	IFloatAdd 					; now guess + original/guess
.2d6a	a2 08		ldx #$08			ldx 	#IFR0 						; divide by 2
.2d6c	20 fa 30	jsr $30fa			jsr 	IFloatShiftRight
.2d6f	a2 0c		ldx #$0c			ldx 	#IFR1
.2d71	20 3b 30	jsr $303b			jsr 	IFloatPullRx 				; Finally pull the oeifinal
.2d74	60		rts				rts
.2d75					IFloatFractionalR0:
.2d75	a5 0b		lda $0b				lda 	IFR0+IExp					; is it integer already ?
.2d77	29 3f		and #$3f			and 	#IFXMask
.2d79	f0 17		beq $2d92			beq 	_FIPZero 					; if so, return with zero as no fractional part.
.2d7b	20 0f 2d	jsr $2d0f			jsr 	IFloatAbsoluteR0 			; absolute value R9
.2d7e	a2 08		ldx #$08			ldx 	#IFR0
.2d80	20 02 31	jsr $3102			jsr 	IFloatNormalise 			; normalise R0
.2d83	a2 14		ldx #$14			ldx 	#IFRTemp 					; copy to RTemp
.2d85	20 6d 30	jsr $306d			jsr 	IFloatCopyToRegister
.2d88	20 cb 2d	jsr $2dcb			jsr 	IFloatIntegerR0 			; take integer part of R0
.2d8b	a2 14		ldx #$14			ldx 	#IFRTemp 					; subtract
.2d8d	20 ba 2a	jsr $2aba			jsr 	IFloatSubtract
.2d90	80 05		bra $2d97			bra 	_FIPExit
.2d92					_FIPZero:
.2d92	a2 08		ldx #$08			ldx 	#IFR0
.2d94	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.2d97					_FIPExit:
.2d97	18		clc				clc
.2d98	60		rts				rts
.2d99					IFloatCompare:
.2d99	20 ba 2a	jsr $2aba			jsr 	IFloatSubtract 				; subtract R0 from RX.
.2d9c	b5 03		lda $03,x			lda 	IExp,x 						; check if integer comparison
.2d9e	05 0b		ora $0b				ora 	IFR0+IExp
.2da0	a2 08		ldx #$08			ldx 	#IFR0 						; only using R0 from now on.
.2da2	29 3f		and #$3f			and 	#IFXMask
.2da4	d0 19		bne $2dbf			bne 	_IFCNonInteger
.2da6	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero 			; check if zero
.2da9	f0 0f		beq $2dba			beq 	_IFCZero
.2dab					_IFCReturnSign:
.2dab	a5 0b		lda $0b				lda 	IFR0+IExp 					; get the sign bit/unused -> stack.
.2dad	29 c0		and #$c0			and 	#(IFXMask ^ $FF)
.2daf	48		pha				pha
.2db0	a9 01		lda #$01			lda 	#1
.2db2	20 cd 30	jsr $30cd			jsr 	IFloatSetByte 				; return to +1
.2db5	68		pla				pla 								; sign bit back
.2db6	85 0b		sta $0b				sta 	IFR0+IExp					; set that sign
.2db8	18		clc				clc
.2db9	60		rts				rts
.2dba					_IFCZero:
.2dba	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.2dbd	18		clc				clc
.2dbe	60		rts				rts
.2dbf					_IFCNonInteger:
.2dbf	a5 08		lda $08				lda 	IFR0+IM0
.2dc1	29 00		and #$00			and		#$00
.2dc3	05 09		ora $09				ora 	IFR0+IM1
.2dc5	05 0a		ora $0a				ora 	IFR0+IM2
.2dc7	f0 f1		beq $2dba			beq 	_IFCZero 					; near enough !
.2dc9	80 e0		bra $2dab			bra 	_IFCReturnSign 				; return the sign of the difference.
.2dcb					IFloatIntegerR0:
.2dcb	a5 0b		lda $0b				lda 	IFR0+IExp					; is it integer already ?
.2dcd	29 3f		and #$3f			and 	#IFXMask
.2dcf	f0 1b		beq $2dec			beq 	_FIPExit 					; if so do nothing
.2dd1	a2 08		ldx #$08			ldx 	#IFR0
.2dd3	20 02 31	jsr $3102			jsr 	IFloatNormalise 			; normalise
.2dd6	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero 			; is it zero ?
.2dd9	f0 0e		beq $2de9			beq 	_FIPZero 					; if so return zero.
.2ddb					_FIPShift:
.2ddb	a5 0b		lda $0b				lda 	IFR0+IExp 					; if Exponent >= 0 exit.
.2ddd	29 20		and #$20			and 	#$20 						; still -ve
.2ddf	f0 0b		beq $2dec			beq 	_FIPExit
.2de1	20 fa 30	jsr $30fa			jsr 	IFloatShiftRight 			; shift mantissa right
.2de4	20 24 31	jsr $3124			jsr 	IFloatIncExponent 			; bump exponent
.2de7	80 f2		bra $2ddb			bra 	_FIPShift
.2de9					_FIPZero:
.2de9	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.2dec					_FIPExit:
.2dec	18		clc				clc
.2ded	60		rts				rts
.2dee					IFloatDivideFloat:
.2dee	8e d6 06	stx $06d6			stx 	IFTarget  					; this is s1, s0 = R0
.2df1	20 26 2c	jsr $2c26			jsr 	IFCalculateNewSign 			; calculate sign of result
.2df4	20 02 31	jsr $3102			jsr 	IFloatNormalise 			; normalise RX
.2df7	a2 08		ldx #$08			ldx 	#IFR0 						; normalise R0
.2df9	20 02 31	jsr $3102			jsr 	IFloatNormalise
.2dfc	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero
.2dff	f0 56		beq $2e57			beq 	_IFDFDivZero 				; exit if this normalised to zero.
.2e01	a5 0b		lda $0b				lda 	IFR0+IExp 					; calculate s0.exponent
.2e03	20 1d 2c	jsr $2c1d			jsr 	IFMSignExtend
.2e06	8d d7 06	sta $06d7			sta 	IFNewExponent
.2e09	ae d6 06	ldx $06d6			ldx 	IFTarget 					; calculate s1.exponent
.2e0c	b5 03		lda $03,x			lda 	IExp,x
.2e0e	20 1d 2c	jsr $2c1d			jsr 	IFMSignExtend
.2e11	38		sec				sec
.2e12	ed d7 06	sbc $06d7			sbc 	IFNewExponent 				; s1.exponent - s0.exponent - 23
.2e15	38		sec				sec
.2e16	e9 17		sbc #$17			sbc 	#23
.2e18	8d d7 06	sta $06d7			sta 	IFNewExponent
.2e1b	20 59 2e	jsr $2e59			jsr 	IFloatDivideSupport 		; call the support routine (see maths.py)
.2e1e	a5 16		lda $16				lda 	IFRTemp+IM2 				; result has overflowed ?
.2e20	10 08		bpl $2e2a			bpl 	_IFDFNoShiftResult
.2e22	a2 14		ldx #$14			ldx 	#IFRTemp 					; if so, fix it up.
.2e24	20 fa 30	jsr $30fa			jsr 	IFloatShiftRight
.2e27	ee d7 06	inc $06d7			inc 	IFNewExponent
.2e2a					_IFDFNoShiftResult:
.2e2a	ad d7 06	lda $06d7			lda 	IFNewExponent 				; underflow/overflow check.
.2e2d	30 06		bmi $2e35			bmi 	_IFDFCheckUnderflow
.2e2f	c9 20		cmp #$20			cmp 	#$20 						; overflow in division
.2e31	b0 24		bcs $2e57			bcs 	_IFDFDivZero
.2e33	80 11		bra $2e46			bra		_IFDFExit
.2e35					_IFDFCheckUnderflow:
.2e35	ad d7 06	lda $06d7			lda 	IFNewExponent 				; shift into a legal exponent.
.2e38	c9 e0		cmp #$e0			cmp 	#$E0 						; if exponent < -32.
.2e3a	b0 0a		bcs $2e46			bcs 	_IFDFExit
.2e3c	ee d7 06	inc $06d7			inc 	IFNewExponent
.2e3f	a2 14		ldx #$14			ldx 	#IFRTemp
.2e41	20 fa 30	jsr $30fa			jsr 	IFloatShiftRight
.2e44	80 ef		bra $2e35			bra 	_IFDFCheckUnderflow
.2e46					_IFDFExit:
.2e46	ad d7 06	lda $06d7			lda 	IFNewExponent 				; combine exponent and sign.
.2e49	29 3f		and #$3f			and 	#IFXMask
.2e4b	0d d8 06	ora $06d8			ora 	IFNewSign
.2e4e	85 17		sta $17				sta 	IFRTemp+IExp
.2e50	a2 14		ldx #$14			ldx 	#IFRTemp 					; copy RTemp to R0.
.2e52	20 5c 30	jsr $305c			jsr 	IFloatCopyFromRegister
.2e55	18		clc				clc
.2e56	60		rts				rts
.2e57					_IFDFDivZero:
.2e57	38		sec				sec
.2e58	60		rts				rts
.2e59					IFloatDivideSupport:
.2e59	a2 14		ldx #$14			ldx 	#IFRTemp 					; zero RTemp
.2e5b	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.2e5e	5a		phy				phy 								; main division loop x 23
.2e5f	a0 17		ldy #$17			ldy 	#23
.2e61					_IFDSLoop:
.2e61	20 94 2c	jsr $2c94			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.2e64	20 88 2c	jsr $2c88			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.2e67	88		dey				dey
.2e68	d0 f7		bne $2e61			bne 	_IFDSLoop 					; do it 24 times
.2e6a	7a		ply				ply
.2e6b	60		rts				rts
.2e6c					IFloatIntegerToStringR0:
.2e6c	8d d9 06	sta $06d9			sta 	IFBase 						; save base to use.
.2e6f	20 4c 31	jsr $314c			jsr 	IFloatBufferReset			; empty buffer
.2e72	a5 0b		lda $0b				lda 	IFR0+IExp					; check integer
.2e74	29 3f		and #$3f			and 	#IFXMask
.2e76	d0 1e		bne $2e96			bne 	_IFIFail
.2e78	a2 08		ldx #$08			ldx 	#IFR0 						; skip - check if zero.
.2e7a	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero
.2e7d	f0 0e		beq $2e8d			beq 	_IFINotNegative
.2e7f	a5 0b		lda $0b				lda 	IFR0+IExp 					; is signed ?
.2e81	29 40		and #$40			and 	#IFSign
.2e83	f0 08		beq $2e8d			beq 	_IFINotNegative
.2e85	a9 2d		lda #$2d			lda 	#"-"						; output -
.2e87	20 5b 31	jsr $315b			jsr 	IFloatBufferWrite
.2e8a	20 d6 30	jsr $30d6			jsr 	IFloatNegate 				; tidy up !
.2e8d					_IFINotNegative:
.2e8d	20 98 2e	jsr $2e98			jsr 	_IFIRecursiveConvert 		; start converting
.2e90	20 53 31	jsr $3153			jsr 	IFloatGetBufferAddress
.2e93	18		clc				clc
.2e94	80 01		bra $2e97			bra 	_IFIExit
.2e96					_IFIFail:
.2e96	38		sec				sec
.2e97					_IFIExit:
.2e97	60		rts				rts
.2e98					_IFIRecursiveConvert:
.2e98	a2 0c		ldx #$0c			ldx 	#IFR1
.2e9a	20 6d 30	jsr $306d			jsr 	IFloatCopyToRegister 		; R0->R1
.2e9d	a2 08		ldx #$08			ldx 	#IFR0
.2e9f	ad d9 06	lda $06d9			lda 	IFBase 						; Base -> R0
.2ea2	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.2ea5	a2 0c		ldx #$0c			ldx 	#IFR1 						; R0 = R1 / R0
.2ea7	20 30 2c	jsr $2c30			jsr 	IFloatDivideInteger
.2eaa	a2 08		ldx #$08			ldx 	#IFR0 						; if result <> 0
.2eac	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero
.2eaf	f0 09		beq $2eba			beq 	_IFIOutDigit
.2eb1	a5 0c		lda $0c				lda 	IFR1+IM0 					; save remainder
.2eb3	48		pha				pha
.2eb4	20 98 2e	jsr $2e98			jsr 	_IFIRecursiveConvert 		; convert the divider
.2eb7	68		pla				pla
.2eb8	85 0c		sta $0c				sta 	IFR1+IM0 					; restore remainder
.2eba					_IFIOutDigit:
.2eba	a5 0c		lda $0c				lda 	IFR1+IM0 					; get remainder.
.2ebc	c9 0a		cmp #$0a			cmp	 	#10
.2ebe	90 02		bcc $2ec2			bcc 	_IFINotHex
.2ec0	69 06		adc #$06			adc 	#6
.2ec2					_IFINotHex:
.2ec2	69 30		adc #$30			adc 	#48
.2ec4	20 5b 31	jsr $315b			jsr 	IFloatBufferWrite
.2ec7	60		rts				rts
.06d9					IFBase:
>06d9							.fill 	1
.2ec8					IFloatFloatToStringR0:
.2ec8	a2 10		ldx #$10			ldx 	#IFR2 						; copy R2 to stack,value to R2
.2eca	20 1a 30	jsr $301a			jsr 	IFloatPushRx
.2ecd	20 6d 30	jsr $306d			jsr 	IFloatCopyToRegister
.2ed0	20 cb 2d	jsr $2dcb			jsr 	IFloatIntegerR0				; make R0 integer
.2ed3	a9 0a		lda #$0a			lda 	#10 						; base 10.
.2ed5	20 6c 2e	jsr $2e6c			jsr 	IFloatIntegerToStringR0 	; do the integer part.
.2ed8	9c da 06	stz $06da			stz 	IFloatDecimalCount 			; zero the decimal count.
.2edb	a5 13		lda $13				lda 	IFR2+IExp 					; is integer.
.2edd	29 3f		and #$3f			and 	#IFXMask
.2edf	f0 44		beq $2f25			beq 	_IFFSExit
.2ee1					_IFloatFracLoop:
.2ee1	a2 10		ldx #$10			ldx 	#IFR2 						; R0 = fractional part of R2
.2ee3	20 5c 30	jsr $305c			jsr 	IFloatCopyFromRegister
.2ee6	20 75 2d	jsr $2d75			jsr 	IFloatFractionalR0
.2ee9	20 02 31	jsr $3102			jsr 	IFloatNormalise
.2eec	a2 10		ldx #$10			ldx 	#IFR2
.2eee	20 6d 30	jsr $306d			jsr 	IFloatCopyToRegister 		; copy to R2
.2ef1	a2 10		ldx #$10			ldx 	#IFR2 						; set R2 to 10
.2ef3	a9 0a		lda #$0a			lda 	#10
.2ef5	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.2ef8	a2 10		ldx #$10			ldx 	#IFR2						; R0,R2 = R2 * 10
.2efa	20 6b 2b	jsr $2b6b			jsr 	IFloatMultiply
.2efd	a2 10		ldx #$10			ldx 	#IFR2
.2eff	20 6d 30	jsr $306d			jsr 	IFloatCopyToRegister
.2f02	20 cb 2d	jsr $2dcb			jsr 	IFloatIntegerR0 			; get integer part of R0
.2f05	ad da 06	lda $06da			lda 	IFloatDecimalCount 			; done 5 dp, no more
.2f08	c9 03		cmp #$03			cmp 	#3
.2f0a	f0 16		beq $2f22			beq 	_IFFSExitStripZero
.2f0c	ad da 06	lda $06da			lda 	IFloatDecimalCount 			; written the DP yet ?
.2f0f	d0 05		bne $2f16			bne 	_IFloatNotFirst
.2f11	a9 2e		lda #$2e			lda 	#"." 						; write decimal point
.2f13	20 5b 31	jsr $315b			jsr 	IFloatBufferWrite
.2f16					_IFloatNotFirst:
.2f16	ee da 06	inc $06da			inc 	IFloatDecimalCount
.2f19	a5 08		lda $08				lda 	IFR0+IM0 					; get digit
.2f1b	09 30		ora #$30			ora 	#"0"						; ASCII
.2f1d	20 5b 31	jsr $315b			jsr 	IFloatBufferWrite 			; write to the buffer.
.2f20	80 bf		bra $2ee1			bra 	_IFloatFracLoop
.2f22					_IFFSExitStripZero:
.2f22	20 6a 31	jsr $316a			jsr 	IFloatStripTrailingZeros
.2f25					_IFFSExit:
.2f25	a2 10		ldx #$10			ldx 	#IFR2 						; restore R2
.2f27	20 3b 30	jsr $303b			jsr 	IFloatPullRx
.2f2a	20 53 31	jsr $3153			jsr 	IFloatGetBufferAddress
.2f2d	18		clc				clc
.2f2e	60		rts				rts
.06da					IFloatDecimalCount:
>06da							.fill 	1
.2f2f					IFloatStringToFloatR0:
.2f2f	8d db 06	sta $06db			sta 	IFCount 					; save it out.
.2f32	86 20		stx $20				stx 	iTemp0
.2f34	84 21		sty $21				sty 	iTemp0+1
.2f36	a2 08		ldx #$08			ldx 	#IFR0 						; reset the current value.
.2f38	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.2f3b	9c dc 06	stz $06dc			stz 	IFSignFlag 					; clear the sign flag
.2f3e	20 cb 2f	jsr $2fcb			jsr 	IFSTFGetNext 				; get first
.2f41	f0 1b		beq $2f5e			beq 	_IFSTFFail 					; no character
.2f43	90 10		bcc $2f55			bcc 	_IFSTFHaveChar 				; legitimate character, go do it.
.2f45	c9 2d		cmp #$2d			cmp 	#"-" 						; if not -, fail
.2f47	d0 15		bne $2f5e			bne 	_IFSTFFail
.2f49	a9 40		lda #$40			lda 	#IFSign 					; set sign flag
.2f4b	8d dc 06	sta $06dc			sta 	IFSignFlag
.2f4e					_IFSTFLoop:
.2f4e	20 cb 2f	jsr $2fcb			jsr 	IFSTFGetNext 				; get next
.2f51	b0 0b		bcs $2f5e			bcs 	_IFSTFFail 					; bad character.
.2f53	f0 11		beq $2f66			beq 	_IFSTFExit 					; end of data
.2f55					_IFSTFHaveChar:
.2f55	c9 2e		cmp #$2e			cmp 	#"."						; decimal point ?
.2f57	f0 08		beq $2f61			beq 	_IFSTFDecimal
.2f59	20 ef 2f	jsr $2fef			jsr 	IFSTFAddR0 					; add number in
.2f5c	80 f0		bra $2f4e			bra 	_IFSTFLoop 					; keep going until . or end.
.2f5e					_IFSTFFail:
.2f5e	38		sec				sec
.2f5f	80 0d		bra $2f6e			bra 	_IFSTFReturn
.2f61					_IFSTFDecimal:
.2f61	20 76 2f	jsr $2f76			jsr 	IFSTFDecimal 				; call the decimal places code.
.2f64	b0 08		bcs $2f6e			bcs 	_IFSTFReturn 				; error
.2f66					_IFSTFExit:
.2f66	a5 0b		lda $0b				lda 	IFR0+IExp 					; copy sign flag in.
.2f68	0d dc 06	ora $06dc			ora 	IFSignFlag
.2f6b	85 0b		sta $0b				sta 	IFR0+IExp
.2f6d	18		clc				clc
.2f6e					_IFSTFReturn:
.2f6e	60		rts				rts
.2f6f					IFloatAddDecimalToR0:
.2f6f	8d db 06	sta $06db			sta 	IFCount 					; save it out.
.2f72	86 20		stx $20				stx 	iTemp0
.2f74	84 21		sty $21				sty 	iTemp0+1
.2f76					IFSTFDecimal:
.2f76	a2 08		ldx #$08			ldx 	#IFR0 						; push integer part on stack
.2f78	20 1a 30	jsr $301a			jsr 	IFloatPushRx
.2f7b	a2 08		ldx #$08			ldx 	#IFR0 						; R0 is the decimal digits so far.
.2f7d	20 cb 30	jsr $30cb			jsr 	IFloatSetZero
.2f80	9c dd 06	stz $06dd			stz 	IFDecimalPlaces
.2f83					_IFSTDLoop:
.2f83	20 cb 2f	jsr $2fcb			jsr 	IFSTFGetNext 				; get next
.2f86	b0 41		bcs $2fc9			bcs 	_IFSTFFail2 				; bad character.
.2f88	f0 11		beq $2f9b			beq 	_IFSTFComplete 				; end of data, work out the result.
.2f8a	c9 2e		cmp #$2e			cmp 	#"."						; only one decimal
.2f8c	f0 39		beq $2fc7			beq 	_IFSTFExit2
.2f8e	20 ef 2f	jsr $2fef			jsr 	IFSTFAddR0 					; add number in
.2f91	ee dd 06	inc $06dd			inc 	IFDecimalPlaces 			; count decimals
.2f94	ad dd 06	lda $06dd			lda 	IFDecimalPlaces 			; no more than 3 DP used.
.2f97	c9 03		cmp #$03			cmp 	#3
.2f99	90 e8		bcc $2f83			bcc 	_IFSTDLoop
.2f9b					_IFSTFComplete:
.2f9b	ad dd 06	lda $06dd			lda 	IFDecimalPlaces 			; decimals x 4 as accessing multiplier from a LUT.
.2f9e	f0 27		beq $2fc7			beq 	_IFSTFExit2					; if none, this is syntactically fine, just ignore
.2fa0	3a		dec a				dec 	a 							; table indexed from 1.
.2fa1	0a		asl a				asl 	a
.2fa2	0a		asl a				asl 	a
.2fa3	aa		tax				tax
.2fa4	bd 06 30	lda $3006,x			lda 	TableTen,x 					; copy table entry into R0 - these are 0.1,0.01,0.001
.2fa7	85 0c		sta $0c				sta  	IFR1+IM0 					; 0.0001 etc, up to 5 decimals.
.2fa9	bd 07 30	lda $3007,x			lda 	TableTen+1,x
.2fac	85 0d		sta $0d				sta  	IFR1+IM1
.2fae	bd 08 30	lda $3008,x			lda 	TableTen+2,x
.2fb1	85 0e		sta $0e				sta  	IFR1+IM2
.2fb3	bd 09 30	lda $3009,x			lda 	TableTen+3,x
.2fb6	85 0f		sta $0f				sta  	IFR1+IExp
.2fb8	a2 0c		ldx #$0c			ldx 	#IFR1 						; multiply into result
.2fba	20 6b 2b	jsr $2b6b			jsr 	IFloatMultiply
.2fbd	a2 0c		ldx #$0c			ldx 	#IFR1  						; pop and add the decimal.
.2fbf	20 3b 30	jsr $303b			jsr 	IFloatPullRx
.2fc2	a2 0c		ldx #$0c			ldx 	#IFR1
.2fc4	20 c1 2a	jsr $2ac1			jsr 	IFloatAdd
.2fc7					_IFSTFExit2:
.2fc7	18		clc				clc
.2fc8	60		rts				rts
.2fc9					_IFSTFFail2:
.2fc9	38		sec				sec
.2fca	60		rts				rts
.2fcb					IFSTFGetNext:
.2fcb	ad db 06	lda $06db			lda 	IFCount  					; if count is zero, return with Z set.
.2fce	f0 19		beq $2fe9			beq 	_IFSTFReturnOk
.2fd0	b2 20		lda ($20)			lda 	(iTemp0) 					; get next character
.2fd2	e6 20		inc $20				inc 	iTemp0 						; point at next.
.2fd4	d0 02		bne $2fd8			bne 	_IFSTFGNNoCarry
.2fd6	e6 21		inc $21				inc 	iTemp0+1
.2fd8					_IFSTFGNNoCarry:
.2fd8	ce db 06	dec $06db			dec 	IFCount 					; dec count.
.2fdb	c9 2e		cmp #$2e			cmp 	#"."	 					; check, dp is allowed.
.2fdd	f0 08		beq $2fe7			beq 	_IFSTFGOkay
.2fdf	c9 30		cmp #$30			cmp 	#"0"						; < 0 fail.
.2fe1	90 08		bcc $2feb			bcc 	_IFSTFGFail
.2fe3	c9 3a		cmp #$3a			cmp 	#"9"+1 						; > 9 fail.
.2fe5	b0 04		bcs $2feb			bcs 	_IFSTFGFail
.2fe7					_IFSTFGOkay:
.2fe7	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.2fe9					_IFSTFReturnOk:
.2fe9	18		clc				clc
.2fea	60		rts				rts
.2feb					_IFSTFGFail:
.2feb	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.2fed	38		sec				sec
.2fee	60		rts				rts
.2fef					IFSTFAddR0:
.2fef	29 0f		and #$0f			and 	#15 						; to int value
.2ff1	48		pha				pha 								; save it.
.2ff2	a9 0a		lda #$0a			lda 	#10
.2ff4	a2 0c		ldx #$0c			ldx 	#IFR1
.2ff6	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.2ff9	20 6b 2b	jsr $2b6b			jsr 	IFloatMultiply
.2ffc	68		pla				pla
.2ffd	a2 0c		ldx #$0c			ldx 	#IFR1
.2fff	20 cd 30	jsr $30cd			jsr 	IFloatSetByte
.3002	20 c1 2a	jsr $2ac1			jsr 	IFloatAdd
.3005	60		rts				rts
.06db					IFCount:
>06db							.fill 	1
.06dc					IFSignFlag:
>06dc							.fill 	1
.06dd					IFDecimalPlaces:
>06dd							.fill 	1
.3006					TableTen:
>3006	9a 19 00 30				.byte	$9a,$19,$00,$30 ; 0.10001
>300a	8f 02 00 30				.byte	$8f,$02,$00,$30 ; 0.00999
>300e	42 00 00 30				.byte	$42,$00,$00,$30 ; 0.00101
>3012	07 00 00 30				.byte	$07,$00,$00,$30 ; 0.00011
>3016	01 00 00 30				.byte	$01,$00,$00,$30 ; 2e-05
.301a					IFloatPushRx:
.301a	5a		phy				phy
.301b	ac de 06	ldy $06de			ldy 	IFStackIndex 				; push IM0,1,2,Exp on the stack
.301e	b5 00		lda $00,x			lda 	IM0,x
.3020	99 df 06	sta $06df,y			sta 	IFStack,y
.3023	b5 01		lda $01,x			lda 	IM1,x
.3025	99 e0 06	sta $06e0,y			sta 	IFStack+1,y
.3028	b5 02		lda $02,x			lda 	IM2,x
.302a	99 e1 06	sta $06e1,y			sta 	IFStack+2,y
.302d	b5 03		lda $03,x			lda 	IExp,x
.302f	99 e2 06	sta $06e2,y			sta 	IFStack+3,y
.3032	c8		iny				iny
.3033	c8		iny				iny
.3034	c8		iny				iny
.3035	c8		iny				iny
.3036	8c de 06	sty $06de			sty 	IFStackIndex 				; update SP
.3039	7a		ply				ply
.303a	60		rts				rts
.303b					IFloatPullRx:
.303b	5a		phy				phy
.303c	ac de 06	ldy $06de			ldy 	IFStackIndex	 			; decrement SP
.303f	88		dey				dey
.3040	88		dey				dey
.3041	88		dey				dey
.3042	88		dey				dey
.3043	b9 df 06	lda $06df,y			lda 	IFStack,y 					; pop IM0,1,2,Exp off stack
.3046	95 00		sta $00,x			sta 	IM0,x
.3048	b9 e0 06	lda $06e0,y			lda 	IFStack+1,y
.304b	95 01		sta $01,x			sta 	IM1,x
.304d	b9 e1 06	lda $06e1,y			lda 	IFStack+2,y
.3050	95 02		sta $02,x			sta 	IM2,x
.3052	b9 e2 06	lda $06e2,y			lda 	IFStack+3,y
.3055	95 03		sta $03,x			sta 	IExp,x
.3057	8c de 06	sty $06de			sty 	IFStackIndex 				; update SP
.305a	7a		ply				ply
.305b	60		rts				rts
.06de					IFStackIndex:
>06de							.fill 	1
.06df					IFStack:
>06df							.fill 	16*4
.305c					IFloatCopyFromRegister:
.305c	b5 00		lda $00,x			lda 	0,x
.305e	85 08		sta $08				sta 	IFR0
.3060	b5 01		lda $01,x			lda 	1,x
.3062	85 09		sta $09				sta 	IFR0+1
.3064	b5 02		lda $02,x			lda 	2,x
.3066	85 0a		sta $0a				sta 	IFR0+2
.3068	b5 03		lda $03,x			lda 	3,x
.306a	85 0b		sta $0b				sta 	IFR0+3
.306c	60		rts				rts
.306d					IFloatCopyToRegister:
.306d	a5 08		lda $08				lda 	IFR0
.306f	95 00		sta $00,x			sta 	0,x
.3071	a5 09		lda $09				lda 	IFR0+1
.3073	95 01		sta $01,x			sta 	1,x
.3075	a5 0a		lda $0a				lda 	IFR0+2
.3077	95 02		sta $02,x			sta 	2,x
.3079	a5 0b		lda $0b				lda 	IFR0+3
.307b	95 03		sta $03,x			sta 	3,x
.307d	60		rts				rts
.307e					IFloatLoadInline:
.307e	68		pla				pla 								; pop address off to iTemp0
.307f	85 20		sta $20				sta 	iTemp0
.3081	68		pla				pla
.3082	85 21		sta $21				sta 	iTemp0+1
.3084	a0 01		ldy #$01			ldy 	#1
.3086	b1 20		lda ($20),y			lda 	(iTemp0),y 					; copy byte 0
.3088	95 00		sta $00,x			sta 	0,x
.308a	c8		iny				iny
.308b	b1 20		lda ($20),y			lda 	(iTemp0),y 					; copy byte 1
.308d	95 01		sta $01,x			sta 	1,x
.308f	c8		iny				iny
.3090	b1 20		lda ($20),y			lda 	(iTemp0),y 					; copy byte 2
.3092	95 02		sta $02,x			sta 	2,x
.3094	c8		iny				iny
.3095	b1 20		lda ($20),y			lda 	(iTemp0),y 					; copy byte 3
.3097	95 03		sta $03,x			sta 	3,x
.3099	18		clc				clc 								; inc pointer, 1 for return, 4 for data
.309a	a5 20		lda $20				lda 	iTemp0
.309c	69 05		adc #$05			adc 	#5
.309e	85 20		sta $20				sta 	iTemp0
.30a0	90 02		bcc $30a4			bcc 	_IFLINoCarry
.30a2	e6 21		inc $21				inc 	iTemp0+1
.30a4					_IFLINoCarry:
.30a4	6c 20 00	jmp ($0020)			jmp 	(iTemp0)					; effectively RTS
.30a7					IFloatMultiply8BitRx:
.30a7	5a		phy		        phy
.30a8	b5 00		lda $00,x	        lda     IM0,x                       ; AY are the two values
.30aa	a4 08		ldy $08		        ldy     IFR0+IM0
.30ac	4a		lsr a		        lsr     a                           ; prime the carry bit for the loop
.30ad	85 08		sta $08		        sta     IFR0+IM0
.30af	84 09		sty $09		        sty     IFR0+IM1
.30b1	a9 00		lda #$00	        lda     #0
.30b3	a0 08		ldy #$08	        ldy     #8
.30b5					_IFMLoop:
.30b5	90 03		bcc $30ba	        bcc     _IFMNoAdd
.30b7	18		clc		        clc
.30b8	65 09		adc $09		        adc     IFR0+IM1
.30ba					_IFMNoAdd:
.30ba	6a		ror a		        ror     a
.30bb	66 08		ror $08		        ror     IFR0+IM0                    ; pull another bit out for the next iteration
.30bd	88		dey		        dey
.30be	d0 f5		bne $30b5	        bne     _IFMLoop
.30c0	85 09		sta $09		        sta     IFR0+IM1                    ; write MSB out
.30c2	7a		ply		        ply
.30c3	60		rts		        rts
.30c4					IFloatCheckZero:
.30c4	b5 00		lda $00,x			lda 	IM0,x 						; or together mantissa bytes.
.30c6	15 01		ora $01,x			ora 	IM1,x
.30c8	15 02		ora $02,x			ora 	IM2,x
.30ca	60		rts				rts
.30cb					IFloatSetZero:
.30cb	a9 00		lda #$00			lda 	#0
.30cd					IFloatSetByte:
.30cd	95 00		sta $00,x			sta 	IM0,x 						; set mantissa to 00:A
.30cf	74 01		stz $01,x			stz 	IM1,x
.30d1	74 02		stz $02,x			stz 	IM2,x
.30d3	74 03		stz $03,x			stz 	IExp,x 						; zero the exponent.
.30d5	60		rts				rts
.30d6					IFloatNegate:
.30d6	b5 03		lda $03,x			lda 	IExp,x 						; toggle the sign bit.
.30d8	49 40		eor #$40			eor 	#IFSign
.30da	95 03		sta $03,x			sta 	IExp,x
.30dc	18		clc				clc
.30dd	60		rts				rts
.30de					IFloatMantissaNegate:
.30de	38		sec				sec 								; when you want a real 2's complement negative value.
.30df	a9 00		lda #$00			lda 	#0
.30e1	f5 00		sbc $00,x			sbc 	IM0,x
.30e3	95 00		sta $00,x			sta 	IM0,x
.30e5	a9 00		lda #$00			lda 	#0
.30e7	f5 01		sbc $01,x			sbc 	IM1,x
.30e9	95 01		sta $01,x			sta 	IM1,x
.30eb	a9 00		lda #$00			lda 	#0
.30ed	f5 02		sbc $02,x			sbc 	IM2,x
.30ef	95 02		sta $02,x			sta 	IM2,x
.30f1	60		rts				rts
.30f2					IFloatShiftLeft:
.30f2	18		clc				clc
.30f3					IFloatRotateLeft:
.30f3	36 00		rol $00,x			rol 	IM0,x
.30f5	36 01		rol $01,x			rol 	IM1,x
.30f7	36 02		rol $02,x			rol 	IM2,x
.30f9	60		rts				rts
.30fa					IFloatShiftRight:
.30fa	18		clc				clc
.30fb					IFloatRotateRight:
.30fb	76 02		ror $02,x			ror 	IM2,x
.30fd	76 01		ror $01,x			ror 	IM1,x
.30ff	76 00		ror $00,x			ror 	IM0,x
.3101	60		rts				rts
.3102					IFloatNormalise:
.3102	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero 			; is it zero
.3105	f0 18		beq $311f			beq 	_IFNExitZero 				; if so exit
.3107					_IFNLoop:
.3107	b5 02		lda $02,x			lda 	IM2,x 						; is it normalised e.g. bits 7/6 are 01
.3109	29 c0		and #$c0			and 	#$C0
.310b	c9 40		cmp #$40			cmp 	#$40
.310d	f0 13		beq $3122			beq 	_IFNExitOkay 				; if so , then we are done.
.310f	b5 03		lda $03,x			lda 	IExp,x 						; check exponent is not -32 already.
.3111	29 3f		and #$3f			and 	#$3F
.3113	c9 20		cmp #$20			cmp 	#$20
.3115	f0 0b		beq $3122			beq 	_IFNExitOkay 				; if so, then we cannot normalise any more.
.3117	20 38 31	jsr $3138			jsr 	IFloatDecExponent
.311a	20 f2 30	jsr $30f2			jsr 	IFloatShiftLeft 			; shift mantissa left, e.g. multiply by 2
.311d	80 e8		bra $3107			bra 	_IFNLoop
.311f					_IFNExitZero:
.311f	20 cb 30	jsr $30cb			jsr 	IFloatSetZero 				; set the result to zero
.3122					_IFNExitOkay:
.3122	18		clc				clc  								; return with CC.
.3123	60		rts				rts
.3124					IFloatIncExponent:
.3124	b5 03		lda $03,x			lda 	IExp,x
.3126	48		pha				pha
.3127	29 c0		and #$c0			and 	#$C0
.3129	8d 1f 07	sta $071f			sta 	IFXTemp
.312c	68		pla				pla
.312d	1a		inc a				inc 	a
.312e	29 3f		and #$3f			and 	#$3F
.3130	48		pha				pha
.3131	0d 1f 07	ora $071f			ora 	IFXTemp
.3134	95 03		sta $03,x			sta 	IExp,x
.3136	68		pla				pla
.3137	60		rts				rts
.3138					IFloatDecExponent:
.3138	b5 03		lda $03,x			lda 	IExp,x
.313a	48		pha				pha
.313b	29 c0		and #$c0			and 	#$C0
.313d	8d 1f 07	sta $071f			sta 	IFXTemp
.3140	68		pla				pla
.3141	3a		dec a				dec 	a
.3142	29 3f		and #$3f			and 	#$3F
.3144	48		pha				pha
.3145	0d 1f 07	ora $071f			ora 	IFXTemp
.3148	95 03		sta $03,x			sta 	IExp,x
.314a	68		pla				pla
.314b	60		rts				rts
.071f					IFXTemp:
>071f							.fill 	1
.314c					IFloatBufferReset:
.314c	9c 20 07	stz $0720			stz 	IFBufferCount
.314f	9c 21 07	stz $0721			stz 	IFBuffer
.3152	60		rts				rts
.3153					IFloatGetBufferAddress:
.3153	a0 07		ldy #$07			ldy 	#(IFBuffer >> 8)
.3155	a2 21		ldx #$21			ldx 	#(IFBuffer & $FF)
.3157	ad 20 07	lda $0720			lda 	IFBufferCount
.315a	60		rts				rts
.315b					IFloatBufferWrite:
.315b	da		phx				phx
.315c	ae 20 07	ldx $0720			ldx 	IFBufferCount
.315f	9d 21 07	sta $0721,x			sta 	IFBuffer,x
.3162	9e 22 07	stz $0722,x			stz 	IFBuffer+1,x
.3165	ee 20 07	inc $0720			inc 	IFBufferCount
.3168	fa		plx				plx
.3169	60		rts				rts
.316a					IFloatStripTrailingZeros:
.316a	ae 20 07	ldx $0720			ldx 	IFBufferCount
.316d	bd 20 07	lda $0720,x			lda 	IFBuffer-1,x
.3170	c9 30		cmp #$30			cmp		#"0"
.3172	d0 0f		bne $3183			bne 	_IFSTExit
.3174	bd 1f 07	lda $071f,x			lda 	IFBuffer-2,x
.3177	c9 2e		cmp #$2e			cmp 	#"."
.3179	f0 08		beq $3183			beq 	_IFSTExit
.317b	ce 20 07	dec $0720			dec 	IFBufferCount
.317e	9e 20 07	stz $0720,x			stz 	IFBuffer-1,x
.3181	80 e7		bra $316a			bra 	IFloatStripTrailingZeros
.3183					_IFSTExit:
.3183	60		rts				rts
.0720					IFBufferCount:
>0720							.fill 	1
.0721					IFBuffer:
>0721							.fill 	25
.3184					IFloatCheckRange:
.3184	a5 0b		lda $0b				lda 	IFR0+IExp					; force it negative e.g. -|R0|
.3186	09 40		ora #$40			ora 	#IFSign
.3188	85 0b		sta $0b				sta 	IFR0+IExp
.318a	a2 0c		ldx #$0c			ldx 	#IFR1 						; add R1.
.318c	20 c1 2a	jsr $2ac1			jsr 	IFloatAdd 					; add allowed to error.
.318f	a2 08		ldx #$08			ldx 	#IFR0
.3191	20 c4 30	jsr $30c4			jsr 	IFloatCheckZero 			; error if < 0
.3194	f0 06		beq $319c			beq 	_IFAOkay
.3196	a5 0b		lda $0b				lda 	IFR0+IExp
.3198	29 40		and #$40			and 	#IFSign
.319a	d0 01		bne $319d			bne 	_IFAFail
.319c					_IFAOkay:
.319c	60		rts				rts
.319d					_IFAFail:
.319d	38		sec				sec
.319e	68		pla				pla 								; get address - 2
.319f	e9 02		sbc #$02			sbc 	#2
.31a1	aa		tax				tax
.31a2	68		pla				pla
.31a3	e9 00		sbc #$00			sbc 	#0
.31a5	a8		tay				tay
.31a6	a9 aa		lda #$aa			lda 	#$AA 						; sign assert
.31a8					_IFAStop:
>31a8	db						.byte 	$DB 						; display an error AA ADR ADR
.31a9	80 fd		bra $31a8			bra 	_IFAStop

;******  Return to file: basic.asm


;******  Processing file: src/program/testing/testing.asmx


;******  Processing file: src/program/testing/testdat.incx

.7800					Line0:
>7800	35 33 31 20 31 32 32 37			.text '531 1227(B6O9Q-7.94 ""WHILE G9G8 /:735 Q3F TIME R2 L1( G6$ 4.42 1323 2.61(279 DEC( N6F6L2 879 VAL(L6F9"RTRDIKO"',0
>7808	28 42 36 4f 39 51 2d 37 2e 39 34 20 22 22 57 48
>7818	49 4c 45 20 47 39 47 38 20 2f 3a 37 33 35 20 51
>7828	33 46 20 54 49 4d 45 20 52 32 20 4c 31 28 20 47
>7838	36 24 20 34 2e 34 32 20 31 33 32 33 20 32 2e 36
>7848	31 28 32 37 39 20 44 45 43 28 20 4e 36 46 36 4c
>7858	32 20 38 37 39 20 56 41 4c 28 4c 36 46 39 22 52
>7868	54 52 44 49 4b 4f 22 00
.7870					Line1:
>7870	39 30 33 00				.text '903',0
.7874					Line2:
>7874	31 31 31 39 20 22 51 22			.text '1119 "Q" <>1335 * + NEXT 2.43 1587("VI@IVMN"1155 "OO" >= "US"Z2H "SG" 1359"JUAMYX"LOAD SGN( 843',0
>787c	20 3c 3e 31 33 33 35 20 2a 20 2b 20 4e 45 58 54
>788c	20 32 2e 34 33 20 31 35 38 37 28 22 56 49 40 49
>789c	56 4d 4e 22 31 31 35 35 20 22 4f 4f 22 20 3e 3d
>78ac	20 22 55 53 22 5a 32 48 20 22 53 47 22 20 31 33
>78bc	35 39 22 4a 55 41 4d 59 58 22 4c 4f 41 44 20 53
>78cc	47 4e 28 20 38 34 33 00
.78d4					Line3:
>78d4	31 36 39 35 20 20 43 34			.text '1695  C4H5D( + TO M$Q3F RND(LIST 1491 "KVOE@W"1683/-O6C+7.35',0
>78dc	48 35 44 28 20 2b 20 54 4f 20 4d 24 51 33 46 20
>78ec	52 4e 44 28 4c 49 53 54 20 31 34 39 31 20 22 4b
>78fc	56 4f 45 40 57 22 31 36 38 33 2f 2d 4f 36 43 2b
>790c	37 2e 33 35 00
.7911					Line4:
>7911	31 34 34 33 20 39 2e 30			.text '1443 9.05 -0.9"O" /1131<C 663 G6$471=D7Q9$R0"ZVVQVKXR"',0
>7919	35 20 2d 30 2e 39 22 4f 22 20 2f 31 31 33 31 3c
>7929	43 20 36 36 33 20 47 36 24 34 37 31 3d 44 37 51
>7939	39 24 52 30 22 5a 56 56 51 56 4b 58 52 22 00
.7948					Line5:
>7948	35 33 31 20 30 2e 39 32			.text '531 0.92',0
>7950	00
.7951					Line6:
>7951	33 30 33 20 20 36 37 35			.text '303  675"OG"1227 I$="RDFAPQL""""@AW"D1O5C 3.74 LEFT$(D8G0 1215',0
>7959	22 4f 47 22 31 32 32 37 20 49 24 3d 22 52 44 46
>7969	41 50 51 4c 22 22 22 22 40 41 57 22 44 31 4f 35
>7979	43 20 33 2e 37 34 20 4c 45 46 54 24 28 44 38 47
>7989	30 20 31 32 31 35 00
.7990					Line7:
>7990	31 35 39 39 20 20 2a 22			.text '1599  *"D"Q1F3U 0.73 "RYVZW"/POKE',0
>7998	44 22 51 31 46 33 55 20 30 2e 37 33 20 22 52 59
>79a8	56 5a 57 22 2f 50 4f 4b 45 00
.79b2					Line8:
>79b2	31 32 35 31 20 20 3e 43			.text '1251  >CHR$("LORUAGQ"H1G 891',0
>79ba	48 52 24 28 22 4c 4f 52 55 41 47 51 22 48 31 47
>79ca	20 38 39 31 00
.79cf					Line9:
>79cf	36 37 35 20 2d 32 2e 36			.text '675 -2.68 ENDIF',0
>79d7	38 20 45 4e 44 49 46 00
.79df					Line10:
>79df	31 33 32 33 20 20 47 36			.text '1323  G6$"HB@KWR""DNWOVTB" 1215 R0>2.45"HHTK" G4U"VVAVKPF"=U3J G4U>:',0
>79e7	24 22 48 42 40 4b 57 52 22 22 44 4e 57 4f 56 54
>79f7	42 22 20 31 32 31 35 20 52 30 3e 32 2e 34 35 22
>7a07	48 48 54 4b 22 20 47 34 55 22 56 56 41 56 4b 50
>7a17	46 22 3d 55 33 4a 20 47 34 55 3e 3a 00
.7a24					Line11:
>7a24	34 32 33 20 28 20 48 31			.text '423 ( H1A1O$6.19 DATA"PKEXBNG"FOR',0
>7a2c	41 31 4f 24 36 2e 31 39 20 44 41 54 41 22 50 4b
>7a3c	45 58 42 4e 47 22 46 4f 52 00
.7a46					Line12:
>7a46	39 37 35 20 20 2a 20 2a			.text '975  * * G8G5G6$<2.15<>4.39-4.11 INT(- - 771 315(/ 8.52-4.97"O"-6.82"VAD" "JVE" 1143 291 -8.48 1659 D1O5C',0
>7a4e	20 47 38 47 35 47 36 24 3c 32 2e 31 35 3c 3e 34
>7a5e	2e 33 39 2d 34 2e 31 31 20 49 4e 54 28 2d 20 2d
>7a6e	20 37 37 31 20 33 31 35 28 2f 20 38 2e 35 32 2d
>7a7e	34 2e 39 37 22 4f 22 2d 36 2e 38 32 22 56 41 44
>7a8e	22 20 22 4a 56 45 22 20 31 31 34 33 20 32 39 31
>7a9e	20 2d 38 2e 34 38 20 31 36 35 39 20 44 31 4f 35
>7aae	43 00
.7ab0					Line13:
>7ab0	31 35 31 35 00				.text '1515',0
.7ab5					Line14:
>7ab5	31 30 37 31 20 55 32 55			.text '1071 U2U( +"J""LRTDBXR" /',0
>7abd	28 20 2b 22 4a 22 22 4c 52 54 44 42 58 52 22 20
>7acd	2f 00
.7acf					Line15:
>7acf	31 32 36 33 20 20 52 45			.text '1263  READ*/Z(G8L0$( 615"@MD" "YH"1191*891"IDZYM"',0
>7ad7	41 44 2a 2f 5a 28 47 38 4c 30 24 28 20 36 31 35
>7ae7	22 40 4d 44 22 20 22 59 48 22 31 31 39 31 2a 38
>7af7	39 31 22 49 44 5a 59 4d 22 00
.7b01					Line16:
>7b01	36 37 35 20 3d 20 22 47			.text '675 = "GIQQNOWF">5.44 579"BCBJ"MID$(-7.54 4.22*A9A5D1 1143 DIM 627-6.86 "PQEY"L6F9= K3X2G2$ Z6W0E2 G4N 2.95 -3.48 1527"L"',0
>7b09	49 51 51 4e 4f 57 46 22 3e 35 2e 34 34 20 35 37
>7b19	39 22 42 43 42 4a 22 4d 49 44 24 28 2d 37 2e 35
>7b29	34 20 34 2e 32 32 2a 41 39 41 35 44 31 20 31 31
>7b39	34 33 20 44 49 4d 20 36 32 37 2d 36 2e 38 36 20
>7b49	22 50 51 45 59 22 4c 36 46 39 3d 20 4b 33 58 32
>7b59	47 32 24 20 5a 36 57 30 45 32 20 47 34 4e 20 32
>7b69	2e 39 35 20 2d 33 2e 34 38 20 31 35 32 37 22 4c
>7b79	22 00
.7b7b					Line17:
>7b7b	37 38 33 20 22 54 41 57			.text '783 "TAWHHI@" +1.68 DATA',0
>7b83	48 48 49 40 22 20 2b 31 2e 36 38 20 44 41 54 41
>7b93	00
.7b94					Line18:
>7b94	31 33 33 35 20 22 22 20			.text '1335 "" RAND( 1599 DOKE/"" "VLBTS" STEP)',0
>7b9c	52 41 4e 44 28 20 31 35 39 39 20 44 4f 4b 45 2f
>7bac	22 22 20 22 56 4c 42 54 53 22 20 53 54 45 50 29
>7bbc	00
.7bbd					Line19:
>7bbd	31 35 30 33 20 48 31 47			.text '1503 H1G 915-5.84 -2.53 8.45(( 9.21"NADQBUK"483 9.44 6.78 R0',0
>7bc5	20 39 31 35 2d 35 2e 38 34 20 2d 32 2e 35 33 20
>7bd5	38 2e 34 35 28 28 20 39 2e 32 31 22 4e 41 44 51
>7be5	42 55 4b 22 34 38 33 20 39 2e 34 34 20 36 2e 37
>7bf5	38 20 52 30 00
.7bfa					Line20:
>7bfa	35 37 39 20 3c 3c 22 49			.text '579 <<"ISHQ""HW" <>R9S3T5 R2-7.54) *1095-9.55 )PEEK(=H1A1O$',0
>7c02	53 48 51 22 22 48 57 22 20 3c 3e 52 39 53 33 54
>7c12	35 20 52 32 2d 37 2e 35 34 29 20 2a 31 30 39 35
>7c22	2d 39 2e 35 35 20 29 50 45 45 4b 28 3d 48 31 41
>7c32	31 4f 24 00
.7c36					Line21:
>7c36	37 34 37 20 22 45 4b 4f			.text '747 "EKOT"1371 2.48 1275 1539 R2 "V@"723 M4/ W5A$"KTRYQKFV"F7T8D( -1.84',0
>7c3e	54 22 31 33 37 31 20 32 2e 34 38 20 31 32 37 35
>7c4e	20 31 35 33 39 20 52 32 20 22 56 40 22 37 32 33
>7c5e	20 4d 34 2f 20 57 35 41 24 22 4b 54 52 59 51 4b
>7c6e	46 56 22 46 37 54 38 44 28 20 2d 31 2e 38 34 00
.7c7e					Line22:
>7c7e	39 39 39 20 31 35 31 35			.text '999 1515 D9I9 2.04-3.95/"ERHHI"U$=-1.14-1.12 5.63<"VGY"-1.68 555>> = "MPXNPJHW"',0
>7c86	20 44 39 49 39 20 32 2e 30 34 2d 33 2e 39 35 2f
>7c96	22 45 52 48 48 49 22 55 24 3d 2d 31 2e 31 34 2d
>7ca6	31 2e 31 32 20 35 2e 36 33 3c 22 56 47 59 22 2d
>7cb6	31 2e 36 38 20 35 35 35 3e 3e 20 3d 20 22 4d 50
>7cc6	58 4e 50 4a 48 57 22 00
.7cce					Line23:
>7cce	38 33 31 20 20 31 35 36			.text '831  1563 = -7.15-7.04-1.4 UNTIL /3.3 "VGFIGOKX"963"JGHHD"0.98 =6.37 1551 Y2K(-6.39:/',0
>7cd6	33 20 3d 20 2d 37 2e 31 35 2d 37 2e 30 34 2d 31
>7ce6	2e 34 20 55 4e 54 49 4c 20 2f 33 2e 33 20 22 56
>7cf6	47 46 49 47 4f 4b 58 22 39 36 33 22 4a 47 48 48
>7d06	44 22 30 2e 39 38 20 3d 36 2e 33 37 20 31 35 35
>7d16	31 20 59 32 4b 28 2d 36 2e 33 39 3a 2f 00
.7d24					Line24:
>7d24	38 33 31 20 31 35 32 37			.text '831 1527-0.76 903 1515 "PLS" "EOYMMOK" 1.46-279 "" ""XOR',0
>7d2c	2d 30 2e 37 36 20 39 30 33 20 31 35 31 35 20 22
>7d3c	50 4c 53 22 20 22 45 4f 59 4d 4d 4f 4b 22 20 31
>7d4c	2e 34 36 2d 32 37 39 20 22 22 20 22 22 58 4f 52
>7d5c	00
.7d5d					Line25:
>7d5d	31 33 39 35 20 4e 36 20			.text '1395 N6 4.01"ACOBY"CALL 6.23) VAL(CALL 3.27 "WDVVORS"=G3H3Q "RP@I""SXPUZ" "BJT")"XLV"',0
>7d65	34 2e 30 31 22 41 43 4f 42 59 22 43 41 4c 4c 20
>7d75	36 2e 32 33 29 20 56 41 4c 28 43 41 4c 4c 20 33
>7d85	2e 32 37 20 22 57 44 56 56 4f 52 53 22 3d 47 33
>7d95	48 33 51 20 22 52 50 40 49 22 22 53 58 50 55 5a
>7da5	22 20 22 42 4a 54 22 29 22 58 4c 56 22 00
.7db3					Line26:
>7db3	31 33 38 33 20 2b 20 46			.text '1383 + FOR SGN(999 "FEUL"<UNTIL)',0
>7dbb	4f 52 20 53 47 4e 28 39 39 39 20 22 46 45 55 4c
>7dcb	22 3c 55 4e 54 49 4c 29 00
.7dd4					Line27:
>7dd4	31 30 39 35 20 20 22 52			.text '1095  "RJLV"-7.58',0
>7ddc	4a 4c 56 22 2d 37 2e 35 38 00
.7de6					Line28:
>7de6	34 38 33 20 20 33 2e 38			.text '483  3.88 1539 1383 "W"("U@" "XQ@W"795 351 = 807"CX@AYKI"1551 MID$( "KIE"/1563',0
>7dee	38 20 31 35 33 39 20 31 33 38 33 20 22 57 22 28
>7dfe	22 55 40 22 20 22 58 51 40 57 22 37 39 35 20 33
>7e0e	35 31 20 3d 20 38 30 37 22 43 58 40 41 59 4b 49
>7e1e	22 31 35 35 31 20 4d 49 44 24 28 20 22 4b 49 45
>7e2e	22 2f 31 35 36 33 00
.7e35					Line29:
>7e35	31 31 34 33 20 22 48 45			.text '1143 "HEE"DIV "W"-2.17 591"TSKLWCM"+LEFT$( 651+ PRINT "RKCRXDIR"J2A V2K7(TIME CHR$( + X3W( 5.62 RETURN - O7 /"AW""NBIAKHTH""NEDVIAG" 567',0
>7e3d	45 22 44 49 56 20 22 57 22 2d 32 2e 31 37 20 35
>7e4d	39 31 22 54 53 4b 4c 57 43 4d 22 2b 4c 45 46 54
>7e5d	24 28 20 36 35 31 2b 20 50 52 49 4e 54 20 22 52
>7e6d	4b 43 52 58 44 49 52 22 4a 32 41 20 56 32 4b 37
>7e7d	28 54 49 4d 45 20 43 48 52 24 28 20 2b 20 58 33
>7e8d	57 28 20 35 2e 36 32 20 52 45 54 55 52 4e 20 2d
>7e9d	20 4f 37 20 2f 22 41 57 22 22 4e 42 49 41 4b 48
>7ead	54 48 22 22 4e 45 44 56 49 41 47 22 20 35 36 37
>7ebd	00
.7ebe					Line30:
>7ebe	31 36 38 33 20 35 39 31			.text '1683 591/"T@EHBOT" ) N6"RONULMLC"411 > "RGKYZU" "RXPNZ""ZFMA"+ ENDPROC 1.94- 1.8 R0 "VPE""@JXF@M""VIKFQOAJ"A6Z5Z6-3.19 -6.99 P X3Q4*',0
>7ec6	2f 22 54 40 45 48 42 4f 54 22 20 29 20 4e 36 22
>7ed6	52 4f 4e 55 4c 4d 4c 43 22 34 31 31 20 3e 20 22
>7ee6	52 47 4b 59 5a 55 22 20 22 52 58 50 4e 5a 22 22
>7ef6	5a 46 4d 41 22 2b 20 45 4e 44 50 52 4f 43 20 31
>7f06	2e 39 34 2d 20 31 2e 38 20 52 30 20 22 56 50 45
>7f16	22 22 40 4a 58 46 40 4d 22 22 56 49 4b 46 51 4f
>7f26	41 4a 22 41 36 5a 35 5a 36 2d 33 2e 31 39 20 2d
>7f36	36 2e 39 39 20 50 20 58 33 51 34 2a 00
.7f43					Line31:
>7f43	31 31 30 37 20 22 53 22			.text '1107 "S"< -0.51-1.0 P1T0N -2.0',0
>7f4b	3c 20 2d 30 2e 35 31 2d 31 2e 30 20 50 31 54 30
>7f5b	4e 20 2d 32 2e 30 00
.7f62					Line32:
>7f62	31 36 35 39 20 31 36 39			.text '1659 1695 "LV"6.95-1563',0
>7f6a	35 20 22 4c 56 22 36 2e 39 35 2d 31 35 36 33 00
.7f7a					Line33:
>7f7a	37 31 31 20 20 22 59 4e			.text '711  "YNBNZ"435 L1(VAL(399 483 1635',0
>7f82	42 4e 5a 22 34 33 35 20 4c 31 28 56 41 4c 28 33
>7f92	39 39 20 34 38 33 20 31 36 33 35 00
.7f9e					Line34:
>7f9e	33 36 33 20 2f 20 35 36			.text '363 / 567-8.03"XIZE" V2K7( R0 "" 5.09 5.28 999 AND T-0.48/A1T3R',0
>7fa6	37 2d 38 2e 30 33 22 58 49 5a 45 22 20 56 32 4b
>7fb6	37 28 20 52 30 20 22 22 20 35 2e 30 39 20 35 2e
>7fc6	32 38 20 39 39 39 20 41 4e 44 20 54 2d 30 2e 34
>7fd6	38 2f 41 31 54 33 52 00
.7fde					Line35:
>7fde	36 38 37 20 20 55 35 4f			.text '687  U5O5"HNKTJA" "IEN"X3C3 567< 4.92 SAVE 375 267 "TBNZD"-3.61> SQR(W5A$DIV""C',0
>7fe6	35 22 48 4e 4b 54 4a 41 22 20 22 49 45 4e 22 58
>7ff6	33 43 33 20 35 36 37 3c 20 34 2e 39 32 20 53 41
>8006	56 45 20 33 37 35 20 32 36 37 20 22 54 42 4e 5a
>8016	44 22 2d 33 2e 36 31 3e 20 53 51 52 28 57 35 41
>8026	24 44 49 56 22 22 43 00
.802e					Line36:
>802e	31 31 33 31 20 43 48 52			.text '1131 CHR$("YBXLFJL")7.6=1119+ "@KJYFW"795-4.79 3.1/)) IF I7E0-2.18 8.17 F7U("QDRQT""SXSOB" "ZEURBMH@" >FOR 639< -4.21 SGN(',0
>8036	24 28 22 59 42 58 4c 46 4a 4c 22 29 37 2e 36 3d
>8046	31 31 31 39 2b 20 22 40 4b 4a 59 46 57 22 37 39
>8056	35 2d 34 2e 37 39 20 33 2e 31 2f 29 29 20 49 46
>8066	20 49 37 45 30 2d 32 2e 31 38 20 38 2e 31 37 20
>8076	46 37 55 28 22 51 44 52 51 54 22 22 53 58 53 4f
>8086	42 22 20 22 5a 45 55 52 42 4d 48 40 22 20 3e 46
>8096	4f 52 20 36 33 39 3c 20 2d 34 2e 32 31 20 53 47
>80a6	4e 28 00
.80a9					Line37:
>80a9	35 33 31 20 2d 20 36 2e			.text '531 - 6.14"AOGHX" -3.01 -2.26 C6S5(*STOP 1455 1623 M9A5F 1371 THEN G8G2S-9.7 519 1587 903 K3X2G2$567 711+Q 1203 DIV G8G5G6$LIST 1335"TDSEP@ND"',0
>80b1	31 34 22 41 4f 47 48 58 22 20 2d 33 2e 30 31 20
>80c1	2d 32 2e 32 36 20 43 36 53 35 28 2a 53 54 4f 50
>80d1	20 31 34 35 35 20 31 36 32 33 20 4d 39 41 35 46
>80e1	20 31 33 37 31 20 54 48 45 4e 20 47 38 47 32 53
>80f1	2d 39 2e 37 20 35 31 39 20 31 35 38 37 20 39 30
>8101	33 20 4b 33 58 32 47 32 24 35 36 37 20 37 31 31
>8111	2b 51 20 31 32 30 33 20 44 49 56 20 47 38 47 35
>8121	47 36 24 4c 49 53 54 20 31 33 33 35 22 54 44 53
>8131	45 50 40 4e 44 22 00
.8138					Line38:
>8138	31 31 35 35 20 20 3d 4f			.text '1155  =O7 * L6F9 <D7Q9$1563 / P:=I7E0 927 2.97-0.08=',0
>8140	37 20 2a 20 4c 36 46 39 20 3c 44 37 51 39 24 31
>8150	35 36 33 20 2f 20 50 3a 3d 49 37 45 30 20 39 32
>8160	37 20 32 2e 39 37 2d 30 2e 30 38 3d 00
.816d					Line39:
>816d	38 37 39 20 20 2d 33 2e			.text '879  -3.53"PD" PROC"RHE" 4.69 W5A$DATA 615-+"" -2.93 L6F9 ""',0
>8175	35 33 22 50 44 22 20 50 52 4f 43 22 52 48 45 22
>8185	20 34 2e 36 39 20 57 35 41 24 44 41 54 41 20 36
>8195	31 35 2d 2b 22 22 20 2d 32 2e 39 33 20 4c 36 46
>81a5	39 20 22 22 00
.81aa					Line40:
>81aa	33 32 37 20 47 38 47 35			.text '327 G8G5G6$ "XROEGJ" "SCUBRQRR"== -=* -0.92 T3(5.32) "XZ@"',0
>81b2	47 36 24 20 22 58 52 4f 45 47 4a 22 20 22 53 43
>81c2	55 42 52 51 52 52 22 3d 3d 20 2d 3d 2a 20 2d 30
>81d2	2e 39 32 20 54 33 28 35 2e 33 32 29 20 22 58 5a
>81e2	40 22 00
.81e5					Line41:
>81e5	36 36 33 00				.text '663',0
.81e9					Line42:
>81e9	31 32 30 33 20 20 4d 31			.text '1203  M1 U5O5 UNTIL "MAAFUP"G8G5G6$-7.18 N2B( 1371/ 327<G8G5G6$1683) K3X2G2$ "TJRM"351>GOTO 855 D5"MXPID@DO""GOTEUNIA"*',0
>81f1	20 55 35 4f 35 20 55 4e 54 49 4c 20 22 4d 41 41
>8201	46 55 50 22 47 38 47 35 47 36 24 2d 37 2e 31 38
>8211	20 4e 32 42 28 20 31 33 37 31 2f 20 33 32 37 3c
>8221	47 38 47 35 47 36 24 31 36 38 33 29 20 4b 33 58
>8231	32 47 32 24 20 22 54 4a 52 4d 22 33 35 31 3e 47
>8241	4f 54 4f 20 38 35 35 20 44 35 22 4d 58 50 49 44
>8251	40 44 4f 22 22 47 4f 54 45 55 4e 49 41 22 2a 00
.8261					Line43:
>8261	32 39 31 20 2d 33 2e 32			.text '291 -3.22 843 = >= ("" -2.66 DO )*1155 -7.76"UBSCRB"-0.72',0
>8269	32 20 38 34 33 20 3d 20 3e 3d 20 28 22 22 20 2d
>8279	32 2e 36 36 20 44 4f 20 29 2a 31 31 35 35 20 2d
>8289	37 2e 37 36 22 55 42 53 43 52 42 22 2d 30 2e 37
>8299	32 00
.829b					Line44:
>829b	38 35 35 20 4d 24 22 56			.text '855 M$"VX" 8.16 675 TO 5.34 1587 M5 C6S5( D1O5C 1191 END"M"',0
>82a3	58 22 20 38 2e 31 36 20 36 37 35 20 54 4f 20 35
>82b3	2e 33 34 20 31 35 38 37 20 4d 35 20 43 36 53 35
>82c3	28 20 44 31 4f 35 43 20 31 31 39 31 20 45 4e 44
>82d3	22 4d 22 00
.82d7					Line45:
>82d7	34 34 37 20 20 58 33 57			.text '447  X3W( "EZ"7.0 - 783"OC" 351/"ZCKEJS"-3.69 C6S5( "QGIBBLVH"PRINT 1035 8.25 A2 603 +"VCOATTG"',0
>82df	28 20 22 45 5a 22 37 2e 30 20 2d 20 37 38 33 22
>82ef	4f 43 22 20 33 35 31 2f 22 5a 43 4b 45 4a 53 22
>82ff	2d 33 2e 36 39 20 43 36 53 35 28 20 22 51 47 49
>830f	42 42 4c 56 48 22 50 52 49 4e 54 20 31 30 33 35
>831f	20 38 2e 32 35 20 41 32 20 36 30 33 20 2b 22 56
>832f	43 4f 41 54 54 47 22 00
.8337					Line46:
>8337	38 31 39 20 3e 3d 2d 31			.text '819 >=-1.1 M$771',0
>833f	2e 31 20 4d 24 37 37 31 00
.8348					Line47:
>8348	31 33 31 31 20 22 57 22			.text '1311 "W"TO G9G8 4.68 6.59 < 819 0.36 327 2.0 SYS >>S1 U4<891 XOR 963',0
>8350	54 4f 20 47 39 47 38 20 34 2e 36 38 20 36 2e 35
>8360	39 20 3c 20 38 31 39 20 30 2e 33 36 20 33 32 37
>8370	20 32 2e 30 20 53 59 53 20 3e 3e 53 31 20 55 34
>8380	3c 38 39 31 20 58 4f 52 20 39 36 33 00
.838d					Line48:
>838d	34 35 39 00				.text '459',0
.8391					Line49:
>8391	35 30 37 20 31 36 38 33			.text '507 1683 4.47 -5.07 /1203"RNCDAV"603=M2 T1S T1S',0
>8399	20 34 2e 34 37 20 2d 35 2e 30 37 20 2f 31 32 30
>83a9	33 22 52 4e 43 44 41 56 22 36 30 33 3d 4d 32 20
>83b9	54 31 53 20 54 31 53 00
.83c1					Line50:
>83c1	33 38 37 20 38 35 35 20			.text '387 855 C5$RUN',0
>83c9	43 35 24 52 55 4e 00
.83d0					Line51:
>83d0	36 38 37 20 53 39 56 34			.text '687 S9V4G6 1.22 -4.65""- EVENT(459-1059 SAVE: (B6O9Q""M M3"JASTJF"915 ,4.22 879"LAZC@TVV"783 LIST-',0
>83d8	47 36 20 31 2e 32 32 20 2d 34 2e 36 35 22 22 2d
>83e8	20 45 56 45 4e 54 28 34 35 39 2d 31 30 35 39 20
>83f8	53 41 56 45 3a 20 28 42 36 4f 39 51 22 22 4d 20
>8408	4d 33 22 4a 41 53 54 4a 46 22 39 31 35 20 2c 34
>8418	2e 32 32 20 38 37 39 22 4c 41 5a 43 40 54 56 56
>8428	22 37 38 33 20 4c 49 53 54 2d 00
.8433					Line52:
>8433	31 32 38 37 20 45 4e 44			.text '1287 ENDPROC-9.93"OF" 5.31 Z1J4 G2-5.79 4.24 LOOP ( L6F9 RND(1215 I1K4 M5 K0"FCTM"-8.1 -0.79--6.56<>411 R IF; "YJMRCOTD" 303 3.89',0
>843b	50 52 4f 43 2d 39 2e 39 33 22 4f 46 22 20 35 2e
>844b	33 31 20 5a 31 4a 34 20 47 32 2d 35 2e 37 39 20
>845b	34 2e 32 34 20 4c 4f 4f 50 20 28 20 4c 36 46 39
>846b	20 52 4e 44 28 31 32 31 35 20 49 31 4b 34 20 4d
>847b	35 20 4b 30 22 46 43 54 4d 22 2d 38 2e 31 20 2d
>848b	30 2e 37 39 2d 2d 36 2e 35 36 3c 3e 34 31 31 20
>849b	52 20 49 46 3b 20 22 59 4a 4d 52 43 4f 54 44 22
>84ab	20 33 30 33 20 33 2e 38 39 00
.84b5					Line53:
>84b5	31 33 37 31 20 42 38 4e			.text '1371 B8N1$*W4(( FOR 1023"ZPNFR"Q1F3U-1.47 "F" "UZ" G6$ASSERT 5.4"QACLZ""M"+"LZGLXW"843',0
>84bd	31 24 2a 57 34 28 28 20 46 4f 52 20 31 30 32 33
>84cd	22 5a 50 4e 46 52 22 51 31 46 33 55 2d 31 2e 34
>84dd	37 20 22 46 22 20 22 55 5a 22 20 47 36 24 41 53
>84ed	53 45 52 54 20 35 2e 34 22 51 41 43 4c 5a 22 22
>84fd	4d 22 2b 22 4c 5a 47 4c 58 57 22 38 34 33 00
.850c					Line54:
>850c	31 30 31 31 20 38 30 37			.text '1011 807',0
>8514	00
.8515					Line55:
>8515	31 34 31 39 00				.text '1419',0
.851a					Line56:
>851a	31 36 32 33 20 31 2e 34			.text '1623 1.41 1371 291= L1(1359 T1S-4.17 975"J" 1251 L0K0V* 987 579+555 1539"AFKETXTT"363 675 387 Z2H',0
>8522	31 20 31 33 37 31 20 32 39 31 3d 20 4c 31 28 31
>8532	33 35 39 20 54 31 53 2d 34 2e 31 37 20 39 37 35
>8542	22 4a 22 20 31 32 35 31 20 4c 30 4b 30 56 2a 20
>8552	39 38 37 20 35 37 39 2b 35 35 35 20 31 35 33 39
>8562	22 41 46 4b 45 54 58 54 54 22 33 36 33 20 36 37
>8572	35 20 33 38 37 20 5a 32 48 00
.857c					Line57:
>857c	31 32 32 37 20 38 2e 36			.text '1227 8.69 Z4O7H> "BRAOYG"WEND 1239 "PDP" 1455 UNTIL>8.89 783 1095 939--5.58 7.19 435-6.35 SAVE- = 1611 2.89 6.49 LET M',0
>8584	39 20 5a 34 4f 37 48 3e 20 22 42 52 41 4f 59 47
>8594	22 57 45 4e 44 20 31 32 33 39 20 22 50 44 50 22
>85a4	20 31 34 35 35 20 55 4e 54 49 4c 3e 38 2e 38 39
>85b4	20 37 38 33 20 31 30 39 35 20 39 33 39 2d 2d 35
>85c4	2e 35 38 20 37 2e 31 39 20 34 33 35 2d 36 2e 33
>85d4	35 20 53 41 56 45 2d 20 3d 20 31 36 31 31 20 32
>85e4	2e 38 39 20 36 2e 34 39 20 4c 45 54 20 4d 00
.85f3					Line58:
>85f3	37 35 39 20 20 22 40 50			.text '759  "@PPM""FIODTE"W2Q SYS-9.0 A6Z5Z6 M4 /Z4O7H-1.98 SYS >>PROC J$ 7.73 735 1.89 - -9.27 6.16/',0
>85fb	50 4d 22 22 46 49 4f 44 54 45 22 57 32 51 20 53
>860b	59 53 2d 39 2e 30 20 41 36 5a 35 5a 36 20 4d 34
>861b	20 2f 5a 34 4f 37 48 2d 31 2e 39 38 20 53 59 53
>862b	20 3e 3e 50 52 4f 43 20 4a 24 20 37 2e 37 33 20
>863b	37 33 35 20 31 2e 38 39 20 2d 20 2d 39 2e 32 37
>864b	20 36 2e 31 36 2f 00
.8652					Line59:
>8652	39 32 37 20 20 28 3d 20			.text '927  (= 903',0
>865a	39 30 33 00
.865e					Line60:
>865e	31 32 35 31 00				.text '1251',0
.8663					Line61:
>8663	31 36 35 39 20 22 4b 41			.text '1659 "KAKG"X3C3 Z4O7H 795 1059 ASC( 999 INKEY$( "Z"-9.25( DIV> C4H5D( 1695 -X8J0""STR$( ""A1T3R 8.67 X6K3L2 747 LET=D1O5C -7.7',0
>866b	4b 47 22 58 33 43 33 20 5a 34 4f 37 48 20 37 39
>867b	35 20 31 30 35 39 20 41 53 43 28 20 39 39 39 20
>868b	49 4e 4b 45 59 24 28 20 22 5a 22 2d 39 2e 32 35
>869b	28 20 44 49 56 3e 20 43 34 48 35 44 28 20 31 36
>86ab	39 35 20 2d 58 38 4a 30 22 22 53 54 52 24 28 20
>86bb	22 22 41 31 54 33 52 20 38 2e 36 37 20 58 36 4b
>86cb	33 4c 32 20 37 34 37 20 4c 45 54 3d 44 31 4f 35
>86db	43 20 2d 37 2e 37 00
.86e2					Line62:
>86e2	31 32 33 39 20 2d 37 2e			.text '1239 -7.39',0
>86ea	33 39 00
.86ed					Line63:
>86ed	31 34 39 31 20 20 31 36			.text '1491  1623- 7.52 J 4.4 CALL"O" U5O5 MOD 1023 1047 3.24-5.18(',0
>86f5	32 33 2d 20 37 2e 35 32 20 4a 20 34 2e 34 20 43
>8705	41 4c 4c 22 4f 22 20 55 35 4f 35 20 4d 4f 44 20
>8715	31 30 32 33 20 31 30 34 37 20 33 2e 32 34 2d 35
>8725	2e 31 38 28 00
.872a					Line64:
>872a	37 31 31 20 44 34 41 20			.text '711 D4A "CSGPNF" W4$ / / 2.79 (LOOP 9.53 L1( -2.63 "UVGYSM" -2.84',0
>8732	22 43 53 47 50 4e 46 22 20 57 34 24 20 2f 20 2f
>8742	20 32 2e 37 39 20 28 4c 4f 4f 50 20 39 2e 35 33
>8752	20 4c 31 28 20 2d 32 2e 36 33 20 22 55 56 47 59
>8762	53 4d 22 20 2d 32 2e 38 34 00
.876c					Line65:
>876c	31 32 37 35 20 22 44 40			.text '1275 "D@"J2A 6.26 "JXKUO"C6S5(0.12',0
>8774	22 4a 32 41 20 36 2e 32 36 20 22 4a 58 4b 55 4f
>8784	22 43 36 53 35 28 30 2e 31 32 00
.878f					Line66:
>878f	37 33 35 20 58 33 51 34			.text '735 X3Q4 0.13 7.81 D5 G3H3Q 4.26 POKE GOTO 6.02 U2U M5 R9R8 6.95 Q3F I$( 1611"SE" "V" RND(4.04 RESTORE"MEL"2.19 D9I9 ""',0
>8797	20 30 2e 31 33 20 37 2e 38 31 20 44 35 20 47 33
>87a7	48 33 51 20 34 2e 32 36 20 50 4f 4b 45 20 47 4f
>87b7	54 4f 20 36 2e 30 32 20 55 32 55 20 4d 35 20 52
>87c7	39 52 38 20 36 2e 39 35 20 51 33 46 20 49 24 28
>87d7	20 31 36 31 31 22 53 45 22 20 22 56 22 20 52 4e
>87e7	44 28 34 2e 30 34 20 52 45 53 54 4f 52 45 22 4d
>87f7	45 4c 22 32 2e 31 39 20 44 39 49 39 20 22 22 00
.8807					Line67:
>8807	36 35 31 20 20 36 33 39			.text '651  639-8.59> *"WBDXIIQ"= 327 4.18 591+ ELSE -7.66',0
>880f	2d 38 2e 35 39 3e 20 2a 22 57 42 44 58 49 49 51
>881f	22 3d 20 33 32 37 20 34 2e 31 38 20 35 39 31 2b
>882f	20 45 4c 53 45 20 2d 37 2e 36 36 00
.883b					Line68:
>883b	31 36 34 37 00				.text '1647',0
.8840					Line69:
>8840	31 35 31 35 20 20 58 4f			.text '1515  XOR 867 )< 1119"GUD"543 INKEY$(1287 D4A "IXOIAOC"P / 855) Q-3.66 *W4 9.11 C4H5D(',0
>8848	52 20 38 36 37 20 29 3c 20 31 31 31 39 22 47 55
>8858	44 22 35 34 33 20 49 4e 4b 45 59 24 28 31 32 38
>8868	37 20 44 34 41 20 22 49 58 4f 49 41 4f 43 22 50
>8878	20 2f 20 38 35 35 29 20 51 2d 33 2e 36 36 20 2a
>8888	57 34 20 39 2e 31 31 20 43 34 48 35 44 28 00
.8897					Line70:
>8897	35 37 39 20 51 31 46 33			.text '579 Q1F3U 855 L1( + "QDJBZU" AND OR 1347< 1587"NT" Q6R8C',0
>889f	55 20 38 35 35 20 4c 31 28 20 2b 20 22 51 44 4a
>88af	42 5a 55 22 20 41 4e 44 20 4f 52 20 31 33 34 37
>88bf	3c 20 31 35 38 37 22 4e 54 22 20 51 36 52 38 43
>88cf	00
.88d0					Line71:
>88d0	31 30 33 35 20 47 4f 53			.text '1035 GOSUB 1143* "" H1A1O$ 351"RRRHPY"M3 6.89+-6.24 1599 483-3.61 519 6.05 "GCHCR")J LIST* RETURN/ WHILE/--6.54 INT((',0
>88d8	55 42 20 31 31 34 33 2a 20 22 22 20 48 31 41 31
>88e8	4f 24 20 33 35 31 22 52 52 52 48 50 59 22 4d 33
>88f8	20 36 2e 38 39 2b 2d 36 2e 32 34 20 31 35 39 39
>8908	20 34 38 33 2d 33 2e 36 31 20 35 31 39 20 36 2e
>8918	30 35 20 22 47 43 48 43 52 22 29 4a 20 4c 49 53
>8928	54 2a 20 52 45 54 55 52 4e 2f 20 57 48 49 4c 45
>8938	2f 2d 2d 36 2e 35 34 20 49 4e 54 28 28 00
.8946					Line72:
>8946	31 35 33 39 20 31 30 39			.text '1539 1095 531"DDAN" "AIDIN"1071 , )',0
>894e	35 20 35 33 31 22 44 44 41 4e 22 20 22 41 49 44
>895e	49 4e 22 31 30 37 31 20 2c 20 29 00
.896a					Line73:
>896a	37 34 37 20 22 5a 40 57			.text '747 "Z@W@UF@G"4.74-"GGUK" +ENDIF M M3"MBBOCSL"/Y2K J2A/ D1O5C 1179',0
>8972	40 55 46 40 47 22 34 2e 37 34 2d 22 47 47 55 4b
>8982	22 20 2b 45 4e 44 49 46 20 4d 20 4d 33 22 4d 42
>8992	42 4f 43 53 4c 22 2f 59 32 4b 20 4a 32 41 2f 20
>89a2	44 31 4f 35 43 20 31 31 37 39 00
.89ad					Line74:
>89ad	31 36 38 33 20 20 47 34			.text '1683  G4N "HND@CJPO" 1335 "OINJ"891"CWIHRV" 927 6.79)J$Z1J4"PVHS" / UNTIL U5O5',0
>89b5	4e 20 22 48 4e 44 40 43 4a 50 4f 22 20 31 33 33
>89c5	35 20 22 4f 49 4e 4a 22 38 39 31 22 43 57 49 48
>89d5	52 56 22 20 39 32 37 20 36 2e 37 39 29 4a 24 5a
>89e5	31 4a 34 22 50 56 48 53 22 20 2f 20 55 4e 54 49
>89f5	4c 20 55 35 4f 35 00
.89fc					Line75:
>89fc	35 33 31 20 20 4c 45 4e			.text '531  LEN(SAVE',0
>8a04	28 53 41 56 45 00
.8a0a					Line76:
>8a0a	31 32 32 37 20 53 51 52			.text '1227 SQR("ODBGL"1143 0.28 7.19< DEC(-5.8 *759, =*Y3N5E DIV-7.93 267 "DTCUOZ" +1431 3.42-D7Q9$-4.62-8.22 "BMZYIF"',0
>8a12	28 22 4f 44 42 47 4c 22 31 31 34 33 20 30 2e 32
>8a22	38 20 37 2e 31 39 3c 20 44 45 43 28 2d 35 2e 38
>8a32	20 2a 37 35 39 2c 20 3d 2a 59 33 4e 35 45 20 44
>8a42	49 56 2d 37 2e 39 33 20 32 36 37 20 22 44 54 43
>8a52	55 4f 5a 22 20 2b 31 34 33 31 20 33 2e 34 32 2d
>8a62	44 37 51 39 24 2d 34 2e 36 32 2d 38 2e 32 32 20
>8a72	22 42 4d 5a 59 49 46 22 00
.8a7b					Line77:
>8a7b	31 35 33 39 20 22 45 45			.text '1539 "EEUFNRSV"1.49 4.43-5.48/"PHY" Z1J4 O6C C5$/',0
>8a83	55 46 4e 52 53 56 22 31 2e 34 39 20 34 2e 34 33
>8a93	2d 35 2e 34 38 2f 22 50 48 59 22 20 5a 31 4a 34
>8aa3	20 4f 36 43 20 43 35 24 2f 00
.8aad					Line78:
>8aad	39 38 37 00				.text '987',0
.8ab1					Line79:
>8ab1	31 31 30 37 00				.text '1107',0
.8ab6					Line80:
>8ab6	31 32 33 39 20 38 2e 31			.text '1239 8.17 1335=SQR(Q1F3U) -3.81 )-8.31"C"603 1407 303--2.36"OB"C 1407 POKE',0
>8abe	37 20 31 33 33 35 3d 53 51 52 28 51 31 46 33 55
>8ace	29 20 2d 33 2e 38 31 20 29 2d 38 2e 33 31 22 43
>8ade	22 36 30 33 20 31 34 30 37 20 33 30 33 2d 2d 32
>8aee	2e 33 36 22 4f 42 22 43 20 31 34 30 37 20 50 4f
>8afe	4b 45 00
.8b01					Line81:
>8b01	31 35 33 39 20 22 56 50			.text '1539 "VPMIT" "" V2K7(5.13"OVX"-=X3C3 REPEAT"@NZE"-1.92"YYTU"-4.47 G9G8 D4A-RIGHT$( <"UYTW""GNEMLM"L8U 8.36<=',0
>8b09	4d 49 54 22 20 22 22 20 56 32 4b 37 28 35 2e 31
>8b19	33 22 4f 56 58 22 2d 3d 58 33 43 33 20 52 45 50
>8b29	45 41 54 22 40 4e 5a 45 22 2d 31 2e 39 32 22 59
>8b39	59 54 55 22 2d 34 2e 34 37 20 47 39 47 38 20 44
>8b49	34 41 2d 52 49 47 48 54 24 28 20 3c 22 55 59 54
>8b59	57 22 22 47 4e 45 4d 4c 4d 22 4c 38 55 20 38 2e
>8b69	33 36 3c 3d 00
.8b6e					Line82:
>8b6e	31 35 35 31 20 22 54 5a			.text '1551 "TZUYTIT"2.76= 915 Y3N5E CLEAR"RWMJFL" "JJ""WYQJDKHO"-RIGHT$(-1.44 5.09 W2Q',0
>8b76	55 59 54 49 54 22 32 2e 37 36 3d 20 39 31 35 20
>8b86	59 33 4e 35 45 20 43 4c 45 41 52 22 52 57 4d 4a
>8b96	46 4c 22 20 22 4a 4a 22 22 57 59 51 4a 44 4b 48
>8ba6	4f 22 2d 52 49 47 48 54 24 28 2d 31 2e 34 34 20
>8bb6	35 2e 30 39 20 57 32 51 00
.8bbf					Line83:
>8bbf	36 31 35 20 4d 24 29 36			.text '615 M$)639 ABS( 9.51<DIM "LVBPXZ" 6.74 D$SGN(8.5',0
>8bc7	33 39 20 41 42 53 28 20 39 2e 35 31 3c 44 49 4d
>8bd7	20 22 4c 56 42 50 58 5a 22 20 36 2e 37 34 20 44
>8be7	24 53 47 4e 28 38 2e 35 00
.8bf0					Line84:
>8bf0	31 33 38 33 20 22 46 22			.text '1383 "F"U5O5 927-4.2)- "II"A6Z5Z6 4.12-6.21 LEFT$(5.86',0
>8bf8	55 35 4f 35 20 39 32 37 2d 34 2e 32 29 2d 20 22
>8c08	49 49 22 41 36 5a 35 5a 36 20 34 2e 31 32 2d 36
>8c18	2e 32 31 20 4c 45 46 54 24 28 35 2e 38 36 00
.8c27					Line85:
>8c27	31 30 31 31 20 2d 38 2e			.text '1011 -8.35-1.37-2.05 1095 1371 327 603= A6Z5Z6 W4 1479 U5O5 D9I9 0.38 P2W9M-9.72< SYS P 303 W2Q I$975-1.02 H1A1O$ I$THEN-6.12"H" 735',0
>8c2f	33 35 2d 31 2e 33 37 2d 32 2e 30 35 20 31 30 39
>8c3f	35 20 31 33 37 31 20 33 32 37 20 36 30 33 3d 20
>8c4f	41 36 5a 35 5a 36 20 57 34 20 31 34 37 39 20 55
>8c5f	35 4f 35 20 44 39 49 39 20 30 2e 33 38 20 50 32
>8c6f	57 39 4d 2d 39 2e 37 32 3c 20 53 59 53 20 50 20
>8c7f	33 30 33 20 57 32 51 20 49 24 39 37 35 2d 31 2e
>8c8f	30 32 20 48 31 41 31 4f 24 20 49 24 54 48 45 4e
>8c9f	2d 36 2e 31 32 22 48 22 20 37 33 35 00
.8cac					Line86:
>8cac	31 33 35 39 20 20 2d 32			.text '1359  -2.5"TNPLZNVL"/"EPH" "RTSOS"531 "QMWFUJVY"5.69=I1K4/ RETURN-5.75"TGMY""PZN@TE"',0
>8cb4	2e 35 22 54 4e 50 4c 5a 4e 56 4c 22 2f 22 45 50
>8cc4	48 22 20 22 52 54 53 4f 53 22 35 33 31 20 22 51
>8cd4	4d 57 46 55 4a 56 59 22 35 2e 36 39 3d 49 31 4b
>8ce4	34 2f 20 52 45 54 55 52 4e 2d 35 2e 37 35 22 54
>8cf4	47 4d 59 22 22 50 5a 4e 40 54 45 22 00
.8d01					Line87:
>8d01	34 31 31 20 43 4c 45 41			.text '411 CLEAR"NFNKCR" G6$F7U(-6.29 1.45 > 1083 1551>LEN(',0
>8d09	52 22 4e 46 4e 4b 43 52 22 20 47 36 24 46 37 55
>8d19	28 2d 36 2e 32 39 20 31 2e 34 35 20 3e 20 31 30
>8d29	38 33 20 31 35 35 31 3e 4c 45 4e 28 00
.8d36					Line88:
>8d36	33 36 33 20 28 36 2e 38			.text '363 (6.89 "BW"*9.24"DSO"5.55 6.66 REPEAT DEEK(/P3V6S("KGX" M6B$WEND"RHNS"5.87 1.62+G8G2S U4 >="MAW"',0
>8d3e	39 20 22 42 57 22 2a 39 2e 32 34 22 44 53 4f 22
>8d4e	35 2e 35 35 20 36 2e 36 36 20 52 45 50 45 41 54
>8d5e	20 44 45 45 4b 28 2f 50 33 56 36 53 28 22 4b 47
>8d6e	58 22 20 4d 36 42 24 57 45 4e 44 22 52 48 4e 53
>8d7e	22 35 2e 38 37 20 31 2e 36 32 2b 47 38 47 32 53
>8d8e	20 55 34 20 3e 3d 22 4d 41 57 22 00
.8d9a					Line89:
>8d9a	31 35 39 39 20 43 41 4c			.text '1599 CALL )"@PO"',0
>8da2	4c 20 29 22 40 50 4f 22 00
.8dab					Line90:
>8dab	31 30 34 37 20 20 22 22			.text '1047  """" -INT( -8.47 SAVE "ZXWGRE"6.19 F7T8D(NEW 675 "EP"987) -6.88"U"G4N/HEX$(',0
>8db3	22 22 20 2d 49 4e 54 28 20 2d 38 2e 34 37 20 53
>8dc3	41 56 45 20 22 5a 58 57 47 52 45 22 36 2e 31 39
>8dd3	20 46 37 54 38 44 28 4e 45 57 20 36 37 35 20 22
>8de3	45 50 22 39 38 37 29 20 2d 36 2e 38 38 22 55 22
>8df3	47 34 4e 2f 48 45 58 24 28 00
.8dfd					Line91:
>8dfd	38 31 39 20 2d 37 2e 34			.text '819 -7.42"" 1.41"CQPSROS"-1.02 "JSBDV"1539 UNTIL DIM"NUUJ" 0.76 U2U"""WIMG" G6$TO"QUV" )"AUTMTIS"*1.15 567 711 "BXBFLO" -8.67 1407"ZTMVBR"',0
>8e05	32 22 22 20 31 2e 34 31 22 43 51 50 53 52 4f 53
>8e15	22 2d 31 2e 30 32 20 22 4a 53 42 44 56 22 31 35
>8e25	33 39 20 55 4e 54 49 4c 20 44 49 4d 22 4e 55 55
>8e35	4a 22 20 30 2e 37 36 20 55 32 55 22 22 22 57 49
>8e45	4d 47 22 20 47 36 24 54 4f 22 51 55 56 22 20 29
>8e55	22 41 55 54 4d 54 49 53 22 2a 31 2e 31 35 20 35
>8e65	36 37 20 37 31 31 20 22 42 58 42 46 4c 4f 22 20
>8e75	2d 38 2e 36 37 20 31 34 30 37 22 5a 54 4d 56 42
>8e85	52 22 00
.8e88					Line92:
>8e88	33 37 35 20 22 59 58 47			.text '375 "YXG@QZET" "@JFNF" < )/"YDZUN"X3Q4 9.32 951',0
>8e90	40 51 5a 45 54 22 20 22 40 4a 46 4e 46 22 20 3c
>8ea0	20 29 2f 22 59 44 5a 55 4e 22 58 33 51 34 20 39
>8eb0	2e 33 32 20 39 35 31 00
.8eb8					Line93:
>8eb8	36 37 35 00				.text '675',0
.8ebc					Line94:
>8ebc	33 35 31 20 20 46 37 54			.text '351  F7T8D(-7.47-7.04 NEW LIST B4N0Y(/315"LHKZIID""GL@JT"-5.89 Y3N5E"OPFV" 1383 915 = "Y"I$- 891 WHILE 1371 C5$5.19 D$',0
>8ec4	38 44 28 2d 37 2e 34 37 2d 37 2e 30 34 20 4e 45
>8ed4	57 20 4c 49 53 54 20 42 34 4e 30 59 28 2f 33 31
>8ee4	35 22 4c 48 4b 5a 49 49 44 22 22 47 4c 40 4a 54
>8ef4	22 2d 35 2e 38 39 20 59 33 4e 35 45 22 4f 50 46
>8f04	56 22 20 31 33 38 33 20 39 31 35 20 3d 20 22 59
>8f14	22 49 24 2d 20 38 39 31 20 57 48 49 4c 45 20 31
>8f24	33 37 31 20 43 35 24 35 2e 31 39 20 44 24 00
.8f33					Line95:
>8f33	33 32 37 20 31 30 2e 30			.text '327 10.0(C4H5D(<+LEN("" 699 711 1551 3.65 6.28 375 -6.27-2.06 1107 1275"KMXSLYMW"= C 9.61 EVENT(5.93<- 6.72 A2 903 "@KVXY"HEX$(',0
>8f3b	28 43 34 48 35 44 28 3c 2b 4c 45 4e 28 22 22 20
>8f4b	36 39 39 20 37 31 31 20 31 35 35 31 20 33 2e 36
>8f5b	35 20 36 2e 32 38 20 33 37 35 20 2d 36 2e 32 37
>8f6b	2d 32 2e 30 36 20 31 31 30 37 20 31 32 37 35 22
>8f7b	4b 4d 58 53 4c 59 4d 57 22 3d 20 43 20 39 2e 36
>8f8b	31 20 45 56 45 4e 54 28 35 2e 39 33 3c 2d 20 36
>8f9b	2e 37 32 20 41 32 20 39 30 33 20 22 40 4b 56 58
>8fab	59 22 48 45 58 24 28 00
.8fb3					Line96:
>8fb3	35 36 37 20 20 22 53 53			.text '567  "SS" 0.3 <REPEAT/',0
>8fbb	22 20 30 2e 33 20 3c 52 45 50 45 41 54 2f 00
.8fca					Line97:
>8fca	33 37 35 20 2a 20 3c 20			.text '375 * < 7.05 531 "IAJ"J6 OR=495"DGBRITB""JO"303 Z6W0E2 NEW Z6X0$READ *DIM G8G5G6$ "YPGPJYP""VAW" >"YVWB" "WIAAATHQ" P 591 -',0
>8fd2	37 2e 30 35 20 35 33 31 20 22 49 41 4a 22 4a 36
>8fe2	20 4f 52 3d 34 39 35 22 44 47 42 52 49 54 42 22
>8ff2	22 4a 4f 22 33 30 33 20 5a 36 57 30 45 32 20 4e
>9002	45 57 20 5a 36 58 30 24 52 45 41 44 20 2a 44 49
>9012	4d 20 47 38 47 35 47 36 24 20 22 59 50 47 50 4a
>9022	59 50 22 22 56 41 57 22 20 3e 22 59 56 57 42 22
>9032	20 22 57 49 41 41 41 54 48 51 22 20 50 20 35 39
>9042	31 20 2d 00
.9046					Line98:
>9046	31 30 37 31 20 35 2e 33			.text '1071 5.32+"@LRJYV"WHILE GOSUB> 543 771 771',0
>904e	32 2b 22 40 4c 52 4a 59 56 22 57 48 49 4c 45 20
>905e	47 4f 53 55 42 3e 20 35 34 33 20 37 37 31 20 37
>906e	37 31 00
.9071					Line99:
>9071	33 32 37 20 3e 20 4c 49			.text '327 > LIST G2 8.89""1.89"" READ-5.01 R0 8.08"JAO" -SQR( ,-0.48 D7Q9$',0
>9079	53 54 20 47 32 20 38 2e 38 39 22 22 31 2e 38 39
>9089	22 22 20 52 45 41 44 2d 35 2e 30 31 20 52 30 20
>9099	38 2e 30 38 22 4a 41 4f 22 20 2d 53 51 52 28 20
>90a9	2c 2d 30 2e 34 38 20 44 37 51 39 24 00
.90b6					Line100:
>90b6	36 39 39 20 35 33 31 20			.text '699 531 1323',0
>90be	31 33 32 33 00
.90c3					Line101:
>90c3	32 36 37 20 43 48 52 24			.text '267 CHR$( "FL""BACIWI"-8.27-<= "TWSJP@X"',0
>90cb	28 20 22 46 4c 22 22 42 41 43 49 57 49 22 2d 38
>90db	2e 32 37 2d 3c 3d 20 22 54 57 53 4a 50 40 58 22
>90eb	00
.90ec					Line102:
>90ec	35 36 37 00				.text '567',0
.90f0					Line103:
>90f0	31 31 39 31 20 4d 35 20			.text '1191 M5 GOTO "" REPEAT 1107> 735+EXIT(<="G"/387 INKEY$(0.74 783"EFLIMOK"0.73=ABS((H1G 8.78 GOSUB VAL(639-2.8',0
>90f8	47 4f 54 4f 20 22 22 20 52 45 50 45 41 54 20 31
>9108	31 30 37 3e 20 37 33 35 2b 45 58 49 54 28 3c 3d
>9118	22 47 22 2f 33 38 37 20 49 4e 4b 45 59 24 28 30
>9128	2e 37 34 20 37 38 33 22 45 46 4c 49 4d 4f 4b 22
>9138	30 2e 37 33 3d 41 42 53 28 28 48 31 47 20 38 2e
>9148	37 38 20 47 4f 53 55 42 20 56 41 4c 28 36 33 39
>9158	2d 32 2e 38 00
.915d					Line104:
>915d	31 32 39 39 20 41 53 43			.text '1299 ASC(879 C5$5.38 831(EXIT <- )TIME 723"OL"X3W(1659 = >>X3Q4 4.63 M5* >Q3F 879',0
>9165	28 38 37 39 20 43 35 24 35 2e 33 38 20 38 33 31
>9175	28 45 58 49 54 20 3c 2d 20 29 54 49 4d 45 20 37
>9185	32 33 22 4f 4c 22 58 33 57 28 31 36 35 39 20 3d
>9195	20 3e 3e 58 33 51 34 20 34 2e 36 33 20 4d 35 2a
>91a5	20 3e 51 33 46 20 38 37 39 00
.91af					Line105:
>91af	38 35 35 20 2d 20 31 33			.text '855 - 1347 267 "Q@" "F@VDTNF" "@PZNT" 1407 1047 1227 G9G8 RND(T6D9C Q1F3U -4.67"UH"615+ UNTIL -9.49 7.47 2.42 CHR$()Z6X0$',0
>91b7	34 37 20 32 36 37 20 22 51 40 22 20 22 46 40 56
>91c7	44 54 4e 46 22 20 22 40 50 5a 4e 54 22 20 31 34
>91d7	30 37 20 31 30 34 37 20 31 32 32 37 20 47 39 47
>91e7	38 20 52 4e 44 28 54 36 44 39 43 20 51 31 46 33
>91f7	55 20 2d 34 2e 36 37 22 55 48 22 36 31 35 2b 20
>9207	55 4e 54 49 4c 20 2d 39 2e 34 39 20 37 2e 34 37
>9217	20 32 2e 34 32 20 43 48 52 24 28 29 5a 36 58 30
>9227	24 00
.9229					Line106:
>9229	31 30 32 33 20 20 31 30			.text '1023  1071 1527 R2',0
>9231	37 31 20 31 35 32 37 20 52 32 00
.923c					Line107:
>923c	34 37 31 20 4d 49 44 24			.text '471 MID$(1035 1.0 975 615 ENDIF"UKBU@M" "EX@WQ"855 > 303 9.81 Z6X0$<>A6Z5Z6 1407> M6J / >L1( X8J0( "KC" -6.77 "FTDZ" 483',0
>9244	28 31 30 33 35 20 31 2e 30 20 39 37 35 20 36 31
>9254	35 20 45 4e 44 49 46 22 55 4b 42 55 40 4d 22 20
>9264	22 45 58 40 57 51 22 38 35 35 20 3e 20 33 30 33
>9274	20 39 2e 38 31 20 5a 36 58 30 24 3c 3e 41 36 5a
>9284	35 5a 36 20 31 34 30 37 3e 20 4d 36 4a 20 2f 20
>9294	3e 4c 31 28 20 58 38 4a 30 28 20 22 4b 43 22 20
>92a4	2d 36 2e 37 37 20 22 46 54 44 5a 22 20 34 38 33
>92b4	00
.92b5					Line108:
>92b5	35 33 31 20 20 22 50 4e			.text '531  "PNTGRWGY""@QMSBKAB""K"*-7.72 2.02/ < "WTJF" 963<>U2U I7E0>N6F6L2 4.37<)N( DIV 1203 L0K0V-7.63) "EZ"EXIT K3C"YCECKKIS" "C">',0
>92bd	54 47 52 57 47 59 22 22 40 51 4d 53 42 4b 41 42
>92cd	22 22 4b 22 2a 2d 37 2e 37 32 20 32 2e 30 32 2f
>92dd	20 3c 20 22 57 54 4a 46 22 20 39 36 33 3c 3e 55
>92ed	32 55 20 49 37 45 30 3e 4e 36 46 36 4c 32 20 34
>92fd	2e 33 37 3c 29 4e 28 20 44 49 56 20 31 32 30 33
>930d	20 4c 30 4b 30 56 2d 37 2e 36 33 29 20 22 45 5a
>931d	22 45 58 49 54 20 4b 33 43 22 59 43 45 43 4b 4b
>932d	49 53 22 20 22 43 22 3e 00
.9336					Line109:
>9336	39 33 39 20 22 50 59 22			.text '939 "PY""BGT@S""UPFGKA"D1O5C "BF" NEXT( 4.34 LET DEEK(/G8G5G6$/) 8.47> 411 2.02 1635 1575< DO 675 * "N"',0
>933e	22 42 47 54 40 53 22 22 55 50 46 47 4b 41 22 44
>934e	31 4f 35 43 20 22 42 46 22 20 4e 45 58 54 28 20
>935e	34 2e 33 34 20 4c 45 54 20 44 45 45 4b 28 2f 47
>936e	38 47 35 47 36 24 2f 29 20 38 2e 34 37 3e 20 34
>937e	31 31 20 32 2e 30 32 20 31 36 33 35 20 31 35 37
>938e	35 3c 20 44 4f 20 36 37 35 20 2a 20 22 4e 22 00
.939e					Line110:
>939e	35 35 35 20 39 37 35 20			.text '555 975 O6C 903 Z4O7H/<"@YS"603 - G9G8"QA" "JSQKU"1.43 1671"YQKYB@""TC"D5 987 879 "FAX"1119 Q1K1N P7B7S3',0
>93a6	4f 36 43 20 39 30 33 20 5a 34 4f 37 48 2f 3c 22
>93b6	40 59 53 22 36 30 33 20 2d 20 47 39 47 38 22 51
>93c6	41 22 20 22 4a 53 51 4b 55 22 31 2e 34 33 20 31
>93d6	36 37 31 22 59 51 4b 59 42 40 22 22 54 43 22 44
>93e6	35 20 39 38 37 20 38 37 39 20 22 46 41 58 22 31
>93f6	31 31 39 20 51 31 4b 31 4e 20 50 37 42 37 53 33
>9406	00
.9407					Line111:
>9407	31 36 35 39 20 22 22 52			.text '1659 ""RAND(3.32 IF RND(831 O9L STR$(-8.37 >> "GECHOJT" -5.99 1539 8.6"IDUSBBXV"699 -3.23 735-3.67) M9A5F>>',0
>940f	41 4e 44 28 33 2e 33 32 20 49 46 20 52 4e 44 28
>941f	38 33 31 20 4f 39 4c 20 53 54 52 24 28 2d 38 2e
>942f	33 37 20 3e 3e 20 22 47 45 43 48 4f 4a 54 22 20
>943f	2d 35 2e 39 39 20 31 35 33 39 20 38 2e 36 22 49
>944f	44 55 53 42 42 58 56 22 36 39 39 20 2d 33 2e 32
>945f	33 20 37 33 35 2d 33 2e 36 37 29 20 4d 39 41 35
>946f	46 3e 3e 00
.9473					Line112:
>9473	38 34 33 20 3d 20 2b 22			.text '843 = +"BYHV"+1.75 1527-4.14 -1.86 RND(-3.51 F7T8D( 1179 V2K7( -6.87',0
>947b	42 59 48 56 22 2b 31 2e 37 35 20 31 35 32 37 2d
>948b	34 2e 31 34 20 2d 31 2e 38 36 20 52 4e 44 28 2d
>949b	33 2e 35 31 20 46 37 54 38 44 28 20 31 31 37 39
>94ab	20 56 32 4b 37 28 20 2d 36 2e 38 37 00
.94b8					Line113:
>94b8	31 30 39 35 20 2b 53 47			.text '1095 +SGN(-9.47-7.96 699 C4H5D("ZUM" < 819 <>)',0
>94c0	4e 28 2d 39 2e 34 37 2d 37 2e 39 36 20 36 39 39
>94d0	20 43 34 48 35 44 28 22 5a 55 4d 22 20 3c 20 38
>94e0	31 39 20 3c 3e 29 00
.94e7					Line114:
>94e7	34 35 39 20 20 22 59 53			.text '459  "YSQ" INPUT /9.16 INPUT* 1251 END / "ZND"/<NEXT"HZLEKJ" >INPUT<375"UM""YKV"699 O9L(H1G"" -"JCPKTFQ"FRAC(',0
>94ef	51 22 20 49 4e 50 55 54 20 2f 39 2e 31 36 20 49
>94ff	4e 50 55 54 2a 20 31 32 35 31 20 45 4e 44 20 2f
>950f	20 22 5a 4e 44 22 2f 3c 4e 45 58 54 22 48 5a 4c
>951f	45 4b 4a 22 20 3e 49 4e 50 55 54 3c 33 37 35 22
>952f	55 4d 22 22 59 4b 56 22 36 39 39 20 4f 39 4c 28
>953f	48 31 47 22 22 20 2d 22 4a 43 50 4b 54 46 51 22
>954f	46 52 41 43 28 00
.9555					Line115:
>9555	34 38 33 20 20 3e 3e 20			.text '483  >> +G3H3Q T-8.04 T W5A$',0
>955d	2b 47 33 48 33 51 20 54 2d 38 2e 30 34 20 54 20
>956d	57 35 41 24 00
.9572					Line116:
>9572	34 32 33 20 20 43 48 52			.text '423  CHR$(""795"@RKKG""LEV"IF',0
>957a	24 28 22 22 37 39 35 22 40 52 4b 4b 47 22 22 4c
>958a	45 56 22 49 46 00
.9590					Line117:
>9590	39 31 35 20 20 50 32 57			.text '915  P2W9M 1071"UFF@"""-6.63 1023 3.11 5.82 =( (:G2 G8G2S "AMVLSO"',0
>9598	39 4d 20 31 30 37 31 22 55 46 46 40 22 22 22 2d
>95a8	36 2e 36 33 20 31 30 32 33 20 33 2e 31 31 20 35
>95b8	2e 38 32 20 3d 28 20 28 3a 47 32 20 47 38 47 32
>95c8	53 20 22 41 4d 56 4c 53 4f 22 00
.95d3					Line118:
>95d3	31 31 34 33 20 45 4e 44			.text '1143 END"B@KXUO""ZRZSR"+R8H1T ""+ OR "UXDO"8.69=RUN)',0
>95db	22 42 40 4b 58 55 4f 22 22 5a 52 5a 53 52 22 2b
>95eb	52 38 48 31 54 20 22 22 2b 20 4f 52 20 22 55 58
>95fb	44 4f 22 38 2e 36 39 3d 52 55 4e 29 00
.9608					Line119:
>9608	33 37 35 20 20 22 55 44			.text '375  "UDV"1635-4.28/',0
>9610	56 22 31 36 33 35 2d 34 2e 32 38 2f 00

;******  Return to file: src/program/testing/testing.asmx

.961d					TestCode:
.961d	20 49 1f	jsr $1f49			jsr 	PGMNewProgram
.9620	9c ff ff	stz $ffff			stz 	$FFFF

;******  Processing file: src/program/testing/testrun.incx

.9623	a2 00		ldx #$00		ldx #Line0 & $FF
.9625	a0 78		ldy #$78		ldy #Line0 >> 8
.9627	20 6e 99	jsr $996e		jsr TOKOneLine
.962a	a2 70		ldx #$70		ldx #Line1 & $FF
.962c	a0 78		ldy #$78		ldy #Line1 >> 8
.962e	20 6e 99	jsr $996e		jsr TOKOneLine
.9631	a2 74		ldx #$74		ldx #Line2 & $FF
.9633	a0 78		ldy #$78		ldy #Line2 >> 8
.9635	20 6e 99	jsr $996e		jsr TOKOneLine
.9638	a2 d4		ldx #$d4		ldx #Line3 & $FF
.963a	a0 78		ldy #$78		ldy #Line3 >> 8
.963c	20 6e 99	jsr $996e		jsr TOKOneLine
.963f	a2 11		ldx #$11		ldx #Line4 & $FF
.9641	a0 79		ldy #$79		ldy #Line4 >> 8
.9643	20 6e 99	jsr $996e		jsr TOKOneLine
.9646	a2 48		ldx #$48		ldx #Line5 & $FF
.9648	a0 79		ldy #$79		ldy #Line5 >> 8
.964a	20 6e 99	jsr $996e		jsr TOKOneLine
.964d	a2 51		ldx #$51		ldx #Line6 & $FF
.964f	a0 79		ldy #$79		ldy #Line6 >> 8
.9651	20 6e 99	jsr $996e		jsr TOKOneLine
.9654	a2 90		ldx #$90		ldx #Line7 & $FF
.9656	a0 79		ldy #$79		ldy #Line7 >> 8
.9658	20 6e 99	jsr $996e		jsr TOKOneLine
.965b	a2 b2		ldx #$b2		ldx #Line8 & $FF
.965d	a0 79		ldy #$79		ldy #Line8 >> 8
.965f	20 6e 99	jsr $996e		jsr TOKOneLine
.9662	a2 cf		ldx #$cf		ldx #Line9 & $FF
.9664	a0 79		ldy #$79		ldy #Line9 >> 8
.9666	20 6e 99	jsr $996e		jsr TOKOneLine
.9669	a2 df		ldx #$df		ldx #Line10 & $FF
.966b	a0 79		ldy #$79		ldy #Line10 >> 8
.966d	20 6e 99	jsr $996e		jsr TOKOneLine
.9670	a2 24		ldx #$24		ldx #Line11 & $FF
.9672	a0 7a		ldy #$7a		ldy #Line11 >> 8
.9674	20 6e 99	jsr $996e		jsr TOKOneLine
.9677	a2 46		ldx #$46		ldx #Line12 & $FF
.9679	a0 7a		ldy #$7a		ldy #Line12 >> 8
.967b	20 6e 99	jsr $996e		jsr TOKOneLine
.967e	a2 b0		ldx #$b0		ldx #Line13 & $FF
.9680	a0 7a		ldy #$7a		ldy #Line13 >> 8
.9682	20 6e 99	jsr $996e		jsr TOKOneLine
.9685	a2 b5		ldx #$b5		ldx #Line14 & $FF
.9687	a0 7a		ldy #$7a		ldy #Line14 >> 8
.9689	20 6e 99	jsr $996e		jsr TOKOneLine
.968c	a2 cf		ldx #$cf		ldx #Line15 & $FF
.968e	a0 7a		ldy #$7a		ldy #Line15 >> 8
.9690	20 6e 99	jsr $996e		jsr TOKOneLine
.9693	a2 01		ldx #$01		ldx #Line16 & $FF
.9695	a0 7b		ldy #$7b		ldy #Line16 >> 8
.9697	20 6e 99	jsr $996e		jsr TOKOneLine
.969a	a2 7b		ldx #$7b		ldx #Line17 & $FF
.969c	a0 7b		ldy #$7b		ldy #Line17 >> 8
.969e	20 6e 99	jsr $996e		jsr TOKOneLine
.96a1	a2 94		ldx #$94		ldx #Line18 & $FF
.96a3	a0 7b		ldy #$7b		ldy #Line18 >> 8
.96a5	20 6e 99	jsr $996e		jsr TOKOneLine
.96a8	a2 bd		ldx #$bd		ldx #Line19 & $FF
.96aa	a0 7b		ldy #$7b		ldy #Line19 >> 8
.96ac	20 6e 99	jsr $996e		jsr TOKOneLine
.96af	a2 fa		ldx #$fa		ldx #Line20 & $FF
.96b1	a0 7b		ldy #$7b		ldy #Line20 >> 8
.96b3	20 6e 99	jsr $996e		jsr TOKOneLine
.96b6	a2 36		ldx #$36		ldx #Line21 & $FF
.96b8	a0 7c		ldy #$7c		ldy #Line21 >> 8
.96ba	20 6e 99	jsr $996e		jsr TOKOneLine
.96bd	a2 7e		ldx #$7e		ldx #Line22 & $FF
.96bf	a0 7c		ldy #$7c		ldy #Line22 >> 8
.96c1	20 6e 99	jsr $996e		jsr TOKOneLine
.96c4	a2 ce		ldx #$ce		ldx #Line23 & $FF
.96c6	a0 7c		ldy #$7c		ldy #Line23 >> 8
.96c8	20 6e 99	jsr $996e		jsr TOKOneLine
.96cb	a2 24		ldx #$24		ldx #Line24 & $FF
.96cd	a0 7d		ldy #$7d		ldy #Line24 >> 8
.96cf	20 6e 99	jsr $996e		jsr TOKOneLine
.96d2	a2 5d		ldx #$5d		ldx #Line25 & $FF
.96d4	a0 7d		ldy #$7d		ldy #Line25 >> 8
.96d6	20 6e 99	jsr $996e		jsr TOKOneLine
.96d9	a2 b3		ldx #$b3		ldx #Line26 & $FF
.96db	a0 7d		ldy #$7d		ldy #Line26 >> 8
.96dd	20 6e 99	jsr $996e		jsr TOKOneLine
.96e0	a2 d4		ldx #$d4		ldx #Line27 & $FF
.96e2	a0 7d		ldy #$7d		ldy #Line27 >> 8
.96e4	20 6e 99	jsr $996e		jsr TOKOneLine
.96e7	a2 e6		ldx #$e6		ldx #Line28 & $FF
.96e9	a0 7d		ldy #$7d		ldy #Line28 >> 8
.96eb	20 6e 99	jsr $996e		jsr TOKOneLine
.96ee	a2 35		ldx #$35		ldx #Line29 & $FF
.96f0	a0 7e		ldy #$7e		ldy #Line29 >> 8
.96f2	20 6e 99	jsr $996e		jsr TOKOneLine
.96f5	a2 be		ldx #$be		ldx #Line30 & $FF
.96f7	a0 7e		ldy #$7e		ldy #Line30 >> 8
.96f9	20 6e 99	jsr $996e		jsr TOKOneLine
.96fc	a2 43		ldx #$43		ldx #Line31 & $FF
.96fe	a0 7f		ldy #$7f		ldy #Line31 >> 8
.9700	20 6e 99	jsr $996e		jsr TOKOneLine
.9703	a2 62		ldx #$62		ldx #Line32 & $FF
.9705	a0 7f		ldy #$7f		ldy #Line32 >> 8
.9707	20 6e 99	jsr $996e		jsr TOKOneLine
.970a	a2 7a		ldx #$7a		ldx #Line33 & $FF
.970c	a0 7f		ldy #$7f		ldy #Line33 >> 8
.970e	20 6e 99	jsr $996e		jsr TOKOneLine
.9711	a2 9e		ldx #$9e		ldx #Line34 & $FF
.9713	a0 7f		ldy #$7f		ldy #Line34 >> 8
.9715	20 6e 99	jsr $996e		jsr TOKOneLine
.9718	a2 de		ldx #$de		ldx #Line35 & $FF
.971a	a0 7f		ldy #$7f		ldy #Line35 >> 8
.971c	20 6e 99	jsr $996e		jsr TOKOneLine
.971f	a2 2e		ldx #$2e		ldx #Line36 & $FF
.9721	a0 80		ldy #$80		ldy #Line36 >> 8
.9723	20 6e 99	jsr $996e		jsr TOKOneLine
.9726	a2 a9		ldx #$a9		ldx #Line37 & $FF
.9728	a0 80		ldy #$80		ldy #Line37 >> 8
.972a	20 6e 99	jsr $996e		jsr TOKOneLine
.972d	a2 38		ldx #$38		ldx #Line38 & $FF
.972f	a0 81		ldy #$81		ldy #Line38 >> 8
.9731	20 6e 99	jsr $996e		jsr TOKOneLine
.9734	a2 6d		ldx #$6d		ldx #Line39 & $FF
.9736	a0 81		ldy #$81		ldy #Line39 >> 8
.9738	20 6e 99	jsr $996e		jsr TOKOneLine
.973b	a2 aa		ldx #$aa		ldx #Line40 & $FF
.973d	a0 81		ldy #$81		ldy #Line40 >> 8
.973f	20 6e 99	jsr $996e		jsr TOKOneLine
.9742	a2 e5		ldx #$e5		ldx #Line41 & $FF
.9744	a0 81		ldy #$81		ldy #Line41 >> 8
.9746	20 6e 99	jsr $996e		jsr TOKOneLine
.9749	a2 e9		ldx #$e9		ldx #Line42 & $FF
.974b	a0 81		ldy #$81		ldy #Line42 >> 8
.974d	20 6e 99	jsr $996e		jsr TOKOneLine
.9750	a2 61		ldx #$61		ldx #Line43 & $FF
.9752	a0 82		ldy #$82		ldy #Line43 >> 8
.9754	20 6e 99	jsr $996e		jsr TOKOneLine
.9757	a2 9b		ldx #$9b		ldx #Line44 & $FF
.9759	a0 82		ldy #$82		ldy #Line44 >> 8
.975b	20 6e 99	jsr $996e		jsr TOKOneLine
.975e	a2 d7		ldx #$d7		ldx #Line45 & $FF
.9760	a0 82		ldy #$82		ldy #Line45 >> 8
.9762	20 6e 99	jsr $996e		jsr TOKOneLine
.9765	a2 37		ldx #$37		ldx #Line46 & $FF
.9767	a0 83		ldy #$83		ldy #Line46 >> 8
.9769	20 6e 99	jsr $996e		jsr TOKOneLine
.976c	a2 48		ldx #$48		ldx #Line47 & $FF
.976e	a0 83		ldy #$83		ldy #Line47 >> 8
.9770	20 6e 99	jsr $996e		jsr TOKOneLine
.9773	a2 8d		ldx #$8d		ldx #Line48 & $FF
.9775	a0 83		ldy #$83		ldy #Line48 >> 8
.9777	20 6e 99	jsr $996e		jsr TOKOneLine
.977a	a2 91		ldx #$91		ldx #Line49 & $FF
.977c	a0 83		ldy #$83		ldy #Line49 >> 8
.977e	20 6e 99	jsr $996e		jsr TOKOneLine
.9781	a2 c1		ldx #$c1		ldx #Line50 & $FF
.9783	a0 83		ldy #$83		ldy #Line50 >> 8
.9785	20 6e 99	jsr $996e		jsr TOKOneLine
.9788	a2 d0		ldx #$d0		ldx #Line51 & $FF
.978a	a0 83		ldy #$83		ldy #Line51 >> 8
.978c	20 6e 99	jsr $996e		jsr TOKOneLine
.978f	a2 33		ldx #$33		ldx #Line52 & $FF
.9791	a0 84		ldy #$84		ldy #Line52 >> 8
.9793	20 6e 99	jsr $996e		jsr TOKOneLine
.9796	a2 b5		ldx #$b5		ldx #Line53 & $FF
.9798	a0 84		ldy #$84		ldy #Line53 >> 8
.979a	20 6e 99	jsr $996e		jsr TOKOneLine
.979d	a2 0c		ldx #$0c		ldx #Line54 & $FF
.979f	a0 85		ldy #$85		ldy #Line54 >> 8
.97a1	20 6e 99	jsr $996e		jsr TOKOneLine
.97a4	a2 15		ldx #$15		ldx #Line55 & $FF
.97a6	a0 85		ldy #$85		ldy #Line55 >> 8
.97a8	20 6e 99	jsr $996e		jsr TOKOneLine
.97ab	a2 1a		ldx #$1a		ldx #Line56 & $FF
.97ad	a0 85		ldy #$85		ldy #Line56 >> 8
.97af	20 6e 99	jsr $996e		jsr TOKOneLine
.97b2	a2 7c		ldx #$7c		ldx #Line57 & $FF
.97b4	a0 85		ldy #$85		ldy #Line57 >> 8
.97b6	20 6e 99	jsr $996e		jsr TOKOneLine
.97b9	a2 f3		ldx #$f3		ldx #Line58 & $FF
.97bb	a0 85		ldy #$85		ldy #Line58 >> 8
.97bd	20 6e 99	jsr $996e		jsr TOKOneLine
.97c0	a2 52		ldx #$52		ldx #Line59 & $FF
.97c2	a0 86		ldy #$86		ldy #Line59 >> 8
.97c4	20 6e 99	jsr $996e		jsr TOKOneLine
.97c7	a2 5e		ldx #$5e		ldx #Line60 & $FF
.97c9	a0 86		ldy #$86		ldy #Line60 >> 8
.97cb	20 6e 99	jsr $996e		jsr TOKOneLine
.97ce	a2 63		ldx #$63		ldx #Line61 & $FF
.97d0	a0 86		ldy #$86		ldy #Line61 >> 8
.97d2	20 6e 99	jsr $996e		jsr TOKOneLine
.97d5	a2 e2		ldx #$e2		ldx #Line62 & $FF
.97d7	a0 86		ldy #$86		ldy #Line62 >> 8
.97d9	20 6e 99	jsr $996e		jsr TOKOneLine
.97dc	a2 ed		ldx #$ed		ldx #Line63 & $FF
.97de	a0 86		ldy #$86		ldy #Line63 >> 8
.97e0	20 6e 99	jsr $996e		jsr TOKOneLine
.97e3	a2 2a		ldx #$2a		ldx #Line64 & $FF
.97e5	a0 87		ldy #$87		ldy #Line64 >> 8
.97e7	20 6e 99	jsr $996e		jsr TOKOneLine
.97ea	a2 6c		ldx #$6c		ldx #Line65 & $FF
.97ec	a0 87		ldy #$87		ldy #Line65 >> 8
.97ee	20 6e 99	jsr $996e		jsr TOKOneLine
.97f1	a2 8f		ldx #$8f		ldx #Line66 & $FF
.97f3	a0 87		ldy #$87		ldy #Line66 >> 8
.97f5	20 6e 99	jsr $996e		jsr TOKOneLine
.97f8	a2 07		ldx #$07		ldx #Line67 & $FF
.97fa	a0 88		ldy #$88		ldy #Line67 >> 8
.97fc	20 6e 99	jsr $996e		jsr TOKOneLine
.97ff	a2 3b		ldx #$3b		ldx #Line68 & $FF
.9801	a0 88		ldy #$88		ldy #Line68 >> 8
.9803	20 6e 99	jsr $996e		jsr TOKOneLine
.9806	a2 40		ldx #$40		ldx #Line69 & $FF
.9808	a0 88		ldy #$88		ldy #Line69 >> 8
.980a	20 6e 99	jsr $996e		jsr TOKOneLine
.980d	a2 97		ldx #$97		ldx #Line70 & $FF
.980f	a0 88		ldy #$88		ldy #Line70 >> 8
.9811	20 6e 99	jsr $996e		jsr TOKOneLine
.9814	a2 d0		ldx #$d0		ldx #Line71 & $FF
.9816	a0 88		ldy #$88		ldy #Line71 >> 8
.9818	20 6e 99	jsr $996e		jsr TOKOneLine
.981b	a2 46		ldx #$46		ldx #Line72 & $FF
.981d	a0 89		ldy #$89		ldy #Line72 >> 8
.981f	20 6e 99	jsr $996e		jsr TOKOneLine
.9822	a2 6a		ldx #$6a		ldx #Line73 & $FF
.9824	a0 89		ldy #$89		ldy #Line73 >> 8
.9826	20 6e 99	jsr $996e		jsr TOKOneLine
.9829	a2 ad		ldx #$ad		ldx #Line74 & $FF
.982b	a0 89		ldy #$89		ldy #Line74 >> 8
.982d	20 6e 99	jsr $996e		jsr TOKOneLine
.9830	a2 fc		ldx #$fc		ldx #Line75 & $FF
.9832	a0 89		ldy #$89		ldy #Line75 >> 8
.9834	20 6e 99	jsr $996e		jsr TOKOneLine
.9837	a2 0a		ldx #$0a		ldx #Line76 & $FF
.9839	a0 8a		ldy #$8a		ldy #Line76 >> 8
.983b	20 6e 99	jsr $996e		jsr TOKOneLine
.983e	a2 7b		ldx #$7b		ldx #Line77 & $FF
.9840	a0 8a		ldy #$8a		ldy #Line77 >> 8
.9842	20 6e 99	jsr $996e		jsr TOKOneLine
.9845	a2 ad		ldx #$ad		ldx #Line78 & $FF
.9847	a0 8a		ldy #$8a		ldy #Line78 >> 8
.9849	20 6e 99	jsr $996e		jsr TOKOneLine
.984c	a2 b1		ldx #$b1		ldx #Line79 & $FF
.984e	a0 8a		ldy #$8a		ldy #Line79 >> 8
.9850	20 6e 99	jsr $996e		jsr TOKOneLine
.9853	a2 b6		ldx #$b6		ldx #Line80 & $FF
.9855	a0 8a		ldy #$8a		ldy #Line80 >> 8
.9857	20 6e 99	jsr $996e		jsr TOKOneLine
.985a	a2 01		ldx #$01		ldx #Line81 & $FF
.985c	a0 8b		ldy #$8b		ldy #Line81 >> 8
.985e	20 6e 99	jsr $996e		jsr TOKOneLine
.9861	a2 6e		ldx #$6e		ldx #Line82 & $FF
.9863	a0 8b		ldy #$8b		ldy #Line82 >> 8
.9865	20 6e 99	jsr $996e		jsr TOKOneLine
.9868	a2 bf		ldx #$bf		ldx #Line83 & $FF
.986a	a0 8b		ldy #$8b		ldy #Line83 >> 8
.986c	20 6e 99	jsr $996e		jsr TOKOneLine
.986f	a2 f0		ldx #$f0		ldx #Line84 & $FF
.9871	a0 8b		ldy #$8b		ldy #Line84 >> 8
.9873	20 6e 99	jsr $996e		jsr TOKOneLine
.9876	a2 27		ldx #$27		ldx #Line85 & $FF
.9878	a0 8c		ldy #$8c		ldy #Line85 >> 8
.987a	20 6e 99	jsr $996e		jsr TOKOneLine
.987d	a2 ac		ldx #$ac		ldx #Line86 & $FF
.987f	a0 8c		ldy #$8c		ldy #Line86 >> 8
.9881	20 6e 99	jsr $996e		jsr TOKOneLine
.9884	a2 01		ldx #$01		ldx #Line87 & $FF
.9886	a0 8d		ldy #$8d		ldy #Line87 >> 8
.9888	20 6e 99	jsr $996e		jsr TOKOneLine
.988b	a2 36		ldx #$36		ldx #Line88 & $FF
.988d	a0 8d		ldy #$8d		ldy #Line88 >> 8
.988f	20 6e 99	jsr $996e		jsr TOKOneLine
.9892	a2 9a		ldx #$9a		ldx #Line89 & $FF
.9894	a0 8d		ldy #$8d		ldy #Line89 >> 8
.9896	20 6e 99	jsr $996e		jsr TOKOneLine
.9899	a2 ab		ldx #$ab		ldx #Line90 & $FF
.989b	a0 8d		ldy #$8d		ldy #Line90 >> 8
.989d	20 6e 99	jsr $996e		jsr TOKOneLine
.98a0	a2 fd		ldx #$fd		ldx #Line91 & $FF
.98a2	a0 8d		ldy #$8d		ldy #Line91 >> 8
.98a4	20 6e 99	jsr $996e		jsr TOKOneLine
.98a7	a2 88		ldx #$88		ldx #Line92 & $FF
.98a9	a0 8e		ldy #$8e		ldy #Line92 >> 8
.98ab	20 6e 99	jsr $996e		jsr TOKOneLine
.98ae	a2 b8		ldx #$b8		ldx #Line93 & $FF
.98b0	a0 8e		ldy #$8e		ldy #Line93 >> 8
.98b2	20 6e 99	jsr $996e		jsr TOKOneLine
.98b5	a2 bc		ldx #$bc		ldx #Line94 & $FF
.98b7	a0 8e		ldy #$8e		ldy #Line94 >> 8
.98b9	20 6e 99	jsr $996e		jsr TOKOneLine
.98bc	a2 33		ldx #$33		ldx #Line95 & $FF
.98be	a0 8f		ldy #$8f		ldy #Line95 >> 8
.98c0	20 6e 99	jsr $996e		jsr TOKOneLine
.98c3	a2 b3		ldx #$b3		ldx #Line96 & $FF
.98c5	a0 8f		ldy #$8f		ldy #Line96 >> 8
.98c7	20 6e 99	jsr $996e		jsr TOKOneLine
.98ca	a2 ca		ldx #$ca		ldx #Line97 & $FF
.98cc	a0 8f		ldy #$8f		ldy #Line97 >> 8
.98ce	20 6e 99	jsr $996e		jsr TOKOneLine
.98d1	a2 46		ldx #$46		ldx #Line98 & $FF
.98d3	a0 90		ldy #$90		ldy #Line98 >> 8
.98d5	20 6e 99	jsr $996e		jsr TOKOneLine
.98d8	a2 71		ldx #$71		ldx #Line99 & $FF
.98da	a0 90		ldy #$90		ldy #Line99 >> 8
.98dc	20 6e 99	jsr $996e		jsr TOKOneLine
.98df	a2 b6		ldx #$b6		ldx #Line100 & $FF
.98e1	a0 90		ldy #$90		ldy #Line100 >> 8
.98e3	20 6e 99	jsr $996e		jsr TOKOneLine
.98e6	a2 c3		ldx #$c3		ldx #Line101 & $FF
.98e8	a0 90		ldy #$90		ldy #Line101 >> 8
.98ea	20 6e 99	jsr $996e		jsr TOKOneLine
.98ed	a2 ec		ldx #$ec		ldx #Line102 & $FF
.98ef	a0 90		ldy #$90		ldy #Line102 >> 8
.98f1	20 6e 99	jsr $996e		jsr TOKOneLine
.98f4	a2 f0		ldx #$f0		ldx #Line103 & $FF
.98f6	a0 90		ldy #$90		ldy #Line103 >> 8
.98f8	20 6e 99	jsr $996e		jsr TOKOneLine
.98fb	a2 5d		ldx #$5d		ldx #Line104 & $FF
.98fd	a0 91		ldy #$91		ldy #Line104 >> 8
.98ff	20 6e 99	jsr $996e		jsr TOKOneLine
.9902	a2 af		ldx #$af		ldx #Line105 & $FF
.9904	a0 91		ldy #$91		ldy #Line105 >> 8
.9906	20 6e 99	jsr $996e		jsr TOKOneLine
.9909	a2 29		ldx #$29		ldx #Line106 & $FF
.990b	a0 92		ldy #$92		ldy #Line106 >> 8
.990d	20 6e 99	jsr $996e		jsr TOKOneLine
.9910	a2 3c		ldx #$3c		ldx #Line107 & $FF
.9912	a0 92		ldy #$92		ldy #Line107 >> 8
.9914	20 6e 99	jsr $996e		jsr TOKOneLine
.9917	a2 b5		ldx #$b5		ldx #Line108 & $FF
.9919	a0 92		ldy #$92		ldy #Line108 >> 8
.991b	20 6e 99	jsr $996e		jsr TOKOneLine
.991e	a2 36		ldx #$36		ldx #Line109 & $FF
.9920	a0 93		ldy #$93		ldy #Line109 >> 8
.9922	20 6e 99	jsr $996e		jsr TOKOneLine
.9925	a2 9e		ldx #$9e		ldx #Line110 & $FF
.9927	a0 93		ldy #$93		ldy #Line110 >> 8
.9929	20 6e 99	jsr $996e		jsr TOKOneLine
.992c	a2 07		ldx #$07		ldx #Line111 & $FF
.992e	a0 94		ldy #$94		ldy #Line111 >> 8
.9930	20 6e 99	jsr $996e		jsr TOKOneLine
.9933	a2 73		ldx #$73		ldx #Line112 & $FF
.9935	a0 94		ldy #$94		ldy #Line112 >> 8
.9937	20 6e 99	jsr $996e		jsr TOKOneLine
.993a	a2 b8		ldx #$b8		ldx #Line113 & $FF
.993c	a0 94		ldy #$94		ldy #Line113 >> 8
.993e	20 6e 99	jsr $996e		jsr TOKOneLine
.9941	a2 e7		ldx #$e7		ldx #Line114 & $FF
.9943	a0 94		ldy #$94		ldy #Line114 >> 8
.9945	20 6e 99	jsr $996e		jsr TOKOneLine
.9948	a2 55		ldx #$55		ldx #Line115 & $FF
.994a	a0 95		ldy #$95		ldy #Line115 >> 8
.994c	20 6e 99	jsr $996e		jsr TOKOneLine
.994f	a2 72		ldx #$72		ldx #Line116 & $FF
.9951	a0 95		ldy #$95		ldy #Line116 >> 8
.9953	20 6e 99	jsr $996e		jsr TOKOneLine
.9956	a2 90		ldx #$90		ldx #Line117 & $FF
.9958	a0 95		ldy #$95		ldy #Line117 >> 8
.995a	20 6e 99	jsr $996e		jsr TOKOneLine
.995d	a2 d3		ldx #$d3		ldx #Line118 & $FF
.995f	a0 95		ldy #$95		ldy #Line118 >> 8
.9961	20 6e 99	jsr $996e		jsr TOKOneLine
.9964	a2 08		ldx #$08		ldx #Line119 & $FF
.9966	a0 96		ldy #$96		ldy #Line119 >> 8
.9968	20 6e 99	jsr $996e		jsr TOKOneLine

;******  Return to file: src/program/testing/testing.asmx

.996b	4c ff ff	jmp $ffff			jmp 	$FFFF
.996e					TOKOneLine:
.996e	86 26		stx $26				stx 	zTemp2
.9970	84 27		sty $27				sty 	zTemp2+1
.9972	a2 88		ldx #$88			ldx 	#TOKGetSource & $FF
.9974	a0 99		ldy #$99			ldy 	#TOKGetSource >> 8
.9976	38		sec				sec
.9977	20 c7 1f	jsr $1fc7			jsr 	TOKTokenise
.997a	20 a2 1e	jsr $1ea2			jsr 	PGMDeleteLine
.997d	ad 00 04	lda $0400			lda 	TOKLineSize
.9980	c9 04		cmp #$04			cmp 	#4
.9982	f0 03		beq $9987			beq 	_TOKNoInsert
.9984	20 ec 1e	jsr $1eec			jsr 	PGMInsertLine
.9987					_TOKNoInsert:
.9987	60		rts				rts
.9988					TOKGetSource:
.9988	b2 26		lda ($26)			lda 	(zTemp2)
.998a	90 06		bcc $9992			bcc 	_GSNoIncrement
.998c	e6 26		inc $26				inc 	zTemp2
.998e	d0 02		bne $9992			bne 	_GSNoIncrement
.9990	e6 27		inc $27				inc 	zTemp2+1
.9992					_GSNoIncrement:
.9992	c9 00		cmp #$00			cmp 	#0
.9994	60		rts				rts
.073a					SrcPosition:
>073a							.fill 		1

;******  Return to file: basic.asm


;******  End of listing
