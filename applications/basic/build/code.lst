
; 64tass Turbo Assembler Macro V1.58.2974? listing file
; 64tass -q -Wall -c -C -b -L build/code.lst -l build/code.lbl -o build/basic.bin basic.asm
; Fri May 26 06:55:58 2023

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: basic.asm


;******  Processing file: build/ramdata.inc

=$08					ZeroPageBase = $08 							; zero page usage
=$200					StorageBase = $200 							; ROM usage
.0008					rTemp0:
>0008							.fill 	2
.000a					iTemp0:
>000a							.fill 	2
.000c					IFR0:
>000c							.fill 	4
.0010					IFR1:
>0010							.fill 	4
.0014					IFR2:
>0014							.fill 	4
.0018					IFRTemp:
>0018							.fill 	4
.0200					OSXPos:
>0200							.fill 	1
.0201					OSYPos:
>0201							.fill 	1
.0202					OSXSize:
>0202							.fill 	1
.0203					OSYSize:
>0203							.fill 	1
=16					OSKeyboardQueueMaxSize = 16					; keyboard queue max size.
.0204					OSKeyStatus:
>0204							.fill 	32
.0224					OSKeyboardQueue:
>0224							.fill 	OSKeyboardQueueMaxSize
.0234					OSKeyboardQueueSize:
>0234							.fill 	1
.0235					OSIsKeyUp:
>0235							.fill 	1
.0236					OSIsKeyShift:
>0236							.fill 	1

;******  Return to file: basic.asm


;******  Processing file: build/osvectors.inc

=$ffe8					OSGetScreenSize          = $ffe8 ; Get size of screen to XY
=$ffeb					OSReadDevice             = $ffeb ; Read device X to A
=$ffee					OSWriteDevice            = $ffee ; Write A to device X
=$fff1					OSWriteScreen            = $fff1 ; Write A to screen (device 0)
=$fff4					OSReadKeyboard           = $fff4 ; Read A from keyboard (device 1)
=$fff7					OSIsKeyAvailable         = $fff7 ; Check if key available (CS if so)

;******  Return to file: basic.asm

.1000					boot:
.1000	20 c4 13	jsr $13c4			jsr 	IFInitialise
.1003	a9 40		lda #$40			lda 	#$40
.1005	85 1d		sta $1d				sta 	codePtr+1
.1007	64 1c		stz $1c				stz 	codePtr
.1009	a0 04		ldy #$04			ldy 	#4
.100b	20 86 11	jsr $1186			jsr 	EXPTermR0
.100e	4c ff ff	jmp $ffff			jmp 	$FFFF

;******  Processing file: include.files


;******  Processing file: src/data.inc

.001c					codePtr:
>001c							.fill 	2
.001e					zTemp0:
>001e							.fill 	2

;******  Return to file: include.files


;******  Processing file: src/errors/generated/errors.inc


;******  Return to file: include.files


;******  Processing file: src/generated/token_const.inc

=$80					PR_STRUCTURE_FIRST = $80
=$80					PR_REPEAT = $80
=$81					PR_UNTIL = $81
=$82					PR_WHILE = $82
=$83					PR_WEND = $83
=$84					PR_IF = $84
=$85					PR_ENDIF = $85
=$86					PR_DO = $86
=$87					PR_LOOP = $87
=$89					PR_PROC = $89
=$8a					PR_ENDPROC = $8a
=$8b					PR_FOR = $8b
=$8c					PR_NEXT = $8c
=$8c					PR_STRUCTURE_LAST = $8c
=$8d					PR_STANDARD_FIRST = $8d
=$8d					PR_LSQLSQENDRSQRSQ = $8d
=$8e					PR_LSQLSQSHIFTRSQRSQ = $8e
=$8f					PR_ELSE = $8f
=$90					PR_THEN = $90
=$91					PR_TO = $91
=$92					PR_STEP = $92
=$93					PR_LET = $93
=$94					PR_PRINT = $94
=$95					PR_INPUT = $95
=$96					PR_CALL = $96
=$97					PR_SYS = $97
=$98					PR_REM = $98
=$99					PR_EXIT = $99
=$9a					PR_COMMA = $9a
=$9b					PR_SEMICOLON = $9b
=$9c					PR_COLON = $9c
=$9d					PR_SQUOTE = $9d
=$9e					PR_RPAREN = $9e
=$9f					PR_DIM = $9f
=$a0					PR_CLEAR = $a0
=$a1					PR_NEW = $a1
=$a2					PR_RUN = $a2
=$a3					PR_STOP = $a3
=$a4					PR_END = $a4
=$a5					PR_ASSERT = $a5
=$a6					PR_LIST = $a6
=$a7					PR_SAVE = $a7
=$a8					PR_LOAD = $a8
=$a8					PR_STANDARD_LAST = $a8
=$d7					PR_RIGHTDOLLARLPAREN = $d7
=$d7					PR_UNARY_FIRST = $d7
=$d8					PR_LEFTDOLLARLPAREN = $d8
=$d9					PR_MIDDOLLARLPAREN = $d9
=$da					PR_STRDOLLARLPAREN = $da
=$db					PR_VALLPAREN = $db
=$dc					PR_SGNLPAREN = $dc
=$dd					PR_ABSLPAREN = $dd
=$de					PR_LENLPAREN = $de
=$df					PR_SQRLPAREN = $df
=$e0					PR_CHRDOLLARLPAREN = $e0
=$e1					PR_ASCLPAREN = $e1
=$e2					PR_INKEYDOLLARLPAREN = $e2
=$e3					PR_EVENTLPAREN = $e3
=$e4					PR_TIME = $e4
=$e5					PR_INTLPAREN = $e5
=$e6					PR_FRACLPAREN = $e6
=$e7					PR_DECLPAREN = $e7
=$e8					PR_HEXDOLLARLPAREN = $e8
=$e9					PR_RNDLPAREN = $e9
=$ea					PR_RANDLPAREN = $ea
=$eb					PR_LPAREN = $eb
=$ec					PR_DOLLAR = $ec
=$ed					PR_LSQLSQDECIMALRSQRSQ = $ed
=$ee					PR_UNARY_LAST = $ee
=$ee					PR_LSQLSQSTRINGRSQRSQ = $ee
=$ef					PR_EQUAL = $ef
=$ef					PR_BINARY_FIRST = $ef
=$f0					PR_LESSGREATER = $f0
=$f1					PR_LESSEQUAL = $f1
=$f2					PR_LESS = $f2
=$f3					PR_GREATEREQUAL = $f3
=$f4					PR_GREATER = $f4
=$f5					PR_XOR = $f5
=$f6					PR_OR = $f6
=$f7					PR_AND = $f7
=$f8					PR_DIV = $f8
=$f9					PR_MOD = $f9
=$fa					PR_LESSLESS = $fa
=$fb					PR_GREATERGREATER = $fb
=$fc					PR_SLASH = $fc
=$fd					PR_ASTERISK = $fd
=$fe					PR_MINUS = $fe
=$ff					PR_BINARY_LAST = $ff
=$ff					PR_PLUS = $ff

;******  Return to file: include.files


;******  Processing file: src/errors/generated/errors.asm

.1011					ErrorV_syntax:
.1011	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>1014	53 79 6e 74 61 78 20 45			.text	"Syntax Error",0
>101c	72 72 6f 72 00
.1021					ErrorV_range:
.1021	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>1024	4f 75 74 20 4f 66 20 52			.text	"Out Of Range",0
>102c	61 6e 67 65 00
.1031					ErrorV_value:
.1031	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>1034	42 61 64 20 56 61 6c 75			.text	"Bad Value",0
>103c	65 00
.103e					ErrorV_type:
.103e	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>1041	54 79 70 65 20 4d 69 73			.text	"Type Mismatch",0
>1049	6d 61 74 63 68 00
.104f					ErrorV_unimplemented:
.104f	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>1052	4e 6f 74 20 49 6d 70 6c			.text	"Not Implemented",0
>105a	65 6d 65 6e 74 65 64 00
.1062					ErrorV_assert:
.1062	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>1065	41 73 73 65 72 74 20 46			.text	"Assert Fail",0
>106d	61 69 6c 00
.1071					ErrorV_internal:
.1071	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>1074	49 6e 74 65 72 6e 61 6c			.text	"Internal Error",0
>107c	20 45 72 72 6f 72 00
.1083					ErrorV_divzero:
.1083	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>1086	44 69 76 69 64 65 20 42			.text	"Divide By Zero",0
>108e	79 20 5a 65 72 6f 00
.1095					ErrorV_structure:
.1095	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>1098	53 74 72 75 63 74 75 72			.text	"Structure Imbalance",0
>10a0	65 20 49 6d 62 61 6c 61 6e 63 65 00
.10ac					ErrorV_stop:
.10ac	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>10af	50 72 6f 67 72 61 6d 20			.text	"Program Stopped",0
>10b7	53 74 6f 70 70 65 64 00
.10bf					ErrorV_data:
.10bf	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>10c2	4f 75 74 20 4f 66 20 44			.text	"Out Of Data",0
>10ca	61 74 61 00
.10ce					ErrorV_redefine:
.10ce	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>10d1	41 72 72 61 79 20 52 65			.text	"Array Redefined",0
>10d9	64 65 66 69 6e 65 64 00
.10e1					ErrorV_index:
.10e1	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>10e4	42 61 64 20 41 72 72 61			.text	"Bad Array Index",0
>10ec	79 20 49 6e 64 65 78 00
.10f4					ErrorV_memory:
.10f4	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>10f7	4f 75 74 20 4f 66 20 4d			.text	"Out Of Memory",0
>10ff	65 6d 6f 72 79 00
.1105					ErrorV_uninitialised:
.1105	20 b7 1a	jsr $1ab7		jsr	ErrorHandler
>1108	56 61 72 69 61 62 6c 65			.text	"Variable Uninitialised",0
>1110	20 55 6e 69 6e 69 74 69 61 6c 69 73 65 64 00

;******  Return to file: include.files


;******  Processing file: src/errors/syntax.asm

.111f					ERRCheckLParen:
.111f	b1 1c		lda ($1c),y			lda 	(codePtr),y
.1121	c9 eb		cmp #$eb			cmp 	#PR_LPAREN
.1123	d0 18		bne $113d			bne 	ERRSyntaxError
.1125	c8		iny				iny
.1126	60		rts				rts
.1127					ERRCheckRParen:
.1127	b1 1c		lda ($1c),y			lda 	(codePtr),y
.1129	c9 9e		cmp #$9e			cmp 	#PR_RPAREN
.112b	d0 10		bne $113d			bne 	ERRSyntaxError
.112d	c8		iny				iny
.112e	60		rts				rts
.112f					ERRCheckComma:
.112f	b1 1c		lda ($1c),y			lda 	(codePtr),y
.1131	c9 9a		cmp #$9a			cmp 	#PR_COMMA
.1133	d0 08		bne $113d			bne 	ERRSyntaxError
.1135	c8		iny				iny
.1136	60		rts				rts
.1137					ERRCheckA:
.1137	d1 1c		cmp ($1c),y			cmp 	(codePtr),y
.1139	d0 02		bne $113d			bne 	ERRSyntaxError
.113b	c8		iny				iny
.113c	60		rts				rts
.113d					ERRSyntaxError:
.113d	4c 11 10	jmp $1011		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/exprutils.asm

.1140					EXPEvalNumber:
.1140	20 7d 11	jsr $117d			jsr 	EXPTermValueR0
.1143	24 0f		bit $0f				bit 	IFR0+IExp
.1145	30 01		bmi $1148			bmi 	EVUType
.1147	60		rts				rts
.1148					EVUType:
.1148	4c 3e 10	jmp $103e		jmp	ErrorV_type
.114b					EXPEvalInteger:
.114b	20 40 11	jsr $1140			jsr 	EXPEvalNumber 				; get number, coeerce to integer.
.114e	20 d9 16	jsr $16d9			jsr 	IFloatIntegerR0
.1151	60		rts				rts
.1152					EXPEvalInteger16:
.1152	20 4b 11	jsr $114b			jsr 	EXPEvalInteger
.1155	a5 0e		lda $0e				lda 	IFR0+IM2
.1157	d0 21		bne $117a			bne 	EVURange
.1159	a6 0d		ldx $0d				ldx 	IFR0+IM1
.115b	a5 0c		lda $0c				lda 	IFR0+IM0
.115d	60		rts				rts
.115e					EXPEvalInteger8:
.115e	20 4b 11	jsr $114b			jsr 	EXPEvalInteger
.1161	a5 0e		lda $0e				lda 	IFR0+IM2
.1163	05 0d		ora $0d				ora 	IFR0+IM1
.1165	d0 13		bne $117a			bne 	EVURange
.1167	a5 0c		lda $0c				lda 	IFR0+IM0
.1169	60		rts				rts
.116a					EXPEvalString:
.116a	20 7d 11	jsr $117d			jsr 	EXPTermValueR0
.116d	24 0f		bit $0f				bit 	IFR0+IExp
.116f	10 d7		bpl $1148			bpl 	EVUType
.1171	a6 0d		ldx $0d				ldx 	IFR0+IM1
.1173	86 1f		stx $1f				stx 	zTemp0+1
.1175	a5 0c		lda $0c				lda 	IFR0+IM0
.1177	85 1e		sta $1e				sta 	zTemp0
.1179	60		rts				rts
.117a					EVURange:
.117a	4c 21 10	jmp $1021		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/expression/term/term.asm

.117d					EXPTermValueR0:
.117d	20 86 11	jsr $1186			jsr 	EXPTermR0
.1180	90 03		bcc $1185			bcc 	_ETVNotReference
.1182	4c 4f 10	jmp $104f		jmp	ErrorV_unimplemented
.1185					_ETVNotReference:
.1185	60		rts				rts
.1186					EXPTermR0:
.1186	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get next token/element
.1188	30 3f		bmi $11c9			bmi 	_ETMIsUnaryOrMinus 			; if it's a token, it's a unary function, maybe -
.118a	c8		iny				iny 								; consume element
.118b	c9 40		cmp #$40			cmp 	#$40 						; 40-7F are identifiers.
.118d	b0 37		bcs $11c6			bcs 	_ETMIdentifier
.118f	85 0c		sta $0c				sta 	IFR0+IM0 					; initial value in IM0
.1191	64 0f		stz $0f				stz 	IFR0+IExp
.1193	64 0d		stz $0d				stz 	IFR0+IM1
.1195	64 0e		stz $0e				stz 	IFR0+IM2
.1197					_ETMConstant:
.1197	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; what follows.
.1199	c9 40		cmp #$40			cmp 	#$40 						; continuing constant
.119b	b0 24		bcs $11c1			bcs 	_ETMCExit 					; no.
.119d	a6 0e		ldx $0e				ldx 	IFR0+IM2 					; x 256 into A:M2 M1 M0
.119f	a5 0d		lda $0d				lda 	IFR0+IM1
.11a1	85 0e		sta $0e				sta 	IFR0+IM2
.11a3	a5 0c		lda $0c				lda 	IFR0+IM0
.11a5	85 0d		sta $0d				sta 	IFR0+IM1
.11a7	64 0c		stz $0c				stz 	IFR0+IM0
.11a9	8a		txa				txa
.11aa	4a		lsr a				lsr 	a 							; shift right twice, e.g. whole thing is x 64
.11ab	66 0e		ror $0e				ror 	IFR0+IM2
.11ad	66 0d		ror $0d				ror 	IFR0+IM1
.11af	66 0c		ror $0c				ror 	IFR0+IM0
.11b1	4a		lsr a				lsr 	a
.11b2	66 0e		ror $0e				ror 	IFR0+IM2
.11b4	66 0d		ror $0d				ror 	IFR0+IM1
.11b6	66 0c		ror $0c				ror 	IFR0+IM0
.11b8	a5 0c		lda $0c				lda 	IFR0+IM0 					; LSB in.
.11ba	11 1c		ora ($1c),y			ora 	(codePtr),y
.11bc	85 0c		sta $0c				sta 	IFR0+IM0
.11be	c8		iny				iny 								; consume, loop back
.11bf	80 d6		bra $1197			bra 	_ETMConstant
.11c1					_ETMCExit:
.11c1	20 ed 11	jsr $11ed			jsr 	EXPCheckDecimalFollows 		; check for decimals.
.11c4	18		clc				clc 								; return value
.11c5	60		rts				rts
.11c6					_ETMIdentifier:
.11c6	4c 4f 10	jmp $104f		jmp	ErrorV_unimplemented
.11c9					_ETMIsUnaryOrMinus:
.11c9	c8		iny				iny 								; consume element
.11ca	c9 fe		cmp #$fe			cmp 	#PR_MINUS 					; handle - seperately as it has two roles.
.11cc	d0 0a		bne $11d8			bne 	_ETMCheckUnary
.11ce	20 7d 11	jsr $117d			jsr 	EXPTermValueR0 				; get a term to negate
.11d1	a2 0c		ldx #$0c			ldx 	#IFR0 						; and negate it
.11d3	20 e4 19	jsr $19e4			jsr 	IFloatNegate
.11d6	18		clc				clc
.11d7	60		rts				rts
.11d8					_ETMCheckUnary:
.11d8	c9 d7		cmp #$d7			cmp 	#PR_UNARY_FIRST 			; check unary function.
.11da	90 0e		bcc $11ea			bcc 	_ETMUnarySyntax
.11dc	c9 ef		cmp #$ef			cmp 	#PR_UNARY_LAST+1
.11de	b0 0a		bcs $11ea			bcs 	_ETMUnarySyntax
.11e0	0a		asl a				asl 	a
.11e1	aa		tax				tax
.11e2	20 e7 11	jsr $11e7			jsr 	_ETMCallUnaryFunction
.11e5	18		clc				clc
.11e6	60		rts				rts
.11e7					_ETMCallUnaryFunction:
.11e7	7c c4 12	jmp ($12c4,x)			jmp 	(VectorTable,x)
.11ea					_ETMUnarySyntax:
.11ea	4c 11 10	jmp $1011		jmp	ErrorV_syntax
.11ed					EXPCheckDecimalFollows:
.11ed	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; check for decimal
.11ef	c9 ed		cmp #$ed			cmp 	#PR_LSQLSQDECIMALRSQRSQ
.11f1	d0 19		bne $120c			bne 	_ETMCDExit
.11f3	c8		iny				iny 								; consume token.
.11f4	b1 1c		lda ($1c),y			lda 	(codePtr),y 				; get count
.11f6	5a		phy				phy									; save current position
.11f7	48		pha				pha 								; save count of chars.
.11f8	38		sec				sec 								; address into YX : y + codePtr+1
.11f9	98		tya				tya
.11fa	65 1c		adc $1c				adc 	codePtr
.11fc	aa		tax				tax
.11fd	a5 1d		lda $1d				lda 	codePtr+1
.11ff	69 00		adc #$00			adc 	#0
.1201	a8		tay				tay
.1202	68		pla				pla 								; get count.
.1203	20 7d 18	jsr $187d			jsr 	IFloatAddDecimalToR0 		; add the decimal to R0
.1206	7a		ply				ply 								; go to next token.
.1207	98		tya				tya
.1208	38		sec				sec
.1209	71 1c		adc ($1c),y			adc 	(codePtr),y
.120b	a8		tay				tay
.120c					_ETMCDExit:
.120c	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/abs.asm

.120d					EXPUnaryAbs:
.120d	20 40 11	jsr $1140			jsr 	EXPEvalNumber 					; number to R0
.1210	20 27 11	jsr $1127			jsr 	ERRCheckRParen 					; )
.1213	20 1d 16	jsr $161d			jsr 	IFloatAbsoluteR0
.1216	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/decimal.asm

.1217					EXPUnaryInlineDec:
.1217	4c 11 10	jmp $1011		jmp	ErrorV_syntax

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/dollar.asm

.121a					EXPUnaryNull:
.121a	20 7d 11	jsr $117d			jsr 	EXPTermValueR0
.121d	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/fractional.asm

.121e					EXPUnaryFrac:
.121e	20 40 11	jsr $1140			jsr 	EXPEvalNumber 					; number to R0
.1221	20 27 11	jsr $1127			jsr 	ERRCheckRParen 					; )
.1224	20 83 16	jsr $1683			jsr 	IFloatFractionalR0
.1227	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/intfn.asm

.1228					EXPUnaryInt:
.1228	20 40 11	jsr $1140			jsr 	EXPEvalNumber 					; number to R0
.122b	20 27 11	jsr $1127			jsr 	ERRCheckRParen 					; )
.122e	20 d9 16	jsr $16d9			jsr 	IFloatIntegerR0
.1231	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/parenthesis.asm

.1232					EXPUnaryParenthesis:
.1232	20 40 11	jsr $1140			jsr 	EXPEvalNumber 					; number to R0
.1235	20 27 11	jsr $1127			jsr 	ERRCheckRParen 					; )
.1238	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/random.asm

.1239					EXPUnaryRnd:
.1239	20 40 11	jsr $1140			jsr 	EXPEvalNumber 				; number to R0
.123c	20 27 11	jsr $1127			jsr 	ERRCheckRParen 				; )
.123f	a2 0c		ldx #$0c			ldx 	#IFR0
.1241	20 58 12	jsr $1258			jsr 	EXPLoadInRandom
.1244	a9 29		lda #$29			lda 	#64-23 						; hack the exponent to make it work.
.1246	85 0f		sta $0f				sta 	IFR0+IExp
.1248	60		rts				rts
.1249					ExpUnaryRand:
.1249	20 4b 11	jsr $114b			jsr 	EXPEvalInteger 				; integer to R0
.124c	20 27 11	jsr $1127			jsr 	ERRCheckRParen 				; )
.124f	a2 10		ldx #$10			ldx 	#IFR1 						; random to R1
.1251	20 58 12	jsr $1258			jsr 	EXPLoadInRandom
.1254	20 4a 15	jsr $154a			jsr 	IFloatModulusInteger 		; calculate mod r1,r2
.1257	60		rts				rts
.1258					EXPLoadInRandom:
.1258	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.125b	20 6d 12	jsr $126d			jsr 	EXPRandom32
.125e	95 00		sta $00,x			sta 	IM0,x
.1260	20 6d 12	jsr $126d			jsr 	EXPRandom32
.1263	95 01		sta $01,x			sta 	IM1,x
.1265	20 6d 12	jsr $126d			jsr 	EXPRandom32
.1268	29 7f		and #$7f			and 	#$7F
.126a	95 02		sta $02,x			sta 	IM2,x
.126c	60		rts				rts
.126d					EXPRandom32:
.126d	5a		phy				phy
.126e	a0 08		ldy #$08			ldy 	#8
.1270	ad 37 02	lda $0237			lda 	EXPSeed+0
.1273	0d 38 02	ora $0238			ora 	EXPSeed+1
.1276	0d 39 02	ora $0239			ora 	EXPSeed+2
.1279	0d 3a 02	ora $023a			ora 	EXPSeed+3
.127c	d0 08		bne $1286			bne 	_EXPRNoReset
.127e	ee 37 02	inc $0237			inc 	EXPSeed+0
.1281	a0 10		ldy #$10			ldy 	#16
.1283	8c 3a 02	sty $023a			sty 	EXPSeed+3
.1286					_EXPRNoReset:
.1286	ad 37 02	lda $0237			lda 	EXPSeed+0
.1289					_EXPRLoop:
.1289	0a		asl a				asl		a
.128a	2e 38 02	rol $0238			rol 	EXPSeed+1
.128d	2e 39 02	rol $0239			rol 	EXPSeed+2
.1290	2e 3a 02	rol $023a			rol 	EXPSeed+3
.1293	90 02		bcc $1297			bcc 	_EXPRNoEOR
.1295	49 c5		eor #$c5			eor 	#$C5
.1297					_EXPRNoEOR:
.1297	88		dey				dey
.1298	d0 ef		bne $1289			bne 	_EXPRLoop
.129a	8d 37 02	sta $0237			sta 	EXPSeed+0
.129d	7a		ply				ply
.129e	60		rts				rts
.0237					EXPSeed:
>0237							.fill 	4

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sgn.asm

.129f					EXPUnarySgn:
.129f	20 40 11	jsr $1140			jsr 	EXPEvalNumber 					; number to R0
.12a2	20 27 11	jsr $1127			jsr 	ERRCheckRParen 					; )
.12a5	a2 10		ldx #$10			ldx 	#IFR1 							; copy to R1
.12a7	20 7b 19	jsr $197b			jsr 	IFloatCopyToRegister
.12aa	a2 0c		ldx #$0c			ldx 	#IFR0 							; R0 = 0
.12ac	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.12af	a2 10		ldx #$10			ldx 	#IFR1
.12b1	20 a7 16	jsr $16a7			jsr 	IFloatCompare 					; compare R1 vs 0.
.12b4	60		rts				rts

;******  Return to file: include.files


;******  Processing file: src/expression/term/unary/sqr.asm

.12b5					EXPUnarySqr:
.12b5	20 40 11	jsr $1140			jsr 	EXPEvalNumber 					; number to R0
.12b8	20 27 11	jsr $1127			jsr 	ERRCheckRParen 					; )
.12bb	20 25 16	jsr $1625			jsr 	IFloatSquareRootR0 				; square root.
.12be	b0 01		bcs $12c1			bcs 	_EUSValue
.12c0	60		rts				rts
.12c1					_EUSValue:
.12c1	4c 21 10	jmp $1021		jmp	ErrorV_range

;******  Return to file: include.files


;******  Processing file: src/generated/vector_table.asm

.12c4					VectorTable:
>12c4	b7 1a					.word	NotImplemented           ; $80 REPEAT
>12c6	b7 1a					.word	NotImplemented           ; $81 UNTIL
>12c8	b7 1a					.word	NotImplemented           ; $82 WHILE
>12ca	b7 1a					.word	NotImplemented           ; $83 WEND
>12cc	b7 1a					.word	NotImplemented           ; $84 IF
>12ce	b7 1a					.word	NotImplemented           ; $85 ENDIF
>12d0	b7 1a					.word	NotImplemented           ; $86 DO
>12d2	b7 1a					.word	NotImplemented           ; $87 LOOP
>12d4	b7 1a					.word	NotImplemented           ; $88
>12d6	b7 1a					.word	NotImplemented           ; $89 PROC
>12d8	b7 1a					.word	NotImplemented           ; $8a ENDPROC
>12da	b7 1a					.word	NotImplemented           ; $8b FOR
>12dc	b7 1a					.word	NotImplemented           ; $8c NEXT
>12de	b7 1a					.word	NotImplemented           ; $8d [[END]]
>12e0	b7 1a					.word	NotImplemented           ; $8e [[SHIFT]]
>12e2	b7 1a					.word	NotImplemented           ; $8f ELSE
>12e4	b7 1a					.word	NotImplemented           ; $90 THEN
>12e6	b7 1a					.word	NotImplemented           ; $91 TO
>12e8	b7 1a					.word	NotImplemented           ; $92 STEP
>12ea	b7 1a					.word	NotImplemented           ; $93 LET
>12ec	b7 1a					.word	NotImplemented           ; $94 PRINT
>12ee	b7 1a					.word	NotImplemented           ; $95 INPUT
>12f0	b7 1a					.word	NotImplemented           ; $96 CALL
>12f2	b7 1a					.word	NotImplemented           ; $97 SYS
>12f4	b7 1a					.word	NotImplemented           ; $98 REM
>12f6	b7 1a					.word	NotImplemented           ; $99 EXIT
>12f8	b7 1a					.word	NotImplemented           ; $9a ,
>12fa	b7 1a					.word	NotImplemented           ; $9b ;
>12fc	b7 1a					.word	NotImplemented           ; $9c :
>12fe	b7 1a					.word	NotImplemented           ; $9d '
>1300	b7 1a					.word	NotImplemented           ; $9e )
>1302	b7 1a					.word	NotImplemented           ; $9f DIM
>1304	b7 1a					.word	NotImplemented           ; $a0 CLEAR
>1306	b7 1a					.word	NotImplemented           ; $a1 NEW
>1308	b7 1a					.word	NotImplemented           ; $a2 RUN
>130a	b7 1a					.word	NotImplemented           ; $a3 STOP
>130c	b7 1a					.word	NotImplemented           ; $a4 END
>130e	b7 1a					.word	NotImplemented           ; $a5 ASSERT
>1310	b7 1a					.word	NotImplemented           ; $a6 LIST
>1312	b7 1a					.word	NotImplemented           ; $a7 SAVE
>1314	b7 1a					.word	NotImplemented           ; $a8 LOAD
>1316	b7 1a					.word	NotImplemented           ; $a9
>1318	b7 1a					.word	NotImplemented           ; $aa
>131a	b7 1a					.word	NotImplemented           ; $ab
>131c	b7 1a					.word	NotImplemented           ; $ac
>131e	b7 1a					.word	NotImplemented           ; $ad
>1320	b7 1a					.word	NotImplemented           ; $ae
>1322	b7 1a					.word	NotImplemented           ; $af
>1324	b7 1a					.word	NotImplemented           ; $b0
>1326	b7 1a					.word	NotImplemented           ; $b1
>1328	b7 1a					.word	NotImplemented           ; $b2
>132a	b7 1a					.word	NotImplemented           ; $b3
>132c	b7 1a					.word	NotImplemented           ; $b4
>132e	b7 1a					.word	NotImplemented           ; $b5
>1330	b7 1a					.word	NotImplemented           ; $b6
>1332	b7 1a					.word	NotImplemented           ; $b7
>1334	b7 1a					.word	NotImplemented           ; $b8
>1336	b7 1a					.word	NotImplemented           ; $b9
>1338	b7 1a					.word	NotImplemented           ; $ba
>133a	b7 1a					.word	NotImplemented           ; $bb
>133c	b7 1a					.word	NotImplemented           ; $bc
>133e	b7 1a					.word	NotImplemented           ; $bd
>1340	b7 1a					.word	NotImplemented           ; $be
>1342	b7 1a					.word	NotImplemented           ; $bf
>1344	b7 1a					.word	NotImplemented           ; $c0
>1346	b7 1a					.word	NotImplemented           ; $c1
>1348	b7 1a					.word	NotImplemented           ; $c2
>134a	b7 1a					.word	NotImplemented           ; $c3
>134c	b7 1a					.word	NotImplemented           ; $c4
>134e	b7 1a					.word	NotImplemented           ; $c5
>1350	b7 1a					.word	NotImplemented           ; $c6
>1352	b7 1a					.word	NotImplemented           ; $c7
>1354	b7 1a					.word	NotImplemented           ; $c8
>1356	b7 1a					.word	NotImplemented           ; $c9
>1358	b7 1a					.word	NotImplemented           ; $ca
>135a	b7 1a					.word	NotImplemented           ; $cb
>135c	b7 1a					.word	NotImplemented           ; $cc
>135e	b7 1a					.word	NotImplemented           ; $cd
>1360	b7 1a					.word	NotImplemented           ; $ce
>1362	b7 1a					.word	NotImplemented           ; $cf
>1364	b7 1a					.word	NotImplemented           ; $d0
>1366	b7 1a					.word	NotImplemented           ; $d1
>1368	b7 1a					.word	NotImplemented           ; $d2
>136a	b7 1a					.word	NotImplemented           ; $d3
>136c	b7 1a					.word	NotImplemented           ; $d4
>136e	b7 1a					.word	NotImplemented           ; $d5
>1370	b7 1a					.word	NotImplemented           ; $d6
>1372	b7 1a					.word	NotImplemented           ; $d7 RIGHT$(
>1374	b7 1a					.word	NotImplemented           ; $d8 LEFT$(
>1376	b7 1a					.word	NotImplemented           ; $d9 MID$(
>1378	b7 1a					.word	NotImplemented           ; $da STR$(
>137a	b7 1a					.word	NotImplemented           ; $db VAL(
>137c	9f 12					.word	EXPUnarySgn              ; $dc SGN(
>137e	0d 12					.word	EXPUnaryAbs              ; $dd ABS(
>1380	b7 1a					.word	NotImplemented           ; $de LEN(
>1382	b5 12					.word	EXPUnarySqr              ; $df SQR(
>1384	b7 1a					.word	NotImplemented           ; $e0 CHR$(
>1386	b7 1a					.word	NotImplemented           ; $e1 ASC(
>1388	b7 1a					.word	NotImplemented           ; $e2 INKEY$(
>138a	b7 1a					.word	NotImplemented           ; $e3 EVENT(
>138c	b7 1a					.word	NotImplemented           ; $e4 TIME
>138e	28 12					.word	EXPUnaryInt              ; $e5 INT(
>1390	1e 12					.word	EXPUnaryFrac             ; $e6 FRAC(
>1392	b7 1a					.word	NotImplemented           ; $e7 DEC(
>1394	b7 1a					.word	NotImplemented           ; $e8 HEX$(
>1396	39 12					.word	EXPUnaryRnd              ; $e9 RND(
>1398	49 12					.word	ExpUnaryRand             ; $ea RAND(
>139a	32 12					.word	EXPUnaryParenthesis      ; $eb (
>139c	1a 12					.word	EXPUnaryNull             ; $ec $
>139e	17 12					.word	EXPUnaryInlineDec        ; $ed [[DECIMAL]]
>13a0	b7 1a					.word	NotImplemented           ; $ee [[STRING]]
>13a2	b7 1a					.word	NotImplemented           ; $ef =
>13a4	b7 1a					.word	NotImplemented           ; $f0 <>
>13a6	b7 1a					.word	NotImplemented           ; $f1 <=
>13a8	b7 1a					.word	NotImplemented           ; $f2 <
>13aa	b7 1a					.word	NotImplemented           ; $f3 >=
>13ac	b7 1a					.word	NotImplemented           ; $f4 >
>13ae	b7 1a					.word	NotImplemented           ; $f5 XOR
>13b0	b7 1a					.word	NotImplemented           ; $f6 OR
>13b2	b7 1a					.word	NotImplemented           ; $f7 AND
>13b4	b7 1a					.word	NotImplemented           ; $f8 DIV
>13b6	b7 1a					.word	NotImplemented           ; $f9 MOD
>13b8	b7 1a					.word	NotImplemented           ; $fa <<
>13ba	b7 1a					.word	NotImplemented           ; $fb >>
>13bc	b7 1a					.word	NotImplemented           ; $fc /
>13be	b7 1a					.word	NotImplemented           ; $fd *
>13c0	b7 1a					.word	NotImplemented           ; $fe -
>13c2	b7 1a					.word	NotImplemented           ; $ff +

;******  Return to file: include.files


;******  Return to file: basic.asm


;******  Processing file: build/libmathslib.asmlib

=0					IM0 = 0
=1					IM1 = 1
=2					IM2 = 2
=3					IExp = 3
=$3f					IFXMask = $3F
=$40					IFSign = $40
.13c4					IFInitialise:
.13c4	9c 43 02	stz $0243			stz 	IFStackIndex
.13c7	60		rts				rts
.13c8					IFloatSubtract:
.13c8	da		phx				phx
.13c9	a2 0c		ldx #$0c			ldx 	#IFR0
.13cb	20 e4 19	jsr $19e4			jsr 	IFloatNegate 				; negate R0 and fall through to add.
.13ce	fa		plx				plx
.13cf					IFloatAdd:
.13cf	b5 03		lda $03,x			lda 	IExp,x 						; check if both exponents are zero.
.13d1	05 0f		ora $0f				ora 	IFR0+IExp
.13d3	29 3f		and #$3f			and 	#IFXMask 					; if not, then we have to do the
.13d5	d0 4e		bne $1425			bne 	_IFloatAddDecimals 			; decimal version.
.13d7					_IFAddSubMantissa:
.13d7	b5 03		lda $03,x			lda 	IExp,x 						; are the signs different ?
.13d9	45 0f		eor $0f				eor 	IFR0+IExp
.13db	29 40		and #$40			and 	#IFSign
.13dd	d0 21		bne $1400			bne 	_IFloatSubMantissa
.13df	18		clc				clc 								; do the actual addition
.13e0	a5 0c		lda $0c			lda 	IFR0+IM0
.13e2	75 00		adc $00,x		adc 		IM0,x
.13e4	85 0c		sta $0c			sta 	IFR0+IM0
.13e6	a5 0d		lda $0d			lda 	IFR0+IM1
.13e8	75 01		adc $01,x		adc 		IM1,x
.13ea	85 0d		sta $0d			sta 	IFR0+IM1
.13ec	a5 0e		lda $0e			lda 	IFR0+IM2
.13ee	75 02		adc $02,x		adc 		IM2,x
.13f0	85 0e		sta $0e			sta 	IFR0+IM2
.13f2	10 29		bpl $141d			bpl 	_IFloatAddExit 				; if no carry through to bit 23, then exit.
.13f4	a2 0c		ldx #$0c			ldx 	#IFR0						; shift R0 right, divide by 2
.13f6	20 08 1a	jsr $1a08			jsr 	IFloatShiftRight
.13f9	20 32 1a	jsr $1a32			jsr 	IFloatIncExponent
.13fc	d0 1f		bne $141d			bne 	_IFloatAddExit
.13fe	38		sec				sec 								; overflowed numerically.
.13ff	60		rts				rts
.1400					_IFloatSubMantissa:
.1400	38		sec				sec 								; do the subtraction R0-Rx
.1401	a5 0c		lda $0c			lda 	IFR0+IM0
.1403	f5 00		sbc $00,x		sbc 		IM0,x
.1405	85 0c		sta $0c			sta 	IFR0+IM0
.1407	a5 0d		lda $0d			lda 	IFR0+IM1
.1409	f5 01		sbc $01,x		sbc 		IM1,x
.140b	85 0d		sta $0d			sta 	IFR0+IM1
.140d	a5 0e		lda $0e			lda 	IFR0+IM2
.140f	f5 02		sbc $02,x		sbc 		IM2,x
.1411	85 0e		sta $0e			sta 	IFR0+IM2
.1413	b0 08		bcs $141d			bcs 	_IFloatAddExit 				; no borrow so we are done.
.1415	a2 0c		ldx #$0c			ldx 	#IFR0
.1417	20 ec 19	jsr $19ec			jsr 	IFloatMantissaNegate 		; 2's complement negate the mantissa
.141a	20 e4 19	jsr $19e4			jsr 	IFloatNegate 				; negate
.141d					_IFloatAddExit:
.141d	18		clc				clc
.141e	60		rts				rts
.141f					_IFloatZeroAdd:
.141f	fa		plx				plx 								; return this value in R0
.1420	20 6a 19	jsr $196a			jsr 	IFloatCopyFromRegister
.1423	18		clc				clc
.1424	60		rts				rts
.1425					_IFloatAddDecimals:
.1425	20 d2 19	jsr $19d2			jsr		IFloatCheckZero 			; if RX = 0 then exit with R0
.1428	f0 f3		beq $141d			beq 	_IFloatAddExit
.142a	20 10 1a	jsr $1a10			jsr 	IFloatNormalise 			; normalise RX
.142d	da		phx				phx 								; normalise R0
.142e	a2 0c		ldx #$0c			ldx 	#IFR0
.1430	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero
.1433	f0 ea		beq $141f			beq 	_IFloatZeroAdd
.1435	20 10 1a	jsr $1a10			jsr 	IFloatNormalise
.1438	fa		plx				plx
.1439	a5 0f		lda $0f				lda 	IFR0+IExp 					; get the exponent of R0
.143b	29 3f		and #$3f			and 	#IFXMask
.143d	38		sec				sec
.143e	e9 20		sbc #$20			sbc 	#$20 						; map 20..3F..00..1F to 00..0F..E0..FF e.g. scaled unsigned
.1440	85 0a		sta $0a				sta 	iTemp0
.1442	b5 03		lda $03,x			lda 	IExp,x 						; repeat for exponent of Rx
.1444	29 3f		and #$3f			and 	#IFXMask
.1446	38		sec				sec
.1447	e9 20		sbc #$20			sbc 	#$20
.1449	c5 0a		cmp $0a				cmp 	iTemp0 						; get the larger adjusted
.144b	b0 02		bcs $144f			bcs 	_IFloatHaveLarger
.144d	a5 0a		lda $0a				lda 	iTemp0
.144f					_IFloatHaveLarger:
.144f	18		clc				clc 								; get the actual one back.
.1450	69 20		adc #$20			adc 	#$20 						; shift both to that.
.1452	20 5f 14	jsr $145f			jsr 	_IFShiftXToA
.1455	da		phx				phx
.1456	a2 0c		ldx #$0c			ldx 	#IFR0
.1458	20 5f 14	jsr $145f			jsr 	_IFShiftXToA
.145b	fa		plx				plx
.145c	4c d7 13	jmp $13d7			jmp 	_IFAddSubMantissa 			; do the adding bit.
.145f					_IFShiftXToA:
.145f	8d 3b 02	sta $023b			sta 	IFTarget
.1462	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero 			; check adding zero ?
.1465	f0 11		beq $1478			beq 	_IFSXExit
.1467					_IFSXLoop:
.1467	b5 03		lda $03,x			lda 	IExp,x 	 					; shifted to the right level yet ?
.1469	29 3f		and #$3f			and 	#IFXMask
.146b	cd 3b 02	cmp $023b			cmp 	IFTarget
.146e	f0 08		beq $1478			beq 	_IFSXExit
.1470	20 08 1a	jsr $1a08			jsr 	IFloatShiftRight
.1473	20 32 1a	jsr $1a32			jsr 	IFloatIncExponent
.1476	80 ef		bra $1467			bra 	_IFSXLoop
.1478					_IFSXExit:
.1478	60		rts				rts
.023b					IFTarget:
>023b							.fill 	1
.1479					IFloatMultiply:
.1479	8e 3b 02	stx $023b			stx 	IFTarget 					; save the multiplier (RX) which is "adder"
.147c	20 34 15	jsr $1534			jsr 	IFCalculateNewSign
.147f	b5 03		lda $03,x			lda 	IExp,x 						; check two positive 8 bit integers
.1481	05 0f		ora $0f				ora 	IFR0+IExp
.1483	29 3f		and #$3f			and 	#IFXMask
.1485	15 01		ora $01,x			ora 	IM1,x
.1487	05 0d		ora $0d				ora 	IFR0+IM1
.1489	15 02		ora $02,x			ora 	IM2,x
.148b	05 0e		ora $0e				ora 	IFR0+IM2
.148d	d0 0a		bne $1499			bne 	_IFMStandard
.148f	20 b5 19	jsr $19b5			jsr 	IFloatMultiply8BitRx
.1492	ad 3d 02	lda $023d			lda 	IFNewSign
.1495	85 0f		sta $0f				sta 	IFR0+IExp
.1497	18		clc				clc
.1498	60		rts				rts
.1499					_IFMStandard:
.1499	b5 03		lda $03,x			lda 	IExp,x 						; add the two exponents sign extended
.149b	20 2b 15	jsr $152b			jsr 	IFMSignExtend
.149e	8d 3c 02	sta $023c			sta 	IFNewExponent
.14a1	a5 0f		lda $0f				lda 	IFR0+IExp
.14a3	20 2b 15	jsr $152b			jsr 	IFMSignExtend
.14a6	18		clc				clc
.14a7	6d 3c 02	adc $023c			adc 	IFNewExponent
.14aa	8d 3c 02	sta $023c			sta 	IFNewExponent
.14ad	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy R0 to RTemp which is "shifter"
.14af	20 7b 19	jsr $197b			jsr 	IFloatCopyToRegister
.14b2	a2 0c		ldx #$0c			ldx 	#IFR0 						; zero R0 (the result)
.14b4	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.14b7					_IFMLoop:
.14b7	a2 18		ldx #$18			ldx 	#IFRTemp
.14b9	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero
.14bc	f0 3a		beq $14f8			beq 	_IFMExit
.14be	ae 3b 02	ldx $023b			ldx 	IFTarget 					; look at adder MSB
.14c1	b5 02		lda $02,x			lda 	IM2,x 						; if it is set we need to shift everything
.14c3	10 03		bpl $14c8			bpl	 	_IFMTargetOkay
.14c5	20 1c 15	jsr $151c			jsr 	_IFMShiftAll
.14c8					_IFMTargetOkay:
.14c8	a5 18		lda $18				lda 	IFRTemp+0 					; is bit 0 of the shifter (RTemp) set
.14ca	29 01		and #$01			and 	#1
.14cc	f0 16		beq $14e4			beq 	_IFMNoAdd
.14ce	ae 3b 02	ldx $023b			ldx 	IFTarget 					; add adder
.14d1	18		clc				clc
.14d2	a5 0c		lda $0c			lda 	IFR0+IM0
.14d4	75 00		adc $00,x		adc 		IM0,x
.14d6	85 0c		sta $0c			sta 	IFR0+IM0
.14d8	a5 0d		lda $0d			lda 	IFR0+IM1
.14da	75 01		adc $01,x		adc 		IM1,x
.14dc	85 0d		sta $0d			sta 	IFR0+IM1
.14de	a5 0e		lda $0e			lda 	IFR0+IM2
.14e0	75 02		adc $02,x		adc 		IM2,x
.14e2	85 0e		sta $0e			sta 	IFR0+IM2
.14e4					_IFMNoAdd:
.14e4	a5 0e		lda $0e				lda 	IFR0+IM2
.14e6	10 03		bpl $14eb			bpl 	_IFMResultOkay
.14e8	20 1c 15	jsr $151c			jsr 	_IFMShiftAll
.14eb					_IFMResultOkay:
.14eb	a2 18		ldx #$18			ldx 	#IFRTemp
.14ed	20 08 1a	jsr $1a08			jsr 	IFloatShiftRight
.14f0	ae 3b 02	ldx $023b			ldx 	IFTarget
.14f3	20 00 1a	jsr $1a00			jsr 	IFloatShiftLeft
.14f6	80 bf		bra $14b7			bra 	_IFMLoop
.14f8					_IFMExit:
.14f8	ad 3c 02	lda $023c			lda 	IFNewExponent 				; validate new exponent.
.14fb	c9 20		cmp #$20			cmp 	#$20 						; valid exponent 00-1F E0-FF
.14fd	90 0f		bcc $150e			bcc 	_IFMOkay
.14ff	c9 e0		cmp #$e0			cmp 	#$E0
.1501	b0 0b		bcs $150e			bcs 	_IFMOkay
.1503	29 80		and #$80			and 	#$80 						; if +ve exponent then error overflow.
.1505	f0 13		beq $151a			beq 	_IFMError
.1507	a2 0c		ldx #$0c			ldx 	#IFR0 						; return zero underflow
.1509	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.150c	18		clc				clc
.150d	60		rts				rts
.150e					_IFMOkay:
.150e	29 3f		and #$3f			and 	#IFXMask 					; work out exponent + sign and exit
.1510	0d 3d 02	ora $023d			ora 	IFNewSign
.1513	85 0f		sta $0f				sta 	IFR0+IExp
.1515	18		clc				clc
.1516	60		rts				rts
.1517	4c ff ff	jmp $ffff			jmp 	$FFFF
.151a					_IFMError:
.151a	38		sec				sec
.151b	60		rts				rts
.151c					_IFMShiftAll:
.151c	a2 0c		ldx #$0c			ldx 	#IFR0
.151e	20 08 1a	jsr $1a08			jsr 	IFloatShiftRight
.1521	ae 3b 02	ldx $023b			ldx 	IFTarget
.1524	20 08 1a	jsr $1a08			jsr 	IFloatShiftRight
.1527	ee 3c 02	inc $023c			inc 	IFNewExponent
.152a	60		rts				rts
.152b					IFMSignExtend:
.152b	29 3f		and #$3f			and 	#IFXMask
.152d	c9 1f		cmp #$1f			cmp 	#(IFXMask >> 1)
.152f	90 02		bcc $1533			bcc 	_IFMNoSXX
.1531	09 c0		ora #$c0			ora 	#IFXMask ^ $FF
.1533					_IFMNoSXX:
.1533	60		rts				rts
.1534					IFCalculateNewSign:
.1534	b5 03		lda $03,x			lda 	IExp,x
.1536	45 0f		eor $0f				eor 	IFR0+IExp
.1538	29 40		and #$40			and 	#IFSign
.153a	8d 3d 02	sta $023d			sta 	IFNewSign
.153d	60		rts				rts
.023c					IFNewExponent:
>023c							.fill 	1
.023d					IFNewSign:
>023d							.fill 	1
.153e					IFloatDivideInteger:
.153e	20 57 15	jsr $1557			jsr 	IFloatDivideIntegerCommon 	; do the common code.
.1541	b0 06		bcs $1549			bcs 	_IFDIExit
.1543	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy result from register.
.1545	20 6a 19	jsr $196a			jsr 	IFloatCopyFromRegister
.1548	18		clc				clc
.1549					_IFDIExit:
.1549	60		rts				rts
.154a					IFloatModulusInteger:
.154a	20 57 15	jsr $1557			jsr 	IFloatDivideIntegerCommon
.154d	b0 07		bcs $1556			bcs 	_IFMIExit
.154f	ae 3b 02	ldx $023b			ldx 	IFTarget
.1552	20 6a 19	jsr $196a			jsr 	IFloatCopyFromRegister
.1555	18		clc				clc
.1556					_IFMIExit:
.1556	60		rts				rts
.1557					IFloatDivideIntegerCommon:
.1557	8e 3b 02	stx $023b			stx 	IFTarget  					; this is s1, s0 = R0
.155a	20 34 15	jsr $1534			jsr 	IFCalculateNewSign 			; calculate sign of result
.155d	20 85 15	jsr $1585			jsr 	IFDCopyRXToRTemp 			; copy S1 to RTemp
.1560	a2 0c		ldx #$0c			ldx 	#IFR0 						; check divide by zero
.1562	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero
.1565	f0 1c		beq $1583			beq 	_IFDIDivZero
.1567	ae 3b 02	ldx $023b			ldx 	IFTarget 					; zero Rx (S1)
.156a	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.156d	5a		phy				phy
.156e	a0 18		ldy #$18			ldy 	#24
.1570					_IFDILoop:
.1570	20 96 15	jsr $1596			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.1573	20 a2 15	jsr $15a2			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.1576	88		dey				dey
.1577	d0 f7		bne $1570			bne 	_IFDILoop 					; do it 24 times
.1579	7a		ply				ply
.157a	ad 3d 02	lda $023d			lda 	IFNewSign 					; set sign of result.
.157d	29 40		and #$40			and 	#IFSign
.157f	85 1b		sta $1b				sta 	IFRTemp+IExp
.1581	18		clc				clc 								; is okay.
.1582	60		rts				rts
.1583					_IFDIDivZero:
.1583	38		sec				sec
.1584	60		rts				rts
.1585					IFDCopyRXToRTemp:
.1585	b5 00		lda $00,x			lda 	IM0,x
.1587	85 18		sta $18				sta 	IFRTemp+IM0
.1589	b5 01		lda $01,x			lda 	IM1,x
.158b	85 19		sta $19				sta 	IFRTemp+IM1
.158d	b5 02		lda $02,x			lda 	IM2,x
.158f	85 1a		sta $1a				sta 	IFRTemp+IM2
.1591	b5 03		lda $03,x			lda 	IExp,x
.1593	85 1b		sta $1b				sta 	IFRTemp+IExp
.1595	60		rts				rts
.1596					IFDShiftSTempS1Left:
.1596	a2 18		ldx #$18			ldx 	#IFRTemp
.1598	20 00 1a	jsr $1a00			jsr 	IFloatShiftLeft
.159b	ae 3b 02	ldx $023b			ldx 	IFTarget
.159e	20 01 1a	jsr $1a01			jsr 	IFloatRotateLeft
.15a1	60		rts				rts
.15a2					IFDTrySubtract:
.15a2	ae 3b 02	ldx $023b			ldx 	IFTarget 					; s1 = Rx
.15a5	38		sec				sec 								; subtract, saving the results on the stack.
.15a6	b5 00		lda $00,x			lda 	IM0,x
.15a8	e5 0c		sbc $0c				sbc 	IFR0+IM0
.15aa	48		pha				pha
.15ab	b5 01		lda $01,x			lda 	IM1,x
.15ad	e5 0d		sbc $0d				sbc 	IFR0+IM1
.15af	48		pha				pha
.15b0	b5 02		lda $02,x			lda 	IM2,x
.15b2	e5 0e		sbc $0e				sbc 	IFR0+IM2
.15b4	b0 03		bcs $15b9			bcs 	_IFDCanSubtract
.15b6	68		pla				pla 								; cannot subtract, so pop intermediate and exit.
.15b7	68		pla				pla
.15b8	60		rts				rts
.15b9					_IFDCanSubtract:
.15b9	95 02		sta $02,x			sta 	IM2,x 						; write back to S1.Mantissa
.15bb	68		pla				pla
.15bc	95 01		sta $01,x			sta 	IM1,x
.15be	68		pla				pla
.15bf	95 00		sta $00,x			sta 	IM0,x
.15c1	e6 18		inc $18				inc 	IFRTemp+IM0 				; increment temp
.15c3	d0 06		bne $15cb			bne 	_IFDCSExit
.15c5	e6 19		inc $19				inc 	IFRTemp+IM1
.15c7	d0 02		bne $15cb			bne 	_IFDCSExit
.15c9	e6 1a		inc $1a				inc 	IFRTemp+IM2
.15cb					_IFDCSExit:
.15cb	60		rts				rts
.15cc					IFloatBitwiseAnd:
.15cc	5a		phy				phy
.15cd	20 11 16	jsr $1611			jsr 	IFPreProcessBitwise 		; set up everything.
.15d0	d0 0f		bne $15e1			bne 	_IFBAExit
.15d2					_IFBALoop:
.15d2	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.15d5	35 00		and $00,x			and 	IM0,x
.15d7	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.15da	e8		inx				inx
.15db	c8		iny				iny
.15dc	c0 03		cpy #$03			cpy 	#3
.15de	d0 f2		bne $15d2			bne 	_IFBALoop
.15e0	18		clc				clc
.15e1					_IFBAExit:
.15e1	7a		ply				ply
.15e2	60		rts				rts
.15e3					IFloatBitwiseOr:
.15e3	5a		phy				phy
.15e4	20 11 16	jsr $1611			jsr 	IFPreProcessBitwise 		; set up everything.
.15e7	d0 0f		bne $15f8			bne 	_IFBAExit
.15e9					_IFBALoop:
.15e9	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.15ec	15 00		ora $00,x			ora 	IM0,x
.15ee	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.15f1	e8		inx				inx
.15f2	c8		iny				iny
.15f3	c0 03		cpy #$03			cpy 	#3
.15f5	d0 f2		bne $15e9			bne 	_IFBALoop
.15f7	18		clc				clc
.15f8					_IFBAExit:
.15f8	7a		ply				ply
.15f9	60		rts				rts
.15fa					IFloatBitwiseXor:
.15fa	5a		phy				phy
.15fb	20 11 16	jsr $1611			jsr 	IFPreProcessBitwise 		; set up everything.
.15fe	d0 0f		bne $160f			bne 	_IFBAExit
.1600					_IFBALoop:
.1600	b9 0c 00	lda $000c,y			lda 	IFR0+IM0,y
.1603	55 00		eor $00,x			eor 	IM0,x
.1605	99 0c 00	sta $000c,y			sta 	IFR0+IM0,y
.1608	e8		inx				inx
.1609	c8		iny				iny
.160a	c0 03		cpy #$03			cpy 	#3
.160c	d0 f2		bne $1600			bne 	_IFBALoop
.160e	18		clc				clc
.160f					_IFBAExit:
.160f	7a		ply				ply
.1610	60		rts				rts
.1611					IFPreProcessBitwise:
.1611	a0 00		ldy #$00			ldy 	#0 							; set index.
.1613	a5 0f		lda $0f				lda 	IFR0+IExp 					; OR exponents
.1615	15 03		ora $03,x			ora 	IExp,x
.1617	74 03		stz $03,x			stz 	IExp,x 						; zero the result exponent anyway.
.1619	29 3f		and #$3f			and 	#IFXMask 					; NZ if error e.g. not integer
.161b	38		sec				sec 								; carry set just in cases.
.161c	60		rts				rts
.161d					IFloatAbsoluteR0:
.161d	a5 0f		lda $0f				lda 	IFR0+IExp					; reset the sign bit.
.161f	29 bf		and #$bf			and 	#IFSign ^ 255
.1621	85 0f		sta $0f				sta 	IFR0+IExp
.1623	18		clc				clc
.1624	60		rts				rts
.1625					IFloatSquareRootR0:
.1625	a2 0c		ldx #$0c			ldx 	#IFR0 						; if zero, return zero.
.1627	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero
.162a	a5 0f		lda $0f				lda	 	IFR0+IExp 					; if negative fail.
.162c	29 40		and #$40			and 	#IFSign
.162e	d0 2f		bne $165f			bne 	_IFSRFail
.1630	20 10 1a	jsr $1a10			jsr 	IFloatNormalise 			; it will work better !
.1633	a2 10		ldx #$10			ldx 	#IFR1 						; R1 contains original throughout
.1635	20 7b 19	jsr $197b			jsr 	IFloatCopyToRegister
.1638	a5 0f		lda $0f				lda 	IFR0+IExp 					; if exponent is $2A..$3F * 64 otherwise is / 64
.163a	20 2b 15	jsr $152b			jsr 	IFMSignExtend 				; sign extended version of the exponent
.163d	18		clc				clc
.163e	69 17		adc #$17			adc 	#23 						; this makes it a 0.xxx mantissa
.1640	85 0f		sta $0f				sta 	IFR0+IExp
.1642	4a		lsr a				lsr 	a 							; which we can halve.
.1643	38		sec				sec 								; convert back
.1644	e9 17		sbc #$17			sbc 	#23
.1646	29 3f		and #$3f			and 	#IFXMask 					; make appropriate
.1648	85 0f		sta $0f				sta 	IFR0+IExp 					; to R0
.164a	20 61 16	jsr $1661			jsr 	_IFSRNewton
.164d	20 61 16	jsr $1661			jsr 	_IFSRNewton
.1650	20 61 16	jsr $1661			jsr 	_IFSRNewton
.1653	20 61 16	jsr $1661			jsr 	_IFSRNewton
.1656	18		clc				clc
.1657	60		rts				rts
.1658					_IFSRZero:
.1658	a2 0c		ldx #$0c			ldx 	#IFR0
.165a	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.165d	18		clc				clc
.165e	60		rts				rts
.165f					_IFSRFail:
.165f	38		sec				sec
.1660	60		rts				rts
.1661					_IFSRNewton:
.1661	a2 10		ldx #$10			ldx 	#IFR1 						; push original value (R3) on the stack
.1663	20 28 19	jsr $1928			jsr 	IFloatPushRx
.1666	a2 0c		ldx #$0c			ldx 	#IFR0 						; push current guess (R0) on the stack.
.1668	20 28 19	jsr $1928			jsr 	IFloatPushRx
.166b	a2 10		ldx #$10			ldx 	#IFR1 						; guess = original / guess
.166d	20 fc 16	jsr $16fc			jsr 	IFloatDivideFloat
.1670	a2 10		ldx #$10			ldx 	#IFR1 						; restore current guess (was in R0) to R3
.1672	20 49 19	jsr $1949			jsr 	IFloatPullRx
.1675	20 cf 13	jsr $13cf			jsr 	IFloatAdd 					; now guess + original/guess
.1678	a2 0c		ldx #$0c			ldx 	#IFR0 						; divide by 2
.167a	20 08 1a	jsr $1a08			jsr 	IFloatShiftRight
.167d	a2 10		ldx #$10			ldx 	#IFR1
.167f	20 49 19	jsr $1949			jsr 	IFloatPullRx 				; Finally pull the oeifinal
.1682	60		rts				rts
.1683					IFloatFractionalR0:
.1683	a5 0f		lda $0f				lda 	IFR0+IExp					; is it integer already ?
.1685	29 3f		and #$3f			and 	#IFXMask
.1687	f0 17		beq $16a0			beq 	_FIPZero 					; if so, return with zero as no fractional part.
.1689	20 1d 16	jsr $161d			jsr 	IFloatAbsoluteR0 			; absolute value R9
.168c	a2 0c		ldx #$0c			ldx 	#IFR0
.168e	20 10 1a	jsr $1a10			jsr 	IFloatNormalise 			; normalise R0
.1691	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy to RTemp
.1693	20 7b 19	jsr $197b			jsr 	IFloatCopyToRegister
.1696	20 d9 16	jsr $16d9			jsr 	IFloatIntegerR0 			; take integer part of R0
.1699	a2 18		ldx #$18			ldx 	#IFRTemp 					; subtract
.169b	20 c8 13	jsr $13c8			jsr 	IFloatSubtract
.169e	80 05		bra $16a5			bra 	_FIPExit
.16a0					_FIPZero:
.16a0	a2 0c		ldx #$0c			ldx 	#IFR0
.16a2	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.16a5					_FIPExit:
.16a5	18		clc				clc
.16a6	60		rts				rts
.16a7					IFloatCompare:
.16a7	20 c8 13	jsr $13c8			jsr 	IFloatSubtract 				; subtract R0 from RX.
.16aa	b5 03		lda $03,x			lda 	IExp,x 						; check if integer comparison
.16ac	05 0f		ora $0f				ora 	IFR0+IExp
.16ae	a2 0c		ldx #$0c			ldx 	#IFR0 						; only using R0 from now on.
.16b0	29 3f		and #$3f			and 	#IFXMask
.16b2	d0 19		bne $16cd			bne 	_IFCNonInteger
.16b4	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero 			; check if zero
.16b7	f0 0f		beq $16c8			beq 	_IFCZero
.16b9					_IFCReturnSign:
.16b9	a5 0f		lda $0f				lda 	IFR0+IExp 					; get the sign bit/unused -> stack.
.16bb	29 c0		and #$c0			and 	#(IFXMask ^ $FF)
.16bd	48		pha				pha
.16be	a9 01		lda #$01			lda 	#1
.16c0	20 db 19	jsr $19db			jsr 	IFloatSetByte 				; return to +1
.16c3	68		pla				pla 								; sign bit back
.16c4	85 0f		sta $0f				sta 	IFR0+IExp					; set that sign
.16c6	18		clc				clc
.16c7	60		rts				rts
.16c8					_IFCZero:
.16c8	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.16cb	18		clc				clc
.16cc	60		rts				rts
.16cd					_IFCNonInteger:
.16cd	a5 0c		lda $0c				lda 	IFR0+IM0
.16cf	29 00		and #$00			and		#$00
.16d1	05 0d		ora $0d				ora 	IFR0+IM1
.16d3	05 0e		ora $0e				ora 	IFR0+IM2
.16d5	f0 f1		beq $16c8			beq 	_IFCZero 					; near enough !
.16d7	80 e0		bra $16b9			bra 	_IFCReturnSign 				; return the sign of the difference.
.16d9					IFloatIntegerR0:
.16d9	a5 0f		lda $0f				lda 	IFR0+IExp					; is it integer already ?
.16db	29 3f		and #$3f			and 	#IFXMask
.16dd	f0 1b		beq $16fa			beq 	_FIPExit 					; if so do nothing
.16df	a2 0c		ldx #$0c			ldx 	#IFR0
.16e1	20 10 1a	jsr $1a10			jsr 	IFloatNormalise 			; normalise
.16e4	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero 			; is it zero ?
.16e7	f0 0e		beq $16f7			beq 	_FIPZero 					; if so return zero.
.16e9					_FIPShift:
.16e9	a5 0f		lda $0f				lda 	IFR0+IExp 					; if Exponent >= 0 exit.
.16eb	29 20		and #$20			and 	#$20 						; still -ve
.16ed	f0 0b		beq $16fa			beq 	_FIPExit
.16ef	20 08 1a	jsr $1a08			jsr 	IFloatShiftRight 			; shift mantissa right
.16f2	20 32 1a	jsr $1a32			jsr 	IFloatIncExponent 			; bump exponent
.16f5	80 f2		bra $16e9			bra 	_FIPShift
.16f7					_FIPZero:
.16f7	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.16fa					_FIPExit:
.16fa	18		clc				clc
.16fb	60		rts				rts
.16fc					IFloatDivideFloat:
.16fc	8e 3b 02	stx $023b			stx 	IFTarget  					; this is s1, s0 = R0
.16ff	20 34 15	jsr $1534			jsr 	IFCalculateNewSign 			; calculate sign of result
.1702	20 10 1a	jsr $1a10			jsr 	IFloatNormalise 			; normalise RX
.1705	a2 0c		ldx #$0c			ldx 	#IFR0 						; normalise R0
.1707	20 10 1a	jsr $1a10			jsr 	IFloatNormalise
.170a	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero
.170d	f0 56		beq $1765			beq 	_IFDFDivZero 				; exit if this normalised to zero.
.170f	a5 0f		lda $0f				lda 	IFR0+IExp 					; calculate s0.exponent
.1711	20 2b 15	jsr $152b			jsr 	IFMSignExtend
.1714	8d 3c 02	sta $023c			sta 	IFNewExponent
.1717	ae 3b 02	ldx $023b			ldx 	IFTarget 					; calculate s1.exponent
.171a	b5 03		lda $03,x			lda 	IExp,x
.171c	20 2b 15	jsr $152b			jsr 	IFMSignExtend
.171f	38		sec				sec
.1720	ed 3c 02	sbc $023c			sbc 	IFNewExponent 				; s1.exponent - s0.exponent - 23
.1723	38		sec				sec
.1724	e9 17		sbc #$17			sbc 	#23
.1726	8d 3c 02	sta $023c			sta 	IFNewExponent
.1729	20 67 17	jsr $1767			jsr 	IFloatDivideSupport 		; call the support routine (see maths.py)
.172c	a5 1a		lda $1a				lda 	IFRTemp+IM2 				; result has overflowed ?
.172e	10 08		bpl $1738			bpl 	_IFDFNoShiftResult
.1730	a2 18		ldx #$18			ldx 	#IFRTemp 					; if so, fix it up.
.1732	20 08 1a	jsr $1a08			jsr 	IFloatShiftRight
.1735	ee 3c 02	inc $023c			inc 	IFNewExponent
.1738					_IFDFNoShiftResult:
.1738	ad 3c 02	lda $023c			lda 	IFNewExponent 				; underflow/overflow check.
.173b	30 06		bmi $1743			bmi 	_IFDFCheckUnderflow
.173d	c9 20		cmp #$20			cmp 	#$20 						; overflow in division
.173f	b0 24		bcs $1765			bcs 	_IFDFDivZero
.1741	80 11		bra $1754			bra		_IFDFExit
.1743					_IFDFCheckUnderflow:
.1743	ad 3c 02	lda $023c			lda 	IFNewExponent 				; shift into a legal exponent.
.1746	c9 e0		cmp #$e0			cmp 	#$E0 						; if exponent < -32.
.1748	b0 0a		bcs $1754			bcs 	_IFDFExit
.174a	ee 3c 02	inc $023c			inc 	IFNewExponent
.174d	a2 18		ldx #$18			ldx 	#IFRTemp
.174f	20 08 1a	jsr $1a08			jsr 	IFloatShiftRight
.1752	80 ef		bra $1743			bra 	_IFDFCheckUnderflow
.1754					_IFDFExit:
.1754	ad 3c 02	lda $023c			lda 	IFNewExponent 				; combine exponent and sign.
.1757	29 3f		and #$3f			and 	#IFXMask
.1759	0d 3d 02	ora $023d			ora 	IFNewSign
.175c	85 1b		sta $1b				sta 	IFRTemp+IExp
.175e	a2 18		ldx #$18			ldx 	#IFRTemp 					; copy RTemp to R0.
.1760	20 6a 19	jsr $196a			jsr 	IFloatCopyFromRegister
.1763	18		clc				clc
.1764	60		rts				rts
.1765					_IFDFDivZero:
.1765	38		sec				sec
.1766	60		rts				rts
.1767					IFloatDivideSupport:
.1767	a2 18		ldx #$18			ldx 	#IFRTemp 					; zero RTemp
.1769	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.176c	5a		phy				phy 								; main division loop x 23
.176d	a0 17		ldy #$17			ldy 	#23
.176f					_IFDSLoop:
.176f	20 a2 15	jsr $15a2			jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
.1772	20 96 15	jsr $1596			jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
.1775	88		dey				dey
.1776	d0 f7		bne $176f			bne 	_IFDSLoop 					; do it 24 times
.1778	7a		ply				ply
.1779	60		rts				rts
.177a					IFloatIntegerToStringR0:
.177a	8d 3e 02	sta $023e			sta 	IFBase 						; save base to use.
.177d	20 5a 1a	jsr $1a5a			jsr 	IFloatBufferReset			; empty buffer
.1780	a5 0f		lda $0f				lda 	IFR0+IExp					; check integer
.1782	29 3f		and #$3f			and 	#IFXMask
.1784	d0 1e		bne $17a4			bne 	_IFIFail
.1786	a2 0c		ldx #$0c			ldx 	#IFR0 						; skip - check if zero.
.1788	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero
.178b	f0 0e		beq $179b			beq 	_IFINotNegative
.178d	a5 0f		lda $0f				lda 	IFR0+IExp 					; is signed ?
.178f	29 40		and #$40			and 	#IFSign
.1791	f0 08		beq $179b			beq 	_IFINotNegative
.1793	a9 2d		lda #$2d			lda 	#"-"						; output -
.1795	20 69 1a	jsr $1a69			jsr 	IFloatBufferWrite
.1798	20 e4 19	jsr $19e4			jsr 	IFloatNegate 				; tidy up !
.179b					_IFINotNegative:
.179b	20 a6 17	jsr $17a6			jsr 	_IFIRecursiveConvert 		; start converting
.179e	20 61 1a	jsr $1a61			jsr 	IFloatGetBufferAddress
.17a1	18		clc				clc
.17a2	80 01		bra $17a5			bra 	_IFIExit
.17a4					_IFIFail:
.17a4	38		sec				sec
.17a5					_IFIExit:
.17a5	60		rts				rts
.17a6					_IFIRecursiveConvert:
.17a6	a2 10		ldx #$10			ldx 	#IFR1
.17a8	20 7b 19	jsr $197b			jsr 	IFloatCopyToRegister 		; R0->R1
.17ab	a2 0c		ldx #$0c			ldx 	#IFR0
.17ad	ad 3e 02	lda $023e			lda 	IFBase 						; Base -> R0
.17b0	20 db 19	jsr $19db			jsr 	IFloatSetByte
.17b3	a2 10		ldx #$10			ldx 	#IFR1 						; R0 = R1 / R0
.17b5	20 3e 15	jsr $153e			jsr 	IFloatDivideInteger
.17b8	a2 0c		ldx #$0c			ldx 	#IFR0 						; if result <> 0
.17ba	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero
.17bd	f0 09		beq $17c8			beq 	_IFIOutDigit
.17bf	a5 10		lda $10				lda 	IFR1+IM0 					; save remainder
.17c1	48		pha				pha
.17c2	20 a6 17	jsr $17a6			jsr 	_IFIRecursiveConvert 		; convert the divider
.17c5	68		pla				pla
.17c6	85 10		sta $10				sta 	IFR1+IM0 					; restore remainder
.17c8					_IFIOutDigit:
.17c8	a5 10		lda $10				lda 	IFR1+IM0 					; get remainder.
.17ca	c9 0a		cmp #$0a			cmp	 	#10
.17cc	90 02		bcc $17d0			bcc 	_IFINotHex
.17ce	69 06		adc #$06			adc 	#6
.17d0					_IFINotHex:
.17d0	69 30		adc #$30			adc 	#48
.17d2	20 69 1a	jsr $1a69			jsr 	IFloatBufferWrite
.17d5	60		rts				rts
.023e					IFBase:
>023e							.fill 	1
.17d6					IFloatFloatToStringR0:
.17d6	a2 14		ldx #$14			ldx 	#IFR2 						; copy R2 to stack,value to R2
.17d8	20 28 19	jsr $1928			jsr 	IFloatPushRx
.17db	20 7b 19	jsr $197b			jsr 	IFloatCopyToRegister
.17de	20 d9 16	jsr $16d9			jsr 	IFloatIntegerR0				; make R0 integer
.17e1	a9 0a		lda #$0a			lda 	#10 						; base 10.
.17e3	20 7a 17	jsr $177a			jsr 	IFloatIntegerToStringR0 	; do the integer part.
.17e6	9c 3f 02	stz $023f			stz 	IFloatDecimalCount 			; zero the decimal count.
.17e9	a5 17		lda $17				lda 	IFR2+IExp 					; is integer.
.17eb	29 3f		and #$3f			and 	#IFXMask
.17ed	f0 44		beq $1833			beq 	_IFFSExit
.17ef					_IFloatFracLoop:
.17ef	a2 14		ldx #$14			ldx 	#IFR2 						; R0 = fractional part of R2
.17f1	20 6a 19	jsr $196a			jsr 	IFloatCopyFromRegister
.17f4	20 83 16	jsr $1683			jsr 	IFloatFractionalR0
.17f7	20 10 1a	jsr $1a10			jsr 	IFloatNormalise
.17fa	a2 14		ldx #$14			ldx 	#IFR2
.17fc	20 7b 19	jsr $197b			jsr 	IFloatCopyToRegister 		; copy to R2
.17ff	a2 14		ldx #$14			ldx 	#IFR2 						; set R2 to 10
.1801	a9 0a		lda #$0a			lda 	#10
.1803	20 db 19	jsr $19db			jsr 	IFloatSetByte
.1806	a2 14		ldx #$14			ldx 	#IFR2						; R0,R2 = R2 * 10
.1808	20 79 14	jsr $1479			jsr 	IFloatMultiply
.180b	a2 14		ldx #$14			ldx 	#IFR2
.180d	20 7b 19	jsr $197b			jsr 	IFloatCopyToRegister
.1810	20 d9 16	jsr $16d9			jsr 	IFloatIntegerR0 			; get integer part of R0
.1813	ad 3f 02	lda $023f			lda 	IFloatDecimalCount 			; done 5 dp, no more
.1816	c9 03		cmp #$03			cmp 	#3
.1818	f0 16		beq $1830			beq 	_IFFSExitStripZero
.181a	ad 3f 02	lda $023f			lda 	IFloatDecimalCount 			; written the DP yet ?
.181d	d0 05		bne $1824			bne 	_IFloatNotFirst
.181f	a9 2e		lda #$2e			lda 	#"." 						; write decimal point
.1821	20 69 1a	jsr $1a69			jsr 	IFloatBufferWrite
.1824					_IFloatNotFirst:
.1824	ee 3f 02	inc $023f			inc 	IFloatDecimalCount
.1827	a5 0c		lda $0c				lda 	IFR0+IM0 					; get digit
.1829	09 30		ora #$30			ora 	#"0"						; ASCII
.182b	20 69 1a	jsr $1a69			jsr 	IFloatBufferWrite 			; write to the buffer.
.182e	80 bf		bra $17ef			bra 	_IFloatFracLoop
.1830					_IFFSExitStripZero:
.1830	20 78 1a	jsr $1a78			jsr 	IFloatStripTrailingZeros
.1833					_IFFSExit:
.1833	a2 14		ldx #$14			ldx 	#IFR2 						; restore R2
.1835	20 49 19	jsr $1949			jsr 	IFloatPullRx
.1838	20 61 1a	jsr $1a61			jsr 	IFloatGetBufferAddress
.183b	18		clc				clc
.183c	60		rts				rts
.023f					IFloatDecimalCount:
>023f							.fill 	1
.183d					IFloatStringToFloatR0:
.183d	8d 40 02	sta $0240			sta 	IFCount 					; save it out.
.1840	86 0a		stx $0a				stx 	iTemp0
.1842	84 0b		sty $0b				sty 	iTemp0+1
.1844	a2 0c		ldx #$0c			ldx 	#IFR0 						; reset the current value.
.1846	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.1849	9c 41 02	stz $0241			stz 	IFSignFlag 					; clear the sign flag
.184c	20 d9 18	jsr $18d9			jsr 	IFSTFGetNext 				; get first
.184f	f0 1b		beq $186c			beq 	_IFSTFFail 					; no character
.1851	90 10		bcc $1863			bcc 	_IFSTFHaveChar 				; legitimate character, go do it.
.1853	c9 2d		cmp #$2d			cmp 	#"-" 						; if not -, fail
.1855	d0 15		bne $186c			bne 	_IFSTFFail
.1857	a9 40		lda #$40			lda 	#IFSign 					; set sign flag
.1859	8d 41 02	sta $0241			sta 	IFSignFlag
.185c					_IFSTFLoop:
.185c	20 d9 18	jsr $18d9			jsr 	IFSTFGetNext 				; get next
.185f	b0 0b		bcs $186c			bcs 	_IFSTFFail 					; bad character.
.1861	f0 11		beq $1874			beq 	_IFSTFExit 					; end of data
.1863					_IFSTFHaveChar:
.1863	c9 2e		cmp #$2e			cmp 	#"."						; decimal point ?
.1865	f0 08		beq $186f			beq 	_IFSTFDecimal
.1867	20 fd 18	jsr $18fd			jsr 	IFSTFAddR0 					; add number in
.186a	80 f0		bra $185c			bra 	_IFSTFLoop 					; keep going until . or end.
.186c					_IFSTFFail:
.186c	38		sec				sec
.186d	80 0d		bra $187c			bra 	_IFSTFReturn
.186f					_IFSTFDecimal:
.186f	20 84 18	jsr $1884			jsr 	IFSTFDecimal 				; call the decimal places code.
.1872	b0 08		bcs $187c			bcs 	_IFSTFReturn 				; error
.1874					_IFSTFExit:
.1874	a5 0f		lda $0f				lda 	IFR0+IExp 					; copy sign flag in.
.1876	0d 41 02	ora $0241			ora 	IFSignFlag
.1879	85 0f		sta $0f				sta 	IFR0+IExp
.187b	18		clc				clc
.187c					_IFSTFReturn:
.187c	60		rts				rts
.187d					IFloatAddDecimalToR0:
.187d	8d 40 02	sta $0240			sta 	IFCount 					; save it out.
.1880	86 0a		stx $0a				stx 	iTemp0
.1882	84 0b		sty $0b				sty 	iTemp0+1
.1884					IFSTFDecimal:
.1884	a2 0c		ldx #$0c			ldx 	#IFR0 						; push integer part on stack
.1886	20 28 19	jsr $1928			jsr 	IFloatPushRx
.1889	a2 0c		ldx #$0c			ldx 	#IFR0 						; R0 is the decimal digits so far.
.188b	20 d9 19	jsr $19d9			jsr 	IFloatSetZero
.188e	9c 42 02	stz $0242			stz 	IFDecimalPlaces
.1891					_IFSTDLoop:
.1891	20 d9 18	jsr $18d9			jsr 	IFSTFGetNext 				; get next
.1894	b0 41		bcs $18d7			bcs 	_IFSTFFail2 				; bad character.
.1896	f0 11		beq $18a9			beq 	_IFSTFComplete 				; end of data, work out the result.
.1898	c9 2e		cmp #$2e			cmp 	#"."						; only one decimal
.189a	f0 39		beq $18d5			beq 	_IFSTFExit2
.189c	20 fd 18	jsr $18fd			jsr 	IFSTFAddR0 					; add number in
.189f	ee 42 02	inc $0242			inc 	IFDecimalPlaces 			; count decimals
.18a2	ad 42 02	lda $0242			lda 	IFDecimalPlaces 			; no more than 3 DP used.
.18a5	c9 03		cmp #$03			cmp 	#3
.18a7	90 e8		bcc $1891			bcc 	_IFSTDLoop
.18a9					_IFSTFComplete:
.18a9	ad 42 02	lda $0242			lda 	IFDecimalPlaces 			; decimals x 4 as accessing multiplier from a LUT.
.18ac	f0 27		beq $18d5			beq 	_IFSTFExit2					; if none, this is syntactically fine, just ignore
.18ae	3a		dec a				dec 	a 							; table indexed from 1.
.18af	0a		asl a				asl 	a
.18b0	0a		asl a				asl 	a
.18b1	aa		tax				tax
.18b2	bd 14 19	lda $1914,x			lda 	TableTen,x 					; copy table entry into R0 - these are 0.1,0.01,0.001
.18b5	85 10		sta $10				sta  	IFR1+IM0 					; 0.0001 etc, up to 5 decimals.
.18b7	bd 15 19	lda $1915,x			lda 	TableTen+1,x
.18ba	85 11		sta $11				sta  	IFR1+IM1
.18bc	bd 16 19	lda $1916,x			lda 	TableTen+2,x
.18bf	85 12		sta $12				sta  	IFR1+IM2
.18c1	bd 17 19	lda $1917,x			lda 	TableTen+3,x
.18c4	85 13		sta $13				sta  	IFR1+IExp
.18c6	a2 10		ldx #$10			ldx 	#IFR1 						; multiply into result
.18c8	20 79 14	jsr $1479			jsr 	IFloatMultiply
.18cb	a2 10		ldx #$10			ldx 	#IFR1  						; pop and add the decimal.
.18cd	20 49 19	jsr $1949			jsr 	IFloatPullRx
.18d0	a2 10		ldx #$10			ldx 	#IFR1
.18d2	20 cf 13	jsr $13cf			jsr 	IFloatAdd
.18d5					_IFSTFExit2:
.18d5	18		clc				clc
.18d6	60		rts				rts
.18d7					_IFSTFFail2:
.18d7	38		sec				sec
.18d8	60		rts				rts
.18d9					IFSTFGetNext:
.18d9	ad 40 02	lda $0240			lda 	IFCount  					; if count is zero, return with Z set.
.18dc	f0 19		beq $18f7			beq 	_IFSTFReturnOk
.18de	b2 0a		lda ($0a)			lda 	(iTemp0) 					; get next character
.18e0	e6 0a		inc $0a				inc 	iTemp0 						; point at next.
.18e2	d0 02		bne $18e6			bne 	_IFSTFGNNoCarry
.18e4	e6 0b		inc $0b				inc 	iTemp0+1
.18e6					_IFSTFGNNoCarry:
.18e6	ce 40 02	dec $0240			dec 	IFCount 					; dec count.
.18e9	c9 2e		cmp #$2e			cmp 	#"."	 					; check, dp is allowed.
.18eb	f0 08		beq $18f5			beq 	_IFSTFGOkay
.18ed	c9 30		cmp #$30			cmp 	#"0"						; < 0 fail.
.18ef	90 08		bcc $18f9			bcc 	_IFSTFGFail
.18f1	c9 3a		cmp #$3a			cmp 	#"9"+1 						; > 9 fail.
.18f3	b0 04		bcs $18f9			bcs 	_IFSTFGFail
.18f5					_IFSTFGOkay:
.18f5	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.18f7					_IFSTFReturnOk:
.18f7	18		clc				clc
.18f8	60		rts				rts
.18f9					_IFSTFGFail:
.18f9	c9 00		cmp #$00			cmp 	#0 							; clears Z flag
.18fb	38		sec				sec
.18fc	60		rts				rts
.18fd					IFSTFAddR0:
.18fd	29 0f		and #$0f			and 	#15 						; to int value
.18ff	48		pha				pha 								; save it.
.1900	a9 0a		lda #$0a			lda 	#10
.1902	a2 10		ldx #$10			ldx 	#IFR1
.1904	20 db 19	jsr $19db			jsr 	IFloatSetByte
.1907	20 79 14	jsr $1479			jsr 	IFloatMultiply
.190a	68		pla				pla
.190b	a2 10		ldx #$10			ldx 	#IFR1
.190d	20 db 19	jsr $19db			jsr 	IFloatSetByte
.1910	20 cf 13	jsr $13cf			jsr 	IFloatAdd
.1913	60		rts				rts
.0240					IFCount:
>0240							.fill 	1
.0241					IFSignFlag:
>0241							.fill 	1
.0242					IFDecimalPlaces:
>0242							.fill 	1
.1914					TableTen:
>1914	9a 19 00 30				.byte	$9a,$19,$00,$30 ; 0.10001
>1918	8f 02 00 30				.byte	$8f,$02,$00,$30 ; 0.00999
>191c	42 00 00 30				.byte	$42,$00,$00,$30 ; 0.00101
>1920	07 00 00 30				.byte	$07,$00,$00,$30 ; 0.00011
>1924	01 00 00 30				.byte	$01,$00,$00,$30 ; 2e-05
.1928					IFloatPushRx:
.1928	5a		phy				phy
.1929	ac 43 02	ldy $0243			ldy 	IFStackIndex
.192c	b5 00		lda $00,x			lda 	IM0,x
.192e	99 44 02	sta $0244,y			sta 	IFStack,y
.1931	b5 01		lda $01,x			lda 	IM1,x
.1933	99 45 02	sta $0245,y			sta 	IFStack+1,y
.1936	b5 02		lda $02,x			lda 	IM2,x
.1938	99 46 02	sta $0246,y			sta 	IFStack+2,y
.193b	b5 03		lda $03,x			lda 	IExp,x
.193d	99 47 02	sta $0247,y			sta 	IFStack+3,y
.1940	c8		iny				iny
.1941	c8		iny				iny
.1942	c8		iny				iny
.1943	c8		iny				iny
.1944	8c 43 02	sty $0243			sty 	IFStackIndex
.1947	7a		ply				ply
.1948	60		rts				rts
.1949					IFloatPullRx:
.1949	5a		phy				phy
.194a	ac 43 02	ldy $0243			ldy 	IFStackIndex
.194d	88		dey				dey
.194e	88		dey				dey
.194f	88		dey				dey
.1950	88		dey				dey
.1951	b9 44 02	lda $0244,y			lda 	IFStack,y
.1954	95 00		sta $00,x			sta 	IM0,x
.1956	b9 45 02	lda $0245,y			lda 	IFStack+1,y
.1959	95 01		sta $01,x			sta 	IM1,x
.195b	b9 46 02	lda $0246,y			lda 	IFStack+2,y
.195e	95 02		sta $02,x			sta 	IM2,x
.1960	b9 47 02	lda $0247,y			lda 	IFStack+3,y
.1963	95 03		sta $03,x			sta 	IExp,x
.1965	8c 43 02	sty $0243			sty 	IFStackIndex
.1968	7a		ply				ply
.1969	60		rts				rts
.0243					IFStackIndex:
>0243							.fill 	1
.0244					IFStack:
>0244							.fill 	16*4
.196a					IFloatCopyFromRegister:
.196a	b5 00		lda $00,x			lda 	0,x
.196c	85 0c		sta $0c				sta 	IFR0
.196e	b5 01		lda $01,x			lda 	1,x
.1970	85 0d		sta $0d				sta 	IFR0+1
.1972	b5 02		lda $02,x			lda 	2,x
.1974	85 0e		sta $0e				sta 	IFR0+2
.1976	b5 03		lda $03,x			lda 	3,x
.1978	85 0f		sta $0f				sta 	IFR0+3
.197a	60		rts				rts
.197b					IFloatCopyToRegister:
.197b	a5 0c		lda $0c				lda 	IFR0
.197d	95 00		sta $00,x			sta 	0,x
.197f	a5 0d		lda $0d				lda 	IFR0+1
.1981	95 01		sta $01,x			sta 	1,x
.1983	a5 0e		lda $0e				lda 	IFR0+2
.1985	95 02		sta $02,x			sta 	2,x
.1987	a5 0f		lda $0f				lda 	IFR0+3
.1989	95 03		sta $03,x			sta 	3,x
.198b	60		rts				rts
.198c					IFloatLoadInline:
.198c	68		pla				pla 								; pop address off to iTemp0
.198d	85 0a		sta $0a				sta 	iTemp0
.198f	68		pla				pla
.1990	85 0b		sta $0b				sta 	iTemp0+1
.1992	a0 01		ldy #$01			ldy 	#1
.1994	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 0
.1996	95 00		sta $00,x			sta 	0,x
.1998	c8		iny				iny
.1999	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 1
.199b	95 01		sta $01,x			sta 	1,x
.199d	c8		iny				iny
.199e	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 2
.19a0	95 02		sta $02,x			sta 	2,x
.19a2	c8		iny				iny
.19a3	b1 0a		lda ($0a),y			lda 	(iTemp0),y 					; copy byte 3
.19a5	95 03		sta $03,x			sta 	3,x
.19a7	18		clc				clc 								; inc pointer, 1 for return, 4 for data
.19a8	a5 0a		lda $0a				lda 	iTemp0
.19aa	69 05		adc #$05			adc 	#5
.19ac	85 0a		sta $0a				sta 	iTemp0
.19ae	90 02		bcc $19b2			bcc 	_IFLINoCarry
.19b0	e6 0b		inc $0b				inc 	iTemp0+1
.19b2					_IFLINoCarry:
.19b2	6c 0a 00	jmp ($000a)			jmp 	(iTemp0)					; effectively RTS
.19b5					IFloatMultiply8BitRx:
.19b5	5a		phy		        phy
.19b6	b5 00		lda $00,x	        lda     IM0,x                       ; AY are the two values
.19b8	a4 0c		ldy $0c		        ldy     IFR0+IM0
.19ba	4a		lsr a		        lsr     a                           ; prime the carry bit for the loop
.19bb	85 0c		sta $0c		        sta     IFR0+IM0
.19bd	84 0d		sty $0d		        sty     IFR0+IM1
.19bf	a9 00		lda #$00	        lda     #0
.19c1	a0 08		ldy #$08	        ldy     #8
.19c3					_IFMLoop:
.19c3	90 03		bcc $19c8	        bcc     _IFMNoAdd
.19c5	18		clc		        clc
.19c6	65 0d		adc $0d		        adc     IFR0+IM1
.19c8					_IFMNoAdd:
.19c8	6a		ror a		        ror     a
.19c9	66 0c		ror $0c		        ror     IFR0+IM0                    ; pull another bit out for the next iteration
.19cb	88		dey		        dey
.19cc	d0 f5		bne $19c3	        bne     _IFMLoop
.19ce	85 0d		sta $0d		        sta     IFR0+IM1                    ; write MSB out
.19d0	7a		ply		        ply
.19d1	60		rts		        rts
.19d2					IFloatCheckZero:
.19d2	b5 00		lda $00,x			lda 	IM0,x
.19d4	15 01		ora $01,x			ora 	IM1,x
.19d6	15 02		ora $02,x			ora 	IM2,x
.19d8	60		rts				rts
.19d9					IFloatSetZero:
.19d9	a9 00		lda #$00			lda 	#0
.19db					IFloatSetByte:
.19db	95 00		sta $00,x			sta 	IM0,x 						; set mantissa to 00A
.19dd	74 01		stz $01,x			stz 	IM1,x
.19df	74 02		stz $02,x			stz 	IM2,x
.19e1	74 03		stz $03,x			stz 	IExp,x 						; zero the exponent.
.19e3	60		rts				rts
.19e4					IFloatNegate:
.19e4	b5 03		lda $03,x			lda 	IExp,x
.19e6	49 40		eor #$40			eor 	#IFSign
.19e8	95 03		sta $03,x			sta 	IExp,x
.19ea	18		clc				clc
.19eb	60		rts				rts
.19ec					IFloatMantissaNegate:
.19ec	38		sec				sec
.19ed	a9 00		lda #$00			lda 	#0
.19ef	f5 00		sbc $00,x			sbc 	IM0,x
.19f1	95 00		sta $00,x			sta 	IM0,x
.19f3	a9 00		lda #$00			lda 	#0
.19f5	f5 01		sbc $01,x			sbc 	IM1,x
.19f7	95 01		sta $01,x			sta 	IM1,x
.19f9	a9 00		lda #$00			lda 	#0
.19fb	f5 02		sbc $02,x			sbc 	IM2,x
.19fd	95 02		sta $02,x			sta 	IM2,x
.19ff	60		rts				rts
.1a00					IFloatShiftLeft:
.1a00	18		clc				clc
.1a01					IFloatRotateLeft:
.1a01	36 00		rol $00,x			rol 	IM0,x
.1a03	36 01		rol $01,x			rol 	IM1,x
.1a05	36 02		rol $02,x			rol 	IM2,x
.1a07	60		rts				rts
.1a08					IFloatShiftRight:
.1a08	18		clc				clc
.1a09					IFloatRotateRight:
.1a09	76 02		ror $02,x			ror 	IM2,x
.1a0b	76 01		ror $01,x			ror 	IM1,x
.1a0d	76 00		ror $00,x			ror 	IM0,x
.1a0f	60		rts				rts
.1a10					IFloatNormalise:
.1a10	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero 			; is it zero
.1a13	f0 18		beq $1a2d			beq 	_IFNExitZero 				; if so exit
.1a15					_IFNLoop:
.1a15	b5 02		lda $02,x			lda 	IM2,x 						; is it normalised e.g. bits 7/6 are 01
.1a17	29 c0		and #$c0			and 	#$C0
.1a19	c9 40		cmp #$40			cmp 	#$40
.1a1b	f0 13		beq $1a30			beq 	_IFNExitOkay 				; if so , then we are done.
.1a1d	b5 03		lda $03,x			lda 	IExp,x 						; check exponent is not -32 already.
.1a1f	29 3f		and #$3f			and 	#$3F
.1a21	c9 20		cmp #$20			cmp 	#$20
.1a23	f0 0b		beq $1a30			beq 	_IFNExitOkay 				; if so, then we cannot normalise any more.
.1a25	20 46 1a	jsr $1a46			jsr 	IFloatDecExponent
.1a28	20 00 1a	jsr $1a00			jsr 	IFloatShiftLeft 			; shift mantissa left, e.g. multiply by 2
.1a2b	80 e8		bra $1a15			bra 	_IFNLoop
.1a2d					_IFNExitZero:
.1a2d	20 d9 19	jsr $19d9			jsr 	IFloatSetZero 				; set the result to zero
.1a30					_IFNExitOkay:
.1a30	18		clc				clc  								; return with CC.
.1a31	60		rts				rts
.1a32					IFloatIncExponent:
.1a32	b5 03		lda $03,x			lda 	IExp,x
.1a34	48		pha				pha
.1a35	29 c0		and #$c0			and 	#$C0
.1a37	8d 84 02	sta $0284			sta 	IFXTemp
.1a3a	68		pla				pla
.1a3b	1a		inc a				inc 	a
.1a3c	29 3f		and #$3f			and 	#$3F
.1a3e	48		pha				pha
.1a3f	0d 84 02	ora $0284			ora 	IFXTemp
.1a42	95 03		sta $03,x			sta 	IExp,x
.1a44	68		pla				pla
.1a45	60		rts				rts
.1a46					IFloatDecExponent:
.1a46	b5 03		lda $03,x			lda 	IExp,x
.1a48	48		pha				pha
.1a49	29 c0		and #$c0			and 	#$C0
.1a4b	8d 84 02	sta $0284			sta 	IFXTemp
.1a4e	68		pla				pla
.1a4f	3a		dec a				dec 	a
.1a50	29 3f		and #$3f			and 	#$3F
.1a52	48		pha				pha
.1a53	0d 84 02	ora $0284			ora 	IFXTemp
.1a56	95 03		sta $03,x			sta 	IExp,x
.1a58	68		pla				pla
.1a59	60		rts				rts
.0284					IFXTemp:
>0284							.fill 	1
.1a5a					IFloatBufferReset:
.1a5a	9c 85 02	stz $0285			stz 	IFBufferCount
.1a5d	9c 86 02	stz $0286			stz 	IFBuffer
.1a60	60		rts				rts
.1a61					IFloatGetBufferAddress:
.1a61	a0 02		ldy #$02			ldy 	#(IFBuffer >> 8)
.1a63	a2 86		ldx #$86			ldx 	#(IFBuffer & $FF)
.1a65	ad 85 02	lda $0285			lda 	IFBufferCount
.1a68	60		rts				rts
.1a69					IFloatBufferWrite:
.1a69	da		phx				phx
.1a6a	ae 85 02	ldx $0285			ldx 	IFBufferCount
.1a6d	9d 86 02	sta $0286,x			sta 	IFBuffer,x
.1a70	9e 87 02	stz $0287,x			stz 	IFBuffer+1,x
.1a73	ee 85 02	inc $0285			inc 	IFBufferCount
.1a76	fa		plx				plx
.1a77	60		rts				rts
.1a78					IFloatStripTrailingZeros:
.1a78	ae 85 02	ldx $0285			ldx 	IFBufferCount
.1a7b	bd 85 02	lda $0285,x			lda 	IFBuffer-1,x
.1a7e	c9 30		cmp #$30			cmp		#"0"
.1a80	d0 0f		bne $1a91			bne 	_IFSTExit
.1a82	bd 84 02	lda $0284,x			lda 	IFBuffer-2,x
.1a85	c9 2e		cmp #$2e			cmp 	#"."
.1a87	f0 08		beq $1a91			beq 	_IFSTExit
.1a89	ce 85 02	dec $0285			dec 	IFBufferCount
.1a8c	9e 85 02	stz $0285,x			stz 	IFBuffer-1,x
.1a8f	80 e7		bra $1a78			bra 	IFloatStripTrailingZeros
.1a91					_IFSTExit:
.1a91	60		rts				rts
.0285					IFBufferCount:
>0285							.fill 	1
.0286					IFBuffer:
>0286							.fill 	25
.1a92					IFloatCheck:
.1a92	a5 0f		lda $0f				lda 	IFR0+IExp					; force it negative
.1a94	09 40		ora #$40			ora 	#IFSign
.1a96	85 0f		sta $0f				sta 	IFR0+IExp
.1a98	20 cf 13	jsr $13cf			jsr 	IFloatAdd 					; add allowed to error.
.1a9b	a2 0c		ldx #$0c			ldx 	#IFR0
.1a9d	20 d2 19	jsr $19d2			jsr 	IFloatCheckZero 			; error if < 0
.1aa0	f0 06		beq $1aa8			beq 	_IFAOkay
.1aa2	a5 0f		lda $0f				lda 	IFR0+IExp
.1aa4	29 40		and #$40			and 	#IFSign
.1aa6	d0 01		bne $1aa9			bne 	_IFAFail
.1aa8					_IFAOkay:
.1aa8	60		rts				rts
.1aa9					_IFAFail:
.1aa9	38		sec				sec
.1aaa	68		pla				pla 								; get address - 2
.1aab	e9 02		sbc #$02			sbc 	#2
.1aad	aa		tax				tax
.1aae	68		pla				pla
.1aaf	e9 00		sbc #$00			sbc 	#0
.1ab1	a8		tay				tay
.1ab2	a9 aa		lda #$aa			lda 	#$AA 						; sign assert
.1ab4					_IFAStop:
>1ab4	db						.byte 	$DB 						; display an error AA ADR ADR
.1ab5	80 fd		bra $1ab4			bra 	_IFAStop

;******  Return to file: basic.asm

.1ab7					NotImplemented:
.1ab7					ErrorHandler:
>1ab7	db						.byte 	$DB
.1ab8	a9 ee		lda #$ee			lda 	#$EE
.1aba	4c b7 1a	jmp $1ab7			jmp 	ErrorHandler

;******  End of listing
