;
;	This file is automatically generated.
;
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		readheader.asm
;		Purpose:	Read a sector header
;		Created:	2nd July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									    Read a header
;
; ************************************************************************************************

		.section code

FSReadNextHeader:
		inc 	currentSector 				; bump last sector and read next one.
		lda 	currentSector
FSReadHeaderA:
		cmp 	#0 							; sector 0 always okay.
		beq 	_FSIsOk
		cmp 	sectorCount 				; check legitimate sector
		bcs 	_FSReadHFail
_FSIsOk:
		phx
		sta 	currentSector 				; save as current
		jsr 	FSHOpenRead 				; open for read
		ldx 	#0 							; read in.
_FSReadHLoop:
		jsr 	FSHRead
		sta 	sectorHeader,x
		inx
		cpx 	#32
		bne 	_FSReadHLoop
		jsr 	FSHEndCommand				; end read.
		plx

		lda 	shFileSize 					; copy file size - makes easily accessible
		sta 	shFileSizeCopy 				; for directory function.
		lda 	shFileSize+1
		sta 	shFileSizeCopy+1

		clc
		rts
_FSReadHFail:
		sec
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		read.asm
;		Purpose:	Read a file
;		Created:	2nd July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Read File
;
;						   On entry, YX points to a file block.
;							On exit, CS if file not found.
;
; ************************************************************************************************

		.section code

OSReadFile:
		stx 	fsBlock 					; file block.
		sty 	fsBlock+1

		stz 	currentSector
		lda 	#$FF 						; set flag to $FF
		sta 	successFlag
		;
		;		Look for (F)irst
		;
_OSReadLoop1:
		jsr 	FSReadNextHeader 			; read header ?
		bcs 	_OSReadExit 				; end of search.
		lda 	shFirstNext 				; is it the (F)irst record
		cmp 	#"F"
		bne 	_OSReadLoop1
		jsr 	FSCompareFileNames 			; is it F/N and matching.
		bcc 	_OSReadLoop1 				; no, try next sector
		stz 	successFlag 				; zero when found file.

_OSReadBlock:
		lda 	currentSector
		jsr 	FSReadData 					; read the data file in.
		lda 	shContinue 					; continuation ?
		cmp 	#"N" 						; exit if no.
		beq 	_OSReadExit
		;
_OSReadLoop2:
		lda 	currentSector
		jsr 	FSReadNextHeader 			; read header ?
		bcs 	_OSReadExit 				; end of search.
		lda 	shFirstNext 				; is it the (F)irst record
		cmp 	#"N"
		bne 	_OSReadLoop2
		jsr 	FSCompareFileNames 			; is it F/N and matching.
		bcc 	_OSReadLoop2 				; no, try next sector
		bra 	_OSReadBlock 				; read block in.

_OSReadExit:
		asl 	successFlag					; shift success flag (0 if done) into carry
		rts

; ************************************************************************************************
;
;								Read current sector into memory
;
; ************************************************************************************************

FSReadData:
		lda 	currentSector
		jsr 	FSHOpenRead 				; open for read
		ldx 	#32 						; read past the header
_FSReadHLoop:
		jsr 	FSHRead
		dex
		bne 	_FSReadHLoop
		;
_FSRDCopy:
		lda 	shDataSize 					; datasize count zero ?
		ora 	shDataSize+1
		beq 	_OSRDExit
		;
		lda 	shDataSize 					; decrement the data count.
		bne 	_OSRDNoBorrow
		dec 	shDataSize+1
_OSRDNoBorrow:
		dec 	shDataSize
		;
		jsr 	FSIncrementSetLoad 			; load address to zTemp0 and increment it.
		jsr 	FSHRead 					; copy byte there
		sta 	(iTemp0)
		bra 	_FSRDCopy 					; go round again.

_OSRDExit:
		jsr 	FSHEndCommand
		rts

; ************************************************************************************************
;
;						Copy load/save address to zTemp0, increment it.
;
; ************************************************************************************************

FSIncrementSetLoad:
		clc
		ldy 	#2 							; increment load address
		lda 	(fsBlock),y  				; copying previous to zTemp0
		sta 	iTemp0
		adc 	#1
		sta 	(fsBlock),y
		iny
		lda 	(fsBlock),y
		sta 	iTemp0+1
		adc 	#0
		sta 	(fsBlock),y
		rts


		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		read.asm
;		Purpose:	Read a file
;		Created:	3rd July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Write File
;
;						   On entry, YX points to a file block.
;					  On exit, CS if failed (most likely no space)
;
; ************************************************************************************************

		.section code

OSWriteFile:
		stx 	fsBlock 					; file block.
		sty 	fsBlock+1
		jsr 	OSDeleteFile 				; delete file if it already exists.
		stz 	currentSector
		stz 	notFirstSector 				; clear "not first sector" (e.g. is first sector)
		;
		sec 								; work out bytes per sector available.
		lda 	sectorSize 					; (sector size - 32)
		sbc 	#32
		sta 	sectorCapacity
		lda 	sectorSize+1
		sbc 	#0
		sta 	sectorCapacity+1
		;
		ldy 	#4 							; copy the size of the data to write to
		lda 	(fsBlock),y 				; the remaining size variable.
		sta 	fileRemainingSize
		iny
		lda 	(fsBlock),y
		sta 	fileRemainingSize+1
		;
		;		Main write loop. First find an empty slot.
		;
_OSWriteLoop:
		lda 	sectorCount  				; so we count incase we are full.
		sta 	iTemp0
		;
_OSFindUnused:
		dec 	iTemp0 						; done a full lap, no empty slots
		beq 	_OSWriteFail
		jsr 	FSReadNextHeader 			; read next header
		lda 	shFirstNext 				; check F, N , I
		cmp 	#"I"
		beq 	_OSFindUnused
		cmp 	#"N"
		beq 	_OSFindUnused
		cmp 	#"F"
		beq 	_OSFindUnused
		;
		lda 	currentSector 				; erase sector
		jsr 	FSHErase
		lda 	currentSector 				; open for write.
		jsr 	FSHOpenWrite
		jsr 	FSWriteCreateHeader 		; create header
		jsr 	FSWriteSendData 			; send the data
		jsr 	FSHEndCommand 				; and we're done this block.
		;
		dec 	notFirstSector 				; set not first sector state.
		;
		lda 	fileRemainingSize 			; check there is more to save, if not then exit.
		ora 	fileRemainingSize+1
		bne		_OSWriteLoop
		clc
		rts
		;
		;		Come here on failure (probably out of space)
		;
_OSWriteFail:
		jsr 	OSDeleteFile 				; delete any parts of the file.
		sec 								; return error
		rts

; ************************************************************************************************
;
;										Create the 32 byte header
;
; ************************************************************************************************

FSWriteCreateHeader:
		;
		;		First or Next flag
		;
		lda 	#"N"						; first or next ?
		ldx 	notFirstSector
		bne 	_FSWCNotNext
		lda 	#"F"
_FSWCNotNext:
		jsr 	FSHWrite 					; +0 (first or next)
		;
		;		Work out the number of bytes going out into YX
		;
		ldx 	fileRemainingSize 			; XY is the number of bytes.
		ldy 	fileRemainingSize+1
		;
		cpx 	sectorCapacity 				; compare fileRemaining vs sectorCapacity
		tya
		sbc 	sectorCapacity+1
		bcc 	_FSNotFull
		ldx 	sectorCapacity 				; if remaining >= capacity ... use capacity
		ldy 	sectorCapacity+1
_FSNotFull:
		stx 	bytesToWrite
		sty 	bytesToWrite+1
		;
		;		More records ? (YX = file Remaining size)
		;
		lda 	#"Y"
		cpx 	fileRemainingSize
		bne 	_FSNotAll
		cpy 	fileRemainingSize+1
		bne 	_FSNotAll
		lda 	#"N"
_FSNotAll:
		jsr 	FSHWrite 					; +1 (has more data)
		;
		;		Output data size and file size.
		;
		txa 								; +2,+3 (data to send out)
		jsr 	FSHWrite
		tya
		jsr 	FSHWrite
		;
		ldy 	#4
		lda 	(fsBlock),y
		jsr 	FSHWrite
		iny
		lda 	(fsBlock),y
		jsr 	FSHWrite
		;
		;		Output 10 char gap which is reserved.
		;
		ldx		#10 						; output 10 blanks
_FSWCBlanks:
		lda 	#$FF
		jsr 	FSHWrite
		dex
		bne 	_FSWCBlanks
		;
		;		Output name
		;
		ldy 	#1
		lda 	(fsBlock),y
		sta 	iTemp0+1
		lda 	(fsBlock)
		sta 	iTemp0
		;
		lda 	(iTemp0) 					; output length, also => X
		tax
		jsr 	FSHWrite
_FSOutName: 								; output name
		dex
		bmi 	_FSNameDone
		lda 	(iTemp0),y
		iny
		jsr 	FSHWrite
		bra 	_FSOutName
_FSNameDone:				 				; pad out to 32 byte header.
		lda 	#$FF
		jsr 	FSHWrite
		iny
		cpy 	#16
		bne 	_FSNameDone
		rts

; ************************************************************************************************
;
;										Output the body
;
; ************************************************************************************************

FSWriteSendData:
		lda 	bytesToWrite 				; complete
		ora 	bytesToWrite+1
		beq 	_FSWSDExit
		jsr 	FSIncrementSetLoad 			; bump address, copy original to iTemp0
		lda 	(iTemp0)
		jsr 	FSHWrite
		;
		lda 	bytesToWrite 				; decrement bytes to write counter
		bne 	_FSWSDNoBorrow
		dec 	bytesToWrite+1
_FSWSDNoBorrow:
		dec 	bytesToWrite

		lda 	fileRemainingSize 			; decrement remaining size.
		bne 	_FSWSDNoBorrow2
		dec 	fileRemainingSize+1
_FSWSDNoBorrow2:
		dec 	fileRemainingSize
		bra 	FSWriteSendData

_FSWSDExit:
		rts

		.send code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		directory.asm
;		Purpose:	Read a directory
;		Created:	2nd July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Directory Read.
;
;	Enter with CS to initialise.
;
;	Each subsequent call returns either CS (end of directory)
;										CC (record available), YX points to name (len prefix)
;
; ************************************************************************************************

		.section code

OSReadDirectory:
		bcs 	_OSRDReset
		;
_OSRDLoop:
		jsr 	FSReadNextHeader 			; read next sector header.
		bcs 	_OSRDExit 					; exit, end of file space, CS
		lda 	shFirstNext 				; is it an 'F' record
		cmp 	#'F'
		bne 	_OSRDLoop
		ldx 	#shNameLength & $FF 		; return the buffer address
		ldy 	#shNameLength >> 8
		clc 								; return with carry clear.
		rts

_OSRDReset:
		stz 	currentSector 				; back to the start.
_OSRDExit:
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		delete.asm
;		Purpose:	Delete a file
;		Created:	2nd July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Delete File
;
;						   On entry, YX points to a file block.
;							On exit, CS if file not found.
;
; ************************************************************************************************

		.section code

OSDeleteFile:
		stx 	fsBlock 					; file block.
		sty 	fsBlock+1

		stz 	currentSector
		lda 	#$FF 						; set flag to $FF
		sta 	successFlag
_OSDeleteLoop:
		jsr 	FSReadNextHeader 			; read header ?
		bcs 	_OSDeleteExit 				; end of search.
		jsr 	FSCompareFileNames 			; is it F/N and matching.
		bcc 	_OSDeleteLoop 				; no, try next sector

		lda 	currentSector 				; yes, then erase this sector
		jsr 	FSHErase
		stz 	successFlag 				; zero if successful
		bra 	_OSDeleteLoop
_OSDeleteExit:
		asl 	successFlag					; shift success flag (0 if done) into carry
		rts

; ************************************************************************************************
;
;			Check current header is (F)irst (N)ext and name matches that in iBlock
;										CS if match found
;
; ************************************************************************************************

FSCompareFileNames:
		lda 	shFirstNext 				; is it F/N type ?
		cmp 	#"F"
		beq 	_FSDeleteCheckName
		cmp 	#"N"
		bne 	_FSCompareFail 				; no, then compare fails.
_FSDeleteCheckName:
		ldy 	#1 							; copy filename to iTemp0
		lda 	(fsBlock)
		sta 	iTemp0
		lda 	(fsBlock),y
		sta 	iTemp0+1
		;
		lda 	(iTemp0) 					; compare n+1
		tay
_FSCompareName:
		lda 	shNameLength,y
		cmp 	(iTemp0),y
		bne 	_FSCompareFail
		dey
		bpl 	_FSCompareName
		sec
		rts

_FSCompareFail:
		clc
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		initialise.asm
;		Purpose:	Initialise the Filesystem library
;		Created:	1st July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Initialise the Filesystem
;
; ************************************************************************************************

		.section code

FSInitialise:
		stz 	sectorCount 				; initial values to read $00
		stz 	sectorCount+1
		stz 	sectorSize
		stz 	sectorSize+1
		;
		;		Read in from the first sector (unaffected by size or count !)
		;		the sector size and count values.
		;
		;		Note in this version, a maximum of 256 sectors only allowed.
		;
		lda 	#0 							; read header sector 0
		jsr 	FSReadHeaderA

		lda 	sectorHeader+2 				; copy sector count
		sta 	sectorCount
		lda 	sectorHeader+3
		sta 	sectorCount+1

		lda 	sectorHeader+4 				; sector size power

		inc 	sectorSize 					; convert to sector size.
_FSICalcSS:
		asl 	sectorSize
		rol 	sectorSize+1
		dec 	a
		bne 	_FSICalcSS

		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		emulator.asm
;		Purpose:	Emulator interface
;		Created:	1st July 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;									Interface to Flash Hardware
;
; ************************************************************************************************

		.section code

flash 	.macro
		sta 	$CF11 						; save data
		lda 	#\1 						; activate on command write
		sta 	$CF10
		.endm

FSHErase:
		.flash 	0
		rts

FSHOpenRead:
		.flash 	1
		rts

FSHOpenWrite:
		.flash 	2
		rts

FSHRead:
		.flash 	3
		lda 	$CF12
		rts

FSHWrite:
		.flash 	4
		rts

FSHEndCommand:
		.flash 	5
		rts

		.send code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

