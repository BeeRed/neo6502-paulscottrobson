;
;	This file is automatically generated.
;
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		macros.inc
;		Purpose:	Macros
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;										Useful macros
;
; ************************************************************************************************

binop 	.macro
	lda 	IFR0+IM0
	\1 		IM0,x
	sta 	IFR0+IM0
	lda 	IFR0+IM1
	\1 		IM1,x
	sta 	IFR0+IM1
	lda 	IFR0+IM2
	\1 		IM2,x
	sta 	IFR0+IM2
	.endm

IM0 = 0
IM1 = 1
IM2 = 2
IExp = 3

IFXMask = $3F
IFSign = $40

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		initialise.asm
;		Purpose:	Initialise the library
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;										Initialise the library
;
; ************************************************************************************************

IFInitialise:
		stz 	IFStackIndex
		rts

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		add.asm
;		Purpose:	Add two numbers
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Sub two numbers R0 = RX - R0
;
; ************************************************************************************************

IFloatSubtract:
		phx
		ldx 	#IFR0
		jsr 	IFloatNegate 				; negate R0 and fall through to add.
		plx

; ************************************************************************************************
;
;								Add two numbers R0 = RX + R0
;
; ************************************************************************************************

IFloatAdd:
		lda 	IExp,x 						; check if both exponents are zero.
		ora 	IFR0+IExp
		and 	#IFXMask 					; if not, then we have to do the
		bne 	_IFloatAddDecimals 			; decimal version.
;
;		Add or Subtract the mantissae, adjusting the result accordingly.
;
_IFAddSubMantissa:
		lda 	IExp,x 						; are the signs different ?
		eor 	IFR0+IExp
		and 	#IFSign
		bne 	_IFloatSubMantissa
		;
		;		Addition of the mantissae.
		;
		clc 								; do the actual addition
		.binop 	adc 						; the sign is that of R0 e.g. 4 + 5 = 9
		bpl 	_IFloatAddExit 				; if no carry through to bit 23, then exit.
		;
		ldx 	#IFR0						; shift R0 right, divide by 2
		jsr 	IFloatShiftRight
		jsr 	IFloatIncExponent
		bne 	_IFloatAddExit
		sec 								; overflowed numerically.
		rts
		;
		;		Subtraction of the mantissae
		;
_IFloatSubMantissa:
		sec 								; do the subtraction R0-Rx
		.binop 	sbc 						; the sign is that of R0 e.g. 7-3 = 4
		bcs 	_IFloatAddExit 				; no borrow so we are done.
		;
		ldx 	#IFR0
		jsr 	IFloatMantissaNegate 		; 2's complement negate the mantissa
		jsr 	IFloatNegate 				; negate
_IFloatAddExit:
		clc
		rts

_IFloatZeroAdd:
		plx 								; return this value in R0
		jsr 	IFloatCopyFromRegister
		clc
		rts

_IFloatAddDecimals:
		jsr		IFloatCheckZero 			; if RX = 0 then exit with R0
		beq 	_IFloatAddExit

		jsr 	IFloatNormalise 			; normalise RX
		phx 								; normalise R0
		ldx 	#IFR0
		jsr 	IFloatCheckZero
		beq 	_IFloatZeroAdd
		jsr 	IFloatNormalise
		plx
		;
		lda 	IFR0+IExp 					; get the exponent of R0
		and 	#IFXMask
		sec
		sbc 	#$20 						; map 20..3F..00..1F to 00..0F..E0..FF e.g. scaled unsigned
		sta 	iTemp0
		;
		lda 	IExp,x 						; repeat for exponent of Rx
		and 	#IFXMask
		sec
		sbc 	#$20
		cmp 	iTemp0 						; get the larger adjusted
		bcs 	_IFloatHaveLarger
		lda 	iTemp0
_IFloatHaveLarger:
		clc 								; get the actual one back.
		adc 	#$20 						; shift both to that.
		jsr 	_IFShiftXToA
		phx
		ldx 	#IFR0
		jsr 	_IFShiftXToA
		plx
		jmp 	_IFAddSubMantissa 			; do the adding bit.

_IFShiftXToA:
		sta 	IFTarget
		jsr 	IFloatCheckZero 			; check adding zero ?
		beq 	_IFSXExit
_IFSXLoop:
		lda 	IExp,x 	 					; shifted to the right level yet ?
		and 	#IFXMask
		cmp 	IFTarget
		beq 	_IFSXExit
		jsr 	IFloatShiftRight
		jsr 	IFloatIncExponent
		bra 	_IFSXLoop
_IFSXExit:
		rts

		.send 	code

		.section storage
IFTarget:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		multiply.asm
;		Purpose:	Multiply two numbers
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Multiply two numbers R0 = RX * R0
;
; ************************************************************************************************

IFloatMultiply:
		stx 	IFTarget 					; save the multiplier (RX) which is "adder"
		jsr 	IFCalculateNewSign
		;
		;		Check for fast multiply.
		;
		lda 	IExp,x 						; check two positive 8 bit integers
		ora 	IFR0+IExp
		and 	#IFXMask
		ora 	IM1,x
		ora 	IFR0+IM1
		ora 	IM2,x
		ora 	IFR0+IM2
		bne 	_IFMStandard
		jsr 	IFloatMultiply8BitRx
		lda 	IFNewSign
		sta 	IFR0+IExp
		clc
		rts

_IFMStandard:
		;
		;		Add the two exponents, sign extended.
		;
		lda 	IExp,x 						; add the two exponents sign extended
		jsr 	IFMSignExtend
		sta 	IFNewExponent
		lda 	IFR0+IExp
		jsr 	IFMSignExtend
		clc
		adc 	IFNewExponent
		sta 	IFNewExponent

		ldx 	#IFRTemp 					; copy R0 to RTemp which is "shifter"
		jsr 	IFloatCopyToRegister

		ldx 	#IFR0 						; zero R0 (the result)
		jsr 	IFloatSetZero
		; --------------------------------------------------------------------------------
		;
		;								Multiplication loop
		;
		; --------------------------------------------------------------------------------
_IFMLoop:
		;
		;		Check if shifter (RTemp) has reached zero
		;
		ldx 	#IFRTemp
		jsr 	IFloatCheckZero
		beq 	_IFMExit
		;
		; 		Has adder overflown, if so we need to right shift everything
		;
		ldx 	IFTarget 					; look at adder MSB
		lda 	IM2,x 						; if it is set we need to shift everything
		bpl	 	_IFMTargetOkay
		jsr 	_IFMShiftAll
_IFMTargetOkay:
		;
		;		if bit 0 of shifter set, add Rx to R0.
		;
		lda 	IFRTemp+0 					; is bit 0 of the shifter (RTemp) set
		and 	#1
		beq 	_IFMNoAdd
		ldx 	IFTarget 					; add adder
		clc
		.binop 	adc
_IFMNoAdd:
		;
		;		if the result in R0 has overflowed, then right shift everything
		;
		lda 	IFR0+IM2
		bpl 	_IFMResultOkay
		jsr 	_IFMShiftAll
_IFMResultOkay:
		;
		;		Shifter shift left, adder shift right.
		;
		ldx 	#IFRTemp
		jsr 	IFloatShiftRight
		ldx 	IFTarget
		jsr 	IFloatShiftLeft
		;
		bra 	_IFMLoop
		;
		; 		Exit - work out the new exponent and sign and exit with error on overflow, zero on underflow.
		;
_IFMExit:
		lda 	IFNewExponent 				; validate new exponent.
		cmp 	#$20 						; valid exponent 00-1F E0-FF
		bcc 	_IFMOkay
		cmp 	#$E0
		bcs 	_IFMOkay
		;
		and 	#$80 						; if +ve exponent then error overflow.
		beq 	_IFMError
		ldx 	#IFR0 						; return zero underflow
		jsr 	IFloatSetZero
		clc
		rts
		;
		;		Value is A-Ok.
		;
_IFMOkay:
		and 	#IFXMask 					; work out exponent + sign and exit
		ora 	IFNewSign
		sta 	IFR0+IExp
		clc
		rts

		jmp 	$FFFF

_IFMError:
		sec
		rts

;
;		Shift the whole calculation right : the adder, the result, and increment the new exponent to handle it.
;
_IFMShiftAll:
		ldx 	#IFR0
		jsr 	IFloatShiftRight
		ldx 	IFTarget
		jsr 	IFloatShiftRight
		inc 	IFNewExponent
		rts

;
;		Mask out and sign extend the
;
IFMSignExtend:
		and 	#IFXMask
		cmp 	#(IFXMask >> 1)
		bcc 	_IFMNoSXX
		ora 	#IFXMask ^ $FF
_IFMNoSXX:
		rts

; ************************************************************************************************
;
;								Calculate the sign of the result
;
; ************************************************************************************************

IFCalculateNewSign:
		lda 	IExp,x
		eor 	IFR0+IExp
		and 	#IFSign
		sta 	IFNewSign
		rts

		.send 	code

		.section storage
IFNewExponent:
		.fill 	1
IFNewSign:
		.fill 	1
		.send storage


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		idivide.asm
;		Purpose:	Divide two integers
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Integer Divide/Modulus two integers R0 = RX / R0
;
; ************************************************************************************************

IFloatDivideInteger:
		jsr 	IFloatDivideIntegerCommon 	; do the common code.
		bcs 	_IFDIExit
		ldx 	#IFRTemp 					; copy result from register.
		jsr 	IFloatCopyFromRegister
		clc
_IFDIExit:
		rts

IFloatModulusInteger:
		jsr 	IFloatDivideIntegerCommon
		bcs 	_IFMIExit
		ldx 	IFTarget
		jsr 	IFloatCopyFromRegister
		clc
_IFMIExit:
		rts

IFloatDivideIntegerCommon:
		stx 	IFTarget  					; this is s1, s0 = R0
		jsr 	IFCalculateNewSign 			; calculate sign of result

		jsr 	IFDCopyRXToRTemp 			; copy S1 to RTemp

		ldx 	#IFR0 						; check divide by zero
		jsr 	IFloatCheckZero
		beq 	_IFDIDivZero

		ldx 	IFTarget 					; zero Rx (S1)
		jsr 	IFloatSetZero

		phy
		ldy 	#24
_IFDILoop:
		jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
		jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
		dey
		bne 	_IFDILoop 					; do it 24 times
		ply

		lda 	IFNewSign 					; set sign of result.
		and 	#IFSign
		sta 	IFRTemp+IExp
		clc 								; is okay.
		rts

_IFDIDivZero:
		sec
		rts

; ************************************************************************************************
;
;							Support routine : Copy RX to RTemp
;
; ************************************************************************************************

IFDCopyRXToRTemp:
		lda 	IM0,x
		sta 	IFRTemp+IM0
		lda 	IM1,x
		sta 	IFRTemp+IM1
		lda 	IM2,x
		sta 	IFRTemp+IM2
		lda 	IExp,x
		sta 	IFRTemp+IExp
		rts

; ************************************************************************************************
;
;						Support routine : shift RTemp:R0 left one bit
;
; ************************************************************************************************

IFDShiftSTempS1Left:
		ldx 	#IFRTemp
		jsr 	IFloatShiftLeft
		ldx 	IFTarget
		jsr 	IFloatRotateLeft
		rts

; ************************************************************************************************
;
;		Support routine - subtract s0.mantissa from s1.mantissa if possible, if subtracted
;		increment STemp.mantissa
;
; ************************************************************************************************

IFDTrySubtract:
		ldx 	IFTarget 					; s1 = Rx
		;
		sec 								; subtract, saving the results on the stack.
		lda 	IM0,x
		sbc 	IFR0+IM0
		pha

		lda 	IM1,x
		sbc 	IFR0+IM1
		pha

		lda 	IM2,x
		sbc 	IFR0+IM2
		bcs 	_IFDCanSubtract

		pla 								; cannot subtract, so pop intermediate and exit.
		pla
		rts

_IFDCanSubtract:
		sta 	IM2,x 						; write back to S1.Mantissa
		pla
		sta 	IM1,x
		pla
		sta 	IM0,x
		;
		inc 	IFRTemp+IM0 				; increment temp
		bne 	_IFDCSExit
		inc 	IFRTemp+IM1
		bne 	_IFDCSExit
		inc 	IFRTemp+IM2
_IFDCSExit:
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		logical.asm
;		Purpose:	Logical operators
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									Bitwise AND R0 := R0 & Rx
;
; ************************************************************************************************

IFloatBitwiseAnd:
		phy
		jsr 	IFPreProcessBitwise 		; set up everything.
		bne 	_IFBAExit
_IFBALoop:
		lda 	IFR0+IM0,y
		and 	IM0,x
		sta 	IFR0+IM0,y
		inx
		iny
		cpy 	#3
		bne 	_IFBALoop
		clc
_IFBAExit:
		ply
		rts

; ************************************************************************************************
;
;									Bitwise OR R0 := R0 | Rx
;
; ************************************************************************************************

IFloatBitwiseOr:
		phy
		jsr 	IFPreProcessBitwise 		; set up everything.
		bne 	_IFBAExit
_IFBALoop:
		lda 	IFR0+IM0,y
		ora 	IM0,x
		sta 	IFR0+IM0,y
		inx
		iny
		cpy 	#3
		bne 	_IFBALoop
		clc
_IFBAExit:
		ply
		rts

; ************************************************************************************************
;
;									Bitwise XOR R0 := R0 ^ Rx
;
; ************************************************************************************************

IFloatBitwiseXor:
		phy
		jsr 	IFPreProcessBitwise 		; set up everything.
		bne 	_IFBAExit
_IFBALoop:
		lda 	IFR0+IM0,y
		eor 	IM0,x
		sta 	IFR0+IM0,y
		inx
		iny
		cpy 	#3
		bne 	_IFBALoop
		clc
_IFBAExit:
		ply
		rts

IFPreProcessBitwise:
		ldy 	#0 							; set index.
		lda 	IFR0+IExp 					; OR exponents
		ora 	IExp,x
		stz 	IExp,x 						; zero the result exponent anyway.
		and 	#IFXMask 					; NZ if error e.g. not integer
		sec 								; carry set just in cases.
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		absolute.asm
;		Purpose:	Make Rx Absolute value
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									Make R0 into an integer
;
; ************************************************************************************************

IFloatAbsoluteR0:
		lda 	IFR0+IExp					; reset the sign bit.
		and 	#IFSign ^ 255
		sta 	IFR0+IExp
		clc
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		squareroot.asm
;		Purpose:	Square Root
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Calculate Square Root of R0
;
; ************************************************************************************************

IFloatSquareRootR0:
		ldx 	#IFR0 						; if zero, return zero.
		jsr 	IFloatCheckZero
		lda	 	IFR0+IExp 					; if negative fail.
		and 	#IFSign
		bne 	_IFSRFail
		jsr 	IFloatNormalise 			; it will work better !
		;
		ldx 	#IFR1 						; R1 contains original throughout
		jsr 	IFloatCopyToRegister
		;
		lda 	IFR0+IExp 					; if exponent is $2A..$3F * 64 otherwise is / 64
		jsr 	IFMSignExtend 				; sign extended version of the exponent
		clc
		adc 	#23 						; this makes it a 0.xxx mantissa
		sta 	IFR0+IExp
		lsr 	a 							; which we can halve.
		sec 								; convert back
		sbc 	#23
		and 	#IFXMask 					; make appropriate
		sta 	IFR0+IExp 					; to R0
		;
		jsr 	_IFSRNewton
		jsr 	_IFSRNewton
		jsr 	_IFSRNewton
		jsr 	_IFSRNewton

		clc
		rts

_IFSRZero:
		ldx 	#IFR0
		jsr 	IFloatSetZero
		clc
		rts
_IFSRFail:
		sec
		rts

_IFSRNewton:
		ldx 	#IFR1 						; push original value (R3) on the stack
		jsr 	IFloatPushRx
		ldx 	#IFR0 						; push current guess (R0) on the stack.
		jsr 	IFloatPushRx
		ldx 	#IFR1 						; guess = original / guess
		jsr 	IFloatDivideFloat
		ldx 	#IFR1 						; restore current guess (was in R0) to R3
		jsr 	IFloatPullRx
		jsr 	IFloatAdd 					; now guess + original/guess
		ldx 	#IFR0 						; divide by 2
		jsr 	IFloatShiftRight
		ldx 	#IFR1
		jsr 	IFloatPullRx 				; Finally pull the oeifinal
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		fractional.asm
;		Purpose:	Get Rx Fractional part
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;								Get Fractional Part of R0
;
; ************************************************************************************************

IFloatFractionalR0:
		lda 	IFR0+IExp					; is it integer already ?
		and 	#IFXMask
		beq 	_FIPZero 					; if so, return with zero as no fractional part.
		jsr 	IFloatAbsoluteR0 			; absolute value R9

		ldx 	#IFR0
		jsr 	IFloatNormalise 			; normalise R0

		ldx 	#IFRTemp 					; copy to RTemp
		jsr 	IFloatCopyToRegister
		jsr 	IFloatIntegerR0 			; take integer part of R0
		ldx 	#IFRTemp 					; subtract
		jsr 	IFloatSubtract
		bra 	_FIPExit

_FIPZero:
		ldx 	#IFR0
		jsr 	IFloatSetZero
_FIPExit:
		clc
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		compare.asm
;		Purpose:	Compare two numbers
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							 Compare two numbers R0 = RX vs R0 (-1,0,1)
;
; ************************************************************************************************

IFloatCompare:
		jsr 	IFloatSubtract 				; subtract R0 from RX.
		lda 	IExp,x 						; check if integer comparison
		ora 	IFR0+IExp
		ldx 	#IFR0 						; only using R0 from now on.
		and 	#IFXMask
		bne 	_IFCNonInteger
		;
		;		Integer compare
		;
		jsr 	IFloatCheckZero 			; check if zero
		beq 	_IFCZero
_IFCReturnSign:
		lda 	IFR0+IExp 					; get the sign bit/unused -> stack.
		and 	#(IFXMask ^ $FF)
		pha
		lda 	#1
		jsr 	IFloatSetByte 				; return to +1
		pla 								; sign bit back
		sta 	IFR0+IExp					; set that sign
		clc
		rts

_IFCZero:									; return 0.
		jsr 	IFloatSetZero
		clc
		rts
		;
		;		Float compare - check the upper 2 bytes are zero - this is *nearly* zero.
		; 		can vary how many of lower byte we check.
		;
_IFCNonInteger:
		lda 	IFR0+IM0
		and		#$00
		ora 	IFR0+IM1
		ora 	IFR0+IM2
		beq 	_IFCZero 					; near enough !
		bra 	_IFCReturnSign 				; return the sign of the difference.

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		integer.asm
;		Purpose:	Make Rx Integer
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author : 	Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section 	code

; ************************************************************************************************
;
;									Make R0 into an integer
;
; ************************************************************************************************

IFloatIntegerR0:
		lda 	IFR0+IExp					; is it integer already ?
		and 	#IFXMask
		beq 	_FIPExit 					; if so do nothing
		ldx 	#IFR0
		jsr 	IFloatNormalise 			; normalise
		jsr 	IFloatCheckZero 			; is it zero ?
		beq 	_FIPZero 					; if so return zero.
_FIPShift:
		lda 	IFR0+IExp 					; if Exponent >= 0 exit.
		and 	#$20 						; still -ve
		beq 	_FIPExit
		jsr 	IFloatShiftRight 			; shift mantissa right
		jsr 	IFloatIncExponent 			; bump exponent
		bra 	_FIPShift
_FIPZero:
		jsr 	IFloatSetZero
_FIPExit:
		clc
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		fdivide.asm
;		Purpose:	Divide two integers/float result
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Float Divide two numbers R0 = RX / R0
;
; ************************************************************************************************

IFloatDivideFloat:
		stx 	IFTarget  					; this is s1, s0 = R0
		jsr 	IFCalculateNewSign 			; calculate sign of result
		;
		;		Normalise and cheeck division by zero.
		;
		jsr 	IFloatNormalise 			; normalise RX

		ldx 	#IFR0 						; normalise R0
		jsr 	IFloatNormalise
		jsr 	IFloatCheckZero
		beq 	_IFDFDivZero 				; exit if this normalised to zero.
		;
		;		Calculate new exponent
		;
		lda 	IFR0+IExp 					; calculate s0.exponent
		jsr 	IFMSignExtend
		sta 	IFNewExponent

		ldx 	IFTarget 					; calculate s1.exponent
		lda 	IExp,x
		jsr 	IFMSignExtend
		sec
		sbc 	IFNewExponent 				; s1.exponent - s0.exponent - 23
		sec
		sbc 	#23
		sta 	IFNewExponent

		jsr 	IFloatDivideSupport 		; call the support routine (see maths.py)

		lda 	IFRTemp+IM2 				; result has overflowed ?
		bpl 	_IFDFNoShiftResult

		ldx 	#IFRTemp 					; if so, fix it up.
		jsr 	IFloatShiftRight
		inc 	IFNewExponent
_IFDFNoShiftResult:

		lda 	IFNewExponent 				; underflow/overflow check.
		bmi 	_IFDFCheckUnderflow
		cmp 	#$20 						; overflow in division
		bcs 	_IFDFDivZero
		bra		_IFDFExit

_IFDFCheckUnderflow:
		lda 	IFNewExponent 				; shift into a legal exponent.
		cmp 	#$E0 						; if exponent < -32.
		bcs 	_IFDFExit
		inc 	IFNewExponent
		ldx 	#IFRTemp
		jsr 	IFloatShiftRight
		bra 	_IFDFCheckUnderflow

_IFDFExit:
		lda 	IFNewExponent 				; combine exponent and sign.
		and 	#IFXMask
		ora 	IFNewSign
		sta 	IFRTemp+IExp
		;
		ldx 	#IFRTemp 					; copy RTemp to R0.
		jsr 	IFloatCopyFromRegister
		clc
		rts
_IFDFDivZero:
		sec
		rts

; ************************************************************************************************
;
;							Helper function for float division.
;
; ************************************************************************************************

IFloatDivideSupport:
		ldx 	#IFRTemp 					; zero RTemp
		jsr 	IFloatSetZero

		phy 								; main division loop x 23
		ldy 	#23
_IFDSLoop:
		jsr 	IFDTrySubtract 				; do if s0 >= sx subtract code.
		jsr 	IFDShiftSTempS1Left 		; shift the 64 bit value sTemp,s1 left one bit.
		dey
		bne 	_IFDSLoop 					; do it 24 times
		ply
		rts

		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		inttostring.asm
;		Purpose:	Convert integer to string, base 2..16
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;			Convert Integer R0 to String, uses R1. Returns CC ok, YX buffer, A count
;
; ************************************************************************************************

IFloatIntegerToStringR0:
		sta 	IFBase 						; save base to use.

		jsr 	IFloatBufferReset			; empty buffer

		lda 	IFR0+IExp					; check integer
		and 	#IFXMask
		bne 	_IFIFail
		;
		;		Output - sign if -ve
		;
		ldx 	#IFR0 						; skip - check if zero.
		jsr 	IFloatCheckZero
		beq 	_IFINotNegative
		lda 	IFR0+IExp 					; is signed ?
		and 	#IFSign
		beq 	_IFINotNegative
		lda 	#"-"						; output -
		jsr 	IFloatBufferWrite
		jsr 	IFloatNegate 				; tidy up !
_IFINotNegative:
		jsr 	_IFIRecursiveConvert 		; start converting
		jsr 	IFloatGetBufferAddress
		clc
		bra 	_IFIExit

_IFIFail:
		sec
_IFIExit:
		rts

_IFIRecursiveConvert:
		ldx 	#IFR1
		jsr 	IFloatCopyToRegister 		; R0->R1
		ldx 	#IFR0
		lda 	IFBase 						; Base -> R0
		jsr 	IFloatSetByte
		ldx 	#IFR1 						; R0 = R1 / R0
		jsr 	IFloatDivideInteger
		ldx 	#IFR0 						; if result <> 0
		jsr 	IFloatCheckZero
		beq 	_IFIOutDigit
		;
		lda 	IFR1+IM0 					; save remainder
		pha
		jsr 	_IFIRecursiveConvert 		; convert the divider
		pla
		sta 	IFR1+IM0 					; restore remainder
_IFIOutDigit:
		lda 	IFR1+IM0 					; get remainder.
		cmp	 	#10
		bcc 	_IFINotHex
		adc 	#6
_IFINotHex:
		adc 	#48
		jsr 	IFloatBufferWrite
		rts
		.send code

		.section storage
IFBase:
		.fill 	1
		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		floattostring.asm
;		Purpose:	Convert float to string, base 10 only
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;				Convert Float R0 to String. Returns CC ok, YX buffer, A count
;
; ************************************************************************************************

IFloatFloatToStringR0:
		ldx 	#IFR2 						; copy R2 to stack,value to R2
		jsr 	IFloatPushRx
		jsr 	IFloatCopyToRegister

		jsr 	IFloatIntegerR0				; make R0 integer
		lda 	#10 						; base 10.
		jsr 	IFloatIntegerToStringR0 	; do the integer part.
		stz 	IFloatDecimalCount 			; zero the decimal count.

		lda 	IFR2+IExp 					; is integer.
		and 	#IFXMask
		beq 	_IFFSExit

_IFloatFracLoop:
		ldx 	#IFR2 						; R0 = fractional part of R2
		jsr 	IFloatCopyFromRegister
		jsr 	IFloatFractionalR0
		jsr 	IFloatNormalise
		ldx 	#IFR2
		jsr 	IFloatCopyToRegister 		; copy to R2

		ldx 	#IFR2 						; set R2 to 10
		lda 	#10
		jsr 	IFloatSetByte

		ldx 	#IFR2						; R0,R2 = R2 * 10
		jsr 	IFloatMultiply

		ldx 	#IFR2
		jsr 	IFloatCopyToRegister

		jsr 	IFloatIntegerR0 			; get integer part of R0

		lda 	IFloatDecimalCount 			; done 5 dp, no more
		cmp 	#3
		beq 	_IFFSExitStripZero

		lda 	IFloatDecimalCount 			; written the DP yet ?
		bne 	_IFloatNotFirst
		lda 	#"." 						; write decimal point
		jsr 	IFloatBufferWrite
_IFloatNotFirst:
		inc 	IFloatDecimalCount

		lda 	IFR0+IM0 					; get digit
		ora 	#"0"						; ASCII
		jsr 	IFloatBufferWrite 			; write to the buffer.
		bra 	_IFloatFracLoop

_IFFSExitStripZero:
		;
		;		Remove trailing zeros, except the last one.
		;
		jsr 	IFloatStripTrailingZeros
_IFFSExit:
		ldx 	#IFR2 						; restore R2
		jsr 	IFloatPullRx
		jsr 	IFloatGetBufferAddress
		clc
		rts
		.send code

		.section storage
IFloatDecimalCount:
		.fill 	1
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		floatfromstring.asm
;		Purpose:	Convert string to integer/float accordingly.
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;						Convert String XY length A to Float or Integer in R0.
;											(uses iTemp0)
;
; ************************************************************************************************

IFloatStringToFloatR0:
		sta 	IFCount 					; save it out.
		stx 	iTemp0
		sty 	iTemp0+1

		ldx 	#IFR0 						; reset the current value.
		jsr 	IFloatSetZero
		stz 	IFSignFlag 					; clear the sign flag
		jsr 	IFSTFGetNext 				; get first
		beq 	_IFSTFFail 					; no character
		bcc 	_IFSTFHaveChar 				; legitimate character, go do it.
		cmp 	#"-" 						; if not -, fail
		bne 	_IFSTFFail
		lda 	#IFSign 					; set sign flag
		sta 	IFSignFlag
		;
		;		Integer processing loop
		;
_IFSTFLoop:
		jsr 	IFSTFGetNext 				; get next
		bcs 	_IFSTFFail 					; bad character.
		beq 	_IFSTFExit 					; end of data
_IFSTFHaveChar:
		cmp 	#"."						; decimal point ?
		beq 	_IFSTFDecimal
		jsr 	IFSTFAddR0 					; add number in
		bra 	_IFSTFLoop 					; keep going until . or end.
		;
		;		Succeed and fail points.
		;
_IFSTFFail:
		sec
		bra 	_IFSTFReturn

_IFSTFDecimal:
		jsr 	IFSTFDecimal 				; call the decimal places code.
		bcs 	_IFSTFReturn 				; error
_IFSTFExit:
		lda 	IFR0+IExp 					; copy sign flag in.
		ora 	IFSignFlag
		sta 	IFR0+IExp
		clc
_IFSTFReturn:
		rts

; ************************************************************************************************
;
;					Convert String XY length A to Post Decimal value added to R0.
;										(uses iTemp0)
;
; ************************************************************************************************

IFloatAddDecimalToR0:
		sta 	IFCount 					; save it out.
		stx 	iTemp0
		sty 	iTemp0+1
		;
		;		Handle decimals. R0 is the integer total
		;
IFSTFDecimal:
		ldx 	#IFR0 						; push integer part on stack
		jsr 	IFloatPushRx
		ldx 	#IFR0 						; R0 is the decimal digits so far.
		jsr 	IFloatSetZero
		stz 	IFDecimalPlaces
_IFSTDLoop:
		jsr 	IFSTFGetNext 				; get next
		bcs 	_IFSTFFail2 				; bad character.
		beq 	_IFSTFComplete 				; end of data, work out the result.
		cmp 	#"."						; only one decimal
		beq 	_IFSTFExit2
		jsr 	IFSTFAddR0 					; add number in
		inc 	IFDecimalPlaces 			; count decimals
		lda 	IFDecimalPlaces 			; no more than 3 DP used.
		cmp 	#3
		bcc 	_IFSTDLoop

_IFSTFComplete:
		lda 	IFDecimalPlaces 			; decimals x 4 as accessing multiplier from a LUT.
		beq 	_IFSTFExit2					; if none, this is syntactically fine, just ignore
		dec 	a 							; table indexed from 1.
		asl 	a
		asl 	a
		tax
		lda 	TableTen,x 					; copy table entry into R0 - these are 0.1,0.01,0.001
		sta  	IFR1+IM0 					; 0.0001 etc, up to 5 decimals.
		lda 	TableTen+1,x
		sta  	IFR1+IM1
		lda 	TableTen+2,x
		sta  	IFR1+IM2
		lda 	TableTen+3,x
		sta  	IFR1+IExp
		ldx 	#IFR1 						; multiply into result
		jsr 	IFloatMultiply
		ldx 	#IFR1  						; pop and add the decimal.
		jsr 	IFloatPullRx
		ldx 	#IFR1
		jsr 	IFloatAdd
_IFSTFExit2:
		clc
		rts
_IFSTFFail2:
		sec
		rts




; ************************************************************************************************
;
;					Fetch next character. Z if EOF. CS if bad character
;
; ************************************************************************************************

IFSTFGetNext:
		lda 	IFCount  					; if count is zero, return with Z set.
		beq 	_IFSTFReturnOk
		lda 	(iTemp0) 					; get next character
		inc 	iTemp0 						; point at next.
		bne 	_IFSTFGNNoCarry
		inc 	iTemp0+1
_IFSTFGNNoCarry:
		dec 	IFCount 					; dec count.
		cmp 	#"."	 					; check, dp is allowed.
		beq 	_IFSTFGOkay
		cmp 	#"0"						; < 0 fail.
		bcc 	_IFSTFGFail
		cmp 	#"9"+1 						; > 9 fail.
		bcs 	_IFSTFGFail
_IFSTFGOkay:
		cmp 	#0 							; clears Z flag
_IFSTFReturnOk:
		clc
		rts

_IFSTFGFail:
		cmp 	#0 							; clears Z flag
		sec
		rts

; ************************************************************************************************
;
;							Multiply R0 by 10 and add A. (uses R1)
;
; ************************************************************************************************

IFSTFAddR0:
		and 	#15 						; to int value
		pha 								; save it.
		lda 	#10
		ldx 	#IFR1
		jsr 	IFloatSetByte
		jsr 	IFloatMultiply
		pla
		ldx 	#IFR1
		jsr 	IFloatSetByte
		jsr 	IFloatAdd
		rts

		.send code

		.section storage
IFCount:
		.fill 	1
IFSignFlag:
		.fill 	1
IFDecimalPlaces:
		.fill 	1
		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

TableTen:
	.byte	$9a,$19,$00,$30 ; 0.10001
	.byte	$8f,$02,$00,$30 ; 0.00999
	.byte	$42,$00,$00,$30 ; 0.00101
	.byte	$07,$00,$00,$30 ; 0.00011
	.byte	$01,$00,$00,$30 ; 2e-05
; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		stack.asm
;		Purpose:	Push/Pull register
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Push R:X on the stack
;
; ************************************************************************************************

IFloatPushRx:
		phy
		ldy 	IFStackIndex
		lda 	IM0,x
		sta 	IFStack,y
		lda 	IM1,x
		sta 	IFStack+1,y
		lda 	IM2,x
		sta 	IFStack+2,y
		lda 	IExp,x
		sta 	IFStack+3,y
		iny
		iny
		iny
		iny
		sty 	IFStackIndex
		ply
		rts

; ************************************************************************************************
;
;									Pull R:X off the stack
;
; ************************************************************************************************

IFloatPullRx:
		phy
		ldy 	IFStackIndex
		dey
		dey
		dey
		dey

		lda 	IFStack,y
		sta 	IM0,x
		lda 	IFStack+1,y
		sta 	IM1,x
		lda 	IFStack+2,y
		sta 	IM2,x
		lda 	IFStack+3,y
		sta 	IExp,x

		sty 	IFStackIndex
		ply
		rts

		.send 	code

		.section storage
IFStackIndex:
		.fill 	1
IFStack:
		.fill 	16*4
		.send storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		copy.asm
;		Purpose:	Copy to/from internal registers
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;									Load R0 from register X
;
; ************************************************************************************************

IFloatCopyFromRegister:
		lda 	0,x
		sta 	IFR0
		lda 	1,x
		sta 	IFR0+1
		lda 	2,x
		sta 	IFR0+2
		lda 	3,x
		sta 	IFR0+3
		rts

; ************************************************************************************************
;
;									Save R0 to register X
;
; ************************************************************************************************

IFloatCopyToRegister:
		lda 	IFR0
		sta 	0,x
		lda 	IFR0+1
		sta 	1,x
		lda 	IFR0+2
		sta 	2,x
		lda 	IFR0+3
		sta 	3,x
		rts

		.send 	code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		inline.asm
;		Purpose:	Load inline constant
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

; ************************************************************************************************
;
;							Load 4 byte inline constant following into Rx
;								(uses iTemp0 but should be test only ?)
;
; ************************************************************************************************

		.section code
IFloatLoadInline:
		pla 								; pop address off to iTemp0
		sta 	iTemp0
		pla
		sta 	iTemp0+1

		ldy 	#1
		lda 	(iTemp0),y 					; copy byte 0
		sta 	0,x
		iny
		lda 	(iTemp0),y 					; copy byte 1
		sta 	1,x
		iny
		lda 	(iTemp0),y 					; copy byte 2
		sta 	2,x
		iny
		lda 	(iTemp0),y 					; copy byte 3
		sta 	3,x

		clc 								; inc pointer, 1 for return, 4 for data
		lda 	iTemp0
		adc 	#5
		sta 	iTemp0
		bcc 	_IFLINoCarry
		inc 	iTemp0+1
_IFLINoCarry:
		jmp 	(iTemp0)					; effectively RTS

		.send 	code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;	Name:		multiply8x8.asm
;	Purpose:	Fast 8x8 multiply r0 = r0.rx
;	Created:	25th May 2023
;	Reviewed: 	No
;	Author:		Paul Robson (paul@robsons.org.uk)
;                       Thwaite (https://www.nesdev.org/wiki/8-bit_Multiply)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;					                  R0 = R0 * RX
;
; ************************************************************************************************

IFloatMultiply8BitRx:
        phy
        lda     IM0,x                       ; AY are the two values
        ldy     IFR0+IM0
        ;
        ;     Factor 1 is stored in the lower bits of IFR0+IM0; the low byte of
        ;     the product is stored in the upper bits.
        ;
        lsr     a                           ; prime the carry bit for the loop
        sta     IFR0+IM0
        sty     IFR0+IM1
        lda     #0
        ldy     #8
_IFMLoop:
        ;       At the start of the loop, one bit of IFR0+IM0 has already been
        ;       shifted out into the carry.
        bcc     _IFMNoAdd
        clc
        adc     IFR0+IM1
_IFMNoAdd:
        ror     a
        ror     IFR0+IM0                    ; pull another bit out for the next iteration
        dey
        bne     _IFMLoop
        sta     IFR0+IM1                    ; write MSB out
        ply
        rts

	.send 	code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		basics.asm
;		Purpose:	Very simple functions.
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Check Rx zero, return Z flag
;
; ************************************************************************************************

IFloatCheckZero:
		lda 	IM0,x
		ora 	IM1,x
		ora 	IM2,x
		rts

; ************************************************************************************************
;
;							Set Rx to zero or byte value
;
; ************************************************************************************************

IFloatSetZero:
		lda 	#0
IFloatSetByte:
		sta 	IM0,x 						; set mantissa to 00A
		stz 	IM1,x
		stz 	IM2,x
		stz 	IExp,x 						; zero the exponent.
		rts

; ************************************************************************************************
;
;									Negate Rx
;
; ************************************************************************************************

IFloatNegate:
		lda 	IExp,x
		eor 	#IFSign
		sta 	IExp,x
		clc
		rts

; ************************************************************************************************
;
;						Negate Rx Mantissa, two's complement
;
; ************************************************************************************************

IFloatMantissaNegate:
		sec
		lda 	#0
		sbc 	IM0,x
		sta 	IM0,x
		lda 	#0
		sbc 	IM1,x
		sta 	IM1,x
		lda 	#0
		sbc 	IM2,x
		sta 	IM2,x

		rts

; ************************************************************************************************
;
;								Shift/Rotate Rx left
;
; ************************************************************************************************

IFloatShiftLeft:
		clc
IFloatRotateLeft:
		rol 	IM0,x
		rol 	IM1,x
		rol 	IM2,x
		rts

; ************************************************************************************************
;
;								Shift/Rotate Rx right
;
; ************************************************************************************************

IFloatShiftRight:
		clc
IFloatRotateRight:
		ror 	IM2,x
		ror 	IM1,x
		ror 	IM0,x
		rts


		.send 	code


; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		normalise.asm
;		Purpose:	Normalise register
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							Normalise register X, CS if error.
;
; ************************************************************************************************

IFloatNormalise:
		jsr 	IFloatCheckZero 			; is it zero
		beq 	_IFNExitZero 				; if so exit
		;
_IFNLoop:
		lda 	IM2,x 						; is it normalised e.g. bits 7/6 are 01
		and 	#$C0
		cmp 	#$40
		beq 	_IFNExitOkay 				; if so , then we are done.
		;
		lda 	IExp,x 						; check exponent is not -32 already.
		and 	#$3F
		cmp 	#$20
		beq 	_IFNExitOkay 				; if so, then we cannot normalise any more.
		;
		jsr 	IFloatDecExponent

		jsr 	IFloatShiftLeft 			; shift mantissa left, e.g. multiply by 2
		bra 	_IFNLoop

_IFNExitZero:
		jsr 	IFloatSetZero 				; set the result to zero

_IFNExitOkay:
		clc  								; return with CC.
		rts

; ************************************************************************************************
;
;		Increment/Decrement exponent, preserving upper bits. Returns the new exponent in A
;
; ************************************************************************************************

IFloatIncExponent:
		lda 	IExp,x
		pha
		and 	#$C0
		sta 	IFXTemp
		pla
		inc 	a
		and 	#$3F
		pha
		ora 	IFXTemp
		sta 	IExp,x
		pla
		rts

IFloatDecExponent:
		lda 	IExp,x
		pha
		and 	#$C0
		sta 	IFXTemp
		pla
		dec 	a
		and 	#$3F
		pha
		ora 	IFXTemp
		sta 	IExp,x
		pla
		rts

		.send 	code

		.section storage
IFXTemp:
		.fill 	1
		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		buffer.asm
;		Purpose:	Buffer for String I/O
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;								Reset / Empty the buffer
;
; ************************************************************************************************

IFloatBufferReset:
		stz 	IFBufferCount
		stz 	IFBuffer
		rts

; ************************************************************************************************
;
;								Get buffer address to YX length A
;
; ************************************************************************************************

IFloatGetBufferAddress:
		ldy 	#(IFBuffer >> 8)
		ldx 	#(IFBuffer & $FF)
		lda 	IFBufferCount
		rts

; ************************************************************************************************
;
;								Write character to buffer
;
; ************************************************************************************************

IFloatBufferWrite:
		phx
		ldx 	IFBufferCount
		sta 	IFBuffer,x
		stz 	IFBuffer+1,x
		inc 	IFBufferCount
		plx
		rts

; ************************************************************************************************
;
;								Strip any trailing zeros
;
; ************************************************************************************************

IFloatStripTrailingZeros:
		ldx 	IFBufferCount
		lda 	IFBuffer-1,x
		cmp		#"0"
		bne 	_IFSTExit
		lda 	IFBuffer-2,x
		cmp 	#"."
		beq 	_IFSTExit
		dec 	IFBufferCount
		stz 	IFBuffer-1,x
		bra 	IFloatStripTrailingZeros
_IFSTExit:
		rts

		.send code

		.section storage
IFBufferCount:
		.fill 	1
IFBuffer:
		.fill 	25
		.send 	storage

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

; ************************************************************************************************
; ************************************************************************************************
;
;		Name:		check.asm
;		Purpose:	Check |R0| is <= R1
;		Created:	25th May 2023
;		Reviewed: 	No
;		Author:		Paul Robson (paul@robsons.org.uk)
;
; ************************************************************************************************
; ************************************************************************************************

		.section code

; ************************************************************************************************
;
;							  			Check Abs(R0) < R1
;
; ************************************************************************************************

IFloatCheck:
		lda 	IFR0+IExp					; force it negative
		ora 	#IFSign
		sta 	IFR0+IExp
		jsr 	IFloatAdd 					; add allowed to error.
		ldx 	#IFR0
		jsr 	IFloatCheckZero 			; error if < 0
		beq 	_IFAOkay
		lda 	IFR0+IExp
		and 	#IFSign
		bne 	_IFAFail
_IFAOkay:
		rts

_IFAFail:
		sec
		pla 								; get address - 2
		sbc 	#2
		tax
		pla
		sbc 	#0
		tay
		lda 	#$AA 						; sign assert
_IFAStop:
		.byte 	$DB 						; display an error AA ADR ADR
		bra 	_IFAStop
		.send 	code

; ************************************************************************************************
;
;									Changes and Updates
;
; ************************************************************************************************
;
;		Date			Notes
;		==== 			=====
;
; ************************************************************************************************

